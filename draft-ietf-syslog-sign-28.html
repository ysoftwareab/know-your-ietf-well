<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Signed syslog Messages</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Signed syslog Messages">
<meta name="keywords" content="syslog, syslog-sign">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">syslog Working Group</td><td class="header">J. Kelsey</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">NIST</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">J. Callas</td></tr>
<tr><td class="header">Expires: April 18, 2010</td><td class="header">PGP Corporation</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">A. Clemm</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Cisco Systems</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">October 15, 2009</td></tr>
</table></td></tr></table>
<h1><br />Signed syslog Messages<br />draft-ietf-syslog-sign-28.txt</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.
This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November
10, 2008. The person(s) controlling the copyright in some of this
material may not have granted the IETF Trust the right to allow
modifications of such material outside the IETF Standards Process.
Without obtaining an adequate license from the person(s) controlling
the copyright in such materials, this document may not be modified
outside the IETF Standards Process, and derivative works of it may
not be created outside the IETF Standards Process, except to format
it for publication as an RFC or to translate it into languages other
than English.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on April 18, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>
			This document describes a mechanism to add origin authentication, message integrity, 
			replay resistance, message sequencing, and detection of missing messages to the transmitted 
			syslog messages.  This specification is intended to be used in conjunction with the work 
			defined in <a class='info' href='#RFC5424'>[RFC5424]<span> (</span><span class='info'>Gerhards, R., &ldquo;The syslog Protocol,&rdquo; March&nbsp;2009.</span><span>)</span></a>, "The syslog Protocol".  
			
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#intro">1.</a>&nbsp;
Introduction<br />
<a href="#conventions">2.</a>&nbsp;
Conventions Used in this Document<br />
<a href="#format">3.</a>&nbsp;
syslog Message Format<br />
<a href="#sigBlock">4.</a>&nbsp;
Signature Blocks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sigBlkPkts">4.1.</a>&nbsp;
syslog Messages Containing a Signature Block<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sigBlockFormat">4.2.</a>&nbsp;
Signature Block Format and Fields<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Version">4.2.1.</a>&nbsp;
Version<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rebootid">4.2.2.</a>&nbsp;
Reboot Session ID<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#siggrp">4.2.3.</a>&nbsp;
Signature Group and Signature Priority<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#globBlk">4.2.4.</a>&nbsp;
Global Block Counter<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#firstmsg">4.2.5.</a>&nbsp;
First Message Number<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#count">4.2.6.</a>&nbsp;
Count<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#hash">4.2.7.</a>&nbsp;
Hash Block<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sig">4.2.8.</a>&nbsp;
Signature<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sigex">4.2.9.</a>&nbsp;
Example<br />
<a href="#payncert">5.</a>&nbsp;
Payload and Certificate Blocks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#prelims">5.1.</a>&nbsp;
Preliminaries: Key Management and Distribution Issues<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#build">5.2.</a>&nbsp;
Payload Block<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#payloadfields">5.2.1.</a>&nbsp;
Block Format and Fields<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#origauth">5.2.2.</a>&nbsp;
Signer Authentication and Authorization<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#buildcert">5.3.</a>&nbsp;
Certificate Block<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#certmsg">5.3.1.</a>&nbsp;
syslog Messages Containing a Certificate Block<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#certblock">5.3.2.</a>&nbsp;
Certificate Block Format and Fields<br />
<a href="#redunnflex">6.</a>&nbsp;
Redundancy and Flexibility<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#confpar">6.1.</a>&nbsp;
Configuration parameters<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#redunCertblk">6.1.1.</a>&nbsp;
Configuration Parameters for Certificate Blocks<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#redunSigblk">6.1.2.</a>&nbsp;
Configuration Parameters for Signature Blocks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#flex">6.2.</a>&nbsp;
Overlapping Signature Blocks<br />
<a href="#verify">7.</a>&nbsp;
Efficient Verification of Logs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#offline">7.1.</a>&nbsp;
Offline Review of Logs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#online">7.2.</a>&nbsp;
Online Review of Logs<br />
<a href="#security">8.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SecCrypto">8.1.</a>&nbsp;
Cryptographic Constraints<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SecPacket">8.2.</a>&nbsp;
Packet Parameters<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SecAuth">8.3.</a>&nbsp;
Message Authenticity<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SeqReplay">8.4.</a>&nbsp;
Replaying<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SecRelDel">8.5.</a>&nbsp;
Reliable Delivery<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SecSeq">8.6.</a>&nbsp;
Sequenced Delivery<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SecInt">8.7.</a>&nbsp;
Message Integrity<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SecObs">8.8.</a>&nbsp;
Message Observation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SecMITM">8.9.</a>&nbsp;
Man In The Middle Attacks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SecDen">8.10.</a>&nbsp;
Denial of Service<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SecCov">8.11.</a>&nbsp;
Covert Channels<br />
<a href="#iana">9.</a>&nbsp;
IANA Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ianaSyslog">9.1.</a>&nbsp;
Structured Data and syslog messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ianaVer">9.2.</a>&nbsp;
Version Field<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ianaSIG">9.3.</a>&nbsp;
SG Field<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ianabuild">9.4.</a>&nbsp;
Key Blob Type<br />
<a href="#authors">10.</a>&nbsp;
Working Group<br />
<a href="#acks">11.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">12.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">12.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">12.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
			This document describes a mechanism, called syslog-sign in this document,
			that adds origin
			authentication, message integrity, replay resistance, message
			sequencing, and detection of missing messages to syslog.  Essentially,
			this is accomplished by sending a special syslog message.  
			The contents of this syslog message is called a Signature Block.  
			Each Signature Block contains, in effect, a detached signature on
			some number of previously sent messages.  It is cryptographically signed and contains 
			the hashes of previously sent syslog messages.  
			The originator of syslog-sign messages is also simply referred to as "signer".  
			The signer can be the same originator as the originator whose messages it signs, 
			or it can be a separate originator.  
			
</p>
<p>
			While most implementations
			of syslog involve only a single originator
			and a single collector of each message,
			provisions need to be made to cover situations in which messages are 
			sent to multiple collectors.  
			This concerns, in particular, situations in which different messages 
			from the same originator are sent to different collectors, 
			which means that some messages are sent 
			to some collectors but not to others.  
			The required differentiation of messages is generally performed 
			based on the Priority value of the individual messages.  
			For example, messages from any Facility
			with a Severity value of 3, 2, 1, or 0 may be sent to one collector
			while all messages of Facilities 4, 10, 13, and 14 may be sent to
			another collector.  Appropriate syslog-sign messages must be kept
			with their proper syslog messages.  To address this, syslog-sign
			uses a Signature Group.  A Signature Group identifies a group of
			messages that are all kept together for signing purposes by the
			signer.  A Signature Block always belongs to exactly one Signature
			Group and always signs messages belonging only to that Signature
			Group.
			
</p>
<p>
			Additionally, a signer sends Certificate Blocks to provide key
			management information between the signer and the collector.  A
			Certificate Block has a field to denote the type of key material
			which may be such things as a PKIX certificate, an OpenPGP certificate,
			or even an indication that a key had been pre-distributed.  
			In the cases of certificates being sent, the
			certificates may have to be split across multiple Certificate Blocks 
			carried in separate messages.
			
</p>
<p>
			It is possible that the same host contains multiple signers that
			each use their own keys to sign syslog messages.  In this case,
			each signer sends its own Certificate Block and Signature
			Blocks.  Furthermore, each signer defines its own 
			Signature Groups.  Each signer on a given host needs to use a distinct 
			combination of APP-NAME and PROCID for its 
			Signature Block and Certificate Block message.     
			(This implies that the combination of HOSTNAME, APP-NAME and PROCID 
			uniquely distinguishes originators of syslog-sign messages across hosts, 
			provided that the signers use a unique HOSTNAME.)  
			
</p>
<p>
			The collector may verify that the hash of 
			each received message matches the signed hash contained
			in the corresponding Signature Block.  
			A collector may process these Signature
			Blocks as they arrive, building an authenticated log file.
			Alternatively, it may store all the log messages in the order they
			were received.  This allows a network operator to authenticate the
			log file at the time the logs are reviewed.
			
</p>
<p>
			The mechanism described in this specification is intended to be used in
			conjunction with  
			the syslog protocol as defined in <a class='info' href='#RFC5424'>[RFC5424]<span> (</span><span class='info'>Gerhards, R., &ldquo;The syslog Protocol,&rdquo; March&nbsp;2009.</span><span>)</span></a>
			as its message delivery mechanism and uses the concept of 
			STRUCTURED-DATA elements defined
			in that document.  In fact, this specification mandates implementation of 
			syslog protocol.  Nevertheless, it is conceivable that the concepts 
			underlying this mechanism could 
			also be used in conjunction with other message delivery mechanisms.  
			Designers of other efforts to define event notification mechanisms are 
			therefore encouraged to consider this specification in their designs.
			
</p>
<a name="conventions"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Conventions Used in this Document</h3>

<p>
			The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
			"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this 
			document are to be interpreted as described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
			
</p>
<a name="format"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
syslog Message Format</h3>

<p>
			This specification is intended to be used in conjunction with the syslog 
			protocol as defined in
			<a class='info' href='#RFC5424'>[RFC5424]<span> (</span><span class='info'>Gerhards, R., &ldquo;The syslog Protocol,&rdquo; March&nbsp;2009.</span><span>)</span></a>.  The syslog protocol therefore 
			MUST be supported by implementations of this specification.   
			
</p>
<p>
			Because the originator generating the 
			Signature Block message, also simply referred to as "signer", 
			signs each message in its entirety, 
			the messages MUST NOT be changed in transit.  By the same token, 
			the syslog-sign messages MUST NOT be changed in transit.  
			<a class='info' href='#RFC5424'>[RFC5424]<span> (</span><span class='info'>Gerhards, R., &ldquo;The syslog Protocol,&rdquo; March&nbsp;2009.</span><span>)</span></a> specifically prohibits behavior by relays in which 
			syslog messages
			are deliberately altered, because one of the effects of such behavior would be to 
			render any signing invalid and hence make the mechanism useless.   
			Likewise, any truncation of messages
			that occurs between sending and receiving renders the mechanism useless.  
			For this reason, syslog signer and collector implementations implementing this 
			specification MUST support messages of up to and including 2048 octets in length, 
			in order to minimize the chance of truncation.   
			While syslog signer and collector implementations MAY support messages with a 
			length larger than 2048 octets, implementers need to be aware that any message
			truncations that occur render the mechanism useless.  
			
</p>
<p>
			This specification uses the syslog message format
			described in <a class='info' href='#RFC5424'>[RFC5424]<span> (</span><span class='info'>Gerhards, R., &ldquo;The syslog Protocol,&rdquo; March&nbsp;2009.</span><span>)</span></a>.  
			Along with other fields, that document describes the concept of Structured Data (SD).  
			Structured Data is defined in terms of SD ELEMENTS (SDEs).  
			An SDE consists of a name and a set of parameter name - value pairs.  
			The SDE name is referred to as SD-ID.  
			The name-value pairs are referred to as SD-PARAM, or SD Parameters,
			with the name constituting the SD-PARAM-NAME, and the value constituting the SD-PARAM-VALUE.  
			
</p>
<p>
			The syslog messages defined in this document carry the data that is associated with 
			Signature Blocks and Certificate Blocks
			as Structured Data.  
			The special syslog messages defined in this document 
			include for this purpose definitions 
			of SDEs to convey parameters that relate to the signing of syslog messages.  
			The MSG part of the syslog messages defined in this document SHOULD 
			simply be empty -- 
			the content of the messages is not intended for interpretation by humans but by applications
			that use those messages to build an authenticated log.    
			
</p>
<p> 
			Because the syslog messages defined in this document adhere to the format 
			described in <a class='info' href='#RFC5424'>[RFC5424]<span> (</span><span class='info'>Gerhards, R., &ldquo;The syslog Protocol,&rdquo; March&nbsp;2009.</span><span>)</span></a>, they identify the machine that 
			originates the syslog message in the HOSTNAME field.  Therefore, the Signature Block and Certificate 
			Block data do not need to include any additional parameter to identify the machine that orginates the 
			message.   
			
</p>
<p>
				In addition, several signers MAY sign messages on a single host
				independently of each other, each using their own Signature Groups.
				In that case, each unique signer is distinguished by the combination
				of APP-NAME and PROCID.  (By the same token, the same message might be
				signed by multiple signers.)  Each unique signer MUST have a unique
				APP-NAME and PROCID on each host.  (This implies that the
				combination of HOSTNAME, APP-NAM and PROCID uniquely distinguishes the
				originator of syslog-sign messages, provided that the signers use a
				unique HOSTNAME.)  A Signature Block message MUST use the same
				combination of HOSTNAME, APP-NAME, and PROC-ID that was used to send
				the corresponding Certificate Block messages containing the Payload
				Block.
			
</p>
<a name="sigBlock"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Signature Blocks</h3>

<p>
			This section describes the format of the Signature Block and the fields used
			within the Signature Block, as well as the syslog messages used to carry the 
			Signature Block.  
			
</p>
<a name="sigBlkPkts"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
syslog Messages Containing a Signature Block</h3>

<p>
				There is a need to distinguish the Signature Block itself from the syslog message
				that is used to carry a Signature Block.  
				Signature Blocks MUST be encompassed within completely formed 
				syslog messages.  Syslog messages that contain a Signature Block are also referred to as 
				Signature Block messages.  
				
</p>
<p>
				A Signature Block message 
				is identified by the presence of an
				SD ELEMENT with an SD-ID with the value "ssign".  
				In addition, a Signature Block message 
				MUST contain valid APP-NAME, PROCID, and MSGID fields to be compliant with 
				<a class='info' href='#RFC5424'>[RFC5424]<span> (</span><span class='info'>Gerhards, R., &ldquo;The syslog Protocol,&rdquo; March&nbsp;2009.</span><span>)</span></a>.   
				This specification does not mandate particular values for these fields; however, 
				for consistency, a signer MUST use the 
				same values for APP-NAME, PROCID, and MSGID fields for 
				every Signature Block message that is sent, whichever values are chosen.  
				It MUST also use the same value for its HOSTNAME field.  
				To allow for the possibility of multiple signers per host, 
				the combination of APP-NAME and PROCID MUST be unique for each such signer on any 
				given host.  
				If a signer daemon is restarted, it MAY use a new PROCID for what is otherwise the 
				same signer but MUST continue to use the same APP-NAME.  
				If it uses a new PROCID, it MUST send a new Payload Block using Certificate Block messages
				that use the same new PROCID (and the same APP-NAME).      
				It is RECOMMENDED (but not required) to use 110 as value 
				for the PRI field, corresponding to facility 13 (log audit) and severity 6 (informational).  
				The Signature Block is 
				carried as Structured Data within the Signature Block message, per the definitions 
				that follow in the next section.  
				A Signature Block 
				message MAY carry other Structured Data besides the Structured Data of the 
				Signature Block itself.  
				The MSG part of a Signature Block message SHOULD be empty.  
				
</p>
<p>
				The syslog messages defined as part of syslog-sign themselves 
				(Signature Block messages and Certificate Block messages) MUST NOT be
				signed by a Signature Block.  Collectors that 
				implement syslog-sign know to distinguish syslog messages that are associated with syslog-sign 
				from those that are subjected to signing and 
				process them differently.  The intent of syslog-sign is to sign a stream of syslog 
				messages, not to alter it.  
				
</p>
<a name="sigBlockFormat"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Signature Block Format and Fields</h3>

<p>
				The content of a Signature Block message is the Signature Block.  
				The Signature Block MUST
				be encoded as an SD ELEMENT, as defined in 
				<a class='info' href='#RFC5424'>[RFC5424]<span> (</span><span class='info'>Gerhards, R., &ldquo;The syslog Protocol,&rdquo; March&nbsp;2009.</span><span>)</span></a>.  
				
</p>
<p>
				The SD-ID MUST have the value of "ssign".  
				
</p>
<p>
				The SDE contains the fields of the Signature Block encoded as 
				SD Parameters, as specified in the following.    
				The Signature Block is composed of the following fields. The value of each field
				MUST be printable ASCII, and any binary values MUST be 
				base 64 encoded, as defined in <a class='info' href='#RFC4648'>[RFC4648]<span> (</span><span class='info'>Josefsson, S., &ldquo;The Base16, Base32, and Base64 Data Encodings,&rdquo; October&nbsp;2006.</span><span>)</span></a>.  
				
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    Field                     SD-PARAM-NAME        Size in octets
    -----                     -------------        ---- -- ------

    Version                          VER                 4

    Reboot Session ID               RSID                1-10

    Signature Group                   SG                 1

    Signature Priority              SPRI                1-3

    Global Block Counter             GBC                1-10

    First Message Number             FMN                1-10

    Count                            CNT                1-2

    Hash Block                        HB      variable, size of hash
                                            times the number of hashes
                                             (base 64 encoded binary)

    Signature                       SIGN             variable
                                             (base 64 encoded binary)
</pre></div>
<p>
				The fields MUST be provided in the order listed.  Each SD parameter MUST occur once 
				and only once in the Signature Block.  New SD parameters MUST NOT be added unless a new Version
				of the protocol is defined.   (Implementations that wish to add proprietary extensions will need 
				to define a separate SD ELEMENT.)
				A Signature Block is accordingly encoded as follows, where xxx denotes a placeholder for the 
				particular values: 
				
</p>
<p>
				[ssign VER="xxx" RSID="xxx" SG="xxx" SPRI="xxx" GBC="xxx" 
				FMN="xxx" CNT="xxx" HB="xxx" SIGN="xxx"]  
				
</p>
<p>
				Values of the fields constitute SD parameter values and are hence enclosed in quotes, 
				per <a class='info' href='#RFC5424'>[RFC5424]<span> (</span><span class='info'>Gerhards, R., &ldquo;The syslog Protocol,&rdquo; March&nbsp;2009.</span><span>)</span></a>.  
				The fields are separated by single spaces and are described in the subsequent subsections.   
				
</p>
<a name="Version"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
Version</h3>

<p>
					The Version field is an alphanumeric value 
					that has a length of 4 octets, which may include leading zeroes.  
					The first two octets and the last octet contain a 
					decimal character in the range of "0" to "9", whereas the third octet
					contains an alphanumeric character in the range of "0" to "9", "a" to "z", 
					or "A" to "Z".  
					The value in this field specifies
					the version of the syslog-sign protocol. This is extensible to allow
					for different hash algorithms and signature schemes to be used in
					the future. The value of this field is the grouping of the protocol
					version (2 octets), the hash algorithm (1 octet) and the signature
					scheme (1 octet).  

					</p>
<blockquote class="text">
<p>
						Protocol Version - 2 octets, with "01" as the value for 
                                    the protocol version that is described in this document.  
						
</p>
<p>
						Hash Algorithm - 1 octet, where, in conjunction 
						with Protocol Version 01, a value of "1" denotes SHA1 and  
						a value of "2" denotes SHA256, as defined in
						<a class='info' href='#FIPS.180-2.2002'>[FIPS.180&#8209;2.2002]<span> (</span><span class='info'>National Institute of Standards and Technology, &ldquo;Secure Hash Standard,&rdquo; August&nbsp;2002.</span><span>)</span></a>.  (This is the octet
						that can have a value of not just "0" to "9" but also "a" to "z" and "A" to "Z".)  
						
</p>
<p>
						Signature Scheme - 1 octet, where, in conjunction
						with Protocol Version 01, a value of "1" denotes
						OpenPGP DSA, defined in <a class='info' href='#RFC4880'>[RFC4880]<span> (</span><span class='info'>Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R. Thayer, &ldquo;OpenPGP Message Format,&rdquo; November&nbsp;2007.</span><span>)</span></a> and 
						<a class='info' href='#FIPS.186-2.2000'>[FIPS.186&#8209;2.2000]<span> (</span><span class='info'>National Institute of Standards and Technology, &ldquo;Digital Signature Standard,&rdquo; January&nbsp;2000.</span><span>)</span></a>.
						
</p>
</blockquote><p>

					The version, hash algorithm and signature scheme defined in
					this document would accordingly be represented as "0111" (if SHA1 is used as Hash Algorithm) 
					and "0121" (if SHA256 is used as Hash Algorithm), respectively 
					(without the quotation marks).  
					
</p>
<p>
					The values of the Hash Algorithm and Signature Scheme are 
					defined relative to the Protocol Version.  If the single-octet representation of the values 
					for Hash Algorithm and Signature Scheme were to ever represent a limitation, 
					this limitation could be overcome by defining a new Protocol Version with additional
					Hash Algorithms and/or Signature Schemes, and having implementations support both 
					Protocol Versions concurrently.  
 					
</p>
<a name="rebootid"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
Reboot Session ID</h3>

<p>
					The Reboot Session ID is a decimal value that has a length between 1 and 10 octets.  
					The acceptable values for
					this are between 0 and 9999999999.  Leading zeroes MUST be omitted.  
					
</p>
<p>
					 A Reboot Session ID is expected to strictly monotonically increase 
					 (i.e., to never repeat or decrease) whenever a signer 
					 reboots in order to allow collectors to distinguish messages and
					 message signatures across reboots.  There are several ways in which
					 this may be accomplished.  In one way, the Reboot Session ID may
					 increase by 1, starting with a value of 1.  Note that in this case, a
					 signer is required to retain the previous Reboot Session ID across
					 reboots.  In another way, a value of the unix time (number of seconds
					 since 1 January 1970) may be used.  Implementers of this
					 method need to beware of the possibility of multiple reboots 
					 occurring within a single second.  Implementers need to also beware   
					 of the year 2038 problem, which will cause the 32-bit representation of 
					 unix time to wrap in the year 2038.  In yet another way,
					 implementers MAY consider using the snmpEngineBoots value as a
					 source for this counter as defined in <a class='info' href='#RFC3414'>[RFC3414]<span> (</span><span class='info'>Blumenthal, U. and B. Wijnen, &ldquo;User-based Security Model (USM) for version 3 of the Simple Network Management Protocol (SNMPv3),&rdquo; December&nbsp;2002.</span><span>)</span></a>.  
					
</p>
<p> 
					In cases where a signer is not able to guarantee that the Reboot Session ID is always 
					increased after a reboot, the Reboot Session ID MUST always be set to a value of 0.   
					If the value can no longer be increased (e.g., because it reaches 9999999999), 
					it SHOULD be reset to a value of 1.  Implementations SHOULD ensure that 
					such a reset does not go undetected, 
					for example by requesting operator 
					acknowledgment when a reset is performed upon reboot.    
					
</p>
<p>
					If a reboot of a signer takes place, Signature Block messages MAY use a new PROCID.  
					However, Signature Block messages of the same signer MUST continue to use the 
					same HOSTNAME, APP-NAME, and MSGID.      
					
</p>
<a name="siggrp"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3"></a><h3>4.2.3.&nbsp;
Signature Group and Signature Priority</h3>

<p>
					The SG parameter may take any value from
					0-3 inclusive.  The SPRI parameter may take any value from 0-191 inclusive.  
                    These fields
					taken together allow network administrators to associate
					groupings of syslog messages with appropriate Signature Blocks and
					Certificate Blocks.  
					Groupings of syslog messages that are signed together are also 
					called Signature Groups.  A Signature Block contains only hashes 
					of those syslog messages that are part of the same Signature Group.  
					
</p>
<p>
					For example, in some cases, network
					administrators might have originators send syslog messages of Facilities 0 through 15
					to one collector and those with Facilities 16
					through 23 to another.  In such cases, associated Signature Blocks should 
					likely be sent to the corresponding collectors as well, signing the syslog 
					messages that are intended for each collector separately.  This way, each
					collector receives Signature Blocks for all syslog messages
					that it receives, and only for those.  
					The ability to associate different categories of syslog messages with different 
					Signature Groups, signed in separate Signature Blocks, 
					provides administrators with flexibility in this regard.  
					
</p>
<p>
					Syslog-sign provides four options for handling Signature Groups,
					linking them with PRI values so they may be routed to the
					destination commensurate with the corresponding syslog messages. In
					all cases, no more than 192 distinct Signature Groups (0-191) are permitted.  
					
</p>
<p>
					The Signature Group to which a Signature Block pertains is indicated by 
					the Signature Priority (SPRI) field.  
					The Signature Group (SG) field indicates how to interpret the Signature 
					Priority field.  (Note that the SG field does not indicate the Signature Group itself, 
					as its name might suggest.)  The SG field can have one of the following values:  

					</p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>
						"0" -- There is only one Signature Group.  
						In this case, the administrators want all Signature
						Blocks to be sent to a single destination; in all likelihood,
						all of the syslog messages will also be going to that same
						destination.  Signature Blocks contain signatures for
						all messages regardless of their PRI value.  
						This means that, in effect,
						the Signature Block's SPRI value can be ignored.  
						However, it is RECOMMENDED that a single SPRI value be used for all
						Signature Blocks.    
						Furthermore, it is RECOMMENDED to set that value 
						to the same value as the 
						PRI field of the Signature Block message.  This way, the PRI of the Signature
						Block message matches the SPRI of the Signature Block that it contains.
						
</dd>
<dt>b.</dt>
<dd>
						"1" -- Each PRI value is associated with its own Signature Group. Signature
						Blocks for a given Signature Group have SPRI = PRI for that
						Signature Group.  In other words, the SPRI of the Signature Block matches 
						the PRI value of the syslog messages that are part of the Signature Group
						and hence signed by the Signature Block.  
						An SG value of 1 can, for example, be used when the administrator of a signer
						does not know where any of the syslog messages will ultimately
						go but anticipates that messages with different PRI values will be collected and 
						processed separately.  Having a Signature Group per PRI value provides 
						administrators with 
						a large degree of flexibility with regard to how to divide 
						up the processing of syslog messages and their signatures after they 
						are received, at the same time allowing 
						Signature Blocks to follow the corresponding syslog messages to their
						eventual destination.    
						
</dd>
<dt>c.</dt>
<dd>
						"2" -- Each Signature Group contains a range of PRI values.
						Signature Groups are assigned sequentially. A Signature Block for
						a given Signature Group has its own SPRI value denoting the
						highest PRI value of syslog messages in that Signature Group.  
						The lowest PRI value of syslog messages in that Signature Group will
						be one larger than the SPRI value of the previous Signature Group or "0" 
						in case there is no other Signature Group with a lower SPRI value.  
						The specific Signature Groups and ranges they are associated with 
						are subject to configuration by a system administrator.  
						
</dd>
<dt>d.</dt>
<dd>
							"3" -- Signature Groups are not assigned with any of the above
							relationships to PRI values of the syslog messages they
							sign. Instead, another scheme is used, which is outside the scope of
							this specification.  There has to be some predefined
							arrangement between the originator and the intended collectors as to which
							syslog messages are to be included in which Signature Group, requiring
							configuration by a system administrator.  This provides administrators also
							with the flexibility to group syslog messages into Signature Groups according to
							criteria that are not tied to the PRI value. 
							Note that this option is is not intended for 
							deployments which lack such an arrangement, as in those cases a collector could 
							misinterpret the intended meaning of the Signature Group.
							A collector that receives Signature Block messages of a Signature Group
							of whose scheme it is not aware SHOULD
							bring this fact to the attention of the system administrator.  The particular
							mechanism used for that is implementation-specific and outside
							the scope of this specification.
						
</dd>
</dl></blockquote><p>

					One reasonable way to configure some installations is to have only
					one Signature Group, indicated with SG=0, and have the signer send a copy of 
					each Signature Block to each collector.   In that case, collectors that are not 
					configured to receive every syslog message will still receive signatures for
					every message, even ones they are not supposed to receive.   
					While the collector will not be able to detect gaps in the
					messages (because the presence of a signature of a message that is missing 
					does not tell the collector whether
					or not the corresponding message would be of the collector's concern), 
					it does allow all messages that do arrive at each collector
					to be put into the right order and to be verified.  It also
					allows each collector to detect duplicates.  
					Likewise, configuring only one Signature Group can be a reasonable way to 
					configure installations that involve relay chains, 
					where one or more interim relays may or may not relay all messages to the 
					same destination.  
					
</p>
<a name="globBlk"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.4"></a><h3>4.2.4.&nbsp;
Global Block Counter</h3>

<p>
					The Global Block Counter is a decimal value representing the number of
					Signature Blocks sent by syslog-sign before the current one, in this
					reboot session. This takes at least 1 octet and at most 10 octets
					displayed as a decimal counter. The acceptable values for this
					are between 0 and 9999999999, starting with 0.  Leading zeroes MUST be omitted.  
					If the value of the Global Block Counter 
					has reached 9999999999 and the Reboot Session ID has a value other than 0
					(indicating the fact that persistence of the Reboot Session ID is supported),
					then the Reboot Session ID MUST be incremented by 1 and the
					Global Block Counter resumes at 0.  When 
					the Reboot Session ID is 0 (i.e., persistent 
					Reboot Session IDs are not supported) and the Global Block Counter
					reaches its maximum value, then the Global Block Counter is reset to 0 
					and the Reboot Session ID MUST remain at 0.   
					
</p>
<p>
					Note that the Global Block Counter
					crosses Signature Groups; it allows one to roughly synchronize when
					two messages were sent, even though they went to different
					collectors and are part of different Signature Groups.  
					
</p>
<p>
					Because a reboot results in the start of a new reboot session, the signer MUST 
					reset the Global Block Counter to 0 after a reboot occurs.  
					Applications need to take into account the possibility that a 
					reboot occurred when authenticating 
					a log, and situations in which reboots occur frequently may result 
					in losing the ability to verify the proper sequence in which messages were
					sent, hence jeopardizing the integrity of the log.  
					
</p>
<a name="firstmsg"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.5"></a><h3>4.2.5.&nbsp;
First Message Number</h3>

<p>
					This is a decimal value between 1 and 10 octets, with leading zeroes omitted.  
					It contains the unique
					message number within this Signature Group of the first message
					whose hash appears in this block.  The very first message of the
					reboot session is numbered "1".  This implies that when the Reboot Session ID 
					increases, the message number is reset to 1.  
					
</p>
<p>
					For example, if this Signature Group has processed 1000 messages so
					far and message number 1001 is the first message whose hash appears
					in this Signature Block, then this field contains 1001.  The 
					message number is relative to the Signature Group to which it belongs; 
					hence, a message number does not identify a message beyond its Signature Group.    
					
</p>
<p>
					Should the message number reach 9999999999 within the same reboot session and 
					Signature Group, the message number subsequently restarts at 1.   
					In such event, the Global Block Counter will be vastly different 
					between two occurrences of the same message number.     
					
</p>
<a name="count"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.6"></a><h3>4.2.6.&nbsp;
Count</h3>

<p>
					The count is a 1 or 2 octet field that indicates the number of message
					hashes to follow.  The valid values for this field are 1 through
					99.  The number of hashes included in the Signature
					Block MUST be chosen such that the length of the 
					resulting syslog message does not exceed the maximum permissible syslog 
					message length.  
					
</p>
<a name="hash"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.7"></a><h3>4.2.7.&nbsp;
Hash Block</h3>

<p>
					The hash block is a block of hashes, each separately encoded in
					base 64. Each hash in the hash block is the hash of the entire
					syslog message represented by the hash, independent of the underlying
					transport.  Hashes are ordered from left to right in the order of occurrence 
					of the syslog messages that they represent.   The space character is 
					used to separate the hashes.  Note, the hash block constitutes a single SD-Param;  
					a Signature Block message MUST include all its hashes in a single hash block and 
					MUST NOT spread its hashes across several hash blocks.    
					
</p>
<p>
					The "entire syslog message" refers to what is described as the syslog 
					message excluding 
					transport parts that are described in 
					<a class='info' href='#RFC5425'>[RFC5425]<span> (</span><span class='info'>Miao, F., Yuzhi, M., and J. Salowey, &ldquo;TLS Transport Mapping for syslog,&rdquo; March&nbsp;2009.</span><span>)</span></a> and 
					<a class='info' href='#RFC5426'>[RFC5426]<span> (</span><span class='info'>Okmianski, A., &ldquo;Transmission of syslog Messages over UDP,&rdquo; March&nbsp;2009.</span><span>)</span></a>, 
					and excluding other parts that may be defined 
					in future transports.  The hash value 
					will be the result of the hashing algorithm run across the syslog message, 
					starting with the "&lt;" of the PRI portion of the header part of the 
					message.  The hash algorithm used
					and indicated by the Version field determines the size of
					each hash, but the size MUST NOT be shorter than 160 bits without the use of 
					padding. It is
					base 64 encoded as per <a class='info' href='#RFC4648'>[RFC4648]<span> (</span><span class='info'>Josefsson, S., &ldquo;The Base16, Base32, and Base64 Data Encodings,&rdquo; October&nbsp;2006.</span><span>)</span></a>.
					
</p>
<p>
					The number of hashes in a hash block SHOULD be chosen such that the resulting 
					Signature Block message does not exceed a length of 2048 octets in order to 
					avoid the possibility that truncation occurs.  When more
					hashes need to be sent than fit inside a Signature Block message, it is
					advisable to start a new Signature Block.  
					
</p>
<a name="sig"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.8"></a><h3>4.2.8.&nbsp;
Signature</h3>

<p>
					This is a digital signature, encoded in base 64 
					per <a class='info' href='#RFC4648'>[RFC4648]<span> (</span><span class='info'>Josefsson, S., &ldquo;The Base16, Base32, and Base64 Data Encodings,&rdquo; October&nbsp;2006.</span><span>)</span></a>. 
					The signature is calculated over the completely formatted Signature
					Block message (starting from the first octet of PRI and continuing
					to the last octet of MSG, or STRUCTURED-DATA if MSG is not present),
					before the SIGN parameter (SD Parameter Name and the space before it
					[" SIGN"], "=", and the corresponding value) is added.  
					For the OpenPGP DSA signature scheme, the value of the signature field 
					contains the DSA values r and s, 
					encoded as two multiprecision integers 
					(see <a class='info' href='#RFC4880'>[RFC4880]<span> (</span><span class='info'>Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R. Thayer, &ldquo;OpenPGP Message Format,&rdquo; November&nbsp;2007.</span><span>)</span></a>, Sections 5.2.2 and 3.2), concatenated, 
					and then encoded in base 64 <a class='info' href='#RFC4648'>[RFC4648]<span> (</span><span class='info'>Josefsson, S., &ldquo;The Base16, Base32, and Base64 Data Encodings,&rdquo; October&nbsp;2006.</span><span>)</span></a>.
					
</p>
<a name="sigex"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.9"></a><h3>4.2.9.&nbsp;
Example</h3>

<p>
				An example of a Signature Block message is depicted below, broken into lines to fit 
				internet-draft publication rules.  There is a space at the end of each line, with the 
				exception of the last line which ends with "]".   
				
</p>
<p>
				</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  &lt;110&gt;1 2009-05-03T14:00:39.529966+02:00 host.example.org syslogd
  2138 - [ssign VER="0111" RSID="1" SG="0" SPRI="0" GBC="2" FMN="1"
  CNT="7" HB="K6wzcombEvKJ+UTMcn9bPryAeaU= zrkDcIeaDluypaPCY8WWzwHpPok=
  zgrWOdpx16ADc7UmckyIFY53icE= XfopJ+S8/hODapiBBCgVQaLqBKg=
  J67gKMFl/OauTC20ibbydwIlJC8= M5GziVgB6KPY3ERU1HXdSi2vtdw=
  Wxd/lU7uG/ipEYT9xeqnsfohyH0="
  SIGN="AKBbX4J7QkrwuwdbV7Taujk2lvOf8gCgC62We1QYfnrNHz7FzAvdySuMyfM="]
</pre></div><p>

				
</p>
<p>
				The message is of syslog-sign protocol version "01".  It uses SHA1 as hash algorithm 
				and an OpenPGP DSA signature scheme.  Its reboot session ID is 1.  
				Its Signature Group is 0 which means that all syslog messages go to the same destination; 
				its Signature Priority (which can effectively be ignored because all syslog messages 
				will be 
				signed regardless of their PRI value) is 0.  Its Global Block Counter is 2.  The first
				message number is 1; the message contains 7 message hashes.  
				
</p>
<a name="payncert"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Payload and Certificate Blocks</h3>

<p>
			Certificate Blocks and Payload Blocks provide key management for
			syslog-sign.  Their purpose is to support key management that uses
			public key cryptosystems. 
			
</p>
<a name="prelims"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Preliminaries: Key Management and Distribution Issues</h3>

<p>
				A Payload Block contains public key certificate information that is to be conveyed 
				to the collector.  A Payload Block is sent at the 
				beginning of a new reboot session, carrying public key 
				information in effect for the reboot session.  
				However, a Payload Block is not sent directly, but in (one or more) fragments.  
				Those fragments are termed Certificate Blocks.  Therefore, signers send at 
				least one Certificate Block at the beginning of a new reboot session.  
				
</p>
<p>
				There are three key points to understand about Certificate Blocks:

				</p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>
					They handle a variable-sized payload, fragmenting it if
					necessary and transmitting the fragments as legal syslog
					messages. This payload is built (as described below) at the
					beginning of a reboot session and is transmitted in pieces with
					each Certificate Block carrying a piece. There is
					exactly one Payload Block per reboot session.
					
</dd>
<dt>b.</dt>
<dd>
					The Certificate Blocks are digitally signed. The signer does not
					sign the Payload Block, but the signatures on the Certificate
					Blocks ensure its authenticity. Note that it may not even be
					possible to verify the signature on the Certificate Blocks
					without the information in the Payload Block; in this case the
					Payload Block is reconstructed, the key is extracted, and then
					the Certificate Blocks are verified. (This is necessary even
					when the Payload Block carries a certificate, because some other
					fields of the Payload Block are not otherwise verified.)  In
					practice, most installations keep the same public key over
					long periods of time, so that most of the time, it is easy to
					verify the signatures on the Certificate Blocks, and use the
					Payload Block to provide other useful per-session information.
					
</dd>
<dt>c.</dt>
<dd>
					The kind of Payload Block that is expected is determined by what
					kind of key material is on the collector that receives it. The
					signer and collector (or offline log viewer) both have some key
					material (such as a root public key or pre-distributed public
					key) and an acceptable value for the Key Blob Type in the
					Payload Block, below. The collector or offline log viewer MUST
					NOT accept a Payload Block of the wrong type.
					
</dd>
</dl></blockquote><p>
				
</p>
<a name="build"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Payload Block</h3>

<p>
				The Payload Block is built when a new reboot session is started.
				There is a one-to-one correspondence between reboot sessions and Payload
				Blocks. 
				A signer creates a new Payload Block after each reboot.  The Payload 
				Block is used until the next reboot.  
				
</p>
<a name="payloadfields"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1"></a><h3>5.2.1.&nbsp;
Block Format and Fields</h3>

<p>
				A Payload Block MUST have the following fields:  

				</p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>
					Full local time stamp for the signer at the time the reboot session started.  
					This 
					must be in the time stamp format specified in 
					<a class='info' href='#RFC5424'>[RFC5424]<span> (</span><span class='info'>Gerhards, R., &ldquo;The syslog Protocol,&rdquo; March&nbsp;2009.</span><span>)</span></a>
					(essentially, time stamp format per 
					<a class='info' href='#RFC3339'>[RFC3339]<span> (</span><span class='info'>Klyne, G. and C. Newman, &ldquo;Date and Time on the Internet: Timestamps,&rdquo; July&nbsp;2002.</span><span>)</span></a> with some further restrictions).
					
</dd>
<dt>b.</dt>
<dd>
					Key Blob Type, a one-octet field containing one of five values:

					
<ol class="text">
<li>
						'C' -- a PKIX certificate.
						
</li>
<li>
						'P' -- an OpenPGP certificate (a Transferable Public Key as defined in
						<a class='info' href='#RFC4880'>[RFC4880]<span> (</span><span class='info'>Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R. Thayer, &ldquo;OpenPGP Message Format,&rdquo; November&nbsp;2007.</span><span>)</span></a>, Section 11.1).
						
</li>
<li>
						'K' -- the public key whose corresponding private key is
						being used to sign these messages.  For the OpenPGP DSA signature scheme,
						this field contains the DSA prime p, DSA group order q, 
						DSA group generator g, 
						and DSA public-key value y, encoded as four multiprecision integers 
						(see <a class='info' href='#RFC4880'>[RFC4880]<span> (</span><span class='info'>Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R. Thayer, &ldquo;OpenPGP Message Format,&rdquo; November&nbsp;2007.</span><span>)</span></a>, Sections 5.5.2 and 3.2). 
						
</li>
<li>
						'N' -- no key information sent; key is pre-distributed.
						
</li>
<li>
						'U' -- installation-specific key exchange information
						
</li>
</ol>
					
</dd>
<dt>c.</dt>
<dd>
					The key blob, if any, base 64
					encoded per <a class='info' href='#RFC4648'>[RFC4648]<span> (</span><span class='info'>Josefsson, S., &ldquo;The Base16, Base32, and Base64 Data Encodings,&rdquo; October&nbsp;2006.</span><span>)</span></a> and
					consisting of the raw key data.  
					
</dd>
</dl></blockquote><p>
				
</p>
<p>
				The fields are separated by single space characters.  
				Because a Payload Block is not carried in a 
				syslog message directly, only the corresponding Certificate Blocks, 
				it does not need to be encoded as an SD ELEMENT.    
				The Payload Block does not contain a field that identifies the reboot 
				session; instead, the reboot session can be inferred from the 
				Reboot Session ID parameter of the Certificate Blocks that are used to 
				carry the Payload Block.  
				
</p>
<p>
				When a PKIX certificate is used ("C" key blob type), it is the
				certificate specified in (<a class='info' href='#RFC5280'>[RFC5280]<span> (</span><span class='info'>Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &ldquo;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile,&rdquo; May&nbsp;2008.</span><span>)</span></a>).
				Per <a class='info' href='#RFC5425'>[RFC5425]<span> (</span><span class='info'>Miao, F., Yuzhi, M., and J. Salowey, &ldquo;TLS Transport Mapping for syslog,&rdquo; March&nbsp;2009.</span><span>)</span></a>,
				syslog messages may be transported over the TLS protocol,
				even where there is no PKI.  
				If that transport is used, then the
				device will already have a PKIX certificate and it MAY use the
				private key associated with that certificate to sign messages.  
				In the case where there is no PKI, the chain of trust of a PKIX
				certificate must still be established to meet conventional security
				requirements. 
				The methods for doing this are described in <a class='info' href='#RFC5425'>[RFC5425]<span> (</span><span class='info'>Miao, F., Yuzhi, M., and J. Salowey, &ldquo;TLS Transport Mapping for syslog,&rdquo; March&nbsp;2009.</span><span>)</span></a>.
				
</p>
<a name="origauth"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2"></a><h3>5.2.2.&nbsp;
Signer Authentication and Authorization</h3>

<p>
				When the collector receives a Payload Block, it needs to determine
				whether the signatures are to be trusted. The following methods are
				in scope of this specification:
				</p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>
					X.509 certification path validation: The collector is configured
					with one or more trust anchors (typically root CA certificates),
					which allow it to verify a binding between the subject name and
					the public key. Certification path validation is performed
					as specified in <a class='info' href='#RFC5280'>[RFC5280]<span> (</span><span class='info'>Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &ldquo;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile,&rdquo; May&nbsp;2008.</span><span>)</span></a>.  
					<br />

				  
					If the HOSTNAME contains an FQDN or an IP address, it is then
					compared against the certificate as described in <a class='info' href='#RFC5425'>[RFC5425]<span> (</span><span class='info'>Miao, F., Yuzhi, M., and J. Salowey, &ldquo;TLS Transport Mapping for syslog,&rdquo; March&nbsp;2009.</span><span>)</span></a>,
					Section 5.2. Comparing other forms of HOSTNAMEs is beyond the
					scope of this specification.
					<br />
<br />

				  
					Collectors SHOULD support this method.					
					<br />
<br />

					  
					Note that due to message size restrictions, syslog-sign sends
					only the end-entity certificate in the Payload Block. Depending
					on the PKI deployment, the collector may need to obtain
					intermediate certificates by other means (for example, from a
					directory).					
					
</dd>
<dt>b.</dt>
<dd>
					  X.509 end-entity certificate matching: The collector is
					  configured with information necessary to identify the valid
					  end-entity certificates of its valid peers, and for each peer,
					  the HOSTNAME(s) it is authorized to use.
					  <br />

					
					  To ensure interoperability, implementations MUST support
					  fingerprints of X.509 certificates as described below. Other
					  methods MAY be supported.
					  <br />
<br />


					  Collectors MUST support key blob type 'C', and specifying the
					  list of valid peers using certificate fingerprints.  The
					  fingerprint is calculated and formatted as specified in
					  <a class='info' href='#RFC5425'>[RFC5425]<span> (</span><span class='info'>Miao, F., Yuzhi, M., and J. Salowey, &ldquo;TLS Transport Mapping for syslog,&rdquo; March&nbsp;2009.</span><span>)</span></a>, Section 4.2.2.				
					  <br />
<br />


					  For each peer, the collector MUST support specifying a list of
					  HOSTNAME(s) this peer is allowed to use either as FQDNs or IP
					  addresses. Other forms of HOSTNAMEs are beyond the scope of this
					  specification.					
					  <br />
<br />


					  If the locally configured FQDN is an internationalized domain
					  name, conforming implementations MUST convert it to the ASCII
					  Compatible Encoding (ACE) format for performing comparisons as
					  specified in Section 7 of <a class='info' href='#RFC5280'>[RFC5280]<span> (</span><span class='info'>Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &ldquo;Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile,&rdquo; May&nbsp;2008.</span><span>)</span></a>. 
					  An exact case-insensitive
					  string match MUST be supported, but the implementation MAY also
					  support wildcards of any type ("*", regular expressions, etc.)
					  in locally configured names.					
					  <br />
<br />


					  Signer implementations MUST provide a means to generate a
					  key pair and self-signed certificate in the case that a key pair
					  and certificate are not available through another mechanism, and
					  MUST make the certificate fingerprint available through a
					  management interface.					
					
</dd>
<dt>c.</dt>
<dd>
					  OpenPGP V4 fingerprints: Like X.509 fingerprints, except key
					  blob type 'P' is used, and the fingerprint is calculated as
					  specified in <a class='info' href='#RFC4880'>[RFC4880]<span> (</span><span class='info'>Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R. Thayer, &ldquo;OpenPGP Message Format,&rdquo; November&nbsp;2007.</span><span>)</span></a>, Section 12.2. 
					  When the fingerprint value
					  is display or configured, each byte is represented in
					  hexadecimal (using two uppercase ASCII characters), and space is
					  added after every second byte. For example: "0830 2A52 2CD1 D712
					  6E76 6EEC 32A5 CAE1 03C8 4F6E". 	
					  <br />


					Signers and collectors MAY support this method.
					
</dd>
</dl></blockquote><p>
				   Other methods, such as "web of trust", are beyond the scope of this
				   document.
				
</p>
<a name="buildcert"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Certificate Block</h3>

<p>
				This section describes the format of the Certificate Block and the fields used
				within the Certificate Block, as well as the syslog messages used to carry
				Certificate Blocks.  
				
</p>
<a name="certmsg"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.1"></a><h3>5.3.1.&nbsp;
syslog Messages Containing a Certificate Block</h3>

<p>
					Certificate Blocks are used to get the Payload Block to the collector.
					As with a Signature Block, each Certificate Block is carried in its 
					own syslog message, 
					called Certificate Block message.  
					In case separate collectors are associated with different Signature Groups, 
					Certificate Block messages need to be sent to each collector. 
					
</p>
<p>
					Because certificates can legitimately be much longer than 2048 octets,
					the Payload Block can be split up into several pieces, with 
					each Certificate Block carrying a piece of the Payload Block.  
					Note
					that the signer MAY make the Certificate Blocks of any legal length
					(that is, any length that keeps the entire Certificate Block message 
					within 2048 octets) that holds all the
					required fields. Software that processes Certificate Blocks MUST
					deal correctly with blocks of any legal length.
					The length of the fragment of the Payload Block that a Certificate Block
					carries MUST be at least 1 octet.  The length SHOULD be chosen 
					such that the length of the Certificate
					Block message does not exceed 2048 octets.  
					
</p>
<p>
						A Certificate Block message
						is identified by the presence of an
						SD ELEMENT
						with an SD-ID with the value "ssign-cert".
						In addition, a Certificate Block message
						MUST contain valid APP-NAME, PROCID, and MSGID fields to be compliant with
						syslog protocol.
						Syslog-sign does not mandate particular values for these fields; however,
						for consistency, a signer MUST use the
						same value for APP-NAME, PROCID, and MSGID fields for
						every Certificate Block message, whichever values are chosen.
						It MUST also use the same value for its HOSTNAME field.
						To allow for the possibility of multiple signers per host,
						the combination of APP-NAME and PROCID MUST be unique for each such originator.
						If a signer daemon is restarted, it MAY use a new PROCID for what is otherwise 
						the same signer.    The combination of APP-NAME and PROCID MUST be the same
						that is used for Signature Block messages of the same signer; however, a 
						different MSGID MAY be used for Signature Block and Certificate Block messages.
						It is RECOMMENDED to use 110 as value
						for the PRI field, corresponding to facility 13 (log audit)
						and severity 6 (informational).
						The Certificate Block is
						carried as Structured Data within the Certificate Block message.
						A Certificate Block
						message MAY carry other Structured Data besides the Structured Data of the
						Certificate Block itself.
						The MSG part of a Certificate Block message SHOULD be empty.
					
</p>
<a name="certblock"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2"></a><h3>5.3.2.&nbsp;
Certificate Block Format and Fields</h3>

<p>
					The contents of a Certificate Block message is the Certificate Block itself.  
					Like a Signature Block, the Certificate Block is encoded as an SD ELEMENT.   
					The SD-ID of the Certificate Block is "ssign-cert".  
					The Certificate Block is composed of the following fields, each of which is 
					encoded as an SD Parameter with parameter name as indicated. Each field
					must be printable ASCII, and any binary values are base 64 encoded per 
					<a class='info' href='#RFC4648'>[RFC4648]<span> (</span><span class='info'>Josefsson, S., &ldquo;The Base16, Base32, and Base64 Data Encodings,&rdquo; October&nbsp;2006.</span><span>)</span></a>.
					
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
    Field                       SD-PARAM-NAME      Size in octets
    -----                       -------------      ---- -- ------

    Version                          VER                 4

    Reboot Session ID               RSID                1-10

    Signature Group                   SG                 1

    Signature Priority              SPRI                1-3

    Total Payload Block Length      TPBL                1-8

    Index into Payload Block       INDEX                1-8

    Fragment Length                 FLEN                1-4

    Payload Block Fragment          FRAG              variable
                                             (base 64 encoded binary)

    Signature                       SIGN             variable
                                             (base 64 encoded binary)
</pre></div>
<p>
					The fields MUST be provided in the order listed.  
					New SD parameters MUST NOT be added unless a new Version
					of the protocol is defined.   (Implementations that wish to add proprietary extensions 
					will need to define a separate SD ELEMENT.)
					A Certificate Block is accordingly encoded as follows, where xxx denotes a 
					placeholder for the particular values: 
					
</p>
<p>
					[ssign-cert VER="xxx" RSID="xxx" SG="xxx" SPRI="xxx" TPBL="xxx" 
					INDEX="xxx" FLEN="xxx" FRAG="xxx" SIGN="xxx"]  
					
</p>
<p>
					Values of the fields constitute SD parameter values and are hence enclosed in quotes, 
					per <a class='info' href='#RFC5424'>[RFC5424]<span> (</span><span class='info'>Gerhards, R., &ldquo;The syslog Protocol,&rdquo; March&nbsp;2009.</span><span>)</span></a>.  
					The fields are separated by single spaces and are described below.  Each SD parameter MUST
					occur once and only once.  
					
</p>
<a name="VersionCER"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2.1"></a><h3>5.3.2.1.&nbsp;
Version</h3>

<p>
						The Version field is 4 octets in length. 
						This field is identical in format and meaning to the
						Version field described in <a class='info' href='#Version'>Section&nbsp;4.2.1<span> (</span><span class='info'>Version</span><span>)</span></a>.
						
</p>
<a name="rebootidCER"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2.2"></a><h3>5.3.2.2.&nbsp;
Reboot Session ID</h3>

<p>
						The Reboot Session ID is identical in format and meaning to the 
						RSID field described in
						<a class='info' href='#rebootid'>Section&nbsp;4.2.2<span> (</span><span class='info'>Reboot Session ID</span><span>)</span></a>.
						
</p>
<a name="siggrpCER"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2.3"></a><h3>5.3.2.3.&nbsp;
Signature Group and Signature Priority</h3>

<p>
							The SIG field is identical in format and meaning to the SIG field described in
							<a class='info' href='#siggrp'>Section&nbsp;4.2.3<span> (</span><span class='info'>Signature Group and Signature Priority</span><span>)</span></a>.
							The SPRI field is identical in format and meaning to the SPRI field described there.
						
</p>
<p>
							A signer SHOULD send separate Certificate Block messages for each Signature Group.  
							This ensures that each collector that is associated with a Signature Group will 
							receive the necessary key material in the case that messages of different Signature 
							Groups are sent to different collectors.  Note that the signer needs to get the same 
							Payload Block to each collector, as for any given signer there is a one-to-one 
							relationship between Payload 
							Block and Reboot Session across all Signature Groups.  Deployments that wish  
							to associate different key material (and hence different Payload Blocks) with 
							different Signature Groups can use separate 
							signers for that purpose, each distinguished by its own combination 
							of HOSTNAME, APP-NAME, PROCID.    	
						
</p>
<a name="tpbl"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2.4"></a><h3>5.3.2.4.&nbsp;
Total Payload Block Length</h3>

<p>
						The Total Payload Block Length is a value representing the total length
						of the Payload Block in octets, expressed as a decimal with one to eight octets 
						with leading zeroes omitted.
						
</p>
<a name="index"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2.5"></a><h3>5.3.2.5.&nbsp;
Index into Payload Block</h3>

<p>
						This is a decimal value between 1 and 8 octets, 
						with leading zeroes omitted.  
						It contains the number of octets
						into the Payload Block at which this fragment starts.  The first octet of
						the first fragment is numbered "1".  (Note, it is not numbered "0".)  
						
</p>
<a name="fraglen"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2.6"></a><h3>5.3.2.6.&nbsp;
Fragment Length</h3>

<p>
						The total length of this fragment expressed as a decimal integer
						with one to four octets with leading zeroes omitted.  
						The fragment length must be at least 1.  
						
</p>
<a name="pbfragment"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2.7"></a><h3>5.3.2.7.&nbsp;
Payload Block Fragment</h3>

<p>
						The Payload Block Fragment contains a fragment of the payload block. 
						Its length must match the indicated fragment length.    
						
</p>
<a name="sigCER"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2.8"></a><h3>5.3.2.8.&nbsp;
Signature</h3>

<p>
						This is a digital signature, encoded in base 64, as per 
						<a class='info' href='#RFC4648'>[RFC4648]<span> (</span><span class='info'>Josefsson, S., &ldquo;The Base16, Base32, and Base64 Data Encodings,&rdquo; October&nbsp;2006.</span><span>)</span></a>. The Version field effectively specifies the
						original encoding of the signature. 
						
						The signature is calculated over the completely formatted
						Certificate Block message, before the SIGN parameter is added (see
						<a class='info' href='#sig'>Section&nbsp;4.2.8<span> (</span><span class='info'>Signature</span><span>)</span></a>).
						
						For the OpenPGP DSA signature scheme, the value of the signature field 
						contains the DSA values r and s, 
						encoded as two multiprecision integers 
						(see <a class='info' href='#RFC4880'>[RFC4880]<span> (</span><span class='info'>Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R. Thayer, &ldquo;OpenPGP Message Format,&rdquo; November&nbsp;2007.</span><span>)</span></a>, Sections 5.2.2 and 3.2), concatenated, 
						and then encoded in base 64 <a class='info' href='#RFC4648'>[RFC4648]<span> (</span><span class='info'>Josefsson, S., &ldquo;The Base16, Base32, and Base64 Data Encodings,&rdquo; October&nbsp;2006.</span><span>)</span></a>. 
						
</p>
<a name="certex"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3.2.9"></a><h3>5.3.2.9.&nbsp;
Example</h3>

<p>
					An example of a Certificate Block message is is depicted below, broken into lines to fit 
					internet-draft publication rules.  There are no spaces at the end of the lines that contain 
					the key blob and the signature.  
					
</p>
<p>
					</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
   &lt;110&gt;1 2009-05-03T14:00:39.519307+02:00 host.example.org syslogd
   2138 - [ssign-cert VER="0111" RSID="1" SG="0" SPRI="0" TPBL="587"
   INDEX="1" FLEN="587" FRAG="2009-05-03T14:00:39.519005+02:00 K BACsLMZ
   NCV2NUAwe4RAeAnSQuvv2KS51SnHFAaWJNU2XVDYvW1LjmJgg4vKvQPo3HEOD+2hEkt1z
   cXADe03u5pmHoWy5FGiyCbglYxJkUJJrQqlTSS6vID9yhsmEnh07w3pOsxmb4qYo0uWQr
   AAenBweVMlBgV3ZA5IMA8xq8l+i8wCgkWJjCjfLar7s+0X3HVrRroyARv8EAIYoxofh9m
   N8n821BTTuQnz5hp40d6Z3UudKePu2di5Mx3GFelwnV0Qh5mSs0YkuHJg0mcXyUAoeYry
   5X6482fUxbm+gOHVmYSDtBmZEB8PTEt8Os8aedWgKEt/E4dT+Hmod4omECLteLXxtScTM
   gDXyC+bSBMjRRCaeWhHrYYdYBACCWMdTc12hRLJTn8LX99kv1I7qwgieyna8GCJv/rEgC
   ssS9E1qARM+h19KovIUOhl4VzBw3rK7v8Dlw/CJyYDd5kwSvCwjhO21LiReeS90VPYuZF
   RC1B82Sub152zOqIcAWsgd4myCCiZbWBsuJ8P0gtarFIpleNacCc6OV3i2Rg=="
   SIGN="AKAQEUiQptgpd0lKcXbuggGXH/dCdQCgdysrTBLUlbeGAQ4vwrnLOqSL7+c="]
</pre></div><p>

				
</p>
<p>
				The message is of syslog-sign protocol version "01".  It uses SHA1 as hash algorithm and an
				OpenPGP DSA signature scheme.  Its reboot session ID is 1.  
				Its Signature Group is 0; its Signature Priority is 0.  The Total Payload Block Length
				is 587.  The index into the payload block is 1 (meaning this is the first fragment).  
				The length of the fragment is 587 (meaning that the Certificate Block message contains the 
				entire Payload Block).  The Payload Block has the time stamp 2009-05-03T14:00:39.519005+02:00.  
				The Key Blob Type is 'K', meaning that it contains a public key whose corresponding 
				private key is being used to sign these messages.    
				
</p>
<p>
				Note that the Certificate Block message in this example has a time stamp
				that is very close to the time stamp in the Payload Block.  
				The fact that the time stamps are so close implies that this is the first 
				Certificate Block message
				sent in this reboot session; additional Certificate Block messages can be 
				sent later with a later time stamp, which will carry the same Payload Block 
				that will still contain the same time stamp.  
				
</p>
<a name="redunnflex"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Redundancy and Flexibility</h3>

<p>
				As described in Section 8.5 of <a class='info' href='#RFC5424'>[RFC5424]<span> (</span><span class='info'>Gerhards, R., &ldquo;The syslog Protocol,&rdquo; March&nbsp;2009.</span><span>)</span></a>, 
				a transport sender may
				discard syslog messages.  Likewise, when syslog messages are sent over
				unreliable transport, they can be lost in transit.  
				However, if a collector does not receive
				Signature and Certificate Blocks, many messages may not be able to
				be verified. The signer is allowed to send Signature and
				Certificate Blocks multiple times.  Sending Signature and Certificate Blocks 
				multiple times provides redundancy with the intent to ensure that
				the collector or relay does get the Signature Blocks and in particular the 
				Payload Block at some point in time.  In the meantime, any online review of logs 
				as described in <a class='info' href='#online'>Section&nbsp;7.2<span> (</span><span class='info'>Online Review of Logs</span><span>)</span></a> is delayed until the 
				needed blocks are received.      
				The collector MUST ignore duplicats of 
				Signature Blocks and Certificate Blocks that it has already received and
				authenticated.  The signer can in principle change its redundancy
				level for any reason, without communicating this fact to the
				collector.
				
</p>
<p>
				A signer that is also the originator of messages that it signs 
				does not need to queue up other messages while sending 
				redundant Certificate Block and Signature Block messages.  It MAY send redundant 
				Certificate Block messages even after Signature Block messages 
				and regular syslog messages have been sent.  By the same token, it MAY
				send redundant Signature Block messages even after newer syslog messages 
				that are signed by a subsequent Signature Block have been sent, or even 
				after a subsequent Signature Block message.  
				
</p>
<p> 
				In addition, the signer has flexibility in how many hashes to include within 
				a Signature Block.  It is legitimate for an originator to send short Signature
				Blocks to allow the collector to verify messages with minimal delay.  
				
</p>
<a name="confpar"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Configuration parameters</h3>

<p>
				Although the transport sender is not constrained in how it decides to send
				redundant Signature and Certificate Blocks, or even in whether it
				decides to send along multiple copies of normal syslog messages,
				we define some redundancy parameters below which may be useful
				in controlling redundant transmission from the transport sender to the
				transport receiver, and which may be useful for administrators to configure.  
				
</p>
<a name="redunCertblk"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.1"></a><h3>6.1.1.&nbsp;
Configuration Parameters for Certificate Blocks</h3>

<p>
					Certificate Blocks are always sent at the beginning of a new reboot
					session.  One technique to ensure reliable delivery (see Section 8.5) is to send 
					multiple copies. This can be controlled by a "certInitialRepeat" parameter:

					</p>
<blockquote class="text">
<p>
					certInitialRepeat = number of times each Certificate Block should be
					sent before the first message is sent.  
					
</p>
</blockquote><p>
					It is also useful to resend Certificate Blocks every now and then
					for long-lived reboot sessions. This can be controlled by the certResendDelay 
					and certResendCount parameters:

					</p>
<blockquote class="text">
<p>
					certResendDelay  = maximum time delay in seconds until resending the  
					Certificate Block.    
					
</p>
<p>
					certResendCount  = maximum number of other syslog messages to send until resending 
					the Certificate Block.  
					
</p>
</blockquote><p>
					In some cases, it may be desirable to allow for configuration of the
					transport sender such that Certificate Blocks are not sent at all after
					the first normal syslog message has been sent.
					This could be expressed by 
					setting both certResendDelay and certResendCount to "0".  	
					However, it is RECOMMENDED
					to configure the transport sender to send redundant Certificate Blocks even after the 
					first message is sent when the UDP transport <a class='info' href='#RFC5426'>[RFC5426]<span> (</span><span class='info'>Okmianski, A., &ldquo;Transmission of syslog Messages over UDP,&rdquo; March&nbsp;2009.</span><span>)</span></a>
					is used.  			
					
</p>
<p>
						Implementations which support sending syslog messages of different 
						Signature Groups to different collectors and which wish to offer very granular
						controls MAY allow the above 
						parameters to be configured on a per Signature Group basis.  
					
</p>
<a name="redunSigblk"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1.2"></a><h3>6.1.2.&nbsp;
Configuration Parameters for Signature Blocks</h3>

<p>
					Verification of log messages involves a certain delay of time that is caused by the lag 
					in time
					between the sending of the message itself and the corresponding Signature Block.  
					The following configuration parameter can be useful to limit the time lag that will 
					be incurred (note that the maximum message length may also force
					generating a Signature Block; see Sections <a class='info' href='#count'>Section&nbsp;4.2.6<span> (</span><span class='info'>Count</span><span>)</span></a> and 
					<a class='info' href='#hash'>Section&nbsp;4.2.7<span> (</span><span class='info'>Hash Block</span><span>)</span></a>):  
					</p>
<blockquote class="text">
<p>
					   sigMaxDelay = generate a new Signature Block if this many seconds
					   have elapsed since the message with the First Message Number of the Signature Block 
					   was sent.  
					
</p>
</blockquote><p>

				   Retransmissions of Signature Blocks are not sent immediately after
				   the original transmission, but slightly later. The following
				   parameters control when those retransmissions are done:

					</p>
<blockquote class="text">
<p> 
					sigNumberResends = number of times a Signature Block is resent.
					(It is recommended so select a value of greater than "0"
					in particular when the UDP transport <a class='info' href='#RFC5426'>[RFC5426]<span> (</span><span class='info'>Okmianski, A., &ldquo;Transmission of syslog Messages over UDP,&rdquo; March&nbsp;2009.</span><span>)</span></a> is used.)  
					
</p>
<p>
					sigResendDelay   = send the next retransmission when this many seconds have elapsed
					since the previous sending of this Signature Block.
					
</p>
<p>
					sigResendCount   = send the next retransmission when this many other syslog messages have
					been sent since the previous sending of this Signature Block.
					
</p>
</blockquote><p>
					
</p>
<a name="flex"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Overlapping Signature Blocks</h3>

<p>
				Notwithstanding the fact that the signer is not constrained in whether it 
				decides to send redundant Signature Block messages, Signature Blocks SHOULD NOT overlap.  
				This facilitates their processing by the receiving collector.  
				This means that an originator of 
				Signature Block messages, after having sent a first message with some
				First Message Number and a Count, SHOULD NOT send a second message with the same 
				First Message Number but a different Count.   
				It also means that an originator of Signature Block messages SHOULD NOT 
				send a second message whose First Message Number is greater than the First Message 
				Number, but smaller than the First Message Number plus the Count indicated in the 
				first message.  
				
</p>
<p>
				That said, the possibility of Signature Blocks that overlap does provide additional
				flexibility with regards to redundancy; it provides an additional option that may 
				be desirable in some deployments.  
				Therefore collectors MUST be designed in a way that they can cope with
				overlapping Signature Blocks when confronted with them.   The collector MUST
				ignore hashes of messages that it has already received and validated.  
				
</p>
<a name="verify"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Efficient Verification of Logs</h3>

<p>
			The logs secured with syslog-sign may be reviewed either online or
			offline. Online review is somewhat more complicated and
			computationally expensive, but not prohibitively so. 
			This section outlines a method for online and a method for 
			offline verification of logs which implementations MAY
			choose to implement to verify logs efficiently.  
			Implementations MAY also choose to implement a different method; it is 
			ultimately up to each implementation how to process the messages that 
			it receives.  
			
</p>
<a name="offline"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Offline Review of Logs</h3>

<p>
					When the collector stores logs to be reviewed later, they can be
					authenticated offline just before they are reviewed. Reviewing these
					logs offline is simple and relatively inexpensive in terms of resources
					used, so long as there is enough space available on the reviewing
					machine. 
				
</p>
<p>
					To do so, we first go through the stored log file.  Each message
					in the log file is classified
					as a normal message, a Signature Block message, or a
					Certificate Block message.
					Signature Blocks and Certificate Blocks are then separated by
					signer (as identified by HOSTNAME, APP-NAME, PROCID), Reboot Session ID,
					and Signature Group, and stored in their own
					files. Normal messages are stored in a keyed file, indexed on
					their hash values.  They are not separated by signer, as their
					(HOSTNAME, APP-NAME, PROCID) identifies the application that
					generated the message.  The application that generated the message
					does not have to coincide with the signer.
				
</p>
<p>
					For each signer, Reboot Session ID,
					and Signature Group, we then do the following:
				</p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>
						We sort the Certificate Block file by INDEX value, and check to
						see whether we have a set of Certificate Blocks that can reconstruct
						the Payload Block. If so, we reconstruct the Payload Block,
						verify any key-identifying information, and then use this to
						verify the signatures on the Certificate Blocks we have received.
						When this is done, we have verified the reboot session and key
						used for the rest of the process.
						
</dd>
<dt>b.</dt>
<dd>
						We sort the Signature Block file by First Message Number. We now
						create an authenticated log file, which consists of some
						header information and then a sequence of message number,
						message text pairs. 
						We next go through the Signature Block file.
						We initialize a cursor for the last message number processed with the number 0.  
						For each Signature Block in the file, we do the following:
					
<ol class="text">
<li>
						Verify the signature on the Signature Block.
						
</li>
<li>
						If the value of the First Message Number of the Signature Block is less than or equal 
						to the last message number processed, skip the first (last message number processed
						minus First Message Number plus 1) hashes.  
						
</li>
<li>
						For each remaining hashed message in the Signature Block:

						
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>
							Look up the hash value in the keyed message file.
							
</dd>
<dt>b.</dt>
<dd>
							If the message is found, write (message number, message
							text) to the authenticated log file.
							
</dd>
</dl></blockquote>
						
</li>
<li>
						Set the last message number processed to the value of the 
						First Message Number plus the Count of the Signature Block
						minus 1.  
						
</li>
<li>
						Skip all other Signature Blocks with the same
						First Message Number unless one with a larger Count is encountered.
						
</li>
</ol>
					
					The resulting authenticated log file contains all messages
					that have been authenticated.  In addition, it implicitly indicates 
					all gaps in the authenticated messages (specifically 
					in the case when all messages of the same Signature Group 
					are sent to the same collector), because their 
					message numbers are missing. 
					
</dd>
</dl></blockquote><p>
				
				One can see that, assuming sufficient space for building
				the keyed file, this whole process is linear in the number of
				messages (generally two seeks, one to write and the other to read,
				per normal message received), and O(N lg N) in the number of
				Signature Blocks. This estimate comes with two caveats: first, the
				Signature Blocks arrive very nearly in sorted order, and so can
				probably be sorted more cheaply on average than O(N lg N) steps.
				Second, the signature verification on each Signature Block
				almost certainly is more expensive than the sorting step in
				practice. We have not discussed error-recovery, which may be
				necessary for the Certificate Blocks. In practice, a simple
				error-recovery strategy is probably enough: if the Payload
				Block is not valid, then we can just try alternate
				instances of each Certificate Block, if such are available, until we
				get the Payload Block right.
				
</p>
<p>
				It is easy for an attacker to flood us with plausible-looking
				messages, Signature Blocks, and Certificate Blocks.
				
</p>
<a name="online"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Online Review of Logs</h3>

<p>
					Some collector implementations may need to monitor log
					messages in close to real-time. This can be done with
					syslog-sign, though it is somewhat more complex than offline
					verification.
					This is done as follows:  

					</p>
<blockquote class="text"><dl>
<dt>a.</dt>
<dd>
						We have an authenticated message file, into which we write (message number,
						message text) pairs which have been authenticated. We will
						assume that we are handling only one signer, Signature Group, and
						Reboot Session ID at any given time.  
						(For the concurrent support of multiple signers, Signature Groups, and Reboot Session IDs, 
						the same procedure is applied analogously to each.  
						Signature Block mesages and Certificate Block 
						messages clearly indicate their respective signer, Signature Group, and Reboot Session ID.)
					
</dd>
<dt>b.</dt>
<dd>
					We have three data structures: A queue in which (message
					number, hash of message) pairs are kept in sorted order, a queue
					in which (arrival sequence, hash of message) pairs are kept in sorted
					order, and a hash table that stores (message text, count) pairs
					indexed by hash value. In the hash table, count may be any number
					greater than zero; when count is zero, the entry in the hash
					table is cleared.
					
</dd>
<dt>c.</dt>
<dd>
					We must receive all the Certificate Blocks before any other
					processing can really be done. (This is why they are sent first.)
					Once that is done, any additional Certificate Block message that arrives is
					discarded.  
					Any syslog messages or Signature Block messages that arrive before all 
					Certificate Blocks have been received need to be buffered.  Once all 
					Certificate Blocks have been received, the messages in the buffer can be 
					retrieved and processed as if they were just arriving.  
					
</dd>
<dt>d.</dt>
<dd>
					Whenever a normal message arrives, we add (arrival sequence,
					hash of message) to our message queue. If our hash table has an
					entry for the message's hash value, we increment its count by
					one; otherwise, we create a new entry with count = 1. If the
					message queue is full, we roll the oldest messages off the queue
					by taking the oldest entry in the queue, and using it to index the
					hash table. If that entry has count 1, we delete the entry from
					the hash table; otherwise, we decrement its count.  We then
					delete the oldest entry in the queue.
					
</dd>
<dt>e.</dt>
<dd>
					Whenever a Signature Block message arrives, we check its originator, 
					(i.e. the signer) by way of HOSTNAME, APP-NAME, PROCID, as well as its 
					Signature Group, and Reboot
					Session ID to ensure it matches our Certificate Blocks.  
					We then check to see whether the
					First Message Number value is too old to still be of interest, 
					or if another Signature
					Block with that First Message Number and the same Count or a greater Count 
					has already been received. If
					so, we discard the Signature Block. 
					
					Otherwise, we check
					its signature and discard it if the signature is not valid. 
					
					A Signature Block contains a sequence of hashes, each of which is associated 
					with a message number, starting with the First Message Number for the first 
					hash and incrementing by one for each subsequent hash.  
					
					For each hash, we first check to see whether the message
					hash is in the hash table. If this is the case, we do the following:
					
<blockquote class="text"><dl>
<dt>A.</dt>
<dd>
						We check if a message with the same message 
						number is already in the authenticated message queue.  
						
</dd>
<dt>B.</dt>
<dd>
						If that is not the case, we write the (message
						number, message text) into the authenticated message queue, 
						otherwise the signed hash is a duplicate and we discard it.  
						
</dd>
</dl></blockquote>
									
					Otherwise (the message hash is not in the hash table), 
					we write the (message number, message hash) to the
					message number queue. This generally involves rolling the oldest
					entry out of this queue: before this is done, that entry's hash
					value is again looked up in the hash table. If a matching
					entry is found, a check is made if the authenticated message file already contains
					an entry with the same message number and if that is not the case, 
					the (message number, message text) pair is
					written to the authenticated message.  In either case,
					the oldest entry is then discarded.
					
</dd>
<dt>f.</dt>
<dd>
					The result of this is a sequence of messages in the
					authenticated message file, each of which has been
					authenticated, and which are labeled with numbers showing their
					order of original transmission.
					
</dd>
</dl></blockquote><p>
				
				One can see that this whole process is roughly linear
				in the number of messages, and also in the number of Signature
				Blocks received. The process is susceptible to flooding attacks; an
				attacker can send enough normal messages that the messages roll off
				their queue before their Signature Blocks can be processed.
				
</p>
<a name="security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Security Considerations</h3>

<p>
			Normal syslog event messages are unsigned and have most of the security attributes
			described in Section 8 
			of <a class='info' href='#RFC5424'>[RFC5424]<span> (</span><span class='info'>Gerhards, R., &ldquo;The syslog Protocol,&rdquo; March&nbsp;2009.</span><span>)</span></a>.  This document also describes Certificate Blocks
			and Signature Blocks, which are signed syslog messages.  The Signature Blocks contain
			signature information for previously sent syslog event messages.  All of this 
			information can be used to authenticate syslog messages and to minimize or obviate
			many of the security concerns described in <a class='info' href='#RFC5424'>[RFC5424]<span> (</span><span class='info'>Gerhards, R., &ldquo;The syslog Protocol,&rdquo; March&nbsp;2009.</span><span>)</span></a>.  
			
</p>
<p>
			The model for syslog-sign is a direct trust system where the certificate transferred 
			is its own trust anchor. If a transport sender sends a stream of syslog messages that is 
			signed using a certificate, the operator or application will transfer to the transport receiver 
			the certificate that was used when signing. There is no need for a certificate chain. 
			
</p>
<a name="SecCrypto"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
Cryptographic Constraints</h3>

<p>
				As with any technology involving cryptography, it is advisable to check
				the current literature to determine whether any algorithms used here
				have been found to be vulnerable to attack.
				
</p>
<p>
				This specification uses Public Key Cryptography
				technologies. The proper party or parties have to control
				the private key portion of a public-private key pair.
				Any party that controls a private key can sign anything
				it pleases.
				
</p>
<p>
				Certain operations in this specification involve the use of
				random numbers. An appropriate entropy source SHOULD be used to
				generate these numbers. See <a class='info' href='#RFC4086'>[RFC4086]<span> (</span><span class='info'>Eastlake, D., Schiller, J., and S. Crocker, &ldquo;Randomness Recommendations for Security,&rdquo; June&nbsp;2005.</span><span>)</span></a>
				and <a class='info' href='#NIST800.90'>[NIST800.90]<span> (</span><span class='info'>National Institute of Standards and Technology, &ldquo;NIST Special Publication 800-90: Recommendation for Random Number Generation using Deterministic Random Bit Generators,&rdquo; June&nbsp;2006.</span><span>)</span></a>.
				
</p>
<a name="SecPacket"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2"></a><h3>8.2.&nbsp;
Packet Parameters</h3>

<p>
				As a signer, it is advisable to avoid message lengths exceeding 2048 octets.  
				Various problems might result
				if a signer were to send messages with a length greater than 2048
				octets, because relays MAY truncate messages with lengths 
				greater than 2048 octets which would make it impossible for collectors to 				
				validate a hash of the packet.  To increase
				the chance of interoperability, it tends to be  
				best to be conservative with what
				you send but liberal in what you are able to receive.  
				
</p>
<p>
				Signers need to rigidly enforce the correctness of message bodies.
				Problems may 
				arise if the collector does not fully accept the syslog packets sent from an
				signer, or if it has problems with the format of the Certificate Block or
				Signature Block messages.
				
</p>
<p>
				Collectors are not to malfunction in case they receive malformed syslog messages or 
				messages containing characters other than those specified in this document.  In other 
				words, they are to ignore such messages and continue working.
				
</p>
<a name="SecAuth"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.3"></a><h3>8.3.&nbsp;
Message Authenticity</h3>

<p>
				Syslog does not strongly associate the message
				with the message originator.  That association is established by the collector upon 
				verification of the Signature Block.  Before a Signature Block is used to
				ascertain the authenticity of an event message, it might be received, stored, and
				reviewed by a person or automated parser.  It is advisable not to assume a message is 
				authentic until after a message has been
				validated by checking the contents of the Signature Block.
				
</p>
<p>
				With the Signature Block checking, an attacker may only forge messages if he or she
				can compromise the private key of the true originator.  
				
</p>
<a name="SeqReplay"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.4"></a><h3>8.4.&nbsp;
Replaying</h3>

<p>
				Event messages might be recorded and replayed by an
				attacker.  Using the information contained in the
				Signature Blocks, a reviewer can determine whether the received messages are the ones
				originally sent by an originator.  The reviewer can also identify messages that have 
				been replayed.  Using a method for verification of logs such as the one  
				outlined in <a class='info' href='#verify'>Section&nbsp;7<span> (</span><span class='info'>Efficient Verification of Logs</span><span>)</span></a>, a replayed message can be detected by checking
				prior to writing a message to the authenticated log file whether the message is 
				already contained in it.  
				
</p>
<a name="SecRelDel"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.5"></a><h3>8.5.&nbsp;
Reliable Delivery</h3>

<p>
				Event messages sent over UDP might be lost in transit.
				<a class='info' href='#RFC5425'>[RFC5425]<span> (</span><span class='info'>Miao, F., Yuzhi, M., and J. Salowey, &ldquo;TLS Transport Mapping for syslog,&rdquo; March&nbsp;2009.</span><span>)</span></a> can be used for 
				the reliable delivery of syslog messages; 
				however, it does not protect against loss of syslog messages at the 
				application layer, for example if the TCP connection or TLS session has been 
				closed by the transport receiver for some reason.  
				A reviewer can pinpoint any messages sent by the originator but not 
				received by the collector by reviewing the Signature Block information.  
				In addition, the information in
				subsequent Signature Blocks allows a
				reviewer to determine whether any Signature Block messages
				were lost in transit.
				
</p>
<a name="SecSeq"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.6"></a><h3>8.6.&nbsp;
Sequenced Delivery</h3>

<p>
				Syslog messages delivered over UDP might not only be lost, but
				also arrive out of sequence.  
				A reviewer can determine the original order of syslog messages and identify 
				which messages were delivered out of order by examining the information 
				in the Signature Block 
				along with any timestamp information in the message.
				
</p>
<a name="SecInt"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.7"></a><h3>8.7.&nbsp;
Message Integrity</h3>

<p>
				Syslog messages might be damaged in transit.  A review of
				the information in the Signature Block determines whether
				the received message was the intended message sent by
				the originator. A damaged Signature Block or Certificate
				Block is evident because the collector will not be
				able to validate that it was signed by the signer.
				
</p>
<a name="SecObs"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.8"></a><h3>8.8.&nbsp;
Message Observation</h3>

<p>
				Unless TLS is used as a secure transport <a class='info' href='#RFC5425'>[RFC5425]<span> (</span><span class='info'>Miao, F., Yuzhi, M., and J. Salowey, &ldquo;TLS Transport Mapping for syslog,&rdquo; March&nbsp;2009.</span><span>)</span></a>,
				event messages, Certificate Blocks, and Signature Blocks are all sent in plaintext.  
				This allows network administrators to read the
				message when sniffing the wire.  However, this also allows an attacker to see the
				contents of event messages and perhaps to use that information for malicious purposes.
				
</p>
<a name="SecMITM"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.9"></a><h3>8.9.&nbsp;
Man In The Middle Attacks</h3>

<p>
				It is conceivable that an attacker might intercept Certificate Block messages and insert 
				its own Certificate information.  In that case, the attacker would be able to receive
				event messages from the actual originator and then relay modified messages, insert new
				messages, or delete messages.  It would then be able to construct a Signature Block
				and sign it with its own private key.  Network administrators need to verify
				that the key contained in the Payload Block is indeed the key being used on the
				actual signer.  If that is the case, then this MITM attack will not succeed.
				Methods for establishing a chain of trust are also described 
				in <a class='info' href='#RFC5425'>[RFC5425]<span> (</span><span class='info'>Miao, F., Yuzhi, M., and J. Salowey, &ldquo;TLS Transport Mapping for syslog,&rdquo; March&nbsp;2009.</span><span>)</span></a>.
				
</p>
<a name="SecDen"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.10"></a><h3>8.10.&nbsp;
Denial of Service</h3>

<p>

				An attacker might send invalid Signature Block messages to overwhelm the collector's 
				processing capability and consume all available resources.
				For this reason, it can be appropriate to simply 
				receive the Signature Block messages and process them only as time permits.
				
</p>
<p>
				An attacker might also just overwhelm a collector by sending more
				messages to it than it can handle.   
				Implementers are advised to consider features that minimize this threat,  
				such as only accepting syslog messages from known IP addresses.
				
</p>
<a name="SecCov"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.11"></a><h3>8.11.&nbsp;
Covert Channels</h3>

<p>
				Nothing in this protocol attempts to eliminate covert
				channels.  In fact, just about every aspect of
				syslog messages lends itself to the conveyance of covert
				signals.  For example, a collusionist could send odd and
				even PRI values to indicate Morse Code dashes and dots.
				
</p>
<a name="iana"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
IANA Considerations</h3>

<a name="ianaSyslog"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1"></a><h3>9.1.&nbsp;
Structured Data and syslog messages</h3>

<p>
				With regard to  <a class='info' href='#RFC5424'>[RFC5424]<span> (</span><span class='info'>Gerhards, R., &ldquo;The syslog Protocol,&rdquo; March&nbsp;2009.</span><span>)</span></a>,
				IANA is requested to add the following values to the registry entitled "syslog 
				Structured Data id values":    

				</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
       SD-ID         PARAM_NAME
       -----         ----------
       ssign
                     VER
                     RSID
                     SG
                     SPRI
                     GBC
                     FMN
                     CNT
                     HB
                     SIGN

       ssign-cert
                     VER
                     RSID
                     SG
                     SPRI
                     TPBL
                     INDEX
                     FLEN
                     FRAG
                     SIGN
</pre></div><p>

				
				In addition, several fields need to be controlled by the IANA in both 
				the Signature Block and the Certificate Block, as outlined in the following
				sections.
				
</p>
<a name="ianaVer"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.2"></a><h3>9.2.&nbsp;
Version Field</h3>

<p>
				IANA is requested to create three registries, each associated with a different subfield
				of the Version field of Signature Blocks and Certificate Blocks, described in 
				<a class='info' href='#Version'>Section&nbsp;4.2.1<span> (</span><span class='info'>Version</span><span>)</span></a> and <a class='info' href='#VersionCER'>Section&nbsp;5.3.2.1<span> (</span><span class='info'>Version</span><span>)</span></a>, respectively.  
				
</p>
<p>
				The first registry that IANA is requested to create 
				is entitled "syslog-sign protocol version values".   
				It is for the values of the Protocol Version subfield.  The Protocol Version subfield 
				constitutes the first 2 octets in the Version field.  
				New values shall be assigned by the IANA using the "IETF Review" policy
				defined in <a class='info' href='#RFC5226'>[RFC5226]<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a>.  
				Assigned numbers are to be increased by 1, up to a maximum value of "50".  
				Protocol Version numbers of "51" through "99" are vendor-specific;
				values in this range are not to be assigned by the IANA.  
				
</p>
<p>
				IANA is requested to register the Protocol Version values shown below.  

				</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      VALUE                    PROTOCOL VERSION
      -----                    ----------------
      00                       Reserved
      01                       Defined in RFC yyyy
</pre></div><p>


				The second registry that IANA is requested to create 
				is entitled "syslog-sign hash algorithm values". 
				It is for the values of the Hash Algorithm subfield.  The Hash Algorithm subfield 
				constitutes the third octet in the Version field Signature Blocks and Certificate Blocks.  
				New values shall be assigned by the IANA using the "IETF Consensus" policy
				defined in <a class='info' href='#RFC5226'>[RFC5226]<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a>.  Assigned values are to 
				be increased sequentially, first up to a maximum value of "9", then from "a" to "z", then 
				from "A" to "Z".  
				The values are registered relative to the Protocol Version.  This means that the same 
				Hash Algorithm value can be reserved for different Protocol Versions, possibly referring
				to a different hash algorithm each time.  This makes it possible to 
				deal with future scenarios in which the single octet representation becomes a limitation, 
				as more Hash Algorithms can be supported by defining additional Protocol Versions that 
				implementations might support concurrently.  
				
</p>
<p>
				IANA is requested to register the Hash Algorithm values shown below.  

				</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      VALUE     PROTOCOL VERSION     HASH ALGORITHM
      -----     ----------------     --------------
      0         01                   Reserved
      1         01                   SHA1
      2         01                   SHA256
</pre></div><p>


				The third registry that IANA is requested to create 
				is entitled "syslog-sign signature scheme values". 
				It is for the values of the Signature Scheme subfield.  The Signature Scheme subfield 
				constitutes the fourth octet in the Version field of Signature Blocks and Certificate 
				Blocks.  New values shall be assigned by the IANA using the "IETF Consensus" policy
				defined in <a class='info' href='#RFC5226'>[RFC5226]<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a>.  Assigned values are to 
				be increased by 1, up to a maximum value of "9".  This means that the same 
				Signature Scheme value can be reserved for different Protocol Versions, possibly in each 
				case referring to a different Signature Scheme each time.  This makes it possible to 
				deal with future scenarios in which the single octet representation becomes a limitation, 
				as more Signature Schemes can be supported by defining additional Protocol Versions that 
				implementations might support concurrently.  
				
</p>
<p>
				IANA is requested to register the Signature Scheme values shown below.  

				</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      VALUE     PROTOCOL VERSION    SIGNATURE SCHEME
      -----     ----------------    ----------------
      0         01                  Reserved
      1         01                  OpenPGP DSA
</pre></div><p>

				
</p>
<a name="ianaSIG"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.3"></a><h3>9.3.&nbsp;
SG Field</h3>

<p>
				IANA is requested to create a registry entitled "syslog-sign sg field values".  
				It is for values of the SG Field as defined in <a class='info' href='#siggrp'>Section&nbsp;4.2.3<span> (</span><span class='info'>Signature Group and Signature Priority</span><span>)</span></a>.
				New values shall be assigned by 
				the IANA using the "IETF Consensus" policy defined in 
				<a class='info' href='#RFC5226'>[RFC5226]<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a>.  Assigned values are to be incremented by 1, 
				up to a maximum value of "7".  
				Values "8" and "9" shall be left as vendor specific and shall not be assigned by the IANA.
				
</p>
<p>
				IANA is requested to register the SG Field values shown below.

				</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      VALUE     MEANING
      -----     -------
      0         per RFC yyyy
      1         per RFC yyyy
      2         per RFC yyyy
      3         per RFC yyyy
</pre></div><p>

				
</p>
<a name="ianabuild"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.4"></a><h3>9.4.&nbsp;
Key Blob Type</h3>

<p>
				IANA is requested to create a registry entitled "syslog-sign key blob type values".   
				It is to register one-character identifiers for the key blob type, per
				<a class='info' href='#build'>Section&nbsp;5.2<span> (</span><span class='info'>Payload Block</span><span>)</span></a>.  New values shall be assigned by 
				the IANA using the "IETF Consensus" policy defined in 
				<a class='info' href='#RFC5226'>[RFC5226]<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a>.  Uppercase letters may be assigned as values.  
				Lowercase letters are left as vendor specific and shall not be assigned by the IANA.	
				
</p>
<p>
				IANA is requested to register the key blob type values shown below.

				</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      VALUE     KEY BLOB TYPE
      -----     ------------
      'C'       a PKIX certificate
      'P'       an OpenPGP certificate
      'K'       the public key whose corresponding private key is
                used to sign the messages
      'N'       no key information sent, key is pre-distributed
      'U'       installation-specific key exchange information
</pre></div><p>

				
</p>
<a name="authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Working Group</h3>

<p>
			The working group can be contacted via the mailing list:

				</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      syslog@ietf.org
</pre></div><p>

			
</p>
<p>
			The current Chairs of the Working Group can be contacted at:
				</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      Chris Lonvick
      Cisco Systems
      Email: clonvick@cisco.com

      David Harrington
      Huawei Technologies (USA)
      Email: ietfdbh@comcast.net
             dharrington@huawei.com
      Tel: +1-603-436-8634
</pre></div><p>

			
</p>
<a name="acks"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Acknowledgements</h3>

<p>
			The authors wish to thank Alex Brown, Chris Calabrese, Steve Chang, 
			Pasi Eronen, Carson
			Gaspar, Rainer Gerhards, Drew Gross, David Harrington, Chris Lonvick, Albert Mietus, Darrin New, 
			Marshall Rose, 
			Andrew Ross, Martin Schuette, Holt Sorenson, Rodney Thayer, 
			and the many Counterpane Internet Security engineering and 
			operations people who commented on various versions of this proposal.
			
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="FIPS.186-2.2000">[FIPS.186-2.2000]</a></td>
<td class="author-text">National Institute of Standards and Technology, &ldquo;<a href="http://csrc.nist.gov/publications/fips/fips186-2/fips186-2-change1.pdf">Digital Signature Standard</a>,&rdquo; FIPS&nbsp;PUB 186-2, January&nbsp;2000.</td></tr>
<tr><td class="author-text" valign="top"><a name="FIPS.180-2.2002">[FIPS.180-2.2002]</a></td>
<td class="author-text">National Institute of Standards and Technology, &ldquo;<a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf">Secure Hash Standard</a>,&rdquo; FIPS&nbsp;PUB 180-2, August&nbsp;2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:-">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="ftp://ftp.isi.edu/in-notes/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4648">[RFC4648]</a></td>
<td class="author-text">Josefsson, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>,&rdquo; RFC&nbsp;4648, October&nbsp;2006 (<a href="ftp://ftp.isi.edu/in-notes/rfc4648.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4880">[RFC4880]</a></td>
<td class="author-text">Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R. Thayer, &ldquo;<a href="http://tools.ietf.org/html/rfc4880">OpenPGP Message Format</a>,&rdquo; RFC&nbsp;4880, November&nbsp;2007.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5226">[RFC5226]</a></td>
<td class="author-text"><a href="mailto:narten@raleigh.ibm.com">Narten, T.</a> and <a href="mailto:Harald@Alvestrand.no">H. Alvestrand</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>,&rdquo; BCP&nbsp;26, RFC&nbsp;5226, May&nbsp;2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5280">[RFC5280]</a></td>
<td class="author-text">Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, &ldquo;<a href="http://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>,&rdquo; RFC&nbsp;5280, May&nbsp;2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5424">[RFC5424]</a></td>
<td class="author-text">Gerhards, R., &ldquo;<a href="http://tools.ietf.org/html/rfc5424">The syslog Protocol</a>,&rdquo; RFC&nbsp;5424, March&nbsp;2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5425">[RFC5425]</a></td>
<td class="author-text">Miao, F., Yuzhi, M., and J. Salowey, &ldquo;<a href="http://tools.ietf.org/html/rfc5425">TLS Transport Mapping for syslog</a>,&rdquo; RFC&nbsp;5425, March&nbsp;2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5426">[RFC5426]</a></td>
<td class="author-text">Okmianski, A., &ldquo;<a href="http://tools.ietf.org/html/rfc5426">Transmission of syslog Messages over UDP</a>,&rdquo; RFC&nbsp;5426, March&nbsp;2009.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="NIST800.90">[NIST800.90]</a></td>
<td class="author-text">National Institute of Standards and Technology, &ldquo;<a href="http://csrc.nist.gov/publications/nistpubs/800-90/SP800-90_DRBG-June2006-final.pdf">NIST Special Publication 800-90: Recommendation for Random Number Generation using Deterministic Random Bit Generators</a>,&rdquo; June&nbsp;2006.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3339">[RFC3339]</a></td>
<td class="author-text">Klyne, G. and C. Newman, &ldquo;<a href="http://tools.ietf.org/html/rfc3339">Date and Time on the Internet: Timestamps</a>,&rdquo; RFC&nbsp;3339, July&nbsp;2002 (<a href="ftp://ftp.isi.edu/in-notes/rfc3339.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3414">[RFC3414]</a></td>
<td class="author-text">Blumenthal, U. and B. Wijnen, &ldquo;<a href="http://tools.ietf.org/html/rfc3414">User-based Security Model (USM) for version 3 of the Simple Network Management Protocol (SNMPv3)</a>,&rdquo; RFC&nbsp;3414, December&nbsp;2002 (<a href="ftp://ftp.isi.edu/in-notes/rfc3414.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4086">[RFC4086]</a></td>
<td class="author-text"><a href="mailto:dee@lkg.dec.com">Eastlake, D.</a>, <a href="mailto:jis@mit.edu">Schiller, J.</a>, and <a href="mailto:crocker@cybercash.com">S. Crocker</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc4086">Randomness Recommendations for Security</a>,&rdquo; RFC&nbsp;4086, June&nbsp;2005 (<a href="ftp://ftp.isi.edu/in-notes/rfc4086.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">John Kelsey</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">NIST</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:john.kelsey@nist.gov">john.kelsey@nist.gov</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Jon Callas</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">PGP Corporation</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jon@callas.org">jon@callas.org</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Alexander Clemm</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco Systems</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:alex@cisco.com">alex@cisco.com</a></td></tr>
</table>
</body></html>
