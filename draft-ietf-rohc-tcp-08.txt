


Network Working Group            Ghyslain Pelletier, Editor, Ericsson AB
INTERNET-DRAFT                            Lars-Erik Jonsson, Ericsson AB
Expires: April 2005                      Mark A West, Siemens/Roke Manor
                                       Richard Price, Siemens/Roke Manor
                                               Kristofer Sandlund, Effnet
                                                         October 25, 2004


                    RObust Header Compression (ROHC):
                     A Profile for TCP/IP (ROHC-TCP)
                        <draft-ietf-rohc-tcp-08.txt>


Status of this memo

   By submitting this Internet-Draft, I (we) certify that any applicable
   patent or other IPR claims of which I am (we are) aware have been
   disclosed, and any of which I (we) become aware will be disclosed, in
   accordance with RFC 3668 (BCP 79).

   By submitting this Internet-Draft, I (we) accept the provisions of
   Section #3 of RFC 3667 (BCP 78).

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups. Note that other
   groups may also distribute working documents as Internet-Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time. It is inappropriate to use Internet-Drafts as reference
   material or cite them other than as "work in progress".

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/lid-abstracts.txt

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html

   This document is a submission of the IETF ROHC WG. Comments should be
   directed to the ROHC WG mailing list, rohc@ietf.org.


Abstract

   This document specifies a ROHC (Robust Header Compression) profile
   for compression of TCP/IP packets. The profile, called ROHC-TCP, is a
   robust header compression scheme for TCP/IP that provides improved
   compression efficiency and enhanced capabilities for compression of
   various header fields including TCP options.




Pelletier, et al.                                               [Page 1]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   Existing TCP/IP header compression schemes do not work well when used
   over links with significant error rates and long round-trip times.
   For many bandwidth-limited links where header compression is
   essential, such characteristics are common. In addition, existing
   schemes (RFC 1144 [14], RFC 2507 [21]) have not addressed how to
   compress TCP options such as SACK (Selective Acknowledgements) (RFC
   2018 [20], RFC 2883 [22]) and Timestamps (RFC 1323 [15]).


Table of Contents

   1. Introduction.....................................................4
   2. Terminology......................................................4
   3. Background.......................................................5
      3.1. Existing TCP/IP Header Compression Schemes..................5
      3.2. Classification of TCP/IP Header Fields......................6
      3.3. Characteristics of Short-lived TCP Transfers................8
   4. Overview of the TCP/IP Profile...................................9
      4.1. General Concepts............................................9
      4.2. Context Replication.........................................9
      4.3. State Machines and Profile Operation........................9
      4.4. Packet Formats and Encoding Methods.........................9
      4.5. Irregular Chain............................................10
      4.6. TCP Options................................................10
         4.6.1. Compressing TCP Options with List Compression.........10
            4.6.1.1. List Compression.................................10
            4.6.1.2. Table-based Item Compression.....................11
            4.6.1.3. Item Tables......................................12
            4.6.1.4. Constraints to List Compression..................13
         4.6.2. Item Table Mappings...................................13
         4.6.3. Replication of TCP Options............................14
         4.6.4. Compressing Extension Headers.........................14
         4.6.5. Explicit Congestion Notification (ECN) in TCP Headers.14
   5. Compressor and decompressor State Machines......................15
      5.1. Compressor States and Logic................................15
         5.1.1. Initialization and Refresh (IR) State.................15
         5.1.2. Compression (CO) State................................16
         5.1.3. Feedback Logic........................................16
         5.1.4. State Transition Logic................................16
            5.1.4.1. Optimistic Approach, Upward Transition...........16
            5.1.4.2. Optional Acknowledgements (ACKs), Upward Transition
            ..........................................................17
            5.1.4.3. Timeouts, Downward Transition....................17
            5.1.4.4. Negative ACKs (NACKs), Downward Transition.......17
            5.1.4.5. Need for Updates, Downward Transition............17
         5.1.5. State Machine Supporting Context Replication..........17
      5.2. Decompressor States and Logic..............................18
         5.2.1. No Context (NC) State.................................19
         5.2.2. Static Context (SC) State.............................19
         5.2.3. Full Context (FC) State...............................19
         5.2.4. Allowing Decompression................................20



Pelletier, et. al                                               [Page 2]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


         5.2.5. Reconstruction and Verification.......................20
         5.2.6. Actions upon CRC Failure..............................20
         5.2.7. Feedback Logic........................................20
   6. ROHC-TCP - TCP/IP Compression (Profile 0x0006)..................22
      6.1. Profile-specific Encoding Methods..........................22
         6.1.1. inferred_mine_header_checksum().......................22
         6.1.2. inferred_ip_v4_header_checksum()......................22
         6.1.3. inferred_ip_v4_length()...............................23
         6.1.4. inferred_ip_v6_length()...............................23
         6.1.5. inferred_offset().....................................24
         6.1.6. tcpopt_eol_padding_length.............................24
      6.2. Considerations for the Feedback Channel....................24
      6.3. Master Sequence Number (MSN)...............................25
      6.4. CRC Calculations...........................................26
      6.5. Initialization.............................................26
      6.6. Packet Types...............................................27
         6.6.1. Initialization and Refresh Packets (IR)...............27
         6.6.2. Context Replication Packets (IR-CR)...................29
         6.6.3. Compressed Packets (CO)...............................30
      6.7. Packet Formats.............................................30
         6.7.1. General Structures....................................31
         6.7.2. Extension Headers.....................................34
            6.7.2.1. IPv6 DEST opt header.............................34
            6.7.2.2. IPv6 HOP opt header..............................34
            6.7.2.3. IPv6 Routing Header..............................35
            6.7.2.4. GRE Header.......................................36
            6.7.2.5. MINE header......................................39
            6.7.2.6. Authentication Header (AH) header................40
            6.7.2.7. Encapsulation Security Payload (ESP) header......41
         6.7.3. IP Header.............................................43
            6.7.3.1. Structures Common for IPv4 and IPv6..............43
            6.7.3.2. IPv6 Header......................................43
            6.7.3.3. IPv4 Header......................................45
         6.7.4. TCP Header............................................49
         6.7.5. TCP Options...........................................55
         6.7.6. Structures used in Compressed Base Headers............63
         6.7.7. Compressed Base Headers...............................64
      6.8. Feedback Formats and Options...............................77
         6.8.1. Feedback Formats......................................77
         6.8.2. Feedback Options......................................78
         6.8.3. The CONTEXT_MEMORY Feedback Option....................79
   7. Security Consideration..........................................79
   8. IANA Considerations.............................................79
   9. Acknowledgments.................................................80
   10. Authors' Addresses.............................................80
   11. References.....................................................81
      11.1. Normative references......................................81
      11.2. Informative References....................................82






Pelletier, et. al                                               [Page 3]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


1.  Introduction

   There are several reasons to perform header compression on low- or
   medium-speed links for TCP/IP traffic, and these have already been
   discussed in RFC 2507 [21]. Additional considerations that makes
   robustness an important objective for a TCP compression scheme are
   introduced in [10]. Finally, existing TCP/IP header compression
   schemes (RFC 1144 [14], RFC 2507 [21]) are limited in their handling
   of the TCP options field and cannot compress the headers of
   handshaking packets (SYNs and FINs).

   It is thus desirable for a header compression scheme to be able to
   handle loss on the link between the compression and decompression
   point as well as loss before the compression point. The header
   compression scheme also needs to consider how to efficiently compress
   short-lived TCP transfers and TCP options, such as SACK (RFC 2018
   [20], RFC 2883 [22]) and Timestamps (RFC 1323 [15]).

   The ROHC WG has developed a header compression framework on top of
   which various profiles can be defined for different protocol sets, or
   for different compression strategies. This document defines a TCP/IP
   compression profile for the ROHC framework [2], compliant with the
   requirements on ROHC TCP/IP header compression [10].

   Specifically, it describes a header compression scheme for TCP/IP
   header compression (ROHC-TCP) that is robust against packet loss and
   that offers enhanced capabilities, in particular for the compression
   of header fields including TCP options. The profile identifier for
   TCP/IP compression is 0x0006.


2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD, "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [1].

   This document reuses some of the terminology found in RFC 3095 [2].
   In addition, this document uses or defines the following terms:

   Base context

     The base context is a context that has been validated by both the
     compressor and the decompressor. A base context can be used as the
     reference when building a new context using replication.

   Base CID

     The Base Context Identifier is the CID used to identify the Base
     Context, where information needed for context replication can
     be extracted from.



Pelletier, et. al                                               [Page 4]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   Context replication

     Context replication is the mechanism that establishes and
     initializes a new context based on another existing valid context
     (a base context). This mechanism is introduced to reduce the
     overhead of the context establishment procedure, and is especially
     useful for compression of multiple short-lived TCP connections that
     may be occurring simultaneously or near-simultaneously.

   ROHC Context Replication (ROHC-CR)

     "ROHC-CR" in this document normatively refers to the context
     replication mechanism for ROHC profiles defined in [3].

   ROHC Formal Notation (ROHC-FN)

     "ROHC-FN" in this document normatively refers to the formal
     notation for ROHC profiles defined in [4], including the library of
     encoding methods it specifies.

   Short-lived TCP Transfer

     Short-lived TCP transfers refer to TCP connections transmitting
     only small amounts of data for each single connection. Short TCP
     flows seldom need to operate beyond the slow-start phase of TCP to
     complete their transfer, which also means that the transmission
     ends before any significant increase of the TCP congestion window
     may occur.


3.  Background

   This chapter provides some background information on TCP/IP header
   compression.  The fundamentals of general header compression may be
   found in [2]. In the following sections, two existing TCP/IP header
   compression schemes are first described along with a discussion of
   their limitations, followed by the classification of TCP/IP header
   fields. Finally, some of the characteristics of short-lived TCP
   transfers are summarized.

   The behavior analysis of TCP/IP header fields among multiple short-
   lived connections may be found in [11].


3.1.  Existing TCP/IP Header Compression Schemes

   Compressed TCP (CTCP) and IP Header Compression (IPHC) are two
   different schemes that may be used to compress TCP/IP headers. Both
   schemes transmit only the differences from the previous header in
   order to reduce the large overhead of the TCP/IP header.




Pelletier, et. al                                               [Page 5]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   The CTCP (RFC 1144 [14]) compressor detects transport-level
   retransmissions and sends a header that updates the context
   completely when they occur. While CTCP works well over reliable
   links, it is vulnerable when used over less reliable links as even a
   single packet loss results in loss of synchronization between the
   compressor and the decompressor. This in turn leads to the TCP
   receiver discarding all remaining packets in the current window
   because of a checksum error. This effectively prevents the TCP Fast
   Retransmit algorithm (RFC 2001) from being triggered. In such case,
   the compressor must wait until the TCP timeout to resynchronize.

   To reduce the errors due to the inconsistent contexts between
   compressor and decompressor when compressing TCP, IPHC (RFC 2507
   [21]) improves somewhat on CTCP by augmenting the repair mechanism of
   CTCP with a local repair mechanism called TWICE and with a link-level
   nacking mechanism to request a header that updates the context.

   The TWICE algorithm assumes that only the Sequence Number field of
   TCP segments are changing with the deltas between consecutive packets
   being constant in most cases. This assumption is however not always
   true, especially when TCP Timestamps and SACK options are used.

   The full header request mechanism requires a feedback channel that
   may be unavailable in some circumstances. This channel is used to
   explicitly request that the next packet be sent with an uncompressed
   header to allow resynchronization without waiting for a TCP timeout.
   In addition, this mechanism does not perform well on links with long
   round-trip time.

   Both CTCP and IPHC are also limited in their handling of the TCP
   options field. For IPHC, any change in the options field (caused by
   timestamps or SACK, for example) renders the entire field
   uncompressible, while for CTCP such a change in the options field
   effectively disables TCP/IP header compression altogether.

   Finally, existing TCP/IP compression schemes do not compress the
   headers of handshaking packets (SYNs and FINs). Compressing these
   packets may greatly improve the overall header compression ratio for
   the cases where many short-lived TCP connections share the same link.


3.2.  Classification of TCP/IP Header Fields

   Header compression is possible due to the fact that there is much
   redundancy between header field values within packets, especially
   between consecutive packets. To utilize these properties for TCP/IP
   header compression, it is important to understand the change patterns
   of the various header fields.

   All fields of the TCP/IP packet header have been classified in detail
   in [11]. The main conclusion is that most of the header fields can



Pelletier, et. al                                               [Page 6]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   easily be compressed away since they never or seldom change. The
   following fields do however require more sophisticated mechanisms:

       - IPv4 Identification (16 bits)         - IP-ID
       - TCP Sequence Number (32 bits)         - SN
       - TCP Acknowledgement Number (32 bits)  - ACKN
       - TCP Reserved (4 bits)
       - TCP ECN flags (2 bits)                - ECN
       - TCP Window (16 bits)                  - WINDOW
       - TCP Options
          - Maximum Segment Size (4 octets)    - MSS
          - Window Scale (3 octets)            - WSopt
          - SACK Permitted (2 octets)
          - TCP SACK                           - SACK
          - TCP Timestamp (32 bits)            - TS

   The assignment of IP-ID values can be done in various ways, which are
   Sequential, Sequential jump, Random or constant to a value of zero.
   However, designers of IPv4 stacks for cellular terminals should use
   an assignment policy close to Sequential.  Some IPv4 stacks do use a
   sequential assignment when generating IP-ID values but do not
   transmit the contents this field in network byte order; instead it is
   sent with the two octets reversed.  In this case, the compressor can
   compress the IP-ID field after swapping the bytes. Consequently, the
   decompressor also swaps the bytes of the IP-ID after decompression to
   regenerate the original IP-ID.  In RFC 3095 [2], the IP-ID is
   generally inferred from the RTP Sequence Number. However, with
   respect to TCP compression, the analysis in [11] reveals that there
   is no obvious candidate to this purpose among the TCP fields.

   The change pattern of several TCP fields (Sequence Number,
   Acknowledgement Number, Window, etc.) is very hard to predict and
   differs entirely from the behavior of RTP fields discussed in [2]. Of
   particular importance to a TCP/IP header compression scheme is the
   understanding of the sequence and acknowledgement number [11].

   Specifically, the sequence number can be anywhere within a range
   defined by the TCP window at any point on the path (i.e. wherever a
   compressor might be deployed). Missing packets or retransmissions can
   cause the TCP sequence number to fluctuate within the limits of this
   window. The TCP window also bound the jumps in acknowledgement
   number.

   Another important behavior of the TCP/IP header is the dependency
   between the sequence number and the acknowledgment number. It is well
   known that most TCP connections only have one-way traffic (web
   browsing and FTP downloading, for example). This means that on the
   forward path (from server to client), only the sequence number is
   changing while the acknowledgement number remains constant for most
   packets; on the backward path (from client to server), only the




Pelletier, et. al                                               [Page 7]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   sequence number is changing and the acknowledgement number remains
   constant for most packets.

   With respect to TCP options, it is noted that most options (such as
   MSS, WSopt, SACK-permitted, etc.) may appear only on a SYN segment.
   Every implementation should (and we expect most will) ignore unknown
   options on SYN segments.

   Headers specific to Mobile IP (for IPv4 or IPv6) do not receive any
   special treatment in this document, for reasons similar as those
   described in [2].


3.3.  Characteristics of Short-lived TCP Transfers

   Recent studies shows that the majority of TCP flows are short-lived
   transfers with an average and a median size no larger than 10KB.
   Short-lived TCP transfers will degrade the performance of header
   compression schemes that establish a new context by initially sending
   full headers.

   It is hard to improve the performance for a single, unpredictable,
   short-lived connection. However, there are common cases where there
   will be multiple TCP connections between the same pair of hosts. A
   mobile user browsing several web pages from the same web server (this
   is more the case with HTTP/1.0 than HTTP/1.1) is one example.

   In such case, multiple short-lived TCP/IP flows occur simultaneously
   or near simultaneously within a relatively short time interval. It
   may be expected that most (if not all) of the IP header of the these
   connections will be almost identical to each other, with only small
   relative jumps for the IP-ID field.

   Furthermore, a subset of the TCP fields may also be very similar from
   one connection to another. For example, one of the port numbers may
   be reused (the service port) while the other (the ephemeral port) may
   be changed only by a small amount relative to the just-closed
   connection.

   With regard to header compression, this means that parts of a
   compression context used for a TCP connection may be reusable for
   another TCP connection. A mechanism supporting context replication,
   where a new context is initialized from an existing one, provide
   useful optimizations for a sequence of short-lived TCP connections.

   Context replication is possible due to the fact that there is much
   similarity in header field values and context values among multiple
   simultaneous or near simultaneous connections. All header fields and
   related context values have been classified in detail in [11]. The
   main conclusion is that most part of the IP sub-context, some TCP




Pelletier, et. al                                               [Page 8]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   fields, and some context values can easily be replicated since they
   seldom change or change with only a small jump.


4.  Overview of the TCP/IP Profile


4.1.  General Concepts

   Many of the concepts behind the ROHC-TCP profile are similar to those
   described in RFC 3095 [2]. Like for other ROHC profiles, ROHC-TCP
   makes use of the ROHC protocol as described in [2], in sections 5.1
   to 5.2.6. This includes data structures, reserved packet types,
   general packet formats, segmentation and initial decompressor
   processing.


4.2.  Context Replication

   For ROHC-TCP, context replication may be particularly useful for
   short-lived TCP flows [10]. ROHC-TCP therefore supports context
   replication as defined in ROHC-CR [3]; the compressor MAY support
   context replication, while a decompressor implementation is REQUIRED
   to support decompression of the IR-CR packet type.


4.3.  State Machines and Profile Operation

   Header compression with ROHC can be characterized as an interaction
   between two state machines, one compressor machine and one
   decompressor machine, each instantiated once per context.

   For ROHC-TCP compression, the compressor has two states and the
   decompressor has three states. The two compressor states are the
   Initialization and Refresh (IR) state, and the Compression (CO)
   state. The three states of the decompressor are No Context (NC),
   Static Context (SC) and Full Context (FC). The compressor may also
   implement a third state, the Context Replication (CR) state, to
   support context replication ROHC-CR [3]. Transitions need not be
   synchronized between the two state machines.


4.4.  Packet Formats and Encoding Methods

   The packet formats used for ROHC-TCP and found in this document are
   defined using the formal notation, ROHC-FN. The formal notation is
   used to provide an unambiguous representation of the packet formats
   and a clear definition of the encoding methods. The encoding methods
   used in the packet formats for ROHC-TCP are defined in [4].





Pelletier, et. al                                               [Page 9]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


4.5.  Irregular Chain

   The ROHC-TCP profile defines an irregular chain for each header type,
   in addition to the static and dynamic chains as used in RFC 3095 [2].
   This irregular chain handles fields of tunneling headers and of
   extension headers, for which the change pattern is classified as
   IRREGULAR and that have to be sent in each compressed packet.

   The structure of the irregular chain is analogous to the structure of
   the static chain. For each compressed packet, the irregular chain is
   appended at the specified location in the general format of the
   compressed packets (as defined in section 6.6.3).

   Note that the TCP header and the innermost IP header are not a part
   of the irregular chain. This is because the irregular fields of these
   headers are included in the base header of the compressed packet.


4.6.  TCP Options


4.6.1.  Compressing TCP Options with List Compression

   The options in the TCP header are compressed using list compression
   as defined by the ROHC-FN [4]. The following subsections explain how
   this encoding is applied to the TCP options in more details.

   In the definition of the packet formats for ROHC-TCP, the most
   frequent type of TCP options are described. Each of these options has
   an uncompressed format, a format_[option_type]_list_item format and
   an format_[option_type]_irregular format, where [option_type] is the
   name of the actual field item in the option list.

   The list_item represents the option inside the compressed item list,
   and the irregular format is used for the option fields that are
   expected to change with each packet. These irregular fields are
   present in each compressed packet, as part of the irregular chain.


4.6.1.1.  List Compression

   The TCP options in the uncompressed packet can be structured as an
   ordered list, whose order and presence are most of the time constant
   between packets. The generic structure of such a list is as follows:

            +--------+--------+--...--+--------+
      list: | item 1 | item 2 |       | item n |
            +--------+--------+--...--+--------+

   The basic principles of list-based compression are the following:




Pelletier, et. al                                              [Page 10]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


      1) When a context is being initialized, a complete representation
         of the compressed list of options is transmitted. All options
         that have any content are present in the compressed list of
         items.

      2) While the structure AND the content of the list are not
         changing, no information about the list is sent in compressed
         headers.

      3) When the structure of the list is constant, and when only the
         content of one or more options that are defined within the
         irregular format is changing, no information about the list
         needs to be sent; the irregular content is sent as part of the
         irregular chain in the general compressed packet format
         (section 6.6.3).

      4) When the structure of the list changes, a compressed list is
         sent, including a representation of its structure and order.


4.6.1.2.  Table-based Item Compression

   The Table-based item compression compressses individual items sent in
   compressed lists. The compressor assigns a unique identifier "Index"
   to each "Item" of a list.

   Compressor Logic

      The compressor conceptually maintains an Item Table containing all
      items, indexed using Index. The (Index, Item) pair is sent
      together in compressed lists until the compressor gains enough
      confidence that the decompressor has observed the mapping between
      Items and their respective Index. Confidence is obtained by
      receiving an acknowledgment from the decompressor or by sending L
      (Index, Item) pairs (not necessarily consecutively). The value for
      L is maintained by the compressor. After such confidence is
      obtained, the Index alone is sent in compressed lists to indicate
      the corresponding Item.

      The compressor may reassign an existing Index to a new item, and
      then needs to re-establish the mapping as described above.

   Decompressor Logic

      The decompressor conceptually maintains an Item Table that
      contains all (Index, Item) pairs received. The Item Table is
      updated whenever an (Index, Item) pair is received and
      decompression is sucessfully verified usng the CRC. The
      decompressor retrieves the item from the table whenever an Index
      without an accompanying Item is received.




Pelletier, et. al                                              [Page 11]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


4.6.1.3.  Item Tables

   Compressor Logic

      The compressor uses the following structure to represent an entry
      in the Item Table:

                 +-------+------+---------+--------------------------+
         Index i | Known | Item | Counter | MSN_1, MSN_2, ..., MSN_L |
                 +-------+------+---------+--------------------------+

      The flag "Known" indicates whether the mapping between Index i and
      Item has been established, i.e., if Index i can be sent in
      compressed lists without its corresponding Item.

      The "Counter" field is useful to obtain confidence that the
      context at the decompressor contains the (Index, Item) pair.

      The list of sequence numbers, [MSN 1, ..., MSN L], is useful in
      relating an acknowledgment received from the decompressor with the
      (Index, Item) pair, meaning that it is now part of the
      decompressor context.

      The flag "Known" is initially set to a value of zero. It is also
      set to zero whenever Index i is assigned to a new Item. "Known" is
      set to a non-zero value when either of the following conditions
      occur:

         a) The corresponding (Index, Item) pair is acknowledged;
         b) Counter >= L (confidence based of the optimistic approach).

      When the compressor sets the flag "Known", the sequence number
      list can be discarded.

   Decompressor Logic

      The decompressor uses the following structure to represent an
      entry in the Item Table:

                 +-------+------+
         Index i | Known | item |
                 +-------+------+

      The flag "Known" is initially set to a value of zero. "Known" is
      set to a non-zero value when the decompressor receives an (Index,
      Item) pair and inserts the Item into the table at position Index.

      If an index without an accompanying item is received for which the
      value of the "Known" flag is zero, the header MUST be discarded
      and a NACK SHOULD be sent.




Pelletier, et. al                                              [Page 12]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


4.6.1.4.  Constraints to List Compression

   List compression, as defined in the ROHC-FN [4], allows 7-bit indexes
   to be used in the Item table. For ROHC-TCP, the compressor MUST use
   the low-order 4 bits of the item count (i.e. large_xi of [4], section
   5.5.5) to describe an index. In other words, the compressor MUST NOT
   map items with indexes larger than a value of 15. This is because no
   more than 16 different options are expected to be used in a TCP flow.


4.6.2.  Item Table Mappings

   The mapping between TCP option type and table indexes are listed in
   the table below:

      +-----------------+---------------+
      |   Option name   |  Table index  |
      +-----------------+---------------+
      |      NOP        |       0       |
      |      EOL        |       1       |
      |      MSS        |       2       |
      |  WINDOW SCALE   |       3       |
      |   TIMESTAMP     |       4       |
      | SACK-PERMITTED  |       5       |
      |      SACK       |       6       |
      | Generic options |      7-15     |
      +-----------------+---------------+

   Some TCP options are used more frequently than others. To simplify
   their compression, a part of the item table is reserved for these
   option types, as shown on the table above. The decompressor MUST use
   these mappings between item and indexes to decompress TCP options
   compressed using list compression.

   The compressor can thus omit from the compressed packet format an
   option type that corresponds to a reserved item in the item table.
   This is because the type of the option can be known based on the
   index number.

   It is expected that the option types for which an index is reserved
   in the item table will only appear once in a list. However, if an
   option type is detected twice in the same options list and if both
   options have a different content, the compressor should compress the
   second occurence of the option type by mapping it to a generic
   compressed option. Otherwise if the options have the exact same
   content, the compressor can still use the same table index for both.

   The NOP option

      The NOP option can appear more than once in the list. However,
      since its value is always the same, no context information needs



Pelletier, et. al                                              [Page 13]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


      to be transmitted. Multiple NOP options can thus be mapped to the
      same index. Since the NOP option does not have any content when
      compressed as a list_item, it will never be present in the item
      list. For consistence, the compressor should still established an
      entry in the list by setting the presence bit, like for the other
      type of options.

   The EOL option

      The size of the compressed format for the EOL option can be of
      more than one octets, and it is defined so that it includes the
      option padding. This is because the EOL should terminate the
      parsing of the options, but it can also be followed by padding of
      undefined format.

   The Generic option

      The generic option can be used to compress any type of TCP
      options, in particular those that do not have a reserved index in
      the item table.


4.6.3.  Replication of TCP Options

   TCP options can be replicated. When parts (or all) of the options are
   replicated, the entire item table in the context is replicated. The
   list of options for the new flow is then transmitted as a generic
   compressed list, like for other compressed packets.


4.6.4.  Compressing Extension Headers

   In RFC 3095 [2], list compression is used to compress extension
   headers. ROHC-TCP compresses the same type of extension headers.
   However, these headers are treated exactly as other headers and thus
   have a static chain, a dynamic chain as well as an irregular chain
   (see also section 4.5 above).

   The consequence is that headers appearing in or disappearing from the
   flow being compressed will lead to changes to the static chain.
   However, the change pattern of extension headers is not deemed to
   impair compression efficiency with respect to this design strategy.


4.6.5.  Explicit Congestion Notification (ECN) in TCP Headers

   When the ECN is used in the TCP headers, the TOS/TC fields of all IP
   headers in this flow must be sent uncompressed in all packets. This
   is because of the possible use of the "full-functionality option" of
   section 9.1 of RFC 3168 [23].




Pelletier, et. al                                              [Page 14]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   [EditorÆs Note: Here it should be described how this is handled]
   [               in packet formats. I.e. for ecn_used û some    ]
   [               packet types can setup the value of the context]
   [               flag ecn_used. If it is set, the TOS/TC of all ]
   [               IP headers are transmitted in the irregular    ]
   [               chain of all compressed packets.               ]


5.  Compressor and decompressor State Machines

   The header compression state machines and their associated logic as
   specified in this section are a simplified version of the ones found
   in [2].


5.1.  Compressor States and Logic

   The two compressor states are the Initialization and Refresh (IR)
   state, and the Compression (CO) state. The compressor always starts
   in the lower compression state (IR). The compressor will normally
   operate in the higher compression state (CO), under the constraint
   that the compressor is sufficiently confident that the decompressor
   has the information necessary to reconstruct a header compressed
   according to this state.

   The figure below shows the state machine for the compressor. The
   details of each state, state transitions, and compression logic are
   given in sub-sections following the figure.

                 Optimistic approach / ACK     ACK
               +------>------>------>------+  +->-+
               |                           |  |   |
               |                           v  |   v
           +----------+                  +----------+
           | IR State |                  | CO State |
           +----------+                  +----------+
               ^                                |
               |  Timeout / NACK / STATIC-NACK  |
               +-------<-------<-------<--------+

   The transition from IR state to CO state is based on the following
   principles: the need for update and the optimistic approach principle
   or, if a feedback channel is established, feedback received from the
   decompressor.


5.1.1.  Initialization and Refresh (IR) State

   The purpose of the IR state is to initialize the static parts of the
   context at the decompressor or to recover after failure. In this
   state, the compressor sends complete header information. This



Pelletier, et. al                                              [Page 15]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   includes static and non-static fields in uncompressed form plus some
   additional information.

   The compressor stays in the IR state until it is fairly confident
   that the decompressor has received the static information correctly.


5.1.2.  Compression (CO) State

   The purpose of the CO state is to efficiently communicate
   irregularities in the packet stream when needed while maintaining the
   most optimal compression ratio. When operating in this state, the
   compressor normally sends most or all of the information in a
   compressed form.


5.1.3.  Feedback Logic

   The compressor state machine makes use of feedback from decompressor
   to compressor for transitions in the backward direction, and
   optionally to improve the forward transition.

   The reception of either positive feedback (ACKs) or negative feedback
   (NACKs) establishes the feedback channel from the decompressor. Once
   there is an established feedback channel, the compressor makes use of
   this feedback for optionally improving the transitions among
   different states. This helps increasing the compression efficiency by
   providing the information needed for the compressor to achieve the
   necessary confidence level. When the feedback channel is established,
   it becomes superfluous for the compressor to send periodic refreshes.


5.1.4.  State Transition Logic

   The compressor makes its decisions about when to transit between the
   IR and the CO states on the basis of:

      - variations in the packet headers
      - positive feedback from decompressor (Acknowledgements -- ACKs)
      - negative feedback from decompressor (Negative ACKS -- NACKs)
      - confidence level regarding error-free decompression of a packet


5.1.4.1.  Optimistic Approach, Upward Transition

   Transition to the CO state is carried out according to the optimistic
   approach principle. This means that the compressor transits to the CO
   state when it is fairly confident that the decompressor has received
   enough information to correctly decompress packets sent according to
   the higher compression state.




Pelletier, et. al                                              [Page 16]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   In general, there are many approaches where the compressor can obtain
   such information. A simple and general approach can be achieved by
   sending uncompressed or partial full headers periodically.


5.1.4.2.  Optional Acknowledgements (ACKs), Upward Transition

   The compressor can also transit to the CO state based on feedback
   received by the decompressor. If a feedback channel is available, the
   decompressor MAY use positive feedback (ACKs) to acknowledge
   successful decompression of packets. Upon reception of an ACK for a
   context-updating packet, the compressor knows that the decompressor
   has received the acknowledged packet and the transition to the CO
   state can be carried out immediately.

   This functionality is optional, so a compressor MUST NOT expect to
   get such ACKs initially or during normal operation, even if a
   feedback channel is available or established.


5.1.4.3.  Timeouts, Downward Transition

   When the optimistic approach is used (i.e. until a feedback channel
   is established), there will always be a possibility of failure since
   the decompressor may not have received sufficient information for
   correct decompression. Therefore, unless the decompressor has
   established a feedback channel, the compressor MUST periodically
   transit to the IR state.


5.1.4.4.  Negative ACKs (NACKs), Downward Transition

   Negative acknowledgments (NACKs) are also called context requests.
   Upon reception of a NACK, the compressor transits back to the IR
   state and sends updates (such as IR-DYN or IR) to the decompressor.


5.1.4.5.  Need for Updates, Downward Transition

   When the header to be compressed does not conform to the established
   pattern or when the compressor is not confident whether the
   decompressor has the synchronized context, the compressor will
   transit to the IR state.


5.1.5.  State Machine Supporting Context Replication

   For a profile supporting context replication, the additional
   compressor logic (including corresponding state transition and
   feedback logic) defined by ROHC-CR [3] must be added to the
   compressor state machine described above.



Pelletier, et. al                                              [Page 17]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   The following figure shows the resulting state machine:


                       Optimistic approach / ACK
          +--->------>------>------>------>------>------>---+
          |                                                 |
          |     BCID Selection    Optimistic approach / ACK |  ACK
          | +------>----->------+ +----->----->----->-----+ | +->-+
          | |                   | |                       | | |   |
          | |                   v |                       v v |   v
      +---------+           +---------+                  +---------+
      |   IR    |           |   CR    |                  |   CO    |
      |  State  |           |  State  |                  |  State  |
      +---------+           +---------+                  +---------+
          ^ ^                    |                           |
          | | NACK / STATIC-NACK |                           |
          | +---<-----<-----<----+                           |
          |                                                  |
          |           Timeout / NACK / STATIC-NACK           |
          +-----<-------<-------<-------<-------<-------<----+


5.2.  Decompressor States and Logic

   The three states of the decompressor are No Context (NC), Static
   Context (SC) and Full Context (FC). The decompressor starts in its
   lowest compression state, the NC state. Successful decompression will
   always move the decompressor to the FC state. The decompressor state
   machine normally never leaves the FC state once it has entered this
   state; only repeated decompression failures will force the
   decompressor to transit downwards to a lower state.

   Below is the state machine for the decompressor. Details of the
   transitions between states and decompression logic are given in the
   sub-sections following the figure.


                                 Success
                +-->------>------>------>------>------>--+
                |                                        |
    No Static   |            No Dynamic        Success   |    Success
     +-->--+    |             +-->--+      +--->----->---+    +-->--+
     |     |    |             |     |      |             |    |     |
     |     v    |             |     v      |             v    |     v
   +-----------------+   +---------------------+   +-------------------+
   | No Context (NC) |   | Static Context (SC) |   | Full Context (FC) |
   +-----------------+   +---------------------+   +-------------------+
      ^                         |        ^                         |
      | k_2 out of n_2 failures |        | k_1 out of n_1 failures |
      +-----<------<------<-----+        +-----<------<------<-----+




Pelletier, et. al                                              [Page 18]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


5.2.1.  No Context (NC) State

   Initially, while working in the NC state, the decompressor has not
   yet successfully decompressed a packet.

   Upon receiving an IR or an IR-DYN packet, the decompressor will
   verify the correctness of this packet by validating its header using
   the CRC check. If the decompressed packet is successfully verified,
   the decompressor will update the context and use this packet as the
   reference packet. Once a packet has been decompressed correctly, the
   decompressor can transit to the FC state, and only upon repeated
   failures will it transit back to a lower state.


5.2.2.  Static Context (SC) State

   In the SC state, the decompressor assumes static context damage when
   the CRC check of k_2 out of the last n_2 decompressed packets have
   failed. The decompressor moves to the NC state and discards all
   packets until a packet (e.g. IR or IR-DYN packet) that successfully
   passes the verification check is received. The decompressor may send
   feedback (see section 5.2.7) when assuming static context damage.

   Note that appropriate values for k and n, are related to the residual
   error rate of the link.  When the residual error rate is close to
   zero, k = n = 1 may be appropriate.


5.2.3.  Full Context (FC) State

   In the FC state, the decompressor assumes context damage when the CRC
   check of k_1 out of the last n_1 decompressed packets have failed,
   (where k and n are related to the residual error rate of the link as
   in section 5.2.2). The decompressor moves to the SC state and
   discards all packets until a packet carrying a 7- or 8-bit CRC that
   successfully passes the verification check is received. The
   decompressor may send feedback (see section 5.2.7) when assuming
   context damage.

   Upon receiving an IR or an IR-DYN packet, the decompressor SHOULD
   verify the correctness of its header using CRC validation. If the
   verification succeeds, the decompressor will update the context and
   use this packet as the reference packet. Consequently, the
   decompressor will convert the packet into the original packet and
   pass it to the network layer of the system.

   Upon receiving other types of packet, the decompressor will
   decompress it. The decompressor MUST verify the correctness of the
   decompressed packet by CRC check. If this verification succeeds, the
   decompressor passes the decompressed packet to the system's network
   layer. The decompressor will then use this packet as the reference



Pelletier, et. al                                              [Page 19]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   value, if it is not older than the current reference packet (based on
   sequence numbers in the compressed packet or in the uncompressed
   header).


5.2.4.  Allowing Decompression

   In the No Context state, only packets carrying sufficient information
   on the static fields (i.e. IR packets) can be decompressed.

   In the Static Context state, only packets carrying a 7- or 8-bit CRC
   may be decompressed (i.e. IR, IR-DYN and some CO packets).

   In the Full Context state, decompression may be attempted regardless
   of the type of packet received.

   If decompression may not be performed, the packet is discarded.

   As per ROHC-CR [3], IR-CR packets may be decompressed in any state.


5.2.5.  Reconstruction and Verification

   The CRC carried within compressed headers MUST be used to verify
   decompression. When the decompression is verified and successful, the
   decompressor updates the context with the information received in the
   current header; otherwise if the reconstructed header fails the CRC
   check, these updates MUST NOT be performed.


5.2.6.  Actions upon CRC Failure

   When a CRC check fails, the decompressor MUST discard the packet. The
   actions to be taken when CRC verification fails following the
   decompression of an IR-CR packet are specified in [3]. For other
   packet types carrying a CRC, if feedback is used the logic specified
   in section 5.2.7 must be followed when CRC verification fails.

   Note: Decompressor implementations may attempt corrective or repair
   measures prior to performing the above actions, and the result of any
   attempt MUST be verified using the CRC check.


5.2.7.  Feedback Logic

   The decompressor may send positive feedback (ACKs) to initially
   establish the feedback channel for a particular flow. Either positive
   feedback (ACKs) or negative feedback (NACKs) will establish this
   channel. The decompressor will then use the feedback channel to send
   error recovery requests and (optionally) acknowledgements of
   significant context updates.



Pelletier, et. al                                              [Page 20]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004



   Once the decompressor establishes a feedback channel, the compressor
   will operate using an optimistic logic. In particular, this means
   that the compressor will rely on specific decompressor feedback
   logic:

      - the decompressor will send negative acknowledgements in case
        when context damage is assumed or in other failure situations;

      - the decompressor is not strictly expected to send feedback upon
        successful decompression, other than for the purpose of
        improving the forward state transition.

   Once the feedback channel is established, the decompressor is
   REQUIRED to continue sending feedback for the lifetime of the packet
   stream as follow:

     In NC state:

        The decompressor SHOULD send a STATIC-NACK if a packet of a type
        other than IR is received, or if an IR packet has failed the CRC
        check.

     In SC state:

        The decompressor SHOULD send a STATIC-NACK when decompression of
        an IR, an IR-DYN or a CO packet carrying a 7-bit CRC fails and
        if static context damage is assumed (see also section 5.2.2).
        If any other packet type is received, the decompressor SHOULD
        treat it as a CRC mismatch when deciding if feedback is to be
        sent.

     In FC state:

        The decompressor SHOULD send a NACK when decompression of any
        packet type fails and if context damage is assumed (see also
        section 5.2.3).

   When decompression fails, the feedback rate SHOULD be limited. For
   example, feedback could be sent only when decompression of several
   consecutive packets have failed. In addition, the decompressor should
   also limit the rate at which feedback is sent on successful
   decompression, if sent at all. The decompressor may limit the
   feedback rate by sending feedback for one out of a number of packets
   providing the same type of feedback.

   The decompressor MAY optionally send ACKs upon successful
   decompression of any packet type. In particular, when an IR, an IR-
   DYN or any CO packet carrying a 7- or 8-bit CRC is correctly
   decompressed, the compressor may optionally send an ACK.




Pelletier, et. al                                              [Page 21]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   Finally, when the decompressor ACKs an IR packet, it MUST use the CRC
   option (see [2], section 5.7.6.3) when sending this feedback. This is
   necessary to ensure that a context does not erroneously become a
   candidate for later use as a base context for replication [3].


6.  ROHC-TCP - TCP/IP Compression (Profile 0x0006)

   This section describes a ROHC profile for TCP/IP compression. The
   profile identifier for ROHC-TCP is 0x0006.


6.1. Profile-specific Encoding Methods

   This section defines encoding methods that are specific to this
   profile. These methods are used in the formal definition of the
   packet formats in section 6.7.


6.1.1.  inferred_mine_header_checksum()

   This encoding method compresses the minimal encapsulation header
   checksum. This checksum is defined in RFC 2004 [25] as follow:

      Header Checksum

        The 16-bit one's complement of the one's complement sum of all
        16-bit words in the minimal forwarding header.  For purposes of
        computing the checksum, the value of the checksum field is 0.
        The IP header and IP payload (after the minimal forwarding
        header) are not included in this checksum computation.

   The "inferred_mine_header_checksum()" encoding method compresses the
   minimal encapsulation header checksum down to a size of zero bit,
   i.e. no bits are transmitted in compressed headers for this field.
   Using this encoding method, the decompressor infers the value of this
   field using the above computation.


6.1.2. inferred_ip_v4_header_checksum()

   This encoding method compresses the header checksum field of the IPv4
   header. This checksum is defined in RFC 791 [5] as follows:

      Header Checksum:  16 bits

        A checksum on the header only.  Since some header fields change
        (e.g., time to live), this is recomputed and verified at each
        point that the internet header is processed.





Pelletier, et. al                                              [Page 22]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


      The checksum algorithm is:

        The checksum field is the 16 bit one's complement of the one's
        complement sum of all 16 bit words in the header.  For purposes
        of computing the checksum, the value of the checksum field is
        zero.

   The "inferred_ip_v4_header_checksum()" encoding method compresses the
   IPv4 header checksum down to a size of zero bit, i.e. no bits are
   transmitted in compressed headers for this field. Using this encoding
   method, the decompressor infers the value of this field using the
   above computation.


6.1.3.  inferred_ip_v4_length()

   This encoding method compresses the total length field of the IPv4
   header. The total length field of the IPv4 header is defined in RFC
   791 [5] as follows:

      Total Length:  16 bits

        Total Length is the length of the datagram, measured in octets,
        including internet header and data.  This field allows the
        length of a datagram to be up to 65,535 octets.

   The "inferred_ip_v4_length()" encoding method compresses the IPv4
   header checksum down to a size of zero bit, i.e. no bits are
   transmitted in compressed headers for this field. Using this encoding
   method, the decompressor infers the value of this field by counting
   in octets the length of the entire packet after decompression.


6.1.4.  inferred_ip_v6_length()

   This encoding method compresses the payload length field in the IPv6
   header. This length field is defined in RFC 2460 [9] as follow:

      Payload Length:  16-bit unsigned integer
        Length of the IPv6 payload, i.e., the rest of the packet
        following this IPv6 header, in octets.  (Note that any extension
        headers present are considered part of the payload, i.e.,
        included in the length count.)

   The "inferred_ip_v6_length()" encoding method compresses the payload
   length field of the IPv6 header down to a size of zero bit, i.e. no
   bits are transmitted in compressed headers for this field. Using this
   encoding method, the decompressor infers the value of this field by
   counting in octets the length of the entire packet after
   decompression.




Pelletier, et. al                                              [Page 23]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


6.1.5.  inferred_offset()

   This encoding method compresses

   The inferred_offset encoding method is used on the data offset field
   of the TCP header. This field is defined in RFC 793 as:

      Data Offset:  4 bits

        The number of 32 bit words in the TCP Header.  This indicates
        where the data begins.  The TCP header (even one including
        options) is an integral number of 32 bits long.

   The "inferred_offset()" encoding method compresses the data offset
   field of the TCP header down to a size of zero bit, i.e. no bits are
   transmitted in compressed headers for this field. Using this encoding
   method, the decompressor infers the value of this field by first
   decompressing the TCP options list, and by then setting data offset =
   (options length / 4) + 5.


6.1.6.  tcpopt_eol_padding_length

   The tcpopt_eol_padding_length is used in compressed lists for
   representing the TCP end-of-list option. Because the EOL option is
   followed by padding, represented using a number of octets all set to
   zero, the length of the padding must be transmitted to the
   decompressor within the compressed form of the list item.

   The compressor calculates the padding length from the data offset
   field and the number of options octets remaining after the EOL option
   is encountered.

   The decompressor uses this value to reconstruct the EOL option
   padding and the data offset field.


6.2.  Considerations for the Feedback Channel

   The ROHC-TCP profile may be used in environments with or without
   feedback capabilities from decompressor to compressor. ROHC-TCP
   however assumes that if a ROHC feedback channel is available and is
   used at least once by the decompressor, this channel will be present
   during the entire compression operation. Otherwise, if the connection
   is broken and the channel disappears, header compression should be
   restarted.

   To parallel RFC 3095 [2], this is similar to allowing only one mode
   transition per compressor: from the initial unidirectional mode to
   the bi-directional mode of operation, with the transition being
   triggered by the reception of the first packet containing feedback



Pelletier, et. al                                              [Page 24]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   from the decompressor. This effectively means that ROHC-TCP does not
   explicitly define any operational modes.


6.3.  Master Sequence Number (MSN)

   Feedback packets of types ACK and NACK carry information about
   sequence number or acknowledgement number from decompressor to
   compressor. Unfortunately, there is no guarantee that sequence number
   and acknowledgement number fields will be used by every IP protocol
   stack. In addition, the combined size of the sequence number field
   and the acknowledgement number field is rather large, and they can
   therefore not be carried efficiently within the feedback packet.

   To overcome this problem, ROHC-TCP introduces a control field called
   the Master Sequence Number (MSN) field. The MSN field is created at
   the compressor, rather than using one of the fields already present
   in the uncompressed header. The compressor increments the value of
   the MSN by one for each packet that it sends.

   The MSN field has the following two functions:

      1. Differentiating between packets when sending feedback data.

      2. Inferring the value of incrementing fields such as the IP-ID.

   The MSN field is present in every packets sent by the compressor. The
   MSN is LSB encoded within the CO packets, and the 16-bit MSN is sent
   in full in IR/IR-DYN packets. The decompressor always sends the MSN
   as part of the feedback information. The compressor can later use the
   MSN to infer which packet the decompressor is acknowledging.

   When the MSN is initialized, it is initialized to a random value. The
   compressor should only initialize a new MSN for the initial IR or IR-
   CR packet sent for a CID that corresponds to a context that is not
   already associated with this profile. In other words, if the
   compressor reuses the same CID to compress many TCP flows one after
   the other, the MSN is not reinitialized but rather continues to
   increment monotonously.

   For context replication, the compressor does not use the MSN of the
   base context when sending the IR-CR packet, unless the replication
   process overwrites the base context (i.e. BCID == CID). Instead, the
   compressor uses the value of the MSN if it already exists in the
   context being associated with the new flow (CID); otherwise, the MSN
   is initialized to a new value.








Pelletier, et. al                                              [Page 25]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


6.4.  CRC Calculations

   The 3-bit and 7-bit CRCs both cover the entire uncompressed header
   chain. Note that there is no division between CRC-STATIC or CRC-
   DYNAMIC fields in ROHC-TCP, as opposed to profiles defined in [2].


6.5.  Initialization

   The static context of ROHC TCP streams can be initialized in either
   two ways:

   1) By using an IR packet as in section 6.6.1, where the profile is
   six (6) and the static chain ends with the static part of a TCP
   packet.

   2) By replicating an existing context using the mechanism defined by
   ROHC-CR. This is done with the IR-CR packet defined in section 6.6.2,
   where the profile number is six (6) and the static replication chain
   ends with the static part of a TCP packet.


































Pelletier, et. al                                              [Page 26]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


6.6.  Packet Types

   ROHC-TCP defines two different packet types: the Initialization and
   Refresh (IR) packet type, and the Compressed packet type (CO). Each
   type corresponds to one of the possible states of the compressor.

   Each packet type also defines a number of packet formats: 30 packet
   formats are defined for compressed headers (CO), and two for
   initialization and refresh (IR).

   Finally, the profile-specific part of the IR-CR packet [3] is also
   defined in this section.


6.6.1.  Initialization and Refresh Packets (IR)

   ROHC-TCP uses the basic structure of the ROHC IR and IR-DYN packets
   as defined in [2] (section 5.2.3. and 5.2.4. respectively). The 8-bit
   CRC is computed according to section 5.9.1 of [2].


   o Packet type: IR

     This packet type communicates the static part and the dynamic part
     of the context.

   For the ROHC-TCP IR packet, the value of the x bit must be set to
   zero. It has the following format:

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   :         Add-CID octet         : if for small CIDs and (CID != 0)
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   0   0 | IR type octet
   +---+---+---+---+---+---+---+---+
   :                               :
   /      0-2 octets of CID        / 1-2 octets if for large CIDs
   :                               :
   +---+---+---+---+---+---+---+---+
   |            Profile            | 1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              | 1 octet
   +---+---+---+---+---+---+---+---+
   |                               |
   /     Profile Specific Part     / variable length
   |                               |
   - - - - - - - - - - - - - - - -
   |                               |
   /           Payload             /  variable length
   |                               |
    - - - - - - - - - - - - - - - -



Pelletier, et. al                                              [Page 27]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004



      CRC: 8-bit CRC, computed according to section 5.9.1 of [2].

      Profile Specific_Part: The format of this field is defined using
           the formal notation in section 6.7. It consists in the
           static chain, the dynamic chain, the irregular chain and the
           TCP options.

      Payload:  The payload of the corresponding original packet, if
           any. The presence of a payload is inferred from the packet
           length.


   o Packet type: IR-DYN

     This packet type communicates the dynamic part of the context.

   The ROHC-TCP IR-DYN packet has the following format:

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   :         Add-CID octet         : if for small CIDs and (CID != 0)
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   0   0   0 | IR-DYN type octet
   +---+---+---+---+---+---+---+---+
   :                               :
   /      0-2 octets of CID        / 1-2 octets if for large CIDs
   :                               :
   +---+---+---+---+---+---+---+---+
   |            Profile            | 1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              | 1 octet
   +---+---+---+---+---+---+---+---+
   |                               |
   /     Profile_Specific_Part     / variable length
   |                               |
   - - - - - - - - - - - - - - - -
   |                               |
   /           Payload             /  variable length
   |                               |
    - - - - - - - - - - - - - - - -

      CRC: 8-bit CRC, computed according to section 5.9.1 of [2].

      Profile_Specific_Part: The format of this field is defined using
           the formal notation in section 6.7. It consists in the
           dynamic chain, the irregular chain and the TCP options only.

      Payload:  The payload of the corresponding original packet, if
           any. The presence of a payload is inferred from the packet
           length.



Pelletier, et. al                                              [Page 28]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


6.6.2.  Context Replication Packets (IR-CR)

   Context replication requires a dedicated IR packet format that
   uniquely identifies the IR-CR packet for the ROHC-TCP profile.

   o Packet type: IR-CR

     This packet type communicates a reference to a base context along
     with the static and dynamic parts of the replicated context that
     differs from the base context.

   The ROHC-TCP IR-CR packet follows the general format of the ROHC CR
   packet, as defined in ROHC-CR [3], section 3.4.2. With consideration
   to the extensibility of the IR packet type defined in RFC 3095 [2],
   the ROHC-TCP profile supports context replication through the profile
   specific part of the IR packet. This is achieved using the bit (x)
   left in the IR packet header for "Profile specific information". For
   ROHC-TCP, this bit is defined as a flag indicating whether this
   packet is an IR packet or an IR-CR packet. For the ROHC-TCP IR-CR
   packet, the value of the x bit must be set to one.

   The ROHC-TCP IR-CR has the following format:

     0   1   2   3   4   5   6   7
    --- --- --- --- --- --- --- ---
   :         Add-CID octet         : if for small CIDs and (CID != 0)
   +---+---+---+---+---+---+---+---+
   | 1   1   1   1   1   1   0   1 | IR-CR type octet
   +---+---+---+---+---+---+---+---+
   :                               :
   /      0-2 octets of CID        / 1-2 octets if for large CIDs
   :                               :
   +---+---+---+---+---+---+---+---+
   |            Profile            | 1 octet
   +---+---+---+---+---+---+---+---+
   |              CRC              | 1 octet
   +---+---+---+---+---+---+---+---+
   | B |          CRC7             | 1 octet
   +---+---+---+---+---+---+---+---+
   |                               | present if B = 1,
   /           Base CID            / 1 octet if for small CIDs, or
   |                               | 1-2 octets if for large CIDs
   +---+---+---+---+---+---+---+---+
   |                               |
   |     Profile_Specific_Part     / variable length
   |                               |
    - - - - - - - - - - - - - - - -
   |                               |
   /           Payload             / variable length
   |                               |
    - - - - - - - - - - - - - - - -



Pelletier, et. al                                              [Page 29]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004



      B:  B = 1 indicates that the Base CID field is present.

      CRC7: The CRC over the original, uncompressed, header. This 7-bit
          CRC is computed according to section 3.4.1.1 of [3].

      Profile Specific Part: Static and dynamic subheader information
          used for replication. The format of this field is defined
          using the formal notation in section 6.7.

      Payload:  The payload of the corresponding original packet, if
          any. The presence of a payload is inferred from the packet
          length.


6.6.3.  Compressed Packets (CO)

   The ROHC-TCP CO packets communicate irregularities in the packet
   header. All CO packets carry a CRC and can update the context.

   The general format for a compressed TCP header is as follows:

        0   1   2   3   4   5   6   7
       --- --- --- --- --- --- --- ---
      :         Add-CID octet         :  if for small CIDs and CID 1-15
      +---+---+---+---+---+---+---+---+
      |   first octet of base header  |  (with type indication)
      +---+---+---+---+---+---+---+---+
      :                               :
      /   0, 1, or 2 octets of CID    /  1-2 octets if large CIDs
      :                               :
      +---+---+---+---+---+---+---+---+
      /   remainder of base header    /  variable number of bits
      +---+---+---+---+---+---+---+---+
      :                               :
      / Header Chain Irregular Part   /  variable (see section 1.1.1)
      :                               :
       --- --- --- --- --- --- --- ---
      :                               :
      /  TCP Options Irregular Part   /  variable (see section 6.7.5)
      :                               :
       --- --- --- --- --- --- --- ---


6.7.  Packet Formats

   This section describes the set of compressed TCP/IP packet formats.
   The normative description of the packet formats is given using a
   formal notation, the ROHC-FN [4]. The formal description of the
   packet formats specifies all of the information needed to compress
   and decompress a header relative to the context.



Pelletier, et. al                                              [Page 30]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004



   In particular, the notation provides a list of all the fields present
   in the uncompressed and compressed TCP/IP headers, and defines how to
   map from each uncompressed packet to its compressed equivalent and
   vice versa. See the ROHC-FN [4] for an explanation of the formal
   notation itself, and the encoding methods used to compress each of
   the fields in the TCP/IP header.

   Note that the formal definition of the packet formats for ROHC-TCP
   includes comments that follow a specific syntax. These comments,
   called annotations, make use of square brackets as delimiters;
   numbers in between the "[" and the "]" are used to provide additional
   information about the expected number of bits for the field(s) that
   appears as a right-hand operand. These are not normative in any way.

   The following constants are defined to improve readability of the
   packet formats in this section:

      IPPROTO_TCP = 6
      IPPROTO_IP  = 255            % place-holder for IP header in chain


6.7.1.  General Structures

   static_or_irreg32(flag) ===
   {
           uncompressed_format =        field;     %[ 32 ]

           format_irreg_enc    =        field,     %[ 32 ]
           {
              let (flag == 1);
              field ::= irregular(32);
           };

           format_static_enc   =        field,     %[ 0 ]
           {
              let (flag == 0);
              field ::= static;
           };
   };

   static_or_irreg16(flag) ===
   {
           uncompressed_format =        field;     %[ 16 ]

           format_irreg_enc    =        field,     %[ 16 ]
           {
              let (flag == 1);
              field ::= irregular(16);
           };




Pelletier, et. al                                              [Page 31]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


           format_static_enc =       field,     %[ 0 ]
           {
              let (flag == 0);
              field ::= static;
           };
   };

   static_or_irreg8(flag) ===
   {
           uncompressed_format = field;            %[ 8 ]

           format_irreg_enc =        field,     %[ 8 ]
           {
              let (flag == 1);
              field ::= irregular(8);
           };
           format_static_enc =       field,     %[ 0 ]
           {
              let (flag == 0);
              field ::= static;
           };
   };

   tlv_header ===
   {
           uncompressed_format = length,       %[ 8 ]
                                 option_value; % n bits

           format_0 = length,       %[ 8 ]
                      option_value, % n bits
           {
              length       ::= irregular (8);
              option_value ::= irregular (length:uncomp_value * 64 û
                                          64);
           };
   };

   optional32 (flag) ===
   {
           uncompressed_format = item; % 0 or 32 bits

           format_present = item, %[ 32 ]
           {
              let (flag == 1);
              item ::= irregular (32);
           };

           format_not_present = item, %[ 0 ]
           {
              let (flag == 0);
              item ::= compressed_value (0, 0);



Pelletier, et. al                                              [Page 32]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


           };
   };

   lsb_7_or_31 ===
   {
           uncompressed_format     = item; % 7 or 31 bits

           format_lsb_7  = discriminator,  %[ 1 ]
                           item,           %[ 7 ]
           {
                   discriminator ::= '0';
                   item          ::= lsb (7, 8);
           };

           format_lsb_31 = discriminator,  %[ 1 ]
                           item,           %[ 31 ]
           {
                   discriminator ::= '1';
                   item          ::= lsb (31, 256);
           };
   };

   opt_lsb_7_or_31 (flag) ===
   {
           uncompressed_format = item;     % 32 bits

           format_present = item,          % 8 or 32 bits
           {
              let (flag == 1);
              item ::= lsb_7_or_31;
           };

           format_not_present = item,      %[ 0 ]
           {
              let (flag == 0);
              item ::= compressed_value (0, 0);
           };
   };

   crc3 (data_value, data_length) ===
   {
           uncompressed_format = ;

           compressed_format = crc_value,   %[ 3 ]
           {
                   crc_value ::= crc(3, 0x06, 0x07, data_value,
                                 data_length);
           };
   };

   crc7 (data_value, data_length) ===



Pelletier, et. al                                              [Page 33]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   {
           uncompressed_format = ;

           compressed_format = crc_value, %[ 7 ]
           {
                   crc_value ::= crc(7, 0x79, 0x7f, data_value,
                                 data_length);
           };
   };


6.7.2.  Extension Headers


6.7.2.1.  IPv6 DEST opt header
   ip_dest_opt ===
   {
           uncompressed_format = next_header,              %[ 8 ]
                                 length_and_value;         % 8 + n bits

           default_methods =
           {
                   next_header      ::= static;
                   length_and_value ::= static;
           };

           format_dest_opt_static = next_header,           %[ 8 ]
           {
                   next_header      ::= irregular(8);
           };

           format_dest_opt_dynamic = length_and_value,     % 8 + n bits
           {
                   length_and_value ::= tlv_header;
           };

           format_dest_opt_replicate_0 = discriminator,    %[ 8 ]
           {
                   discriminator ::= '00000000';
           };

           format_dest_opt_replicate_1 = discriminator,    %[ 8 ]
                                         length_and_value, % 8 + n bits
           {
                   discriminator    ::= '10000000';
                   length_and_value ::= tlv_header;
           };
   };


6.7.2.2.  IPv6 HOP opt header



Pelletier, et. al                                              [Page 34]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004



   ip_hop_opt ===
   {
           uncompressed_format = next_header,            %[ 8 ]
                                 length_and_value;       % 8 + n bits


           default_methods     =
           {
              next_header       ::= static;
              length_and_value  ::= static;
           };


           format_hop_opt_static = next_header,          %[ 8 ]
           {
              next_header ::= irregular(8);
           };


           format_hop_opt_dynamic = length_and_value,    % 8 + n bits
           {
              length_and_value  ::= tlv_header;
           };


           format_hop_opt_replicate_0 = discriminator,   %[ 8 ]
           {
              discriminator    ::= '00000000';
           };


        format_hop_opt_replicate_1 = discriminator,        %[ 8 ]
                                     length_and_value,     % 8 + n bits
        {
          discriminator    ::= '10000000';
          length_and_value ::= tlv_header;
        };
   };


6.7.2.3.  IPv6 Routing Header

   ip_rout_opt ===
   {
           uncompressed_format = next_header,              %[ 8 ]
                                 length_and_value;         % 8 + n bits

           default_methods     =
           {
              next_header       ::= static;



Pelletier, et. al                                              [Page 35]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


              length_and_value  ::= static;
           };

           format_rout_opt_static = next_header,            %[ 8 ]
                                    length_and_value,       % 8 + n bits
           {
              next_header ::= irregular(8);
              length_and_value  ::= tlv_header;
           };

           format_rout_opt_dynamic =
           {
           };

           format_rout_opt_replicate_0 = discriminator,     %[ 8 ]
           {
              discriminator     ::= '00000000';
           };

           format_rout_opt_replicate_1 = discriminator,     %[ 8 ]
                                         length_and_value,  % 8 + n bits
           {
              discriminator     ::= '10000000';
              length_and_value  ::= tlv_header;
           };
   };


6.7.2.4.  GRE Header

   optional_checksum (flag_value) ===
   {
           uncompressed_format = value,     % 0 or 16 bits
                                 reserved1; % 0 or 16 bits

           format_cs_present = value,     %[ 16 ]
                               reserved1, %[ 0 ]
           {
              let (flag_value == 1);
              value     ::= irregular (16);
              reserved1 ::= uncompressed_value (16, 0);
           };

           format_not_present = value,     %[ 0 ]
                                reserved1, %[ 0 ]
           {
              let (flag_value == 0);
              value     ::= compressed_value (0, 0);
              reserved1 ::= compressed_value (0, 0);
           };
   };



Pelletier, et. al                                              [Page 36]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004



   gre_proto ===
   {
           uncompressed_format = protocol; %[ 16 ]

           default_methods =
           {
           };

           format_ether_v4 = discriminator, %[ 1 ]
           {
                   discriminator ::= compressed_value (1, 0);
                   protocol      ::= uncompressed_value (16, 0x0800);
           };

           format_ether_v6 = discriminator, %[ 1 ]
           {
                   discriminator ::= compressed_value (1, 1);
                   protocol      ::= uncompressed_value (16, 0x86DD);
           };
   };

   gre ===
   {
           uncompressed_format = c_flag,              %[ 1 ]
                                 r_flag,              %[ 1 ]
                                 k_flag,              %[ 1 ]
                                 s_flag,              %[ 1 ]
                                 reserved0,           %[ 9 ]
                                 version,             %[ 3 ]
                                 protocol,            %[ 16 ]
                                 checksum_and_res,    % 0 or 32 bits
                                 key,                 % 0 or 32 bits
                                 sequence_number;     % 0 or 32 bits

           default_methods =
           {
                   c_flag     ::= static;
                   r_flag     ::= static;
                   k_flag     ::= static;
                   s_flag     ::= static;
                   reserved0  ::= uncompressed_value (9, 0);
                   version    ::= static;
                   protocol   ::= static;
                   key        ::= static;
                   checksum_and_res ::= optional_checksum (c_flag);
           };

           format_gre_static = protocol,                %[ 1 ]
                               c_flag,                  %[ 1 ]
                               r_flag,                  %[ 1 ]



Pelletier, et. al                                              [Page 37]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


                               k_flag,                  %[ 1 ]
                               s_flag,                  %[ 1 ]
                               version,                 %[ 3 ]
                               key,                     % 0 or 32 bits
           {
                   protocol ::= gre_proto;

                   c_flag  ::= irregular (1);
                   r_flag  ::= irregular (1);
                   k_flag  ::= irregular (1);
                   s_flag  ::= irregular (1);
                   version ::= irregular (3);

                   key ::= optional32 (k_flag);
                   sequence_number ::= static;
           };


           format_gre_dynamic = checksum_and_res,% 0 or 16 bits
                                sequence_number, % 0 or 32 bits
           {
                   sequence_number ::= optional32 (s_flag);
           };

           format_gre_replicate_0 = discriminator,   % 8 bits
                                    checksum_and_res,% 0 or 16 bits
                                    sequence_number, % 0, 8 or 32 bits
           {
                   discriminator ::= '00000000';

                   sequence_number ::= opt_lsb_7_or_31 (s_flag);
           };

           format_gre_replicate_1 =
                                  discriminator,   %[ 8 ]
                                  c_flag,          %[ 1 ]
                                  r_flag,          %[ 1 ]
                                  k_flag,          %[ 1 ]
                                  s_flag,          %[ 1 ]
                                  reserved,        %[ 1 ]
                                  version,         %[ 3 ]
                                  checksum_and_res,% 0 or 16 bits
                                  key,             % 0 or 32 bits
                                  sequence_number, % 0 or 32 bits
           {
                   discriminator   ::= '10000000';

                   c_flag          ::= irregular (1);
                   r_flag          ::= irregular (1);
                   k_flag          ::= irregular (1);
                   s_flag          ::= irregular (1);



Pelletier, et. al                                              [Page 38]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


                   reserved        ::= '0';
                   version         ::= irregular (3);

                   key             ::= optional32 (k_flag);
                   sequence_number ::= optional32 (s_flag);
           };

           format_gre_irregular = checksum_and_res,% 0 or 16 bits
                                  sequence_number, % 0, 8 or 32 bits
           {
                   sequence_number ::= opt_lsb_7_or_31 (s_flag);
           };
   };


6.7.2.5.  MINE header

   mine ===
   {
           uncompressed_format = next_header,  %[ 8 ]
                                 s_bit,        %[ 1 ]
                                 res_bits,     %[ 7 ]
                                 checksum,     %[ 16 ]
                                 orig_dest,    %[ 32 ]
                                 orig_src;     %  0 or 32 bits

           default_methods =
           {
                   next_header  ::= static;
                   s_bit     ::= static;
                   res_bits  ::= static;
                   checksum  ::= inferred_mine_header_checksum;
                   orig_dest ::= static;
                   orig_src  ::= static;
           };

           format_mine_static = next_header,%[ 8 ]
                                s_bit,      %[ 1 ],
                                res_bits,   %[ 7 ],
                                orig_dest,  %[ 32 ]
                                orig_src,   %  0 or 32 bits
           {
                   next_header ::= irregular (8);
                   s_bit       ::= irregular (1);
                   res_bits    ::= irregular (7);
                   % include reserved - no benefit in removing them
                   orig_dest   ::= irregular (32);
                   orig_src    ::= optional32 (s_bit);
           };

           format_mine_dynamic =



Pelletier, et. al                                              [Page 39]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


           {
           };

           format_mine_replicate_0 = discriminator, %[ 8 ]
                                     checksum,      %[ 0 ]
           {
                   discriminator ::= '00000000';
           };

           format_mine_replicate_1 = discriminator,  %[ 8 ]
                                     s_bit,          %[ 1 ]
                                     res_bits,       %[ 7 ]
                                     orig_dest,      %[ 32 ]
                                     orig_src,       %  0 or 32 bits
           {
                   discriminator ::= '10000000';

                   s_bit         ::= irregular (1);
                   res_bits      ::= irregular (7);
                   orig_dest     ::= irregular (32);
                   orig_src      ::= optional32 (s_bit);
           };
   };


6.7.2.6.  Authentication Header (AH) header

   ah ===
   {
           uncompressed_format = next_header,          %[ 8 ]
                                 length,               %[ 8 ]
                                 res_bits,             %[ 16 ]
                                 spi,                  %[ 32 ]
                                 sequence_number,      %[ 32 ]
                                 auth_data;            % n bits

           default_methods   =
           {
              next_header     ::= static;
              length          ::= static;
              res_bits        ::= static;
              spi             ::= static;
              sequence_number ::= static;
              auth_data       ::= irregular (length.uncomp_value * 32 û
                                             32);
           };

           format_ah_static =   next_header,           %[  8 ]
                                length,                %[  8 ]
                                spi,                   %[ 32 ]
           {



Pelletier, et. al                                              [Page 40]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


              next_header ::= irregular(8);
              length      ::= irregular (8);
              spi         ::= irregular (32);
           };

           format_ah_dynamic =   res_bits,             %[ 16 ]
                                 sequence_number,      %[ 32 ]
                                 auth_data,            %  n bits
           {
              res_bits        ::= irregular (16);
              sequence_number ::= irregular (32);
           };

           format_ah_replicate_0 =   discriminator,    %[ 8 ]
                                     sequence_number,  % 8 or 32 bits
                                     auth_data,        % n bits
           {
              discriminator   ::= '00000000';
              sequence_number ::= lsb_7_or_31;
           };

           format_ah_replicate_1 =   discriminator,    %[ 8 ]
                                     length,           %[ 8 ]
                                     res_bits,         %[ 16 ]
                                     spi,              %[ 32 ]
                                     sequence_number,  %[ 32 ]
                                     auth_data,        %  n bits
           {
              discriminator   ::= '10000000';
              length          ::= irregular (8);
              res_bits        ::= irregular (16);
              spi             ::= irregular (32);
              sequence_number ::= irregular (32);
           };


           format_ah_irregular =   sequence_number,    % 8 or 32 bits
                                   auth_data,          % n bits
           {
              sequence_number ::= lsb_7_or_31;
           };
   };


6.7.2.7.  Encapsulation Security Payload (ESP) header

   esp_null ===
   {
           uncompressed_format = spi,             %[ 32 ]
                                 sequence_number, %[ 32 ]
                                 next_header;     %[ 8 ]



Pelletier, et. al                                              [Page 41]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004



           default_methods =
           {
                   spi         ::= static;
               % Next header will always be present in the trailer part,
               % but sometimes it will ALSO be present in the header
               % (static chain only).
                   nh_field ::= static; % Control field
                   next_header ::= static;
                   sequence_number ::= static;
           };

           format_esp_static = next_header, %[ 8 ]
           {
           % identify next header assume next 96 bits skipped
           % to get to end of packet (i.e. this is anchored from the end
           %  of the packet, not the start)
                   nh_field ::= compressed_value(8, next_header);
                   next_header ::= irregular (8);
           };

           format_esp_dynamic = sequence_number, %[ 32 ]
           {
                   sequence_number  ::= irregular (32);
           };

           format_esp_replicate_0 = discriminator,   %[ 8 ]
                                    sequence_number, % 8 or 32 bits
           {
                   discriminator   ::= '00000000';

                   sequence_number ::= lsb_7_or_31;
           };

           format_esp_replicate_1 = discriminator,    %[ 8 ]
                                    spi,              %[ 32 ]
                                    sequence_number,  %[ 32 ]
           {
                   discriminator   ::= '10000000';

                   spi             ::= irregular (32);
                   sequence_number ::= irregular (32);
           };

           format_esp_irregular = sequence_number, % 8 or 32 bits
           {
                   sequence_number ::= lsb_7_or_31;
           };
   };





Pelletier, et. al                                              [Page 42]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004



6.7.3.  IP Header

6.7.3.1. Structures Common for IPv4 and IPv6

   irreg_tos_tc(flag) ===
   {
           uncompressed_format = tos_tc;        %[ 6 ]

           format_tos_tc_present = tos_tc ,     %[ 6 ]
           {
              let(flag == 1);
              tos_tc  ::= irregular (6);
           };

           format_tos_tc_not_present = tos_tc , %[ 0 ]
           {
              let(flag == 0);
              tos_tc  ::= static;
           };
   };

   ip_irreg_ecn(flag) ===
   {
           uncompressed_format = ip_ecn_flags;     %[ 2 ]

           format_tc_present = ip_ecn_flags,       %[ 2 ]
           {
              let(flag == 1);
              ip_ecn_flags ::= irregular (2);
           };

           format_tc_not_present = ip_ecn_flags, %[ 0 ]
           {
              let(flag == 0);
              ip_ecn_flags ::= static;
           };
   };


6.7.3.2.  IPv6 Header

   fl_enc ===
   {
           uncompressed_format = flow_label;

           format_fl_zero = discriminator,
                            flow_label,
                            reserved,
           {
                   discriminator ::= '0';



Pelletier, et. al                                              [Page 43]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


                   flow_label    ::= uncompressed_value (20, 0);
                   reserved      ::= '0000';
           };

           format_fl_non_zero = discriminator,
                                flow_label,
           {
                   discriminator ::= '1';
                   flow_label    ::= irregular (20);
           };
   };

   ipv6 ===
   {
           uncompressed_format = version,        %[ 4 ]
                                 tos_tc,         %[ 6 ]
                                 ip_ecn_flags,   %[ 2 ]
                                 flow_label,     %[ 20 ]
                                 payload_length, %[ 16 ]
                                 next_header,    %[ 8 ]
                                 ttl_hopl,       %[ 8 ]
                                 src_addr,       %[ 128 ]
                                 dst_addr;       %[ 128 ]

           default_methods =
           {
                   version        ::= uncompressed_value (4, 6);
                   tos_tc         ::= static;
                   ip_ecn_flags   ::= static;
                   flow_label     ::= static;
                   payload_length ::= inferred_ip_v6_length;
                   next_header    ::= static;
                   ttl_hopl       ::= static;
                   src_addr       ::= static;
                   dst_addr       ::= static;
           };

           format_ipv6_static = version_flag,    %[ 1 ]
                                reserved,        %[ 2 ]
                                flow_label,      %   5 or 21 bits
                                next_header,     %[ 8 ]
                                src_addr,        %[ 128 ]
                                dst_addr,        %[ 128 ]
           {
                      version_flag        ::=   '1';
                      reserved            ::=   '00';
                      flow_label          ::=   fl_enc;
                      next_header         ::=   irregular (8);
                      src_addr            ::=   irregular(128);
                      dst_addr            ::=   irregular(128);
           };



Pelletier, et. al                                              [Page 44]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004



           format_ipv6_dynamic = tos_tc,        %[ 6 ]
                                 ip_ecn_flags,  %[ 2 ]
                                 ttl_hopl,      %[ 8 ]
           {
                   tos_tc       ::= irregular (6);
                   ip_ecn_flags ::= irregular (2);
                   ttl_hopl     ::= irregular (8);
           };

           format_ipv6_replicate = tos_tc,       %[ 6 ]
                                   ip_ecn_flags, %[ 2 ]
           {
                   tos_tc       ::= irregular (6);
                   ip_ecn_flags ::= irregular (2);
           };

           format_ipv6_outer_irregular(ecn_used_flag) =
                                     tos_tc, % 0 or 6 bits
                                           ip_ecn_flags, % 0 or 2 bits
           {
           % for 'outer' headers only, irregular chain is required
                   tos_tc        ::= irreg_tos_tc (ecn_used_flag);
                   ip_ecn_flags  ::= ip_irreg_ecn (ecn_used_flag);

           };

         % Can be non-octet-aligned, but combined with the TCP irregular
         % it will be made octet-aligned
           format_ipv6_innermost_irregular(ecn_used_flag) =
                                     ip_ecn_flags, % 0 or 2 bits
           {
                   ip_ecn_flags  ::= ip_irreg_ecn (ecn_used_flag);
           };

   };


6.7.3.3.  IPv4 Header

   ip_id_enc_dyn (behavior) ===
   {
           uncompressed_format = ip_id; %[ 16 ]

           format_ip_id_seq = ip_id,
           {
           let ((behavior == 0) || (behavior == 1) || (behavior == 2));
       % In dynamic chain, but random, seq, and seq-swapped are 16 bits
                 ip_id ::= irregular(16);
           };




Pelletier, et. al                                              [Page 45]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


           format_ip_id_zero = ip_id,
           {
           let (behavior == 3);
                 % Zero IPID
                 ip_id ::= uncompressed_value (16, 0);
           };
   };

   ip_id_enc_irreg (behavior) ===
   {
           uncompressed_format = ip_id; % 0 or 16

           format_ip_id_seq = ip_id,
           {
              let (behavior == 0); % sequential
              ip_id ::= static;    % Nothing to send in irregular chain
           };

           format_ip_id_seq_swapped = ip_id,
           {
              let (behavior == 1); % sequential-swapped
              ip_id ::= static;    % Nothing to send in irregular chain
           };

           format_ip_id_rand = ip_id,
           {
              let (behavior == 2); % random
              ip_id ::= irregular (16);
           };

           format_ip_id_zero = ip_id,
           {
              let (behavior == 3); % zero
              ip_id ::= uncompressed_value (16, 0);
           };
   };


   ip_id_behavior_enc ===
   {
           uncompressed_format = ip_id_behavior; %[ 2 ]

           format_sequential = ip_id_behavior,
           {
              ip_id_behavior ::= '00';
           };

           format_sequential_swapped = ip_id_behavior,
           {
              ip_id_behavior ::= '01';
           };



Pelletier, et. al                                              [Page 46]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004



           format_random = ip_id_behavior,
           {
              ip_id_behavior ::= '10';
           };

           format_zero = ip_id_behavior,
           {
              ip_id_behavior ::= '11';
           };
   };

   ipv4 ===
   {
           uncompressed_format =   version,     %[ 4 ]
                                   hdr_length,  %[ 4 ]
                                   protocol,    %[ 8 ]
                                   tos_tc,      %[ 6 ]
                                   ip_ecn_flags,%[ 2 ]
                                   ttl_hopl,    %[ 8 ]
                                   df,          %[ 1 ]
                                   mf,          %[ 1 ]
                                   rf,          %[ 1 ]
                                   frag_offset, %[ 13 ]
                                   ip_id,       %[ 16 ]
                                   src_addr,    %[ 32 ]
                                   dst_addr,    %[ 32 ]
                                   checksum,    %[ 16 ]
                                   length;      %[ 16 ]

           control_fields  = ip_id_behavior;    % 2 bits

           default_methods =
           {
                   version          ::= static;
                   hdr_length       ::= uncompressed_value (4, 5);
                   protocol         ::= static;
                   tos_tc           ::= static;
                   ip_ecn_flags     ::= static;
                   ttl_hopl         ::= static;
                   df               ::= static;
                   mf               ::= uncompressed_value (1, 0);
                   rf               ::= static;
                   frag_offset      ::= uncompressed_value (13, 0);
                   ip_id            ::= uncompressed_value (16, 0);
                   ip_id_behavior   ::= static;
                   src_addr         ::= static;
                   dst_addr         ::= static;
                   checksum         ::= inferred_ip_v4_header_checksum;
                   length           ::= inferred_ip_v4_length;
           };



Pelletier, et. al                                              [Page 47]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004



           format_ipv4_static = version_flag, %[ 1 ]
                                reserved,     %[ 7 ]
                                protocol,     %[ 8 ]
                                src_addr,     %[ 32 ]
                                dst_addr,     %[ 32 ]
           {
                   version_flag     ::= '0';
                   reserved         ::= '0000000';
                   protocol         ::=  irregular (8);
                   src_addr         ::=  irregular(32);
                   dst_addr         ::=  irregular(32);
           };

           format_ipv4_dynamic = reserved,       %[ 5 ]
                                 df,             %[ 1 ]
                                 ip_id_behavior, %[ 2 ]
                                 tos_tc,         %[ 6 ]
                                 ip_ecn_flags,   %[ 2 ]
                                 ttl_hopl,       %[ 8 ]
                                 ip_id,          % 0/16 bits
           {
                   reserved       ::= '00000';
                   %
                   % compressor chooses behavior of IP-ID
                   %   00 = sequential
                   %   01 = sequential byteswapped
                   %   10 = random
                   %   11 = zero
                   %
                   ip_id_behavior ::= ip_id_behavior_enc;
                   df             ::= irregular (1);
                   tos_tc         ::= irregular (6);
                   ip_ecn_flags   ::= irregular (2);
                   ttl_hopl       ::= irregular (8);
                   ip_id          ::= ip_id_enc_dyn (ip_id_behavior);
           };

           format_ipv4_replicate_0 = discriminator, %[ 8 ]
                                     ip_id,         % 0 or 16 bits
                                     tos_tc,        %[ 6 ]
                                     ip_ecn_flags,  %[ 2 ]
           {
                   discriminator  ::= '00000000';

                   ip_id_behavior ::= static;
                   ip_id          ::= ip_id_enc_irreg (ip_id_behavior);
                   tos_tc         ::= irregular (6);
                   ip_ecn_flags   ::= irregular (2);
           };




Pelletier, et. al                                              [Page 48]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


           format_ipv4_replicate_1 = discriminator,  %[ 5 ]
                                     df,             %[ 1 ]
                                     ip_id_behavior, %[ 2 ]
                                     tos_tc,         %[ 6 ]
                                     ip_ecn_flags,   %[ 2 ]
                                     ttl_hopl,       %[ 8 ]
                                     ip_id,          % 0/16 bits
           {
                   discriminator  ::= '10000';

                   df             ::= irregular (1);
                   tos_tc         ::= irregular (6);
                   ip_ecn_flags   ::= irregular (2);
                   ttl_hopl       ::= irregular (8);

                   %
                   % compressor chooses behavior of IP-ID
                   %   00 = sequential
                   %   01 = sequential byteswapped
                   %   10 = random
                   %   11 = zero
                   %
                   ip_id_behavior ::= ip_id_behavior_enc;
                   ip_id ::= ip_id_enc_dyn (ip_id_behavior);
           };

           format_ipv4_outer_irregular(ecn_used_flag) = ip_id,
                                                        tos_tc,
                                                        ip_ecn_flags,
           {
                   ip_id_behavior ::= static;
                   ip_id          ::= ip_id_enc_irreg (ip_id_behavior);
                   tos_tc         ::= irreg_tos_tc (ecn_used_flag);
                   ip_ecn_flags   ::= ip_irreg_ecn (ecn_used_flag);
           };

         % Can be non-octet-aligned, but combined with the TCP irregular
         % it will be made octet-aligned
           format_ipv4_innermost_irregular(ecn_used_flag) =
                                       ip_id,        % 0 or 16 bits
                                             ip_ecn_flags, % 0 or 2 bits
           {
                   ip_id_behavior ::= static;
                   ip_id          ::= ip_id_enc_irreg (ip_id_behavior);
                   ip_ecn_flags   ::= ip_irreg_ecn (ecn_used_flag);
           };
   };


6.7.4. TCP Header




Pelletier, et. al                                              [Page 49]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   port_replicate(flags) ===
   {
           uncompressed_format  =   port;        %[ 16 ]

           format_port_static_enc   = port,      %[ 0 ]
           {
              let(flags == 00);
              port          ::= static;
           };

           format_port_lsb8         = port,      %[ 8 ]
           {
              let(flags == 01);
              port          ::= lsb (8, 64);
           };

           format_port_irr_enc      = port,      %[ 16 ]
           {
              let(flags == 10);
              port          ::= irregular (16);
           };
   };

   urg_enc_dyn(flag) ===
   {
           uncompressed_format = urg_ptr;

           format_urg_zero = urg_ptr,
           {
              let(flag == 0);
              urg_ptr ::= irregular (16);
           };

           format_urg_non_zero = urg_ptr,
           {
              let(flag == 1);
              urg_ptr ::= uncompressed_value (16, 0);
           };
   };

   ack_enc_dyn(flag) ===
   {
           uncompressed_format = ack_number;

           format_ack_zero = ack_number,
           {
              let(flag == 0);
              ack_number ::= irregular (32);
           };

           format_ack_non_zero = ack_number,



Pelletier, et. al                                              [Page 50]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


           {
              let(flag == 1);
              ack_number ::= uncompressed_value (32, 0);
           };
   };

   tcp_ecn_flags_enc(flag) ===
   {
           uncompressed_format = tcp_ecn_flags;

           format_irreg = tcp_ecn_flags,
           {
              let(flag == 1);
              tcp_ecn_flags ::= irregular(2);
           };

           format_unused =
           {
              let(flag == 0);
              tcp_ecn_flags ::= static;
           };
   };

   tcp_res_flags_enc(flag) ===
   {
           uncompressed_format = tcp_res_flags;

           format_irreg = tcp_res_flags,
           {
              let(flag == 1);
              tcp_res_flags     ::= irregular(4);
           };

           format_unused =
           {
              let(flag == 0);
              tcp_res_flags     ::= uncompressed_value(4, 0);
           };
   };

   rsf_index_enc ===
   {
           uncompressed_format = rsf_flag;

           format_none     = rsf_idx,
           {
                   rsf_idx  ::= '00';
                   rsf_flag ::= uncompressed_value (3, 0x00);
           };

           format_rst_only = rsf_idx,



Pelletier, et. al                                              [Page 51]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


           {
                   rsf_idx  ::= '01';
                   rsf_flag ::= uncompressed_value (3, 0x01);
           };

           format_syn_only = rsf_idx,
           {
                   rsf_idx  ::= '10';
                   rsf_flag ::= uncompressed_value (3, 0x02);
           };

           format_fin_only = rsf_idx,
           {
                   rsf_idx  ::= '11';
                   rsf_flag ::= uncompressed_value (3, 0x04);
           };
   };

   tcp ===
   {
           uncompressed_format = src_port,     %[ 16 ]
                                 dst_port,     %[ 16 ]
                                 rsf_flags,    %[ 3 ]
                                 psh_flag,     %[ 1 ]
                                 urg_flag,     %[ 1 ]
                                 ack_flag,     %[ 1 ]
                                 data_offset,  %[ 4 ]
                                 tcp_ecn_flags,%[ 2 ]
                                 tcp_res_flags,%[ 4 ]
                                 urg_ptr,      %[ 16 ]
                                 window,       %[ 16 ]
                                 checksum,     %[ 16 ]
                                 seq_number,   %[ 32 ]
                                 ack_number,   %[ 32 ]
                                 options;      %  n bits

           control_fields  = msn,              % 16 bits
                             ecn_used;         % 1 bit

           default_methods =
           {
                   src_port      ::= static;
                   dst_port      ::= static;
                   seq_number    ::= static;
                   ack_number    ::= static;
                   rsf_flags     ::= static;
                   psh_flag      ::= irregular (1);
                   urg_flag      ::= static;
                   ack_flag      ::= uncompressed_value (1, 1);
                   urg_ptr       ::= static;
                   window        ::= static;



Pelletier, et. al                                              [Page 52]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


                   checksum      ::= irregular (16);
                   tcp_ecn_flags ::= static;
                   tcp_res_flags ::= static;
           };

           format_tcp_static = src_port,     %[ 16 ]
                               dst_port,     %[ 16 ]
           {
                   next_header   ::=   uncompressed_value (8, 6);

                   src_port      ::=   irregular(16);
                   dst_port      ::=   irregular(16);
           };

           format_tcp_dynamic =  ecn_used,              %[ 1 ]
                                 ack_flag,              %[ 1 ]
                                 urg_flag,              %[ 1 ]
                                 psh_flag,              %[ 1 ]
                                 ack_zero,              %[ 1 ]
                                 urp_zero,              %[ 1 ]
                                 rsf_flags,             %[ 3 ]
                                 tcp_ecn_flags,         %[ 2 ]
                                 tcp_res_flags,         %[ 4 ]
                                 padding,               %[ 1 ]
                                 msn,                   %[ 16 ]
                                 seq_number,            %[ 32 ]
                                 ack_number,            %  0 or 32 bits
                                 window,                %[ 16 ]
                                 checksum,              %[ 16 ]
                                 urg_ptr,               %  0 or 16 bits
                                 options,               %  n bits
           {
                      ecn_used          ::= irregular (1);
                      ack_zero          ::= irregular (1);
                      urp_zero          ::= irregular (1);
                      ack_flag          ::= irregular (1);
                      urg_flag          ::= irregular (1);
                      psh_flag          ::= irregular (1);
                      tcp_ecn_flags     ::= irregular (2);
                      padding           ::= '0';
                      rsf_flags         ::= irregular (3);
                      tcp_res_flags     ::= irregular (4);
                      msn               ::= irregular (16);
                      seq_number        ::= irregular (32);
                      window            ::= irregular (16);
                      checksum          ::= irregular (16);
                      urg_ptr           ::= urg_enc_dyn(urp_zero);
                      ack_number        ::= ack_enc_dyn(ack_zero);
                      options           ::=
                                          list_tcp_options(list_length);
           };



Pelletier, et. al                                              [Page 53]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004




           format_tcp_replicate = reserved,           %[ 1 ]
                                  list_present,       %[ 1 ]
                                  src_port_presence,  %[ 2 ]
                                  dst_port_presence,  %[ 2 ]
                                  ack_number,         %[ 1 ]
                                  urp_presence,       %[ 1 ]
                                  urg_flag,           %[ 1 ]
                                  ack_flag,           %[ 1 ]
                                  psh_flag,           %[ 1 ]
                                  rsf_flags,          %[ 2 ]
                                  tcp_ecn_flags,      %[ 2 ]
                                  ecn_used,           %[ 1 ]
                                  msn,                %[ 16 ]
                                  seq_number,         %[ 32 ]
                                  src_port,           %  0, 8 or 16 bits
                                  dst_port,           %  0, 8 or 16 bits
                                  urg_point,          %  0 or 16 bits
                                  ack_number,         %  0 or 32 bits
                                  tcp_ecn_flags,      %  0 or 2 bits
                                  tcp_res_flags,      %  0 or 4 bits
                                  options_list,       %  n bits
           {
                   reserved            ::=   '0';
                   options_replicate   ::=   irregular (1);
                   msn                 ::=   irregular (16);
                   urg_flag            ::=   irregular (1);
                   ack_flag            ::=   irregular (1);
                   psh_flag            ::=   irregular (1);
                   rsf_flags           ::=   rsf_index_enc;
                   ecn_used            ::=   irregular (1);
                   tcp_ecn_flags       ::=   irregular (2);
                   src_port            ::=
                                      port_replicate(src_port_presence);
                   dst_port            ::=
                                      port_replicate(dst_port_presence);
                   seq_number          ::=   irregular(32);
                   ack_number          ::=
                                        static_or_irreg32(ack_presence);
                   window              ::=
                                     static_or_irreg16(window_presence);
                   urg_point           ::=
                                        static_or_irreg16(urp_presence);
                   options_list        ::=   tcp_list_presence_enc
                                   ((data_offset:uncomp_value + 20) / 4,
                                             list_present);
           };

    % Note that this structure can be non-octet-aligned, but it is known
    % that is will always be used together with an innermost_irregular



Pelletier, et. al                                              [Page 54]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


    % structure that will make it octet-aligned

           format_tcp_irregular = tcp_ecn_flags,
                                  tcp_res_flags,
                                  checksum, %[ 16 ]
           {
                   tcp_ecn_flags  ::= tcp_ecn_flags_enc (ecn_used_flag);
                   tcp_res_flags  ::= tcp_res_flags_enc (ecn_used_flag);
                   checksum       ::= irregular (16);
           };
   };


6.7.5. TCP Options

   tcp_opt_mss ===
   {
           uncompressed_format = type,   %[ 8 ]
                                 length, %[ 8 ]
                                 mss;    %[ 16 ]

           default_methods =
           {
                   type   ::= uncompressed_value (8, 2);
                   length ::= uncompressed_value (8, 4);
                   mss    ::= static;
           };

           format_mss_list_item = mss, %[ 16 ]
           {
                   mss ::= irregular (16);
           };

           format_mss_irregular =
           {
           };
   };

   tcp_opt_wscale ===
   {
           uncompressed_format = type,    %[ 8 ]
                                 length,  %[ 8 ]
                                 wscale;  %[ 8 ]

           default_methods =
           {
                   type    ::= uncompressed_value (8, 3);
                   length  ::= uncompressed_value (8, 3);
                   wscale  ::= static;
           };




Pelletier, et. al                                              [Page 55]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


           format_wscale_list_item = wscale,  %[ 8 ]
           {
                   wscale ::= irregular (8);
           };

           format_wscale_irregular =
           {
           };
   };

   ts_lsb ===
   {
           uncompressed_format = tsval;

           format_tsval_15 = discriminator, %[ 1 ]
                             tsval,         %[ 15 ]
           {
                   discriminator ::= '0';
                   tsval         ::= lsb (15, 128);
           };

           format_tsval_22 = discriminator, %[ 2 ]
                             tsval,         %[ 22 ]
           {
                   discriminator ::= '10';
                   tsval         ::= lsb (22, 256);
           };

           format_tsval_30 = discriminator, %[ 2 ]
                             tsval,         %[ 20 ]
           {
                   discriminator ::= '11';
                   tsval         ::= lsb (30, 512);
           };
   };

   tcp_opt_tsopt ===
   {
           uncompressed_format = type,   %[ 8 ]
                                 length, %[ 8 ]
                                 tsval,  %[ 32 ]
                                 tsecho; %[ 32 ]

           default_methods =
           {
                   type   ::= uncompressed_value (8, 8);
                   length ::= uncompressed_value (8, 10);
           };

           format_tsopt_list_item = tsval,   %[ 32 ]
                                    tsecho,  %[ 32 ]



Pelletier, et. al                                              [Page 56]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


           {
                   tsval  ::= irregular (32);
                   tsecho ::= irregular (32);
           };

           format_tsopt_irregular = tsval,  % 16, 24 or 32 bits
                                    tsecho, % 16, 24 or 32 bits
           {
                   tsval  ::= ts_lsb;
                   tsecho ::= ts_lsb;
           };
   };

   sack_var_length_enc (base) ===
   {
           uncompressed_format = sack_field; %[ 32 ]

           default_methods =
           {
                   let (sack_offset:uncomp_value ==
                        sack_field:uncomp_value - base);
                   let (sack_offset:uncomp_length == 32);
           };

           format_lsb_15 = discriminator,  %[ 1 ]
                           sack_offset,    %[ 15 ]
           {
                   discriminator    ::= '0';
                   sack_offset      ::= lsb (15, -1);
           };

           format_lsb_22 = discriminator,  %[ 2 ]
                           sack_offset,    %[ 22 ]
           {
                   discriminator    ::= '10';
                   sack_offset      ::= lsb (22, -1);
           };

           format_lsb_30 = discriminator,  %[ 2 ]
                           sack_offset,    %[ 30 ]
           {
                   discriminator    ::= '11';
                   sack_offset      ::= lsb (30, -1);
           };
   };

   tcp_opt_sack_block (prev_block_end) ===
   {
           uncompressed_format = block_start, %[ 32 ]
                                 block_end;   %[ 32 ]




Pelletier, et. al                                              [Page 57]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


           format_0 = block_start, % 16, 24 or 32 bits
                      block_end,   % 16, 24 or 32 bits
           {
                   block_start ::= sack_var_length_enc (prev_block_end);
                   block_end   ::= sack_var_length_enc (block_start);
           };
   };


   tcp_opt_sack(ack_value) ===
   {
       % The ACK value from the TCP header is needed as input parameter.
           uncompressed_format = type,    %[ 8 ]
                                 length,  %[ 8 ]
                                 block_1, % n bits
                                 block_2, % n bits
                                 block_3, % n bits
                                 block_4; % n bits

           default_methods =
           {
                   type    ::= uncompressed_value (8, 5);
                   length  ::= irregular (8);
                   block_1 ::= uncompressed_value (0, 0);
                   block_2 ::= uncompressed_value (0, 0);
                   block_3 ::= uncompressed_value (0, 0);
                   block_4 ::= uncompressed_value (0, 0);
           };

           format_sack1_list_item = length,
                                    block_1,
           {
                   length  ::= uncompressed_value (8, 10);
                   block_1 ::= tcp_opt_sack_block (ack_value);
           };

           format_sack2_list_item = length,
                                    block_1,
                                    block_2,
           {
                   length  ::= uncompressed_value (8, 18);
                   block_1 ::= tcp_opt_sack_block (ack_value);
                   block_2 ::= tcp_opt_sack_block
                                             (block_1_end:uncomp_value);
           };

           format_sack3_list_item = length,
                                    block_1,
                                    block_2,
                                    block_3,
           {



Pelletier, et. al                                              [Page 58]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


                   length  ::= uncompressed_value (8, 26);
                   block_1 ::= tcp_opt_sack_block (ack_value);
                   block_2 ::= tcp_opt_sack_block
                                             (block_1_end:uncomp_value);
                   block_3 ::= tcp_opt_sack_block
                                             (block_2_end:uncomp_value);
           };

           format_sack4_list_item = length,
                                    block_1,
                                    block_2,
                                    block_3,
                                    block_4,
           {
                   length  ::= uncompressed_value (8, 34);
                   block_1 ::= tcp_opt_sack_block (ack_value);
                   block_2 ::= tcp_opt_sack_block
                                             (block_1_end:uncomp_value);
                   block_3 ::= tcp_opt_sack_block
                                             (block_2_end:uncomp_value);
                   block_4 ::= tcp_opt_sack_block
                                             (block_3_end:uncomp_value);
           };

           format_sack_irregular =
           {
           };
   };

   %
   % EOL marks the end of the option list and, based on
   % the description in RFC 793 and the BSB TCP code,
   % nothing after this should be processed...
   % So, ignore everything after the EOL option
   % (according to 793 it must be 0)
   %
   % The length of the padding needs to be trasmitted with the
   % compressed list since the length of the list can be unknown to the
   % decompressor.
   %

   tcp_opt_eol ===
   {
           uncompressed_format = type,          %[ 8 ]
                                 padding;       % (n * 8) bits

           default_methods =
           {
                   type    ::= uncompressed_value (8, 0);
                   pad_len ::= static;
                   padding ::= static;



Pelletier, et. al                                              [Page 59]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


           };

           format_eol_list_item =  pad_len,      %  8 bits
                                   padding,      %[ 0 ]
           {
                   pad_len ::= tcpopt_eol_padding_length;
                   padding ::= uncompressed_value (pad_bits, 0);
           };
           format_eol_irregular =
           {
           };
   };

   tcp_opt_nop ===
   {
           uncompressed_format = type; %[ 8 ]

           default_methods =
           {
                   type ::= uncompressed_value (8, 1);
           };

           format_nop_list_item =
           {
           };

           format_nop_irregular =
           {
           };
   };

   tcp_opt_sack_permitted ===
   {
           uncompressed_format = type, %[ 8 ]
                                 length; %[ 8 ]

           default_methods =
           {
                   type   ::= uncompressed_value (8, 1);
                   length ::= uncompressed_value (8, 2);
           };
           format_sack_permitted_list_item =
           {
           };

           format_sack_permitted_irregular =
           {
           };
   };





Pelletier, et. al                                              [Page 60]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   tcp_opt_generic ===
   {
           uncompressed_format = type,       %[ 8 ]
                                 length_msb, %[ 1 ]
                                 length_lsb, %[ 7 ]
                                 contents;   % n bits

           default_methods =
           {
                   type          ::= static;
                   %
                   % lengths are always < 128
                   % (i.e. the msb is always 0)
                   %
                   length_msb    ::= uncompressed_value (1, 0);
                   length_lsb    ::= static;

                   contents      ::= irregular (length_len:uncomp_value
                                                * 8 - 16);
           };

           format_generic_list_item = type,            %[ 8 ]
                                      option_static,   %[ 1 ]
                                      length_lsb,      %[ 7 ]
                                      contents,        % n bits
           {
                   type          ::= irregular (8);
                   option_static ::= '0';
                   length_lsb    ::= irregular (7);
           };

           format_generic_replicate_0 = discriminator, %[ 8 ]
           {
                   discriminator ::= '00000000';
                   contents      ::= static;
           };

           format_generic_replicate_1 = discriminator,  %[ 8 ]
                                        type,           %[ 8 ]
                                        option_static,  %[ 1 ]
                                        length_lsb,     %[ 7 ]
                                        contents,       % n bits
           {
                   discriminator ::= '10000000';
                   type          ::= irregular (8);
                   option_static ::= '0';
                   length_lsb    ::= irregular (7);
           };

           format_generic_irregular_stable = discriminator, %[ 8 ]
                                             contents,      %[ 0 ]



Pelletier, et. al                                              [Page 61]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


           {
                   discriminator ::= '00000000';
                   contents      ::= static;
           };

           format_generic_irregular_full = discriminator, %[ 1 ]
                                           length_lsb,    %[ 7 ]
                                           contents,      % n bits
           {
                   discriminator ::= '1';
                   length_lsb    ::= irregular (7);
                   contents      ::= irregular (length_lsb:uncomp_value
                                                * 8 - 16);
           };

   };

   list_tcp_options(list_length_in_bytes) ===
   {
   % Length is not known a priori on decompressor, so we use a sentinel.
           end_of_list_sentinel ::= uncompressed_value(8, 0);
           end_of_list_padding  ::= uncompressed_value(8, 1);

           mss            ::= tcp_opt_mss;
           wscale         ::= tcp_opt_wscale;
           tsopt          ::= tcp_opt_tsopt;
           sack           ::= tcp_opt_sack;
           sack_permitted ::= tcp_opt_sack_permitted;
           eol            ::= tcp_opt_eol;
           nop            ::= tcp_opt_nop;
           generic        ::= tcp_opt_generic;
   };

   tcp_list_presence_enc(list_length, presence) ===
   {
           uncompressed_format = tcp_options;

           format_list_not_present = tcp_options,
           {
              let (presence == 0);
              tcp_options ::= static;
           };

           format_list_present = tcp_options,
           {
              let (presence == 1);
              tcp_options ::= list_tcp_options(list_length);
           };
   };





Pelletier, et. al                                              [Page 62]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


6.7.6.  Structures used in Compressed Base Headers

   tos_tc_enc(flag) ===
   {
           uncompressed_format = tos_tc;      %[ 6 ]

           format_static       = tos_tc,      %[ 0 ]
           {
              let (flag == 0);
              tos_tc             ::= static;
           };

           format_irreg     = tos_tc,         %[ 6 ]
                              padding,
           {
              let (flag == 1);
              tos_tc             ::= irregular(6);
              padding            ::= compressed_value (2, 0);
           };
   };

   rsf_static_or_byte_enc(flag) ===
   {
           uncompressed_format = rsf_flags;

           format_static = rsf_flags,      %[ 0 ]
           {
              let (flag == 0);
              rsf_flags          ::= static;
           };

           format_irreg = rsf_flags,      %[ 3 ]
           {
              let (flag == 1);
              rsf_flags          ::= irregular(3);
              reserved           ::= compressed_value (5, 0);
           };
   };


   ip_id_lsb (behavior, msn, k, p) ===
   {
           uncompressed_format = ip_id;

           default_methods =
           {
              let (ip_id:uncomp_length == 16);
           };

           format_nbo = ip_id_offset,
           {



Pelletier, et. al                                              [Page 63]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


              let (behavior == 0);
              let (ip_id_offset:uncomp_value ==
                      ip_id:uncomp_value - msn:uncomp_value);
              let (ip_id_offset:uncomp_length == 16);

              ip_id_offset ::= lsb (k, p);
           };

           format_non_nbo = ip_id_offset,
           {
              let (behavior == 1);

              let (ip_id_nbo:uncomp_value ==
                   (ip_id:uncomp_value / 256) + (ip_id:uncomp_value &
                                                 255) * 256);
              let (ip_id_nbo:uncomp_length == 16);
              let (ip_id_offset:uncomp_value ==
                   ip_id_nbo_uncomp_value - msn:uncomp_value);
              let (ip_id_offset:uncomp_length == 16);

              ip_id_offset ::= lsb (k, p);
           };
   };

   dont_fragment(version) ===
   {
           uncompressed_format = df;

           compressed_format_v4 = df,
           {
              let (version == 4);
              df ::= irregular(1);
           };

           compressed_format_v6 = df,
           {
              let (version == 6);
              df ::= compressed_value(1,0);
           };
   };


6.7.7. Compressed Base Headers

   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   % Actual start of compressed packet formats
   % Important note: The base header is the compressed representation of
   % the innermost IP header AND the TCP header.
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





Pelletier, et. al                                              [Page 64]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   co_baseheader ===
   {
      uncompressed_format_v4 = version,
                         header_length,
                                tos_tc,
                          ip_ecn_flags,
                                length,
                                 ip_id,
                                    df,
                                    mf,
                                    rf,
                           frag_offset,
                              ttl_hopl,
                           next_header,
                              checksum,
                              src_addr,
                             dest_addr,
                              src_port,
                             dest_port,
                            seq_number,
                            ack_number,
                           data_offset,
                         tcp_ecn_flags,
                         tcp_res_flags,
                              urg_flag,
                              ack_flag,
                              psh_flag,
                             rsf_flags,
                          tcp_checksum,
                               urg_ptr,
                                window,
                           tcp_options,
      {
         let (version:uncomp_value == 4);
      };

      uncompressed_format_v6 = version,
                                tos_tc,
                          ip_ecn_flags,
                            flow_label,
                        payload_length,
                           next_header,
                              ttl_hopl,
                              src_addr,
                             dest_addr,
                              src_port,
                             dest_port,
                            seq_number,
                            ack_number,
                           data_offset,
                         tcp_ecn_flags,



Pelletier, et. al                                              [Page 65]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


                         tcp_res_flags,
                              urg_flag,
                              ack_flag,
                              psh_flag,
                             rsf_flags,
                          tcp_checksum,
                               urg_ptr,
                                window,
      {
         let (version:uncomp_value == 6);
      };

      control_fields  = msn,              % 16 bits
                        ecn_used,         % 1 bit
                        ip_id_behavior;   % 2 bits

      default_methods =
      {

         version                      ::= static;
         tos_tc                       ::= static;
         ip_ecn_flags                 ::= static;
         ttl_hopl                     ::= static;
         next_header                  ::= static;
         src_addr                     ::= static;
         dest_addr                    ::= static;

         flow_label                   ::= static;

         header_length                ::= uncompressed_value (4,5);
         length                       ::= inferred_ip_v4_length;
         ip_id                        ::= irregular(16);
         rf                           ::= static;
         df                           ::= static;
         mf                           ::= static;
         frag_offset                  ::= static;
         checksum                     ::= inferred_ip_checksum;

         src_port                     ::= static;
         dest_port                    ::= static;
         seq_number                   ::= static;
         ack_number                   ::= static;
         data_offset                  ::= inferred_offset;
         tcp_ecn                      ::= static;
         psh_flag                     ::= irregular (1);
         urg_flag                     ::= uncompressed_value (1, 0);
         ack_flag                     ::= uncompressed_value (1, 1);
         window                       ::= static;
         tcp_checksum                 ::= irregular(16);
         urg_ptr                      ::= static;
         seq_number_scaled            ::= static;



Pelletier, et. al                                              [Page 66]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


         payload_size                 ::= static;
         rsf_flags                    ::= uncompressed_value (3, 0);

         let (version:uncomp_length == 4);

         let (seq_number_scaled:uncomp_length == 32);
         let (seq_number_scaled:uncomp_value ==
                    seq_number:uncomp_value /
                    payload_size:uncomp_value);
         let (seq_number_residue:uncomp_length == 32);
         let (seq_number_residue:uncomp_value ==
                  mod(seq_number:uncomp_value,
                  payload_size:uncomp_value));
      };

   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   % Common compressed packet format
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      format_co_common             =   discriminator,       %[ 4 ]
                                       msn,                 %[ 4 ]
                                       padding1,            %[ 1 ]
                                       header_crc,          %[ 7 ]
                                       urg_flag,            %[ 1 ]
                                       ack_flag,            %[ 1 ]
                                       psh_flag,            %[ 1 ]
                                       df,                  %[ 1 ]
                                       ecn_used,            %[ 1 ]
                                       ip_id_present,       %[ 1 ]
                                       ip_id_behavior,      %[ 2 ]
                                       seq_present,         %[ 1 ]
                                       ack_present,         %[ 1 ]
                                       window_present,      %[ 1 ]
                                       urg_ptr_present,     %[ 1 ]
                                       tos_tc_present,      %[ 1 ]
                                       ttl_hopl_present,    %[ 1 ]
                                       rsf_flags_present,   %[ 1 ]
                                       ecn_flags_present,   %[ 1 ]
                                       seq_number,        % 0 or 32 bits
                                       ack_number,        % 0 or 32 bits
                                       ip_id,             % 0 or 16 bits
                                       window,            % 0 or 16 bits
                                       urg_ptr,           % 0 or 16 bits
                                       ip_ecn_flags,      % 0 or 2 bits
                                       tcp_ecn_flags,     % 0 or 2 bits
                                       tcp_res_flags,     % 0 or 4 bits
                                       ttl_hopl,          % 0 or 8 bits
                                       tos_tc,            % 0 or 8 bits
                                       rsf_flags,         % 0 or 8 bits
                                       ecn_flags,         % 0 or 8 bits
      {



Pelletier, et. al                                              [Page 67]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


                discriminator      ::= '1110';
                padding1           ::= compressed_value (1, 0);

                msn                ::= lsb (3, -1);
                psh_flag           ::= irregular(1);
                header_crc         ::= crc7(this:uncomp_value,
                                            this:uncomp_length);
                ack_flag           ::= irregular(1);
                ip_id_behavior     ::= ip_id_behavior_enc;

                df              ::= dont_fragment(version:uncomp_value);
                ecn_used           ::= irregular(1);
                urg_flag           ::= irregular(1);
                ip_id_present      ::= irregular(1);
                seq_present        ::= irregular(1);
                window_present     ::= irregular(1);
                ack_present        ::= irregular(1);
                urg_ptr_present    ::= irregular(1);
                tos_tc_present     ::= irregular(1);
                ttl_hopl_present   ::= irregular(1);
                rsf_flags_present  ::= irregular(1);
                ecn_flags_present  ::= irregular(1);

                seq_number         ::= static_or_irreg32(seq_present);
                window            ::= static_or_irreg16(window_present);
                ack_number         ::= static_or_irreg32(ack_present);
                ip_id              ::= static_or_irreg16(ip_id_present);
                urg_ptr            ::= static_or_irreg16(urg_present);
                ttl_hops         ::= static_or_irreg8(ttl_hopl_present);
                ip_ecn_flags       ::= ip_irreg_ecn(ecn_used_flag);
                tcp_ecn_flags      ::= tcp_ecn_flags_enc(ecn_used_flag);
                tcp_res_flags      ::= tcp_res_flags_enc(ecn_used_flag);
                tos_tc             ::= tos_tc_enc(tos_tc_present);
                rsf_flags       ::= rsf_static_or_byte_enc(rsf_present);
      };

   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   % IP-ID Sequential Packet CO packet format base headers
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

   % XXX: Note that the following discriminators are now free for use
   % dumpeding sequential packet formats:
   % 11000101, 11000100, 110001101, 11000110000, 1100011001, 11000110001

      format_seq_0           =  discriminator,               %[ 1 ]
                                header_crc,                  %[ 3 ]
                                psh_flag,                    %[ 1 ]
                                msn,                         %[ 3 ]
                                ip_id,                       %[ 4 ]
                                seq_number,                  %[ 12 ]
      {



Pelletier, et. al                                              [Page 68]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


         let ((ip_id_behavior:uncomp_value == 0) ||
              (ip_id_behavior:uncomp_value == 1));
         discriminator       ::= '0';
         msn                 ::= lsb (3, -1);
         header_crc          ::= crc3 (this:uncomp_value,
                                       this:uncomp_length);
         ip_id               ::= ip_id_lsb (ip_id_behavior, msn, 4, -1);
         seq_number          ::= lsb (12, 1023);
         psh_flag            ::= irregular (1);
      };

      format_seq_1           =  discriminator,               %[ 3 ]
                                header_crc,                  %[ 3 ]
                                rsf_flags,                   %[ 2 ]
                                ip_id,                       %[ 8 ]
                                psh_flag,                    %[ 1 ]
                                msn,                         %[ 3 ]
                                seq_number,                  %[ 12 ]
      {
         let ((ip_id_behavior:uncomp_value == 0) ||
              (ip_id_behavior:uncomp_value == 1));
         discriminator       ::= '100';
         msn                 ::= lsb (3, -1);
         header_crc          ::= crc3 (this:uncomp_value,
                                       this:uncomp_length);
         ip_id               ::= ip_id_lsb (ip_id_behavior, msn, 8, -1);
         seq_number          ::= lsb (12, 1023);
         psh_flag            ::= irregular (1);
         rsf_flags           ::= rsf_index_enc;
      };

      format_seq_2           =  discriminator,               %[ 3 ]
                                ip_id,                       %[ 4 ]
                                psh_flag,                    %[ 1 ]
                                ack_number,                  %[ 16 ]
                                msn,                         %[ 3 ]
                                header_crc,                  %[ 3 ]
                                seq_number_scaled,           %[ 10 ]
      {
         let ((ip_id_behavior:uncomp_value == 0) ||
              (ip_id_behavior:uncomp_value == 1));
         discriminator       ::= '101';
         msn                 ::= lsb (3, -1);
         header_crc          ::= crc3 (this:uncomp_value,
                                       this:uncomp_length);
         ip_id               ::= ip_id_lsb (ip_id_behavior, msn, 4, -1);
         ack_number          ::= lsb (16, 0);
         psh_flag            ::= irregular (1);
         seq_number_scaled   ::= lsb (10, 511);
      };




Pelletier, et. al                                              [Page 69]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


      format_seq_3           =  discriminator,               %[ 6 ]
                                seq_number_scaled,           %[ 10 ]
                                psh_flag,                    %[ 1 ]
                                header_crc,                  %[ 7 ]
                                msn,                         %[ 3 ]
                                ip_id,                       %[ 5 ]
                                ecn_used,                    %[ 1 ]
                                list_present,                %[ 1 ]
                                ack_number,                  %[ 14 ]
                                options_list,                % n bits
      {
         let ((ip_id_behavior:uncomp_value == 0) ||
              (ip_id_behavior:uncomp_value == 1));
         discriminator       ::= '110101';
         msn                 ::= lsb (3, -1);
         header_crc          ::= crc7 (this:uncomp_value,
                                       this:uncomp_length);
         ip_id               ::= ip_id_lsb (ip_id_behavior, msn, 5, -1);
         ack_number          ::= lsb (14, 0);
         psh_flag            ::= irregular (1);
         seq_number_scaled   ::= lsb (10, 511);
         ecn_used            ::= irregular(1);
         list_present        ::= irregular(1);
         options_list        ::= tcp_list_presence_enc(list_length,
                                                       list_present);
      };

      format_seq_4           =  discriminator,               %[ 5 ]
                                msn,                         %[ 3 ]
                                psh_flag,                    %[ 1 ]
                                header_crc,                  %[ 7 ]
                                ttl_hopl,                    %[ 8 ]
                                ip_id,                       %[ 6 ]
                                tos_tc,                      %[ 6 ]
                                seq_number,                  %[ 12 ]
      {
         let ((ip_id_behavior:uncomp_value == 0) ||
              (ip_id_behavior:uncomp_value == 1));
         discriminator       ::= '11001';
         msn                 ::= lsb (3, -1);
         psh_flag            ::= irregular (1);
         header_crc          ::= crc7 (this:uncomp_value,
                                       this:uncomp_length);
         ttl_hopl            ::= irregular (8);
         ip_id               ::= ip_id_lsb (ip_id_behavior, msn, 6, -1);
         tos_tc              ::= irregular (6);
         seq_number          ::= lsb (12, 1023);
      };

      format_seq_5           =  discriminator,               %[ 7 ]
                                psh_flag,                    %[ 1 ]



Pelletier, et. al                                              [Page 70]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


                                msn,                         %[ 3 ]
                                ip_id,                       %[ 13 ]
                                ack_flag,                    %[ 1 ]
                                header_crc,                  %[ 3 ]
                                seq_number,                  %[ 12 ]
      {
         let ((ip_id_behavior:uncomp_value == 0) ||
              (ip_id_behavior:uncomp_value == 1));
         discriminator       ::= '1100000';
         msn                 ::= lsb (3, -1);
         header_crc          ::= crc3 (this:uncomp_value,
                                       this:uncomp_length);
         ip_id               ::= ip_id_lsb (ip_id_behavior, msn, 6, -1);
         seq_number          ::= lsb (12, 1023);
         psh_flag            ::= irregular (1);
         ack_flag            ::= irregular (1);
      };

      format_seq_6           =  discriminator,               %[ 6 ]
                                list_present,                %[ 1 ]
                                psh_flag,                    %[ 1 ]
                                ack_flag,                    %[ 1 ]
                                header_crc,                  %[ 7 ]
                                ecn_used,                    %[ 1 ]
                                msn,                         %[ 4 ]
                                seq_number,                  %[ 11 ]
                                ip_id,                       %[ 8 ]
                                ttl_hopl,                    %[ 8 ]
                                options_list,                % n bits
      {
         let ((ip_id_behavior:uncomp_value == 0) ||
              (ip_id_behavior:uncomp_value == 1));
         discriminator       ::= '110111';
         msn                 ::= lsb (4, -1);
         header_crc          ::= crc7 (this:uncomp_value,
                                       this:uncomp_length);
         ack_flag            ::= irregular(1);
         ip_id               ::= ip_id_lsb (ip_id_behavior, msn, 8, -1);
         ttl_hopl            ::= irregular (8);
         seq_number          ::= lsb (11, 511);
         psh_flag            ::= irregular (1);
         ecn_used            ::= irregular (1);
         list_present        ::= irregular(1);
         options_list        ::= tcp_list_presence_enc(list_length,
                                                       list_present);
      };

      format_seq_7           =  discriminator,               %[ 8 ]
                                psh_flag,                    %[ 1 ]
                                msn,                         %[ 4 ]
                                header_crc,                  %[ 3 ]



Pelletier, et. al                                              [Page 71]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


                                seq_number,                  %[ 16 ]
                                ip_id,                       %[ 16 ]
      {
         let ((ip_id_behavior:uncomp_value == 0) ||
              (ip_id_behavior:uncomp_value == 1));
         discriminator       ::= '11000111';
         msn                 ::= lsb (4, -1);
         header_crc          ::= crc3 (this:uncomp_value,
                                       this:uncomp_length);
         ip_id               ::= irregular (16);
         seq_number          ::= lsb (16, 32767);
         psh_flag            ::= irregular (1);
      };

      format_seq_8           =  discriminator,               %[ 7 ]
                                msn,                         %[ 3 ]
                                ip_id,                       %[ 6 ]
                                psh_flag,                    %[ 1 ]
                                header_crc,                  %[ 3 ]
                                seq_number_scaled,           %[ 12 ]
                                ack_number,                  %[ 16 ]
                                window,                      %[ 16 ]
       {
         let ((ip_id_behavior:uncomp_value == 0) ||
              (ip_id_behavior:uncomp_value == 1));
         discriminator       ::= '1100001';
         msn                 ::= lsb (3, -1);
         header_crc          ::= crc3 (this:uncomp_value,
                                       this:uncomp_length);
         ip_id               ::= ip_id_lsb (ip_id_behavior, msn, 6, -1);
         seq_number_scaled   ::= lsb (12, 1023);
         psh_flag            ::= irregular (1);
         ack_number          ::= lsb (16, 0);
         window              ::= irregular (16);
      };

      format_seq_9           =  discriminator,               %[ 6 ]
                                seq_number_scaled,           %[ 10 ]
                                window,                      %[ 16 ]
                                psh_flag,                    %[ 1 ]
                                msn,                         %[ 3 ]
                                header_crc,                  %[ 3 ]
                                ip_id,                       %[ 5 ]
                                tos_tc,                      %[ 6 ]
                                ack_number,                  %[ 14 ]
       {
         let ((ip_id_behavior:uncomp_value == 0) ||
              (ip_id_behavior:uncomp_value == 1));
         discriminator       ::= '110100';
         msn                 ::= lsb (3, -1);
         header_crc          ::= crc3 (this:uncomp_value,



Pelletier, et. al                                              [Page 72]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


                                       this:uncomp_length);
         tos_tc              ::= irregular (6);
         ip_id               ::= ip_id_lsb (ip_id_behavior, msn, 5, -1);
         ack_number          ::= lsb (14, 0);
         psh_flag            ::= irregular (1);
         window              ::= irregular (16);
         seq_number_scaled   ::= lsb (10, 511);
      };

      format_seq_10          =  discriminator,               %[ 6 ]
                                list_present,                %[ 1 ]
                                ip_id,                       %[ 5 ]
                                msn,                         %[ 4 ]
                                seq_number_scaled,           %[ 32 ]
                                payload_size,                %[ 16 ]
                                psh_flag,                    %[ 1 ]
                                ack_number,                  %[ 15 ]
                                header_crc,                  %[ 7 ]
                                window,                      %[ 13 ]
                                seq_number,                  %[ 12 ]
       {
         let ((ip_id_behavior:uncomp_value == 0) ||
              (ip_id_behavior:uncomp_value == 1));
         discriminator       ::= '110110';
         msn                 ::= lsb (4, -1);
         header_crc          ::= crc7 (this:uncomp_value,
                                       this:uncomp_length);
         ip_id               ::= ip_id_lsb (ip_id_behavior, msn, 5, -1);
         seq_number          ::= lsb (12, 1023);
         ack_number          ::= lsb (15, 0);
         psh_flag            ::= irregular (1);
         window              ::= lsb (13, 4095);
         seq_number_scaled   ::= irregular (32);
         payload_size        ::= irregular (16);
         list_present        ::= irregular(1);
         options_list        ::= tcp_list_presence_enc(list_length,
                                                       list_present);
      };

   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   % IP-ID Random/Zero Packet CO packet format base headers
   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
   % XXX: Note: The discriminator '00000' was freed up by
   % reducing the number of packet formats

      format_rnd_0    =   discriminator,                 %[ 2 ]
                          seq_number,                    %[ 14 ]
                          psh_flag,                      %[ 1 ]
                          header_crc,                    %[ 3 ]
                          msn,                           %[ 4 ]
      {



Pelletier, et. al                                              [Page 73]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


         let ((ip_id_behavior:uncomp_value == 2) ||
              (ip_id_behavior:uncomp_value == 3));
         discriminator       ::= '01';
         msn                 ::= lsb(4, -1);
         header_crc          ::= crc3 (this:uncomp_value,
                                       this:uncomp_length);
         seq_number          ::= lsb (13, 4095);
         psh_flag            ::= irregular (1);
         ecn_used            ::= irregular (1);
      };

      format_rnd_1    =   discriminator,                   %[ 3 ]
                          psh_flag,                        %[ 1 ]
                          ack_number,                      %[ 2 ]
                          rsf_flags,                       %[ 2 ]
                          msn,                             %[ 3 ]
                          header_crc,                      %[ 3 ]
                          seq_number_scaled,               %[ 10 ]
      {
         let ((ip_id_behavior:uncomp_value == 2) ||
              (ip_id_behavior:uncomp_value == 3));
         discriminator       ::= '101';
         msn                 ::= lsb(3,-1);
         header_crc          ::= crc3 (this:uncomp_value,
                                       this:uncomp_length);
         ack_number          ::= lsb (2, 1);
         psh_flag            ::= irregular (1);
         rsf_flags           ::= rsf_index_enc;
         seq_number_scaled   ::= lsb (10, 511);
      };

      format_rnd_2    =   discriminator,                   %[ 3 ]
                          list_present,                    %[ 1 ]
                          ecn_used,                        %[ 1 ]
                          msn,                             %[ 3 ]
                          ttl_hopl,                        %[ 8 ]
                          psh_flag,                        %[ 1 ]
                          header_crc,                      %[ 7 ]
                          seq_number,                      %[ 16 ]
      {
         let ((ip_id_behavior:uncomp_value == 2) ||
              (ip_id_behavior:uncomp_value == 3));
         discriminator       ::= '110';
         msn                 ::= lsb(3,-11);
         header_crc          ::= crc7 (this:uncomp_value,
                                       this:uncomp_length);
         ttl_hopl            ::= irregular (8);
         seq_number          ::= lsb (16, 16383);
         psh_flag            ::= irregular (1);
         ecn_used            ::= irregular (1);
         list_present        ::= irregular(1);



Pelletier, et. al                                              [Page 74]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


         options_list        ::= tcp_list_presence_enc(list_length,
                                                       list_present);
      };

      format_rnd_3    =   discriminator,                   %[ 4 ]
                          psh_flag,                        %[ 1 ]
                          header_crc,                      %[ 3 ]
                          ack_number,                      %[ 16 ]
                          msn,                             %[ 4 ]
                          seq_number_scaled,               %[ 12 ]
      {
         let ((ip_id_behavior:uncomp_value == 2) ||
              (ip_id_behavior:uncomp_value == 3));
         discriminator                ::= '0011';
         msn                          ::= lsb(4, -1);
         header_crc                   ::= crc3 (this:uncomp_value,
                                                this:uncomp_length);
         ack_number                   ::= lsb (15, 0);
         psh_flag                     ::= irregular (1);
         seq_number_scaled            ::= lsb (12, 1023);
      };

      format_rnd_4   =    discriminator,                   %[ 3 ]
                          seq_number,                      %[ 13 ]
                          psh_flag,                        %[ 1 ]
                          msn,                             %[ 4 ]
                          header_crc,                      %[ 3 ]
      {
         let ((ip_id_behavior:uncomp_value == 2) ||
              (ip_id_behavior:uncomp_value == 3));
         discriminator       ::= '100';
         msn                 ::= lsb(4,-1);
         header_crc          ::= crc3 (this:uncomp_value,
                                       this:uncomp_length);
         seq_number          ::= lsb (13, 2047);
         psh_flag            ::= irregular (1);
         urg_ptr             ::= irregular (16);
         urg_flag            ::= irregular(1);
      };

      format_rnd_5    =   discriminator,                   %[ 5 ]
                          header_crc,                      %[ 3 ]
                          psh_flag,                        %[ 1 ]
                          ack_number,                      %[ 15 ]
                          msn,                             %[ 4 ]
                          seq_number_scaled,               %[ 12 ]
      {
         let ((ip_id_behavior:uncomp_value == 2) ||
              (ip_id_behavior:uncomp_value == 3));
         discriminator                ::= '00011';
         msn                          ::= lsb(4, -1);



Pelletier, et. al                                              [Page 75]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


         header_crc                   ::= crc3 (this:uncomp_value,
                                                this:uncomp_length);
         ack_number                   ::= lsb (15, 0);
         psh_flag                     ::= irregular (1);
         seq_number_scaled            ::= lsb (12, 1023);
      };

      format_rnd_6   =   discriminator,                   %[ 5 ]
                         msn,                             %[ 3 ]
                         header_crc,                      %[ 7 ]
                         psh_flag,                        %[ 1 ]
                         ack_number,                      %[ 16 ]
                         list_present,                    %[ 1 ]
                         ecn_used,                        %[ 1 ]
                         seq_number_scaled,               %[ 14 ]
      {
         let ((ip_id_behavior:uncomp_value == 2) ||
              (ip_id_behavior:uncomp_value == 3));
         discriminator       ::= '00101';
         msn                 ::= lsb(3, -1);
         header_crc          ::= crc7 (this:uncomp_value,
                                       this:uncomp_length);
         ttl_hopl            ::= irregular (8);
         ack_number          ::= lsb (16, 0);
         psh_flag            ::= irregular (1);
         seq_number_scaled   ::= lsb (14, 4095);
         ecn_used            ::= irregular (1);
         list_present        ::= irregular(1);
         options_list        ::= tcp_list_presence_enc(list_length,
                                                       list_present);
      };

      format_rnd_7    =   discriminator,                   %[ 5 ]
                          header_crc,                      %[ 3 ]
                          window,                          %[ 16 ]
                          psh_flag,                        %[ 1 ]
                          ack_number,                      %[ 15 ]
                          msn,                             %[ 4 ]
                          seq_number_scaled,               %[ 12 ]
      {
         let ((ip_id_behavior:uncomp_value == 2) ||
              (ip_id_behavior:uncomp_value == 3));
         discriminator        ::= '00001';
         msn                  ::= lsb(4, -1);
         header_crc           ::= crc3 (this:uncomp_value,
                                        this:uncomp_length);
         ack_number           ::= lsb (15, 0);
         psh_flag             ::= irregular (1);
         window               ::= irregular (16);
         seq_number_scaled    ::= lsb (12, 1023);
      };



Pelletier, et. al                                              [Page 76]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004



      format_rnd_8   =   discriminator,                   %[ 5 ]
                         msn,                             %[ 3 ]
                         ack_number,                      %[ 32 ]
                         psh_flag,                        %[ 1 ]
                         header_crc,                      %[ 3 ]
                         seq_number,                      %[ 12 ]
      {
         let ((ip_id_behavior:uncomp_value == 2) ||
              (ip_id_behavior:uncomp_value == 3));
         discriminator        ::= '00100';
         msn                  ::= lsb(3, -1);
         header_crc           ::= crc3 (this:uncomp_value,
                                        this:uncomp_length);
         seq_number           ::= lsb (12, 1023);
         ack_number           ::= irregular (32);
         psh_flag             ::= irregular (1);
      };

      format_rnd_9     =   discriminator,                  %[ 5 ]
                           header_crc,                     %[ 3 ]
                           window,                         %[ 16 ]
                           psh_flag,                       %[ 1 ]
                           ack_number,                     %[ 15 ]
                           msn,                            %[ 4 ]
                           seq_number_scaled,              %[ 12 ]
      {
         let ((ip_id_behavior:uncomp_value == 2) ||
              (ip_id_behavior:uncomp_value == 3));
         discriminator        ::= '00010';
         msn                  ::= lsb(4, -1);
         header_crc           ::= crc3 (this:uncomp_value,
                                        this:uncomp_length);
         ack_number           ::= lsb (15, 0);
         psh_flag             ::= irregular (1);
         window               ::= irregular (16);
         seq_number_scaled    ::= lsb (12, 1023);
      };

   };


6.8. Feedback Formats and Options


6.8.1. Feedback Formats

   This section describes the feedback format for ROHC-TCP. ROHC-TCP
   uses the ROHC feedback format described in section 5.2.2 of [2].





Pelletier, et. al                                              [Page 77]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   All feedback formats carry a field labeled SN. The SN field contains
   LSBs of the Master Sequence Number (MSN) described in section 6.3.
   The sequence number to use is the MSN corresponding to the header
   that caused the feedback information to be sent. If that MSN cannot
   be determined, for example when decompression fails, the MSN to use
   is that corresponding to the latest successfully decompressed header.

   FEEDBACK-1

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |              MSN              |
   +---+---+---+---+---+---+---+---+

      MSN: The lsb-encoded master sequence number.

   A FEEDBACK-1 is an ACK.  In order to send a NACK or a STATIC-NACK,
   FEEDBACK-2 must be used.

   FEEDBACK-2

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |Acktype|         MSN           |
   +---+---+---+---+---+---+---+---+
   |              MSN              |
   +---+---+---+---+---+---+---+---+
   /       Feedback options        /
   +---+---+---+---+---+---+---+---+

      Acktype:  0 = ACK
                1 = NACK
                2 = STATIC-NACK
                3 is reserved (MUST NOT be used for parseability)

      MSN: The lsb-encoded master sequence number.


      Feedback options: A variable number of feedback options, see
                       section 6.8.2. Options may appear in any order.


6.8.2. Feedback Options

   ROHC-TCP uses the same feedback options as the options defined in
   section 5.7.6 of [2], with the following exceptions:

   1) The MSN replaces RTP SN in the feedback information.
   2) The CLOCK option ([2], section 5.7.6.6) is not used.
   3) The JITTER option ([2], section 5.7.6.7) is not used.




Pelletier, et. al                                              [Page 78]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004



6.8.3. The CONTEXT_MEMORY Feedback Option

   The CONTEXT_MEMORY option informs the compressor that the
   decompressor does not have sufficient memory resources to handle the
   context of the packet stream, as the stream is currently compressed.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   |  Opt Type = 9 |  Opt Len = 0  |
   +---+---+---+---+---+---+---+---+

   When receiving a CONTEXT_MEMORY option, the compressor SHOULD take
   actions to compress the packet stream in a way that requires less
   decompressor memory resources, or stop compressing the packet stream.

7. Security Consideration

   Because encryption eliminates the redundancy that header compression
   schemes try to exploit, there is some inducement to forego encryption
   of headers in order to enable operation over low-bandwidth links.
   However, for those cases where encryption of data (and not headers)
   is sufficient, TCP does specify an alternative encryption method in
   which only the TCP payload is encrypted and the headers are left in
   the clear.  That would still allow header compression to be applied.

   A malfunctioning or malicious header compressor could cause the
   header decompressor to reconstitute packets that do not match the
   original packets but still have valid IP, and TCP headers and
   possibly also valid TCP checksums.  Such corruption may be detected
   with end-to-end authentication and integrity mechanisms that will not
   be affected by the compression.  Moreover, this header compression
   scheme uses an internal checksum for verification of reconstructed
   headers.  This reduces the probability of producing decompressed
   headers not matching the original ones without this being noticed.

   Denial-of-service attacks are possible if an intruder can introduce
   (for example) bogus IR, CO or FEEDBACK packets onto the link and
   thereby cause compression efficiency to be reduced.  However, an
   intruder having the ability to inject arbitrary packets at the link
   layer in this manner raises additional security issues that dwarf
   those related to the use of header compression.


8. IANA Considerations

   The ROHC profile identifier 0x00XX <# Editor's Note: To be replaced
   before publication #> has been reserved by the IANA for the profile
   defined in this document.

   <# Editor's Note: To be removed before publication #>



Pelletier, et. al                                              [Page 79]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004



   A ROHC profile identifier must be reserved by the IANA for the
   profile defined in this document.  Profiles 0x0000-0x0005 have
   previously been reserved, which means this profile could be 0x0006.
   As for previous ROHC profiles, profile numbers 0xnnXX must also be
   reserved for future updates of this profile.  A suggested
   registration in the "RObust Header Compression (ROHC) Profile
   Identifiers" name space would then be:

     Profile             Usage            Document
     identifier

     0x0006              ROHC TCP         [RFCXXXX (this)]
     0xnn06              Reserved


9. Acknowledgments

   The authors would like to thank Qian Zhang and Hong Bin Liao for
   their work with early versions of this specification. Thanks also to
   Fredrik Lindstroem for reviewing the packet formats, as well as to
   Carsten Bormann and Robert Finking for valuable input.


10. Authors' Addresses

      Ghyslain Pelletier
      Ericsson AB
      Box 920
      SE-971 28 Lulea, Sweden

      Phone: +46 8 404 29 43
      Fax:   +46 920 996 21
      EMail: ghyslain.pelletier@ericsson.com


      Lars-Erik Jonsson
      Ericsson AB
      Box 920
      SE-971 28 Lulea, Sweden

      Phone: +46 8 404 29 61
      Fax:   +46 920 996 21
      EMail: lars-erik.jonsson@ericsson.com


      Mark A West
      Roke Manor Research Ltd
      Romsey, Hants, SO51 0ZN
      United Kingdom




Pelletier, et. al                                              [Page 80]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


      Phone: +44 1794 833311
      Email: mark.a.west@roke.co.uk


      Richard Price
      Roke Manor Research Ltd
      Romsey, Hants, SO51 0ZN
      United Kingdom

      Phone: +44 1794 833681
      Email: richard.price@roke.co.uk


      Kristofer Sandlund
      Effnet AB
      Stationsgatan 69
      S-972 34 Lulea
      Sweden

      Phone:  +46 920 609 17
      Fax:    +46 920 609 27
      EMail:  kristofer.sandlund@effnet.com


11. References

11.1. Normative references

   [1]  S. Bradner, "Key words for use in RFCs to Indicate Requirement
        Levels", RFC 2119, March 1997.

   [2]  Bormann, C., Burmeister, C., Degermark, M., Fukushima, H.,
        Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu,
        Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T.,
        Yoshimura, T. and H. Zheng, "RObust Header Compression (ROHC):
        Framework and four profiles: RTP, UDP, ESP, and uncompressed",
        RFC 3095, July 2001.

   [3]  Pelletier, G., "Robust Header Compression (ROHC): Context
        Replication for ROHC profiles", Internet Draft (work in
        progress), <draft-ietf-rohc-context-replication-03.txt>, July
        2004.

   [4]  R. Price, R. Finking and G. Pelletier, "Formal Notation for
        Robust Header Compression (ROHC-FN)", Internet Draft (work in
        progress), <draft-ietf-rohc-formal-notation-03.txt>, July 2004.

   [5]  Postel, J., "Internet Protocol", STD 5, RFC 791, September 1981.

   [6]  Postel, J., "Transmission Control Protocol", STD 7, RFC 793,
        September 1981.



Pelletier, et. al                                              [Page 81]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004



   [7]  S. Bradner, "The Internet Standards Process - Revision 3", RFC
        2026, October 1996.

   [8]  S. Bradner, "Key words for use in RFCs to Indicate Requirement
        Levels", RFC 2119, March 1997.

   [9]  Deering, S. and R. Hinden, "Internet Protocol, Version 6 (IPv6)
        Specification", RFC 2460, December 1998.



11.2. Informative References

   [10] Jonsson, L-E., "Requirements on ROHC IP/TCP header compression",
        Internet Draft (work in progress), <draft-ietf-rohc-tcp-
        requirements-07.txt>, June 2004.

   [11] West, M. and S. McCann, "TCP/IP Field Behavior", Internet Draft
        (work in progress), <draft-ietf-rohc-tcp-field-behavior-03.txt>,
        July 2004.

   [12] Jonsson, L-E. and G. Pelletier, "RObust Header Compression
        (ROHC): A compression profile for IP", RFC 3843, June 2003.

   [13] Jacobson, V., and R. Braden, "TCP Extensions for Long-Delay
        Paths", LBL, ISI, October 1988.

   [14] Jacobson, V.,"Compressing TCP/IP Headers for Low-Speed Serial
        Links", RFC 1144, February 1990.

   [15] Jacobson, V., Braden, R. and D. Borman, "TCP Extensions for High
        Performance", RFC 1323, May 1992.

   [16] Braden, R. "T/TCP -- TCP Extensions for Transactions Functional
        Specification", ISI, July 1994.

   [17] Connolly, T., et al, "An Extension to TCP: Partial Order
        Service", University of Delaware, November 1994.

   [18] Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobson,
        "RTP: A Transport Protocol for Real-Time Applications", RFC
        1889, January 1996.

   [19] Stevens, W., "TCP Slow Start, Congestion Avoidance, Fast
        Retransmit, and Fast Recovery Algorithms", NOAO, January 1997.

   [20] Mathis, M., Mahdavi, J., Floyd, S. and A. Romanow, "TCP
        Selective Acknowledgment Options", RFC 2018, October 1996.





Pelletier, et. al                                              [Page 82]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


   [21] Degermark, M., Nordgren, B. and S. Pink, "IP Header
        Compression", RFC 2507, February 1999.

   [22] Floyd, S., Mahdavi, J., Mathis, M. and M. Podolsky, "An
        Extension to the Selective Acknowledgement (SACK) Option for
        TCP", RFC 2883, July 2000.

   [23] Ramakrishnan, K., Floyd and D. Black, "The Addition of Explicit
        Congestion Notification (ECN) to IP", RFC 3168, September 2001.

   [24] Jacobson, V., "Fast Retransmit", Message to the end2end-interest
        mailing list, April 1990.

   [25] Perkins, C., ôMinimal Encapsulation within IPö, RFC 2004,
        October 1996.







































Pelletier, et. al                                              [Page 83]

INTERNET-DRAFT           ROHC Profile for TCP/IP        October 25, 2004


Copyright Statement

   Copyright (C) The Internet Society (2004). This document is subject
   to the rights, licenses and restrictions contained in BCP 78, and
   except as set forth therein, the authors retain all their rights.


Disclaimer of Validity

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


































This Internet-Draft expires April 25, 2005.



Pelletier, et. al                                              [Page 84]

