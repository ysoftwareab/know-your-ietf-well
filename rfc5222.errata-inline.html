<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="robots" content="index,follow" />

        <link rel="icon" href="./css/images/rfc.png" type="image/png" />
        <link rel="shortcut icon" href="./css/images/rfc.png" type="image/png" />
        <title>rfc5222</title>
    
        <link rel="stylesheet" type="text/css" href="./css/errata-base.css"/>
        <link rel="stylesheet" type="text/css" href="./css/errata-color.css" title="Default: Basic Colors"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-monochrome.css" title="Monochrome"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-printer.css" title="Printer"/>

        <script src="./css/errata.js"></script>
    </head>
    <body>
        <div class='Verified-headnote-styling'>
<span style="font-weight: bold;">This is a purely informative rendering of an RFC that includes verified errata.  This rendering may not be used as a reference.</span>
<br/>
<br/>
The following 'Verified' errata have been incorporated in this document:
 <a href='#eid4174'>EID 4174</a>,  <a href='#eid4176'>EID 4176</a>
</div>

        <pre>
Network Working Group                                          T. Hardie
Request for Comments: 5222                                Qualcomm, Inc.
Category: Standards Track                                      A. Newton
                                  American Registry for Internet Numbers
                                                          H. Schulzrinne
                                                     Columbia University
                                                           H. Tschofenig
                                                  Nokia Siemens Networks
                                                             August 2008


            LoST: A Location-to-Service Translation Protocol

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Abstract

   This document describes an XML-based protocol for mapping service
   identifiers and geodetic or civic location information to service
   contact URIs.  In particular, it can be used to determine the
   location-appropriate Public Safety Answering Point (PSAP) for
   emergency services.

Table of Contents

1.  Introduction .................................................. 3
2.  Terminology and Requirements Notation ......................... 4
3.  Overview of Protocol Usage .................................... 5
4.  LoST Servers and Their Resolution  ............................ 6
5.  The &lt;mapping&gt; Element  ........................................ 7
  5.1.  The Mapping Data Source: &#x27;source&#x27;, &#x27;sourceId&#x27;, and
        &#x27;lastUpdated&#x27; Attributes .................................. 7
  5.2.  Mapping Validity:  The &#x27;expires&#x27; Attribute ................ 8
  5.3.  Describing the Service with the &lt;displayName&gt; Element  .... 8
  5.4.  The Mapped Service: The &lt;service&gt; Element ................. 8
  5.5.  Defining the Service Region with the &lt;serviceBoundary&gt;
        Element  .................................................. 9
  5.6.  Service Boundaries by Reference: The
        &lt;serviceBoundaryReference&gt; Element ........................ 9
  5.7.  The Service Number: The &lt;serviceNumber&gt; Element  ......... 10
  5.8.  Service URLs: The &lt;uri&gt; Element  ......................... 10

6.  Path of a Request: The &lt;path&gt; Element  ....................... 10
7.  Identifying the Location Element Used for Mapping:
    &lt;locationUsed&gt; ............................................... 11
8.  Mapping a Location and Service to URLs: &lt;findService&gt;  ....... 11
  8.1.  Overview ................................................. 11
  8.2.  Examples ................................................. 11
    8.2.1.  Example Using Geodetic Coordinates ................... 11
    8.2.2.  Civic Address Mapping Example  ....................... 13
  8.3.  Components of the &lt;findService&gt; Request  ................. 15
    8.3.1.  The &lt;location&gt; Element ............................... 15
    8.3.2.  Identifying the Service:  The &lt;service&gt; Element  ..... 16
    8.3.3.  Recursion and Iteration  ............................. 16
    8.3.4.  Service Boundary ..................................... 16
    8.3.5.  Requesting Civic Location Validation ................. 16
  8.4.  Components of the Mapping Response
        &lt;findServiceResponse&gt;  ................................... 18
    8.4.1.  Overview ............................................. 18
    8.4.2.  Civic Address Validation: The &lt;locationValidation&gt;
            Element  ............................................. 19
9.  Retrieving the Service Boundary via &lt;getServiceBoundary&gt; ..... 19
10. List Services: &lt;listServices&gt;  ............................... 21
11. List Services By Location: &lt;listServicesByLocation&gt;  ......... 22
12. Location Profiles  ........................................... 24
  12.1. Location Profile Usage ................................... 25
  12.2. Two-Dimensional Geodetic Profile ......................... 30
  12.3. Basic Civic Profile  ..................................... 31
13. Errors, Warnings, and Redirects  ............................. 32
  13.1. Errors ................................................... 32
  13.2. Warnings ................................................. 34
  13.3. Redirects  ............................................... 36
14. LoST Transport: HTTP ......................................... 36
15. Relax NG Schema  ............................................. 37
16. Internationalization Considerations  ......................... 44
17. IANA Considerations  ......................................... 44
  17.1. U-NAPTR Registrations  ................................... 44
  17.2. Content-Type Registration for &#x27;application/lost+xml&#x27; ..... 44
  17.3. LoST Relax NG Schema Registration  ....................... 46
  17.4. LoST Namespace Registration  ............................. 46
  17.5. LoST Location Profile Registry ........................... 47
18. Security Considerations  ..................................... 47
19. Acknowledgments  ............................................. 48
20. References ................................................... 51
  20.1. Normative References ..................................... 51
  20.2. Informative References ................................... 52
Appendix A.  Non-Normative RELAX NG Schema in XML Syntax ......... 54
Appendix B.  Examples Online ..................................... 67

1.  Introduction

   Protocols such as Naming Authority Pointer (NAPTR) records and the
   Service Location Protocol (SLP) can be used to discover servers
   offering a particular service.  However, for an important class of
   services the appropriate specific service instance depends both on
   the identity of the service and the geographic location of the entity
   that needs to reach it.  Emergency telecommunications services are an
   important example; here, the service instance is a Public Safety
   Answering Point (PSAP) that has jurisdiction over the location of the
   user making the call.  The desired PSAP isn&#x27;t necessarily the one
   that is topologically or even line-of-sight closest to the caller;
   rather, it is the one that serves the caller&#x27;s location based on
   jurisdictional boundaries.

   This document describes a protocol for mapping a service identifier
   and location information compatible with the Presence Information
   Data Format Location Object (PIDF-LO) [6] to one or more service
   URIs.  Service identifiers take the form of the service URNs
   described in [9].  Location information here includes revised civic
   location information [10] and a subset of the PIDF-LO profile [13],
   which consequently includes the Geo-Shapes [12] defined for GML [11].
   Example service URI schemes include sip [14], xmpp [15], and tel
   [16].  While the initial focus is on providing mapping functions for
   emergency services, it is likely that the protocol is applicable to
   other service URNs.  For example, in the United States, the &quot;2-1-1&quot;
   and &quot;3-1-1&quot; service numbers follow a similar location-to-service
   behavior as emergency services.

   This document names this protocol &quot;LoST&quot;, for Location-to-Service
   Translation.  LoST satisfies the requirements [18] for mapping
   protocols.  LoST provides a number of operations, centered around
   mapping locations and service URNs to service URLs and associated
   information.  LoST mapping queries can contain either civic or
   geodetic location information.  For civic addresses, LoST can
   indicate which parts of the civic address are known to be valid or
   invalid, thus providing address validation, as described in Section
   3.5 of [18].  LoST indicates errors in the location data to
   facilitate debugging and proper user feedback, but also provides
   best-effort answers.

   LoST queries can be resolved recursively or iteratively.  To minimize
   round trips and to provide robustness against network failures, LoST
   supports caching of individual mappings and indicates the region for
   which the same answer would be returned (&quot;service region&quot;).

   As defined in this document, LoST messages are carried in HTTP and
   HTTPS protocol exchanges, facilitating use of TLS for protecting the
   integrity and confidentiality of requests and responses.

   This document focuses on the description of the protocol between the
   mapping client and the mapping server.  Other functions, such as
   discovery of mapping servers, data replication and the overall
   mapping server architecture are described in a separate document
   [19].

   The query message carries location information and a service
   identifier encoded as a Uniform Resource Name (URN) (see [9]) from
   the LoST client to the LoST server.  The LoST server uses its
   database to map the input values to one or more Uniform Resource
   Identifiers (URIs) and returns those URIs along with optional
   information, such as hints about the service boundary, in a response
   message to the LoST client.  If the server cannot resolve the query
   itself, it may in turn query another server or return the address of
   another LoST server, identified by a LoST server name.  In addition
   to the mapping function described in Section 8, the protocol also
   allows to retrieve the service boundary (see Section 9) and to list
   the services available for a particular location (see Section 11) or
   supported by a particular server (see Section 10).

2.  Terminology and Requirements Notation

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [1].

   This document uses the following terms:

   Mapping:
      Mapping is a process that takes a location and a service
      identifier as inputs and returns one or more URIs.  Those URIs can
      point either to a host providing that service or to a host that in
      turn routes the request to the final destination.  This definition
      is a generalization of the term &quot;mapping&quot; as used in [18], because
      LoST can be used for non-emergency services.

   LoST client:
      A host acts as a LoST client if it sends LoST query messages and
      receives LoST response messages.

   LoST server:
      A host acts as a LoST server if it receives LoST query messages
      and sends LoST response messages.  In recursive operation, the
      same entity may be both a client and a server.

   Authoritative LoST server:
      An authoritative server acts only as a server and successfully
      resolves the input location and service identifier to a URI or set
      of URIs.

   Service boundary:
      A service boundary circumscribes the region within which all
      locations map to the same service URI or set of URIs for a given
      service.  A service boundary may consist of several non-contiguous
      geometric shapes.

   Validation:
      The term &quot;validation&quot; describes the behavior defined as &quot;location
      validation&quot; in Section 3.5 of [18].

   Additional emergency service terminology can be found in [18].

3.  Overview of Protocol Usage

   The LoST protocol supports the following types of queries and
   responses:

   &lt;findService&gt; and &lt;findServiceResponse&gt;
      A LoST client retrieves contact URIs based on location information
      and a service identifier with this request and response.  The same
      query type may also ask for location validation and for service
      numbers, either combined with a mapping request or separately.
      The details can be found in Section 8.

   &lt;getServiceBoundary&gt; and &lt;getServiceBoundaryResponse&gt;
      A LoST client obtains a service boundary with this request and
      response, as described in Section 9.

   &lt;listServices&gt; and &lt;listServicesResponse&gt;
      With this request and response, a LoST client can find out which
      services a LoST server supports, as described in Section 10.

   &lt;listServicesByLocation&gt; and &lt;listServicesByLocationResponse&gt;
      A LoST client can determine with this request and response which
      services are available for a specific location region.  Section 11
      describes the details.

   LoST clients may initiate any of the above queries at any time.
   Among the common triggers are:

   1.  when the client initially starts up or attaches to a network;

   2.  when the client detects that its location has changed
       sufficiently that it is outside the bounds of the service region;

   3.  when a SIP message arrives at a SIP proxy performing location-
       based call routing;

   4.  when cached mapping information has expired; and

   5.  when invoking a particular service.  At that time, a client may
       omit requests for service boundaries or other auxiliary
       information.

   A service-specific Best Current Practice (BCP) document, such as
   [21], governs whether a client is expected to invoke the mapping
   service just before needing the service or whether to rely on cached
   answers.  Cache entries expire at their expiration time (see
   Section 5.2), or they become invalid if the caller&#x27;s device moves
   beyond the boundaries of the service region.  Service-specific Best
   Current Practice documents may also provide guidance on the contact
   URI schemes most appropriate to the service.  As a general set of
   guidelines, URI schemes that do not provide mechanisms for actually
   initiating a contact method should be avoided (examples include data,
   info, cid, and tag) as transforming those references into contact
   mechanisms requires a layer of indirection that makes the overall
   mechanism more fragile.  Provisionally registered URI schemes should
   also be carefully considered before use, because they are subject to
   change in core semantics.

4.  LoST Servers and Their Resolution

   LoST servers are identified by U-NAPTR/DDDS (URI-Enabled NAPTR/
   Dynamic Delegation Discovery Service) [8] application unique strings,
   in the form of a DNS name.  An example is &#x27;lostserver.example.com&#x27;.

   Clients need to use the U-NAPTR [8] specification described below to
   obtain a URI (indicating host and protocol) for the applicable LoST
   service.  In this document, only the HTTP and HTTPS URL schemes are
   defined.  Note that the HTTP URL can be any valid HTTP URL, including
   those containing path elements.

   The following two DNS entries show the U-NAPTR resolution for
   &quot;example.com&quot; to the HTTPS URL https://lostserv.example.com/secure or
   the HTTP URL http://lostserver.example.com, with the former being
   preferred.

       example.com.

       IN NAPTR 100  10   &quot;u&quot;    &quot;LoST:https&quot;
            &quot;!.*!https://lostserver.example.com/secure!&quot;  &quot;&quot;

       IN NAPTR 200  10   &quot;u&quot;    &quot;LoST:http&quot;
            &quot;!.*!http://lostserver.example.com!&quot;  &quot;&quot;

   Clients learn the LoST server&#x27;s host name by means beyond the scope
   of this specification, such as SIP configuration and DHCP [25].

5.  The &lt;mapping&gt; Element

   The &lt;mapping&gt; element is the core data element in LoST, describing a
   service region and the associated service URLs.  Its attributes and
   elements are described in subsections below.

5.1.  The Mapping Data Source: &#x27;source&#x27;, &#x27;sourceId&#x27;, and &#x27;lastUpdated&#x27;
      Attributes

   The &#x27;source&#x27;, &#x27;sourceId&#x27;, and &#x27;lastUpdated&#x27; attributes uniquely
   identify a particular mapping record.  They are created by the
   authoritative source for a mapping and are never modified when a
   mapping is served from a cache.  All three attributes are REQUIRED
   for all &lt;mapping&gt; elements.  A receiver can replace a mapping with
   another one having the same &#x27;source&#x27; and &#x27;sourceId&#x27; and a more recent
   time in &#x27;lastUpdated&#x27;.

   The &#x27;source&#x27; attribute contains a LoST application unique string
   identifying the authoritative generator of the mapping (Section 4).

   The &#x27;sourceId&#x27; attribute identifies a particular mapping and contains
   an opaque token that MUST be unique among all different mappings
   maintained by the authoritative source for that particular service.
   For example, a Universally Unique Identifier (UUID) is a suitable
   format.

   The &#x27;lastUpdated&#x27; attribute describes when a specific instance of
   mapping, identified by the combination of &#x27;source&#x27; and &#x27;sourceId&#x27;,
   was last changed.  The contents of this attribute has the XML data
   type dateTime in its timezoned form, using the canonical UTC
   representation with the letter &#x27;Z&#x27; as the timezone indicator.

5.2.  Mapping Validity:  The &#x27;expires&#x27; Attribute

   The &#x27;expires&#x27; attribute contains the absolute time at which the
   mapping becomes invalid.  The contents of this attribute is a
   timezoned XML type dateTime, in canonical representation.  The
   &lt;mapping&gt; element MUST include the &#x27;expires&#x27; attribute.

   Optionally, this attribute may contain the values of &#x27;NO-CACHE&#x27; and
   &#x27;NO-EXPIRATION&#x27; instead of a dateTime value.  The value &#x27;NO-CACHE&#x27; is
   an indication that the mapping should not be cached.  The value of
   &#x27;NO-EXPIRATION&#x27; is an indication that the mapping does not expire.

   On occasion, a server may be forced to return an expired mapping if
   it cannot reach the authoritative server or the server fails to
   return a usable answer.  Clients and servers MAY cache the mapping so
   that they have at least some information available.  Caching servers
   that have such stale information SHOULD re-attempt the query each
   time a client requests a mapping.  Since the expired mapping will be
   returned to the client as a non-error/non-warning response, the
   client MUST check the &#x27;expires&#x27; attribute; if the mapping has
   expired, local policy at the client determines whether it discards
   the answer and tries again later or uses the possibly stale response.

5.3.  Describing the Service with the &lt;displayName&gt; Element

   Zero or more &lt;displayName&gt; elements describe the service with a
   string that is suitable for display to human users, each annotated
   with the &#x27;xml:lang&#x27; attribute that contains a language tag to aid in
   the rendering of text.

5.4.  The Mapped Service: The &lt;service&gt; Element

   The mandatory &lt;service&gt; element identifies the service for which this
   mapping applies.  Two cases need to be distinguished when the LoST
   server sets the &lt;service&gt; element in the response message:

   1.  If the requested service, identified by the service URN [9] in
       the &lt;service&gt; element of the request, exists for the location
       indicated, then the LoST server copies the service URN from the
       request into the &lt;service&gt; element.

   2.  If, however, the requested service, identified by the service URN
       [9] in the &lt;service&gt; element in the request, does not exist for
       the location indicated, the server either can return a
       &lt;serviceNotImplemented&gt; (Section 13.1) error or can provide an
       alternate service that approximates the desired service for that

       location.  In the latter case, the server MUST include a
       &lt;service&gt; element with the alternative service URN.  The choice
       of service URN is left to local policy, but the alternate service
       should be able to satisfy the original service request.

5.5.  Defining the Service Region with the &lt;serviceBoundary&gt; Element

   A response MAY indicate the region for which the service URL returned
   would be the same as in the actual query, the so-called service
   region.  The service region can be indicated by value or by reference
   (see Section 5.6).  If a client moves outside the service area and
   wishes to obtain current service data, it sends a new query with its
   current location.  The service region is described by value in one or
   more &lt;serviceBoundary&gt; elements, each formatted according to a
   specific location profile, identified by the &#x27;profile&#x27; attribute (see
   Section 12). &lt;serviceBoundary&gt; elements formatted according to
   different location profiles are alternative representations of the
   same area, not additive to one another; this allows a client
   understanding only one of the profile types to be sure it has a
   complete view of the serviceBoundary.  Within a serviceBoundary
   element there may, however, be multiple locations which are additive;
   this is necessary because some &lt;serviceBoundary&gt; areas could not be
   easily expressed with a single shape or civic location.  If included
   in a response, the &lt;serviceBoundary&gt; element MUST contain at least
   one service boundary that uses the same profile as the request.

   A service boundary is requested by the client, using the
   &#x27;serviceBoundary&#x27; attribute in the request with the value set to
   &quot;value&quot;.

5.6.  Service Boundaries by Reference: The &lt;serviceBoundaryReference&gt;
      Element

   Since geodetic service boundaries may contain thousands of points and
   can thus be quite large, clients may wish to conserve bandwidth by
   requesting a reference to the service boundary instead of the value
   described in Section 5.5.  The identifier of the service boundary is
   returned as an attribute of the &lt;serviceBoundaryReference&gt; element,
   along with a LoST application unique string (see Section 4)
   identifying the server from where it can be retrieved.  The actual
   value of the service boundary is then retrieved with the
   getServiceBoundary (Section 9) request.

   A reference to a service boundary is requested by the client using
   the &#x27;serviceBoundary&#x27; attribute in the request with the value set to
   &quot;reference&quot;.  A LoST server may decide, based on local policy, to
   return the service boundary by value or to omit the
   &lt;serviceBoundaryReference&gt; element in the response.

   The identifier is a random token with at least 128 bits of entropy
   and can be assumed to be globally unique.  It uniquely references a
   particular boundary.  If the boundary changes, a new identifier MUST
   be chosen.  Because of these properties, a client receiving a mapping
   response can simply check if it already has a copy of the boundary
   with that identifier.  If so, it can skip checking with the server
   whether the boundary has been updated.  Since service boundaries are
   likely to remain unchanged for extended periods of time, possibly
   exceeding the normal lifetime of the service URL, this approach
   avoids unnecessarily refreshing the boundary information just because
   the remainder of the mapping has become invalid.

5.7.  The Service Number: The &lt;serviceNumber&gt; Element

   The service number is returned in the optional &lt;serviceNumber&gt;
   element.  It contains a string of digits, * and # that a user on a
   device with a 12-key dial pad could use to reach that particular
   service.

5.8.  Service URLs: The &lt;uri&gt; Element

   The response returns the service URLs in one or more &lt;uri&gt; elements.
   The URLs MUST be absolute URLs.  The ordering of the URLs has no
   particular significance.  Each URL scheme MUST only appear at most
   once, but it is permissible to include both secured and regular
   versions of a protocol, such as both &#x27;http&#x27; and &#x27;https&#x27; or &#x27;sip&#x27; and
   &#x27;sips&#x27;.

6.  Path of a Request: The &lt;path&gt; Element

   To prevent loops and to allow tracing of request and response paths,
   all requests that allow recursion include a &lt;path&gt; element that
   contains one or more &lt;via&gt; elements, each possessing an attribute
   containing a LoST application unique string (see Section 4).  The
   order of &lt;via&gt; elements corresponds to the order of LoST servers,
   i.e., the first &lt;via&gt; element identifies the server that initially
   received the request from the client issuing the request.  Every
   server in a recursive query operation is included in the &lt;path&gt;
   element, including the first server to receive it.

   The server that answers the request instead of forwarding it, such as
   the authoritative server, copies the &lt;path&gt; element verbatim into the
   response.  The &lt;path&gt; element is not modified in responses as the
   responses traverses the server chain back to the querying client.

   If a query is answered iteratively, the querier includes all servers
   that it has already contacted.

   When a cached mapping is returned, then the &lt;path&gt; element cached
   together with the mapping is returned.

   The example in Figure 4 indicates that the answer was given to the
   client by the LoST server at esgw.ueber-110.de.example, which got the
   answer from the (authoritative) LoST server at
   polizei.muenchen.de.example.

7.  Identifying the Location Element Used for Mapping: &lt;locationUsed&gt;

   Several of the requests can provide one or more &lt;location&gt; elements,
   among which the server gets to choose.  It is useful for the client
   to be able to determine which one was actually used in producing the
   result.  For that purpose, the &lt;location&gt; tag MUST contain an &#x27;id&#x27;
   attribute that uniquely identifies the &lt;location&gt; element.  The
   format of the identifier is left to the client; it could, for
   example, use a hash of the location information.  The server returns
   the identifier for the &lt;location&gt; element it used in the
   &lt;locationUsed&gt; tag.

8.  Mapping a Location and Service to URLs: &lt;findService&gt;

8.1.  Overview

   The &lt;findService&gt; query constitutes the core of the LoST
   functionality, mapping civic or geodetic locations to URLs and
   associated data.  After giving an example, we enumerate the elements
   of the query and response.

8.2.  Examples

8.2.1.  Example Using Geodetic Coordinates

   The following is an example of mapping a service to a location using
   geodetic coordinates, for the service associated with the police
   (urn:service:sos.police).

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;findService
     xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;
     xmlns:p2=&quot;http://www.opengis.net/gml&quot;
     serviceBoundary=&quot;value&quot;
     recursive=&quot;true&quot;&gt;

     &lt;location id=&quot;6020688f1ce1896d&quot; profile=&quot;geodetic-2d&quot;&gt;
       &lt;p2:Point id=&quot;point1&quot; srsName=&quot;urn:ogc:def:crs:EPSG::4326&quot;&gt;
          &lt;p2:pos&gt;37.775 -122.422&lt;/p2:pos&gt;
       &lt;/p2:Point&gt;
     &lt;/location&gt;
     &lt;service&gt;urn:service:sos.police&lt;/service&gt;

   &lt;/findService&gt;

                 Figure 1: A &lt;findService&gt; geodetic query

   Given the query above, a server would respond with a service, and
   information related to that service.  In the example below, the
   server has mapped the location given by the client for a police
   service to the New York City Police Department, instructing the
   client that it may contact them via the URIs &quot;sip:nypd@example.com&quot;
   and &quot;xmpp:nypd@example.com&quot;.  The server has also given the client a
   geodetic, two-dimensional boundary for this service.  The mapping was
   last updated on November 1, 2006 and expires on January 1, 2007.  If
   the client&#x27;s location changes beyond the given service boundary or
   the expiration time has been reached, it may want to requery for this
   information, depending on the usage environment of LoST.

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;findServiceResponse xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;
     xmlns:p2=&quot;http://www.opengis.net/gml&quot;&gt;
     &lt;mapping
       expires=&quot;2007-01-01T01:44:33Z&quot;
       lastUpdated=&quot;2006-11-01T01:00:00Z&quot;
       source=&quot;authoritative.example&quot;
       sourceId=&quot;7e3f40b098c711dbb6060800200c9a66&quot;&gt;
       &lt;displayName xml:lang=&quot;en&quot;&gt;
         New York City Police Department
       &lt;/displayName&gt;
       &lt;service&gt;urn:service:sos.police&lt;/service&gt;
       &lt;serviceBoundary profile=&quot;geodetic-2d&quot;&gt;
         &lt;p2:Polygon srsName=&quot;urn:ogc:def::crs:EPSG::4326&quot;&gt;
           &lt;p2:exterior&gt;
             &lt;p2:LinearRing&gt;
               &lt;p2:pos&gt;37.775 -122.4194&lt;/p2:pos&gt;
               &lt;p2:pos&gt;37.555 -122.4194&lt;/p2:pos&gt;
               &lt;p2:pos&gt;37.555 -122.4264&lt;/p2:pos&gt;
               &lt;p2:pos&gt;37.775 -122.4264&lt;/p2:pos&gt;
               &lt;p2:pos&gt;37.775 -122.4194&lt;/p2:pos&gt;
             &lt;/p2:LinearRing&gt;
           &lt;/p2:exterior&gt;
         &lt;/p2:Polygon&gt;
       &lt;/serviceBoundary&gt;
       &lt;uri&gt;sip:nypd@example.com&lt;/uri&gt;
       &lt;uri&gt;xmpp:nypd@example.com&lt;/uri&gt;
       &lt;serviceNumber&gt;911&lt;/serviceNumber&gt;
     &lt;/mapping&gt;
     &lt;path&gt;
       &lt;via source=&quot;resolver.example&quot;/&gt;
       &lt;via source=&quot;authoritative.example&quot;/&gt;
     &lt;/path&gt;
     &lt;locationUsed id=&quot;6020688f1ce1896d&quot;/&gt;
   &lt;/findServiceResponse&gt;

             Figure 2: A &lt;findServiceResponse&gt; geodetic answer

8.2.2.  Civic Address Mapping Example

   The example below shows how to map a service to a location much like
   the example in Section 8.2.1, but using civic address location
   information.  In this example, the client requests the service
   associated with police (urn:service:sos.police) along with a specific
   civic address (house number 6 on a street named Otto-Hahn-Ring in
   Munich, Germany).

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;findService xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;
     recursive=&quot;true&quot; serviceBoundary=&quot;value&quot;&gt;
     &lt;location id=&quot;627b8bf819d0bad4d&quot; profile=&quot;civic&quot;&gt;
       &lt;civicAddress
         xmlns=&quot;urn:ietf:params:xml:ns:pidf:geopriv10:civicAddr&quot;&gt;
         &lt;country&gt;DE&lt;/country&gt;
         &lt;A1&gt;Bavaria&lt;/A1&gt;
         &lt;A3&gt;Munich&lt;/A3&gt;
         &lt;A6&gt;Otto-Hahn-Ring&lt;/A6&gt;
         &lt;HNO&gt;6&lt;/HNO&gt;
         &lt;PC&gt;81675&lt;/PC&gt;
       &lt;/civicAddress&gt;
     &lt;/location&gt;
     &lt;service&gt;urn:service:sos.police&lt;/service&gt;
   &lt;/findService&gt;

               Figure 3: A &lt;findService&gt; civic address query

   Given the query above, a server would respond with a service, and
   information related to that service.  In the example below, the
   server has mapped the location given by the client for a police
   service to the Muenchen Polizei-Abteilung, instructing the client
   that it may contact them via the URIs sip:munich-police@example.com
   and xmpp:munich-police@example.com.  The server has also given the
   client a civic address boundary (the city of Munich) for this
   service.  The mapping was last updated on November 1, 2006 by the
   authoritative source &quot;polizei.muenchen.de.example&quot; and expires on
   January 1, 2007.  This instructs the client to requery for the
   information if its location changes beyond the given service boundary
   (i.e., beyond the indicated district of Munich) or after January 1,
   2007.

    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;findServiceResponse xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;&gt;
      &lt;mapping
        expires=&quot;2007-01-01T01:44:33Z&quot;
        lastUpdated=&quot;2006-11-01T01:00:00Z&quot;
        source=&quot;esgw.ueber-110.de.example&quot;
        sourceId=&quot;e8b05a41d8d1415b80f2cdbb96ccf109&quot;&gt;
        &lt;displayName xml:lang=&quot;de&quot;&gt;
          Muenchen Polizei-Abteilung
        &lt;/displayName&gt;
        &lt;service&gt;urn:service:sos.police&lt;/service&gt;
        &lt;serviceBoundary
          profile=&quot;civic&quot;&gt;
          &lt;civicAddress
            xmlns=&quot;urn:ietf:params:xml:ns:pidf:geopriv10:civicAddr&quot;&gt;
            &lt;country&gt;DE&lt;/country&gt;
            &lt;A1&gt;Bavaria&lt;/A1&gt;
            &lt;A3&gt;Munich&lt;/A3&gt;
            &lt;PC&gt;81675&lt;/PC&gt;
          &lt;/civicAddress&gt;
        &lt;/serviceBoundary&gt;
        &lt;uri&gt;sip:munich-police@example.com&lt;/uri&gt;
        &lt;uri&gt;xmpp:munich-police@example.com&lt;/uri&gt;
        &lt;serviceNumber&gt;110&lt;/serviceNumber&gt;
      &lt;/mapping&gt;
      &lt;path&gt;
        &lt;via source=&quot;esgw.ueber-110.de.example&quot;/&gt;
        &lt;via source=&quot;polizei.muenchen.de.example&quot;/&gt;
      &lt;/path&gt;
      &lt;locationUsed id=&quot;627b8bf819d0bad4d&quot;/&gt;
    &lt;/findServiceResponse&gt;

          Figure 4: A &lt;findServiceResponse&gt; civic address answer

8.3.  Components of the &lt;findService&gt; Request

   The &lt;findService&gt; request includes attributes and elements that
   govern whether the request is handled iteratively or recursively,
   whether location validation is performed, and which elements may be
   contained in the response.

8.3.1.  The &lt;location&gt; Element

   The &lt;findService&gt; query communicates location information using one
   or more &lt;location&gt; elements, which MUST conform to a location profile
   (see Section 12).  There MUST NOT be more than one location element

   for each distinct location profile.  The order of location elements
   is significant; the server uses the first location element where it
   understands the location profile.

8.3.2.  Identifying the Service:  The &lt;service&gt; Element

   The type of service desired is specified by the &lt;service&gt; element.
   It contains service URNs from the registry established in [9].

8.3.3.  Recursion and Iteration

   LoST can operate in either recursive or iterative mode, on a request-
   by-request basis.  In recursive mode, the LoST server initiates
   queries on behalf of the requester and returns the result to the
   requester.

   In iterative mode, the server contacted returns a redirection
   response indicating the next server to be queried if the server
   contacted cannot provide an answer itself.

   For the queries defined in this document, only the LoST &lt;findService&gt;
   and &lt;listServicesByLocation&gt; queries can be recursive, as indicated
   by the &#x27;recursive&#x27; attribute.  A value of &quot;true&quot; indicates a
   recursive query, with the default being &quot;false&quot; when the attribute is
   omitted.  Regardless of the attribute, a server MAY always answer a
   query by providing a LoST application unique string (see Section 4),
   i.e., indirection; however, it MUST NOT recurse if the attribute is
   &quot;false&quot;.

8.3.4.  Service Boundary

   LoST &lt;mapping&gt; elements can describe the service boundary either by
   value or by reference.  Returning a service boundary reference is
   generally more space-efficient for geospatial (polygon) boundaries
   and if the boundaries change rarely, but does incur an additional
   &lt;getServiceBoundary&gt; request.  The querier can express a preference
   for one or the other modality with the &#x27;serviceBoundary&#x27; attribute in
   the &lt;findService&gt; request, but the server makes the final decision as
   to whether to return a reference or a value.

8.3.5.  Requesting Civic Location Validation

   Civic address validation is requested by setting the optional
   attribute &#x27;validateLocation&#x27; to true.  If the attribute is omitted,
   it is assumed to be false.  The response is described in
   Section 8.4.2.  The example in Figure 5 demonstrates address
   validation.  If the server chooses a geodetic location among the
   locations provided in a request, the attribute is ignored.

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;findService
     xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;
     recursive=&quot;true&quot;
     validateLocation=&quot;true&quot;
     serviceBoundary=&quot;value&quot;&gt;
     &lt;location id=&quot;627b8bf819d0bad4d&quot; profile=&quot;civic&quot;&gt;
       &lt;civicAddress
         xmlns=&quot;urn:ietf:params:xml:ns:pidf:geopriv10:civicAddr&quot;&gt;
         &lt;country&gt;DE&lt;/country&gt;
         &lt;A1&gt;Bavaria&lt;/A1&gt;
         &lt;A3&gt;Munich&lt;/A3&gt;
         &lt;A6&gt;Otto-Hahn-Ring&lt;/A6&gt;
         &lt;HNO&gt;6&lt;/HNO&gt;
         &lt;PC&gt;81675&lt;/PC&gt;
       &lt;/civicAddress&gt;
     &lt;/location&gt;
     &lt;service&gt;urn:service:sos.police&lt;/service&gt;
   &lt;/findService&gt;

      Figure 5: A &lt;findService&gt; query with address validation request

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;findServiceResponse xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;&gt;
     &lt;mapping
       expires=&quot;2007-01-01T01:44:33Z&quot;
       lastUpdated=&quot;2006-11-01T01:00:00Z&quot;
       source=&quot;authoritative.example&quot;
       sourceId=&quot;4db898df52b84edfa9b6445ea8a0328e&quot;&gt;
       &lt;displayName xml:lang=&quot;de&quot;&gt;
         Muenchen Polizei-Abteilung
       &lt;/displayName&gt;
       &lt;service&gt;urn:service:sos.police&lt;/service&gt;
       &lt;serviceBoundary profile=&quot;civic&quot;&gt;
         &lt;civicAddress
           xmlns=&quot;urn:ietf:params:xml:ns:pidf:geopriv10:civicAddr&quot;&gt;
           &lt;country&gt;DE&lt;/country&gt;
           &lt;A1&gt;Bavaria&lt;/A1&gt;
           &lt;A3&gt;Munich&lt;/A3&gt;
           &lt;PC&gt;81675&lt;/PC&gt;
         &lt;/civicAddress&gt;
       &lt;/serviceBoundary&gt;
       &lt;uri&gt;sip:munich-police@example.com&lt;/uri&gt;
       &lt;uri&gt;xmpp:munich-police@example.com&lt;/uri&gt;
       &lt;serviceNumber&gt;110&lt;/serviceNumber&gt;
     &lt;/mapping&gt;
     &lt;locationValidation&gt;
       &lt;valid&gt;country A1 A3 A6&lt;/valid&gt;
       &lt;invalid&gt;PC&lt;/invalid&gt;
       &lt;unchecked&gt;HNO&lt;/unchecked&gt;
     &lt;/locationValidation&gt;
     &lt;path&gt;
       &lt;via source=&quot;resolver.example&quot;/&gt;
       &lt;via source=&quot;authoritative.example&quot;/&gt;
     &lt;/path&gt;
     &lt;locationUsed id=&quot;627b8bf819d0bad4d&quot;/&gt;
   &lt;/findServiceResponse&gt;

     Figure 6: A &lt;findServiceResponse&gt; message with address validation
                                information

8.4.  Components of the Mapping Response &lt;findServiceResponse&gt;

8.4.1.  Overview

   Mapping responses consist of the &lt;mapping&gt; element (Section 5)
   describing the mapping itself, possibly followed by warnings
   (Section 13.2), location validation information (Section 8.4.2), and
   an indication of the path (Section 6) the response has taken.

8.4.2.  Civic Address Validation: The &lt;locationValidation&gt; Element

   A server can indicate in its response which civic address elements it
   has recognized as valid, which ones it has ignored, and which ones it
   has checked and found to be invalid.  The server SHOULD include this
   information if the &#x27;validateLocation&#x27; attribute in the request was
   true, but local policy at the server may allow this information to be
   omitted.  Each element contains a list of tokens separated by
   whitespace, enumerating the civic location labels used in child
   elements of the &lt;civicAddress&gt; element.  The &lt;valid&gt; element
   enumerates those civic address elements that have been recognized as
   valid by the LoST server and that have been used to determine the
   mapping.  The &lt;unchecked&gt; elements enumerates the civic address
   elements that the server did not check and that were not used in
   determining the response.  The &lt;invalid&gt; element enumerate civic
   address elements that the server attempted to check, but that did not
   match the other civic address elements found in the &lt;valid&gt; list.
   Civic location tokens that are not listed in either the &lt;valid&gt;,
   &lt;invalid&gt;, or &lt;unchecked&gt; element belong to the class of unchecked
   tokens.

   Note that the same address can yield different responses if parts of
   the civic address contradict each other.  For example, if the postal
   code does not match the city, local server policy determines whether
   the postal code or the city is considered valid.  The mapping
   naturally corresponds to the valid elements.

   The example shown in Figure 5 and in Figure 6 indicates that the
   tokens &#x27;country&#x27;, &#x27;A1&#x27;, &#x27;A3&#x27;, and &#x27;A6&#x27; have been validated by the
   LoST server.  The server considered the postal code 81675 in the &lt;PC&gt;
   element as not valid for this location.  The &#x27;HNO&#x27; token belongs to
   the class of unchecked location tokens.

9.  Retrieving the Service Boundary via &lt;getServiceBoundary&gt;

   As discussed in Section 5.5, the &lt;findServiceResponse&gt; can return a
   globally unique identifier in the &#x27;serviceBoundary&#x27; attribute that
   can be used to retrieve the service boundary, rather than returning
   the boundary by value.  This is shown in the example in Figure 7 and
   Figure 8.  The client can then retrieve the boundary using the
   &lt;getServiceBoundary&gt; request and obtains the boundary in the
   &lt;getServiceBoundaryResponse&gt;, illustrated in the example in Figure 9
   and Figure 10.  The client issues the request to the server
   identified in the &#x27;server&#x27; attribute of the
   &lt;serviceBoundaryReference&gt; element.  These requests are always
   directed to the authoritative server and do not recurse.

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;findService
     xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;
     xmlns:p2=&quot;http://www.opengis.net/gml&quot;
     recursive=&quot;true&quot;
     serviceBoundary=&quot;reference&quot;&gt;
     &lt;location id=&quot;6020688f1ce1896d&quot; profile=&quot;geodetic-2d&quot;&gt;
       &lt;p2:Point id=&quot;point1&quot; srsName=&quot;urn:ogc:def:crs:EPSG::4326&quot;&gt;
          &lt;p2:pos&gt;37.775 -122.422&lt;/p2:pos&gt;
       &lt;/p2:Point&gt;
     &lt;/location&gt;
     &lt;service&gt;urn:service:sos.police&lt;/service&gt;
   &lt;/findService&gt;

    Figure 7: &lt;findService&gt; request and response with service boundary
                                 reference

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;findServiceResponse xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;
     xmlns:p2=&quot;http://www.opengis.net/gml&quot;&gt;
     &lt;mapping
       expires=&quot;2007-01-01T01:44:33Z&quot;
       lastUpdated=&quot;2006-11-01T01:00:00Z&quot;
       source=&quot;authoritative.example&quot;
       sourceId=&quot;7e3f40b098c711dbb6060800200c9a66&quot;&gt;
       &lt;displayName xml:lang=&quot;en&quot;&gt;
         New York City Police Department
       &lt;/displayName&gt;
       &lt;service&gt;urn:service:sos.police&lt;/service&gt;
       &lt;serviceBoundaryReference
         source=&quot;authoritative.example&quot;
         key=&quot;7214148E0433AFE2FA2D48003D31172E&quot;/&gt;
       &lt;uri&gt;sip:nypd@example.com&lt;/uri&gt;
       &lt;uri&gt;xmpp:nypd@example.com&lt;/uri&gt;
       &lt;serviceNumber&gt;911&lt;/serviceNumber&gt;
     &lt;/mapping&gt;
     &lt;path&gt;
       &lt;via source=&quot;resolver.example&quot;/&gt;
       &lt;via source=&quot;authoritative.example&quot;/&gt;
     &lt;/path&gt;
     &lt;locationUsed id=&quot;6020688f1ce1896d&quot;/&gt;
   &lt;/findServiceResponse&gt;

       Figure 8: &lt;findServiceResponse&gt; message with service boundary
                                 reference

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;getServiceBoundary xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;
       key=&quot;7214148E0433AFE2FA2D48003D31172E&quot;/&gt;

     Figure 9: Requesting a service boundary with &lt;getServiceBoundary&gt;

    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;getServiceBoundaryResponse
      xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;&gt;
        &lt;serviceBoundary profile=&quot;geodetic-2d&quot;&gt;
          &lt;p2:Polygon srsName=&quot;urn:ogc:def::crs:EPSG::4326&quot;&gt;
            &lt;p2:exterior&gt;
              &lt;p2:LinearRing&gt;
                &lt;p2:pos&gt;37.775 -122.4194&lt;/p2:pos&gt;
                &lt;p2:pos&gt;37.555 -122.4194&lt;/p2:pos&gt;
                &lt;p2:pos&gt;37.555 -122.4264&lt;/p2:pos&gt;
                &lt;p2:pos&gt;37.775 -122.4264&lt;/p2:pos&gt;
                &lt;p2:pos&gt;37.775 -122.4194&lt;/p2:pos&gt;
              &lt;/p2:LinearRing&gt;
            &lt;/p2:exterior&gt;
          &lt;/p2:Polygon&gt;
        &lt;/serviceBoundary&gt;
      &lt;path&gt;
        &lt;via source=&quot;resolver.example&quot;/&gt;
        &lt;via source=&quot;authoritative.example&quot;/&gt;
      &lt;/path&gt;
    &lt;/getServiceBoundaryResponse&gt;

               Figure 10: Geodetic service boundary response

10.  List Services: &lt;listServices&gt;

   A LoST client can ask a LoST server for the list of services that it
   understands, primarily for diagnostic purposes.  The query does not
   contain location information, as it simply provides an indication of
   which services the server can look up, not whether a particular
   service is offered for a particular area.  Typically, only top-level
   services are included in the answer, implying support for all sub-
   services.  Since the query is answered by the queried server, there
   is no notion of recursion or indirection.  The
   &lt;listServicesByLocation&gt; (Section 11) query below can be used to find
   out whether a particular service is offered for a specific location.
   An example request and response are shown in Figure 11.

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;listServices
     xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;&gt;
     &lt;service&gt;urn:service:sos&lt;/service&gt;
   &lt;/listServices&gt;

                Figure 11: Example of &lt;ListServices&gt; query

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;listServicesResponse
    xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;&gt;
    &lt;serviceList&gt;
     urn:service:sos.ambulance
     urn:service:sos.animal-control
     urn:service:sos.fire
     urn:service:sos.gas
     urn:service:sos.mountain
     urn:service:sos.marine
     urn:service:sos.physician
     urn:service:sos.poison
     urn:service:sos.police
    &lt;/serviceList&gt;
    &lt;path&gt;
     &lt;via source=&quot;authoritative.example&quot;/&gt;
    &lt;/path&gt;
   &lt;/listServicesResponse&gt;

               Figure 12: Example of &lt;ListServicesResponse&gt;

11.  List Services By Location: &lt;listServicesByLocation&gt;

   A LoST client can ask a LoST server for the list of services it knows
   about for a particular area.  The &lt;listServicesByLocation&gt; query
   contains one or more &lt;location&gt; elements, each from a different
   location profile (Section 12), and may contain the &lt;service&gt; element.
   As for &lt;findService&gt;, the server selects the first location element
   that has a profile the server understands and it can operate either
   recursively or iteratively; &lt;via&gt; elements track the progress of the
   request.  The query indicates the services that the server can
   enumerate from within the forest structure of which it is a part.
   Because LoST does not presume a single, overarching organization of
   all potential service types, there may be services available within a
   geographic area that could be described by other LoST servers
   connected to other forest structures.  As an example, the emergency
   services forest for a region may be distinct from the forests that
   locate commercial services within the same region.

   If the query contains the &lt;service&gt; element, the LoST server returns
   only immediate child services of the queried service that are
   available for the provided location.  If the &lt;service&gt; element is
   absent, the LoST service returns all top-level services available for
   the provided location that it knows about.

   A server responds to this query with a
   &lt;listServicesByLocationResponse&gt; response.  This response MAY contain
   &lt;via&gt; elements (see Section 6) and MUST contain a &lt;serviceList&gt;
   element, consisting of a whitespace-separated list of service URNs.
   The query and response are illustrated in Figure 13 and in Figure 14,
   respectively.

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;listServicesByLocation
     xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;
     xmlns:p2=&quot;http://www.opengis.net/gml&quot;
     recursive=&quot;true&quot;&gt;
     &lt;location id=&quot;3e19dfb3b9828c3&quot; profile=&quot;geodetic-2d&quot;&gt;
       &lt;p2:Point srsName=&quot;urn:ogc:def:crs:EPSG::4326&quot;&gt;
         &lt;p2:pos&gt;-34.407 150.883&lt;/p2:pos&gt;
       &lt;/p2:Point&gt;
     &lt;/location&gt;
     &lt;service&gt;urn:service:sos&lt;/service&gt;
   &lt;/listServicesByLocation&gt;

           Figure 13: Example of &lt;ListServicesbyLocation&gt; query

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;listServicesByLocationResponse
    xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;&gt;
    &lt;serviceList&gt;
     urn:service:sos.ambulance
     urn:service:sos.animal-control
     urn:service:sos.fire
     urn:service:sos.gas
     urn:service:sos.mountain
     urn:service:sos.marine
     urn:service:sos.physician
     urn:service:sos.poison
     urn:service:sos.police
    &lt;/serviceList&gt;
    &lt;path&gt;
     &lt;via source=&quot;resolver.example&quot;/&gt;
     &lt;via source=&quot;authoritative.example&quot;/&gt;
    &lt;/path&gt;
    &lt;locationUsed id=&quot;3e19dfb3b9828c3&quot;/&gt;
   &lt;/listServicesByLocationResponse&gt;

      Figure 14: Example of &lt;ListServicesByLocationResponse&gt; response

12.  Location Profiles

   LoST uses location information in &lt;location&gt; elements in requests and
   &lt;serviceBoundary&gt; elements in responses.  Such location information
   may be expressed in a variety of ways.  This variety can cause
   interoperability problems where a request or response contains
   location information in a format not understood by the server or the
   client, respectively.  To achieve interoperability, this document
   defines two mandatory-to-implement baseline location profiles to
   define the manner in which location information is transmitted.  It
   is possible to standardize other profiles in the future.  The
   baseline profiles are:

   geodetic-2d:
      a profile for two-dimensional geodetic location information, as
      described in Section 12.2;.

   civic:
      a profile consisting of civic address location information, as
      described in Section 12.3.

   Requests and responses containing &lt;location&gt; or &lt;serviceBoundary&gt;
   elements MUST contain location information in exactly one of the two
   baseline profiles, in addition to zero or more additional profiles.
   The ordering of location information indicates a preference on the
   part of the sender.

   Standards action is required for defining new profiles.  A location
   profile MUST define:

   1.  The token identifying it in the LoST location profile registry.

   2.  The formal definition of the XML to be used in requests, i.e., an
       enumeration and definition of the XML child elements of the
       &lt;location&gt; element.

   3.  The formal definition of the XML to be used in responses, i.e.,
       an enumeration and definition of the XML child elements of the
       &lt;serviceBoundary&gt; element.

   4.  The declaration of whether geodetic-2d or civic is to be used as
       the baseline profile.  It is necessary to explicitly declare the
       baseline profile as future profiles may be combinations of
       geodetic and civic location information.

12.1.  Location Profile Usage

   A location profile is identified by a token in an IANA-maintained
   registry (Section 17.5).  Clients send location information compliant
   with a location profile, and servers respond with location
   information compliant with that same location profile.

   When a LoST client sends a &lt;findService&gt; request that provides
   location information, it includes one or more &lt;location&gt; elements.  A
   &lt;location&gt; element carries an optional &#x27;profile&#x27; attribute that
   indicates the location format of the child elements.  A client may
   obtain location information that does not conform to a profile it
   recognizes, or it may not have the capability to map XML to profiles.
   In that case, a client MAY omit the profile attribute and the server
   should interpret the XML location data to the best of its ability,
   returning a &quot;locationProfileUnrecognized&quot; error if it is unable to do
   so.

   The concept of location profiles is described in Section 12.  With
   the ability to specify more than one &lt;location&gt; element, the client
   is able to convey location information for multiple location profiles
   in the same request.

   When a LoST server sends a response that contains location
   information, it uses the &lt;serviceBoundary&gt; elements much like the
   client uses the &lt;location&gt; elements.  Each &lt;serviceBoundary&gt; element
   contains location information conforming to the location profile
   specified in the &#x27;profile&#x27; attribute.  A response MAY contain
   multiple mappings or boundaries for the different &lt;location&gt;
   elements, subject to the restrictions below.

   Using the location profiles defined in this document, the following
   rules ensure interoperability between clients and servers:

   1.  A client MUST be capable of understanding the response for the
       baseline profiles it used in the request.

   2.  If a client sends location information conformant to any location
       profile other than the ones described in this document, it MUST
       also send, in the same request, location information conformant
       to one of the baseline profiles.  Otherwise, the server might not
       be able to understand the request.

   3.  A client MUST NOT send multiple &lt;location&gt; objects that are
       derived from different baseline profiles.  In other words, a
       client MUST only send location objects according to the same
       baseline profile in a query, but it MAY contain a location
       element following a baseline profile in addition to some other
       profile.

   4.  If a client has both location information primarily of geodetic
       nature and location information primarily of a civic nature, it
       MUST send separate requests containing each type of location
       information.

   5.  There can only be one instance of each location profile in a
       query.

   6.  Servers MUST implement all profiles described in this document.

   7.  A server uses the first-listed location profile that it
       understands and ignores the others.

   8.  If a server receives a request that only contains location
       information using profiles it does not understand, the server
       responds with a &lt;locationProfileError&gt; (Section 13.1).

   9.  The &lt;serviceBoundary&gt; element MUST use the same location profile
       that was used to retrieve the answer and indicates which profile
       has been used with the &#x27;profile&#x27; attribute.

   These rules enable the use of location profiles not yet specified,
   while ensuring baseline interoperability.  Take, for example, this
   scenario illustrated in Figure 15 and 16.  Client X has had its
   firmware upgraded to support the &#x27;not-yet-standardized-prism-profile&#x27;
   location profile.  Client X sends location information to Server Y,
   which does not understand the &#x27;not-yet-standardized-prism-profile&#x27;
   location profile.  If Client X also sends location information using
   the geodetic-2D baseline profile, then Server Y will still be able to
   understand the request and provide an understandable response, though
   with location information that might not be as precise or expressive
   as desired.  This is possible because both Client X and Server Y
   understand the baseline profile.

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;findService
     xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;
     xmlns:gml=&quot;http://www.opengis.net/gml&quot;
     xmlns:gs=&quot;http://www.opengis.net/pidflo/1.0&quot;
     recursive=&quot;true&quot;
     serviceBoundary=&quot;value&quot;&gt;
     &lt;location id=&quot;ABC 123&quot;
         profile=&quot;not-yet-standardized-prism-profile&quot;&gt;
       &lt;gs:Prism srsName=&quot;urn:ogc:def:crs:EPSG::4979&quot;&gt;
         &lt;gs:base&gt;
           &lt;gml:Polygon&gt;
             &lt;gml:exterior&gt;
               &lt;gml:LinearRing&gt;
                 &lt;gml:posList&gt;
                   42.556844 -73.248157 36.6
                   42.656844 -73.248157 36.6
                   42.656844 -73.348157 36.6
                   42.556844 -73.348157 36.6
                   42.556844 -73.248157 36.6
                 &lt;/gml:posList&gt;
               &lt;/gml:LinearRing&gt;
             &lt;/gml:exterior&gt;
           &lt;/gml:Polygon&gt;
         &lt;/gs:base&gt;
         &lt;gs:height uom=&quot;urn:ogc:def:uom:EPSG::9001&quot;&gt;
           2.4
         &lt;/gs:height&gt;
       &lt;/gs:Prism&gt;
     &lt;/location&gt;
     &lt;location id=&quot;DEF 345&quot; profile=&quot;geodetic-2d&quot;&gt;
       &lt;gml:Point id=&quot;point1&quot; srsName=&quot;urn:ogc:def:crs:EPSG:4326&quot;&gt;
         &lt;gml:pos&gt;42.656844 -73.348157&lt;/gml:pos&gt;
       &lt;/gml:Point&gt;
     &lt;/location&gt;
     &lt;service&gt;urn:service:sos.police&lt;/service&gt;
   &lt;/findService&gt;

    Figure 15: Example of a &lt;findServices&gt; query with baseline profile
                             interoperability

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;findServiceResponse
     xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;
     xmlns:p2=&quot;http://www.opengis.net/&quot;&gt;
     &lt;mapping
       expires=&quot;2007-01-01T01:44:33Z&quot;
       lastUpdated=&quot;2006-11-01T01:00:00Z&quot;
       source=&quot;authoritative.example&quot;
       sourceId=&quot;cf19bbb038fb4ade95852795f045387d&quot;&gt;
       &lt;displayName xml:lang=&quot;en&quot;&gt;
         New York City Police Department
       &lt;/displayName&gt;
       &lt;service&gt;urn:service:sos.police&lt;/service&gt;
       &lt;serviceBoundary profile=&quot;geodetic-2d&quot;&gt;
         &lt;p2:Polygon srsName=&quot;urn:ogc:def::crs:EPSG::4326&quot;&gt;
           &lt;p2:exterior&gt;
             &lt;p2:LinearRing&gt;
               &lt;p2:pos&gt;37.775 -122.4194&lt;/p2:pos&gt;
               &lt;p2:pos&gt;37.555 -122.4194&lt;/p2:pos&gt;
               &lt;p2:pos&gt;37.555 -122.4264&lt;/p2:pos&gt;
               &lt;p2:pos&gt;37.775 -122.4264&lt;/p2:pos&gt;
               &lt;p2:pos&gt;37.775 -122.4194&lt;/p2:pos&gt;
             &lt;/p2:LinearRing&gt;
           &lt;/p2:exterior&gt;
         &lt;/p2:Polygon&gt;
       &lt;/serviceBoundary&gt;
       &lt;uri&gt;sip:nypd@example.com&lt;/uri&gt;
       &lt;serviceNumber&gt;911&lt;/serviceNumber&gt;
     &lt;/mapping&gt;
     &lt;path&gt;
       &lt;via source=&quot;resolver.example&quot;/&gt;
       &lt;via source=&quot;authoritative.example&quot;/&gt;
     &lt;/path&gt;
     &lt;locationUsed id=&quot;DEF 345&quot;/&gt;
   &lt;/findServiceResponse&gt;

    Figure 16: Example of a &lt;findServiceResponse&gt; message with baseline
                         profile interoperability

12.2.  Two-Dimensional Geodetic Profile

   The &quot;geodetic-2d&quot; location profile is identified by the token
   &quot;geodetic-2d&quot;.  Clients and servers use this profile by placing the
   following location shapes into the &lt;serviceBoundary&gt; or into the
   &lt;location&gt; element (unless indicated otherwise):

   Point:
      The &lt;Point&gt; element is described in Section 5.2.1 of [13].
      Section 5.2.1 of [13] shows also the specification of a &lt;Point&gt;
      with either a two-dimensional position (latitude and longitude) or
      three-dimensional position (latitude, longitude, and altitude).  A
      client MAY use the three-dimensional position, and servers MAY
      interpret a three-dimensional position as a two-dimensional
      position by ignoring the altitude value.  A &lt;Point&gt; element is not
      placed into a &lt;serviceBoundary&gt; element.

   Polygon:
      The &lt;Polygon&gt; element is described in Section 5.2.2 of [13].  The
      restriction to 16 points for a polygon contained in Section 7.2.2
      of [12] is not applicable to this document.

   Circle:
      The &lt;Circle&gt; element is described in Section 5.2.3 of [13].

   Ellipse:
      The &lt;Ellipse&gt; element is described in Section 5.2.4 of [13].

   ArcBand:
      The &lt;ArcBand&gt; element is described in Section 5.2.5 of [13].

   When a client uses a &lt;Polygon&gt;, &lt;Circle&gt;, &lt;Ellipse&gt;, or &lt;ArcBand&gt;
   element within the &lt;location&gt; element, it is indicating that it will
   be satisfied by query results appropriate to any portion of the
   shape.  It is left to the server to select an appropriate matching
   algorithm.  A server MAY return multiple &lt;mapping&gt; elements if the
   shape extends across multiple service areas.  Servers are not
   required to return all possible &lt;mapping&gt; elements to avoid denial-
   of-service attacks in which clients present queries that span a very
   large number of service boundaries (e.g., presenting a shape covering
   all of the United States).

   In the case where the server does not return multiple &lt;mapping&gt;
   elements, but the shape extends across a service boundary, it is
   possible that the matching algorithm selected by the LoST server will
   return results that match a portion of the shape but do not match
   those specific to a particular point.  A client may always select a
   point from within the shape to avoid this condition.  The cases where

   it does not are generally those where it knows its own position only
   within the shape given.  In emergency service use cases, that may
   result in the PSAP contacted at the URI provided by LoST being
   required to forward a call to one of its neighbors; this is an
   expected part of the overall emergency response system.  In non-
   emergency service use cases, the service deployment model should take
   into account this issue as part of the provisioning model, as the
   combination of the data in the LoST server and the algorithm used for
   mapping determine which contact URIs are returned when shapes are
   used that overlap multiple service areas.

   As a general guideline, any deployed matching algorithm should ensure
   that the algorithm used does not needlessly return no results if
   there are valid results for any portion of the shape.  If an
   authoritative server receives a query for which the area in the query
   overlaps the area for which the server has mapping information, then
   it MUST return either a mapping whose coverage area intersects the
   query area or a redirect to another server whose coverage area is a
   subset of the server&#x27;s coverage area.

   When geodetic location information of this location profile is placed
   in the &lt;serviceBoundary&gt; element, then the elements with geospatial
   coordinates are alternative descriptions of the same service region,
   not additive geometries.

12.3.  Basic Civic Profile

   The basic civic location profile is identified by the token &#x27;civic&#x27;.
   Clients use this profile by placing a &lt;civicAddress&gt; element, defined
   in [10], within the &lt;location&gt; element.

   Servers use this profile by placing a &lt;civicAddress&gt; element, defined
   in [10], within the &lt;serviceBoundary&gt; element.

   A response MAY contain more than one &lt;serviceBoundary&gt; element with
   profile &#x27;civic&#x27;.  Each &lt;serviceBoundary&gt; element describes a set of
   civic addresses that fall within the service boundary, namely, all
   addresses that textually match the civic address elements provided,
   regardless of the value of other address elements.  A location falls
   within the mapping&#x27;s service boundary if it matches any of the
   &lt;serviceBoundary&gt; elements.  Hence, a response may contain multiple
   &lt;serviceBoundary&gt; elements with civic and/or geodetic location
   profiles.

13.  Errors, Warnings, and Redirects

   When a LoST server cannot fulfill a request completely, it can return
   either an error or a warning, depending on the severity of the
   problem.  It returns an &lt;errors&gt; element if no useful response can be
   returned for the query.  It returns a &lt;warnings&gt; element as part of
   another response element if it was able to respond in part, but the
   response may not be quite what the client had desired.  For both
   elements, the &#x27;source&#x27; attribute names the server that originally
   generated the error or warning, such as the authoritative server.
   Unless otherwise noted, all elements below can be either an error or
   a warning, depending on whether a default response, such as a
   mapping, is included.

13.1.  Errors

   LoST defines a pattern for errors, defined as &lt;errors&gt; elements in
   the Relax NG schema.  This pattern defines a &#x27;message&#x27; attribute
   containing human-readable text and an &#x27;xml:lang&#x27; attribute denoting
   the language of the human-readable text.  One or more such error
   elements are contained in the &lt;errors&gt; element.

   The following errors follow this basic pattern:

   badRequest
      The server could not parse or otherwise understand a request,
      e.g., because the XML was malformed.

   forbidden
      The server refused to send an answer.  This generally only occurs
      for recursive queries, namely, if the client tried to contact the
      authoritative server and was refused.

   internalError
      The server could not satisfy a request due to misconfiguration or
      other operational and non-protocol-related reasons.

   locationProfileUnrecognized
      None of the profiles in the request were recognized by the server
      (see Section 12).

   locationInvalid
      The geodetic or civic location in the request was invalid.  For
      example, the longitude or latitude values fall outside the
      acceptable ranges.

   SRSInvalid
      The spatial reference system (SRS) contained in the location
      element was not recognized or does not match the location profile.

   loop
      During a recursive query, the server was about to visit a server
      that was already in the server list in the &lt;path&gt; element,
      indicating a request loop.

   notFound
      The server could not find an answer to the query.

   serverError
      An answer was received from another LoST server, but it could not
      be parsed or otherwise understood.  This error occurs only for
      recursive queries.

   serverTimeout
      A time out occurred before an answer was received.

   serviceNotImplemented
      The requested service URN is not implemented and no substitution
      was available.

   An example is below:

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;errors xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;
     source=&quot;resolver.example&quot;&gt;
      &lt;internalError message=&quot;Software bug.&quot; xml:lang=&quot;en&quot;/&gt;
   &lt;/errors&gt;

                  Figure 17: Example of an error response

13.2.  Warnings

   A response MAY contain zero or more warnings.  This pattern defines a
   &#x27;message&#x27; attribute containing human-readable text and an &#x27;xml:lang&#x27;
   attribute denoting the language of the human-readable text.  One or
   more such warning elements are contained in the &lt;warnings&gt; element.
   To provide human-readable text in an appropriate language, the HTTP
   content negotiation capabilities (see Section 14) MAY be utilized by
   a server.

   This version of the specification defines the following warnings:

   locationValidationUnavailable
      The &lt;locationValidationUnavailable&gt; element MAY be returned when a
      server wishes to notify a client that it cannot fulfill a location
      validation request.  This warning allows a server to return
      mapping information while signaling this exception state.

   serviceSubstitution
      The &lt;serviceSubstitution&gt; element MAY be returned when a server
      was not able to fulfill a &lt;findService&gt; request for a given
      service URN.  For example, a &lt;findService&gt; request with the
      &#x27;urn:service:sos.police&#x27; service URN for a location in Uruguay may
      cause the LoST service to return a mapping for the
      &#x27;urn:service:sos&#x27; service URN since Uruguay does not make use of
      the sub-services police, fire, and ambulance.  If this warning is
      returned, then the &lt;service&gt; element in the response provides
      information about the service URN that refers to the mapping.

   defaultMappingReturned
      The &lt;defaultMappingReturned&gt; element MAY be returned when a server
      was not able to fulfill a &lt;findService&gt; request for a given
      location but is able to respond with a default URI.  For example,
      a nearby PSAP may be returned.

   An example of a warning is shown below:

    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;findServiceResponse xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;
      xmlns:p2=&quot;http://www.opengis.net/&quot;&gt;
      &lt;mapping
        expires=&quot;2007-01-01T01:44:33Z&quot;
        lastUpdated=&quot;2006-11-01T01:00:00Z&quot;
        source=&quot;authoritative.example&quot;
        sourceId=&quot;fb8ed888433343b7b27865aeb38f3a99&quot;&gt;
        &lt;displayName xml:lang=&quot;en&quot;&gt;
          New York City Police Department
        &lt;/displayName&gt;
        &lt;service&gt;urn:service:sos.police&lt;/service&gt;
        &lt;serviceBoundary profile=&quot;geodetic-2d&quot;&gt;
          &lt;p2:Polygon srsName=&quot;urn:ogc:def::crs:EPSG::4326&quot;&gt;
            &lt;p2:exterior&gt;
              &lt;p2:LinearRing&gt;
                &lt;p2:pos&gt;37.775 -122.4194&lt;/p2:pos&gt;
                &lt;p2:pos&gt;37.555 -122.4194&lt;/p2:pos&gt;
                &lt;p2:pos&gt;37.555 -122.4264&lt;/p2:pos&gt;
                &lt;p2:pos&gt;37.775 -122.4264&lt;/p2:pos&gt;
                &lt;p2:pos&gt;37.775 -122.4194&lt;/p2:pos&gt;
              &lt;/p2:LinearRing&gt;
            &lt;/p2:exterior&gt;
          &lt;/p2:Polygon&gt;
        &lt;/serviceBoundary&gt;
        &lt;uri&gt;sip:nypd@example.com&lt;/uri&gt;
        &lt;serviceNumber&gt;911&lt;/serviceNumber&gt;
      &lt;/mapping&gt;
      &lt;warnings source=&quot;authoritative.example&quot;&gt;
        &lt;defaultMappingReturned
            message=&quot;Unable to determine PSAP for the given location;
                using default PSAP&quot;
            xml:lang=&quot;en&quot;/&gt;
      &lt;/warnings&gt;
      &lt;path&gt;
        &lt;via source=&quot;resolver.example&quot;/&gt;
        &lt;via source=&quot;authoritative.example&quot;/&gt;
      &lt;/path&gt;
    &lt;/findServiceResponse&gt;

                 Figure 18: Example of a warning response

13.3.  Redirects

   A LoST server can respond indicating that the querier should redirect
   the query to another server, using the &lt;redirect&gt; element.  The
   element includes a &#x27;target&#x27; attribute indicating the LoST application
   unique string (see Section 4) that the client SHOULD be contacting
   next, as well as the &#x27;source&#x27; attribute indicating the server that
   generated the redirect response and a &#x27;message&#x27; attribute explaining
   the reason for the redirect response.  During a recursive query, a
   server receiving a &lt;redirect&gt; response can decide whether it wants to
   follow the redirection or simply return the response to its upstream
   querier.  The &quot;expires&quot; value in the response returned by the server
   handling the redirected query indicates the earliest time at which a
   new query might be needed (see Section 5.2).  The query for the same
   tuple of location and service SHOULD NOT be directed to the server
   that gave redirect prior to that time.

   An example is below:

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;redirect xmlns=&quot;urn:ietf:params:xml:ns:lost1&quot;
     target=&quot;eastpsap.example&quot;
     source=&quot;westpsap.example&quot;
     message=&quot;We have temporarily failed over.&quot; xml:lang=&quot;en&quot;/&gt;

                 Figure 19: Example of a redirect response

14.  LoST Transport: HTTP

   LoST needs an underlying protocol transport mechanism to carry
   requests and responses.  This document defines the use of LoST over
   HTTP and LoST over HTTP-over-TLS.  Client and server developers are
   reminded that full support of RFC 2616 HTTP facilities is expected.
   If LoST clients or servers re-implement HTTP, rather than using
   available servers or client code as a base, careful attention must be
   paid to full interoperability.  Other transport mechanisms are left
   to future documents.  The available transport mechanisms are
   determined through the use of the LoST U-NAPTR application.  In
   protocols that support content type indication, LoST uses the media
   type application/lost+xml.

   When using HTTP [3] and HTTP-over-TLS [4], LoST requests use the HTTP
   POST method.  The HTTP request MUST use the Cache-Control response
   directive &quot;no-cache&quot; to disable HTTP-level caching even by caches
   that have been configured to return stale responses to client
   requests.

   All LoST responses, including those indicating a LoST warning or
   error, are carried in 2xx responses, typically 200 (OK).  Other 2xx
   responses, in particular 203 (Non-authoritative information), may be
   returned by HTTP caches that disregard the caching instructions. 3xx,
   4xx, and 5xx HTTP response codes indicate that the HTTP request
   itself failed or was redirected; these responses do not contain any
   LoST XML elements.  The 3xx responses are distinct from the redirects
   that are described in Section 13.3; the redirect operation in
   Section 13.3 occur after a LoST server processes the request.  Where
   an HTTP-layer redirect will be general, a LoST server redirect as
   described in Section 13.3 might be specific to a specific service or
   be the result of other processing by the LoST server.

   The HTTP URL is derived from the LoST server name via U-NAPTR
   application, as discussed above.

15.  Relax NG Schema

<div class='Verified-endnote-styling' id='eid4174'>
<pre>
<b><i><a href='https://www.rfc-editor.org/errata/eid4174'>EID 4174</a> (Verified) is as follows:</i></b>

<b>Section:</b> 15 &amp; Apdx A

<b>Original Text:</b>

In section 15, the Exception pattern says (in part):
  locationProfileUnrecognized =
    element locationProfileUnrecognized {
      attribute unsupportedProfiles { xsd:NMTOKENS },
      basicException
    }

The corresponding section in Appendix A says:
       &lt;define name=&quot;locationProfileUnrecognized&quot;&gt;
         &lt;element name=&quot;locationProfileUnrecognized&quot;&gt;
           &lt;attribute name=&quot;unsupportedProfiles&quot;&gt;
             &lt;data type=&quot;NMTOKENS&quot;/&gt;
           &lt;/attribute&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

<b>Corrected Text:</b>

Section 15 should say:
  locationProfileUnrecognized =
    element locationProfileUnrecognized {
      basicException
    }

Appendix A should say:
       &lt;define name=&quot;locationProfileUnrecognized&quot;&gt;
         &lt;element name=&quot;locationProfileUnrecognized&quot;&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;
</pre>
<b>Notes:</b><br/>
The unsupportedProfiles attribute is not referenced anywhere else in the text of the document; no instruction is given describing the use of this attribute.  This, by itself, is problematic.  However, based on the type, it seems reasonable that the intent may have been to list the location profiles which the server is unable to understand.<br/><br/>Consider the condition under which the locationProfileUnrecognized error is returned (section 12.1):<br/>    8. If a server receives a request that only contains location<br/>       information using profiles it does not understand, the server<br/>       responds with a &lt;locationProfileError&gt;<br/><br/>If none of the locations include the optional profile attribute, the server may not be able to identify any of the profiles and therefore would be incapable of returning a list of profile names.  This is especially problematic considering that the unsupportedProfiles attribute is required by the schema.<br/><br/>Even in cases where one or more locations include the profile attribute, the client already knows what profiles were used in the request, so returning a list of these profiles does not provide new information to the client.<br/><br/>At best, use of the unsupportedProfiles attribute appears to be redundant; at worst, it is impossible.  Therefore, the suggested course of action is to remove the attribute from the schema.
</div>
<div class='Verified-endnote-styling' id='eid4176'>
<pre>
<b><i><a href='https://www.rfc-editor.org/errata/eid4176'>EID 4176</a> (Verified) is as follows:</i></b>

<b>Section:</b> 15 &amp; Apdx A

<b>Original Text:</b>

Section 15:  

exceptionContainer =
    (badRequest?
     &amp; internalError?
     &amp; serviceSubstitution?
     &amp; defaultMappingReturned?
     &amp; forbidden?
     &amp; notFound?
     &amp; loop?
     &amp; serviceNotImplemented?
     &amp; serverTimeout?
     &amp; serverError?
     &amp; locationInvalid?
     &amp; locationProfileUnrecognized?),
    extensionPoint,
    source

And:

  serverError = element serverError { basicException }
  locationInvalid = element locationInvalid { basicException }

Appendix A:

           &lt;optional&gt;
             &lt;ref name=&quot;serverError&quot;/&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
             &lt;ref name=&quot;locationInvalid&quot;/&gt;
           &lt;/optional&gt;

And:

       &lt;define name=&quot;serverError&quot;&gt;
         &lt;element name=&quot;serverError&quot;&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;locationInvalid&quot;&gt;
         &lt;element name=&quot;locationInvalid&quot;&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

<b>Corrected Text:</b>

Section 15:  

exceptionContainer =
    (badRequest?
     &amp; internalError?
     &amp; serviceSubstitution?
     &amp; defaultMappingReturned?
     &amp; forbidden?
     &amp; notFound?
     &amp; loop?
     &amp; serviceNotImplemented?
     &amp; serverTimeout?
     &amp; serverError?
     &amp; SRSInvalid?
     &amp; locationInvalid?
     &amp; locationProfileUnrecognized?),
    extensionPoint,
    source

And:

  serverError = element serverError { basicException }
  SRSInvalid = element SRSInvalid { basicException }
  locationInvalid = element locationInvalid { basicException }

Appendix A:

           &lt;optional&gt;
             &lt;ref name=&quot;serverError&quot;/&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
             &lt;ref name=&quot;SRSInvalid&quot;/&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
             &lt;ref name=&quot;locationInvalid&quot;/&gt;
           &lt;/optional&gt;

And:

       &lt;define name=&quot;serverError&quot;&gt;
         &lt;element name=&quot;serverError&quot;&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;SRSInvalid&quot;&gt;
         &lt;element name=&quot;SRSInvalid&quot;&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;locationInvalid&quot;&gt;
         &lt;element name=&quot;locationInvalid&quot;&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;
</pre>
<b>Notes:</b><br/>
The SRSInvalid error is defined in section 13.1, but was omitted from the schemas.
</div>
   This section provides the Relax NG schema used by the LoST protocol
   in the compact form.  The verbose form is included in Appendix A.

namespace a = &quot;http://relaxng.org/ns/compatibility/annotations/1.0&quot;
default namespace ns1 = &quot;urn:ietf:params:xml:ns:lost1&quot;

##
##       Location-to-Service Translation (LoST) Protocol

##
##       A LoST XML instance has three request types, each with
##       a corresponding response type: find service, list services,
##       and get service boundary.
##
start =
  findService
  | listServices
  | listServicesByLocation
  | getServiceBoundary
  | findServiceResponse
  | listServicesResponse
  | listServicesByLocationResponse
  | getServiceBoundaryResponse
  | errors
  | redirect

##
##       The queries.
##
div {

  findService =
    element findService {
      requestLocation,
      commonRequestPattern,
      attribute validateLocation {
        xsd:boolean &gt;&gt; a:defaultValue [ &quot;false&quot; ]
      }?,
      attribute serviceBoundary {
        (&quot;reference&quot; | &quot;value&quot;) &gt;&gt; a:defaultValue [ &quot;reference&quot; ]
      }?,
      attribute recursive { xsd:boolean &gt;&gt; a:defaultValue [ &quot;false&quot; ] }?
    }
  listServices = element listServices { commonRequestPattern }
  listServicesByLocation =
    element listServicesByLocation {
      requestLocation,
      commonRequestPattern,
      attribute recursive { xsd:boolean &gt;&gt; a:defaultValue [ &quot;true&quot; ] }?
    }
  getServiceBoundary =
    element getServiceBoundary { serviceBoundaryKey, extensionPoint }
}

##
##       The responses.
##
div {
  findServiceResponse =
    element findServiceResponse {
      mapping+, locationValidation?, commonResponsePattern, locationUsed
    }
  listServicesResponse =
    element listServicesResponse { serviceList, commonResponsePattern }
  listServicesByLocationResponse =
    element listServicesByLocationResponse {
      serviceList, commonResponsePattern, locationUsed
    }
  getServiceBoundaryResponse =
    element getServiceBoundaryResponse {
      serviceBoundary, commonResponsePattern
    }
}

##
##       A pattern common to some of the queries.
##
div {
  commonRequestPattern = service, path?, extensionPoint

}

##
##       A pattern common to responses.
##
div {
  commonResponsePattern = warnings*, path, extensionPoint
}

##
##       Location in Requests
##
div {
  requestLocation =
    element location {
      attribute id { xsd:token },
      locationInformation
    }+
}

##
##       Location Information
##
div {
  locationInformation =
    extensionPoint+,
    attribute profile { xsd:NMTOKEN }?
}

##
##       Service Boundary
##
div {
  serviceBoundary = element serviceBoundary { locationInformation }+
}

##
##       Service Boundary Reference
##
div {
  serviceBoundaryReference =
    element serviceBoundaryReference {
      source, serviceBoundaryKey, extensionPoint
    }
  serviceBoundaryKey = attribute key { xsd:token }
}

##

##       Path -
##       Contains a list of via elements -
##       places through which information flowed
##
div {
  path =
    element path {
      element via { source, extensionPoint }+
    }
}

##
##       Location Used
##
div {
  locationUsed =
    element locationUsed {
      attribute id { xsd:token }
    }?
}

##
##       Expires pattern
##
div {
  expires =
    attribute expires { xsd:dateTime | &quot;NO-CACHE&quot; | &quot;NO-EXPIRATION&quot; }
}

##
##       A QName list
##
div {
  qnameList = list { xsd:QName* }
}

##
##       A location-to-service mapping.
##
div {
  mapping =
    element mapping {
      element displayName {
        xsd:string,
        attribute xml:lang { xsd:language }
      }*,
      service,
      (serviceBoundary | serviceBoundaryReference)?,
      element uri { xsd:anyURI }*,
      element serviceNumber {
        xsd:token { pattern = &quot;[0-9*#]+&quot; }
      }?,
      extensionPoint,
      expires,
      attribute lastUpdated { xsd:dateTime },
      source,
      attribute sourceId { xsd:token },
      message
    }
}

##
##       Location validation
##
div {
  locationValidation =
    element locationValidation {
      element valid { qnameList }?,
      element invalid { qnameList }?,
      element unchecked { qnameList }?,
      extensionPoint
    }
}

##
##       Errors and Warnings Container.
##
div {
  exceptionContainer =
    (badRequest?
     &amp; internalError?
     &amp; serviceSubstitution?
     &amp; defaultMappingReturned?
     &amp; forbidden?
     &amp; notFound?
     &amp; loop?
     &amp; serviceNotImplemented?
     &amp; serverTimeout?
     &amp; serverError?
     &amp; locationInvalid?
     &amp; locationProfileUnrecognized?),
    extensionPoint,
    source
  errors = element errors { exceptionContainer }
  warnings = element warnings { exceptionContainer }
}

##
##       Basic Exceptions
##
div {

  ##
  ##         Exception pattern.
  ##
  basicException = message, extensionPoint
  badRequest = element badRequest { basicException }
  internalError = element internalError { basicException }
  serviceSubstitution = element serviceSubstitution { basicException }
  defaultMappingReturned =
    element defaultMappingReturned { basicException }
  forbidden = element forbidden { basicException }
  notFound = element notFound { basicException }
  loop = element loop { basicException }
  serviceNotImplemented =
    element serviceNotImplemented { basicException }
  serverTimeout = element serverTimeout { basicException }
  serverError = element serverError { basicException }
  locationInvalid = element locationInvalid { basicException }
  locationValidationUnavailable =
    element locationValidationUnavailable { basicException }
  locationProfileUnrecognized =
    element locationProfileUnrecognized {
      attribute unsupportedProfiles { xsd:NMTOKENS },
      basicException
    }
}

##
##       Redirect.
##
div {

  ##
  ##         Redirect pattern
  ##
  redirect =
    element redirect {
      attribute target { appUniqueString },
      source,
      message,
      extensionPoint
    }
}

##
##       Some common patterns.
##
div {
  message =
    (attribute message { xsd:token },
     attribute xml:lang { xsd:language })?
  service = element service { xsd:anyURI }?
  appUniqueString =
    xsd:token { pattern = &quot;([a-zA-Z0-9\-]+\.)+[a-zA-Z0-9]+&quot; }
  source = attribute source { appUniqueString }
  serviceList =
    element serviceList {
      list { xsd:anyURI* }
    }
}

##
##       Patterns for inclusion of elements from schemas in
##       other namespaces.
##
div {

  ##
  ##         Any element not in the LoST namespace.
  ##
  notLost = element * - (ns1:* | ns1:*) { anyElement }

  ##
  ##         A wildcard pattern for including any element
  ##         from any other namespace.
  ##
  anyElement =
    (element * { anyElement }
     | attribute * { text }
     | text)*

  ##
  ##         A point where future extensions
  ##         (elements from other namespaces)
  ##         can be added.
  ##
  extensionPoint = notLost*
}

                         Figure 20: RelaxNG schema

16.  Internationalization Considerations

   The LoST protocol is mostly meant for machine-to-machine
   communications; as such, most of its elements are tokens not meant
   for direct human consumption.  If these tokens are presented to the
   end user, some localization may need to occur.  The content of the
   &lt;displayName&gt; element and the &#x27;message&#x27; attributes may be displayed
   to the end user, and they are thus complex types designed for this
   purpose.

   LoST exchanges information using XML.  All XML processors are
   required to understand UTF-8 and UTF-16 encodings, and therefore all
   LoST clients and servers MUST understand UTF-8 and UTF-16 encoded
   XML.  Additionally, LoST servers and clients MUST NOT encode XML with
   encodings other than UTF-8 or UTF-16.

17.  IANA Considerations

17.1.  U-NAPTR Registrations

   This document registers the following U-NAPTR application service
   tag:

      Application Service Tag:  LoST

      Defining Publication:  The specification contained within this
         document.

   This document registers the following U-NAPTR application protocol
   tags:

   o  Application Protocol Tag: http

      Defining Publication: RFC 2616 [3]

   o  Application Protocol Tag: https

      Defining Publication: RFC 2818 [4]

17.2.  Content-Type Registration for &#x27;application/lost+xml&#x27;

   This specification requests the registration of a new MIME type
   according to the procedures of RFC 4288 [7] and guidelines in RFC
   3023 [5].

   MIME media type name:  application

   MIME subtype name:  lost+xml

   Mandatory parameters:  none

   Optional parameters:  charset
      Indicates the character encoding of enclosed XML.

   Encoding considerations:  Uses XML, which can employ 8-bit
      characters, depending on the character encoding used.  See RFC
      3023 [5], Section 3.2.

   Security considerations:  This content type is designed to carry LoST
      protocol payloads.

   Interoperability considerations:  None

   Published specification:  RFC 5222

   Applications that use this media type:  Emergency and location-based
      systems

   Additional information:

      Magic Number:  None

      File Extension:  .lostxml

      Macintosh file type code:  &#x27;TEXT&#x27;

   Personal and email address for further information:
      Hannes Tschofenig, Hannes.Tschofenig@nsn.com

   Intended usage:  LIMITED USE

   Author:
      This specification is a work item of the IETF ECRIT working group,
      with mailing list address &lt;ecrit@ietf.org&gt;.

   Change controller:
      The IESG &lt;iesg@ietf.org&gt;

17.3.  LoST Relax NG Schema Registration

   URI:  urn:ietf:params:xml:schema:lost1

   Registrant Contact:  IETF ECRIT Working Group, Hannes Tschofenig
      (Hannes.Tschofenig@nsn.com).

   Relax NG Schema:  The Relax NG schema to be registered is contained
      in Section 15.  Its first line is

   default namespace = &quot;urn:ietf:params:xml:ns:lost1&quot;

   and its last line is

   }

17.4.  LoST Namespace Registration

   URI:  urn:ietf:params:xml:ns:lost1

   Registrant Contact:  IETF ECRIT Working Group, Hannes Tschofenig
      (Hannes.Tschofenig@nsn.com).

   XML:

BEGIN
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML Basic 1.0//EN&quot;
  &quot;http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd&quot;&gt;
&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;content-type&quot;
        content=&quot;text/html;charset=iso-8859-1&quot;/&gt;
  &lt;title&gt;LoST Namespace&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Namespace for LoST&lt;/h1&gt;
  &lt;h2&gt;urn:ietf:params:xml:ns:lost1&lt;/h2&gt;
&lt;p&gt;See &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc5222.txt&quot;&gt;
   RFC5222&lt;/a&gt;.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
END

17.5.  LoST Location Profile Registry

   This document creates a registry of location profile names for the
   LoST protocol.  Profile names are XML tokens.  This registry will
   operate in accordance with RFC 5226 [2], Standards Action.

   geodetic-2d:
      Defined in Section 12.2.

   civic:
      Defined in Section 12.3.

18.  Security Considerations

   There are several threats to the overall system of which service
   mapping forms a part.  An attacker that can obtain service contact
   URIs can use those URIs to attempt to disrupt those services.  An
   attacker that can prevent the lookup of contact URIs can impair the
   reachability of such services.  An attacker that can eavesdrop on the
   communication requesting this lookup can surmise the existence of an
   emergency and possibly its nature, and may be able to use this to
   launch a physical attack on the caller.

   To avoid an attacker modifying the query or its result, Transport
   Layer Security (TLS) MUST be implemented and SHOULD be used.  Use is
   RECOMMENDED both for clients&#x27; queries to servers and for queries
   among servers; this latter recommendation is to help avoid LoST cache
   poisoning attacks by replacing answers given to caching LoST servers.

   The use of server identity checks with TLS, as described in Section
   3.1 of [4], is also RECOMMENDED.  Omitting the server identity check
   allows an attacker to masquerade as a LoST server, so this approach
   should be used only when getting any answer, even from a potentially
   malicious LoST server, is preferred over closing the connection (and
   thus not getting any answer at all).  The host name compared against
   the server certificate is the host name in the URI, not the DNS name
   used as input to NAPTR resolution.

   Note that the security considerations in [22] recommend comparing the
   input of NAPTR resolution to the certificate, not the output (host
   name in the URI).  This approach was not chosen because in emergency
   service use cases, it is likely that deployments will see a large
   number of inputs to the U-NAPTR algorithm resolving to a single
   server, typically run by a local emergency services authority.  In
   this case, checking the input to the NAPTR resolution against the
   certificates provided by the LoST server would be impractical, as the
   list of organizations using it would be large, subject to rapid
   change, and unknown to the LoST server operator.

   The use of server identity does leave open the possibility of DNS-
   based attacks, as the NAPTR records may be altered by an attacker.
   The attacks include, for example, interception of DNS packets between
   the client and the recursive name server, DNS cache poisoning, and
   intentional modifications by the recursive name server; see [23] for
   more comprehensive discussion.

   DNS Security (DNSSEC) [20] can be used to protect against these
   threats.  While DNSSEC is incompletely deployed, users should be
   aware of the risk, particularly when they are requesting NAPTR
   records in environments where the local recursive name server, or the
   network between the client and the local recursive name server, is
   not considered trustworthy.

   LoST deployments that are unable to use DNSSEC and unwilling to trust
   DNS resolution without DNSSEC cannot use the NATPR-based discovery of
   LoST servers as is.  When suitable configuration mechanisms are
   available, one possibility is to configure the LoST server URIs
   (instead of the domain name to be used for NAPTR resolution)
   directly.  Future specifications for applying LoST in non-emergency
   services may also specify additional discovery mechanisms and name
   matching semantics.

   Generally, LoST servers will not need to authenticate or authorize
   clients presenting mapping queries.  If they do, an authentication of
   the underlying transport mechanism, such as HTTP basic and digest
   authentication, MAY be used.  Basic authentication SHOULD only be
   used in combination with TLS.

   A more detailed description of threats and security requirements is
   provided in [17].  The threats and security requirements in non-
   emergency service uses of LoST may be considerably different from
   those described here.  For example, an attacker might seek monetary
   benefit by returning service mapping information that directed users
   to specific service providers.  Before deploying LoST in new
   contexts, a thorough analysis of the threats and requirements
   specific to that context should be undertaken and decisions made on
   the appropriate mitigations.

19.  Acknowledgments

   We would like to the thank the following working group members for
   the detailed review of previous LoST document versions:

   o  Martin Thomson (Review July 2006)

   o  Jonathan Rosenberg (Review July 2006)

   o  Leslie Daigle (Review September 2006)

   o  Shida Schubert (Review November 2006)

   o  Martin Thomson (Review December 2006)

   o  Barbara Stark (Review January 2007)

   o  Patrik Faltstrom (Review January 2007)

   o  Shida Schubert (Review January 2007 as a designated expert
      reviewer)

   o  Jonathan Rosenberg (Review February 2007)

   o  Tom Taylor (Review February 2007)

   o  Theresa Reese (Review February 2007)

   o  Shida Schubert (Review February 2007)

   o  James Winterbottom (Review July 2007)

   o  Karl Heinz Wolf (Review May and June 2007)

   We would also like to thank the following working group members for
   their input to selected design aspects of the LoST protocol:

   o  Leslie Daigle and Martin Thomson (DNS-based LoST discovery
      procedure)

   o  John Schnizlein (authoritive LoST answers)

   o  Rohan Mahy (display names)

   o  James Polk (error handling)

   o  Ron Watro and Richard Barnes (expiry of cached data)

   o  Stephen Edge, Keith Drage, Tom Taylor, Martin Thomson, and James
      Winterbottom (indication of PSAP confidence level)

   o  Martin Thomson (service boundary references)

   o  Martin Thomson (service URN in LoST response message)

   o  Clive D.W. Feather, Martin Thomson (validation functionality)

   o  Roger Marshall (PSAP preference in LoST response)

   o  James Winterbottom, Marc Linsner, Keith Drage, Tom Taylor, Martin
      Thomson, John Schnizlein, Shida Schubert, Clive D.W. Feather,
      Richard Stastny, John Hearty, Roger Marshall, Jean-Francois Mule,
      Pierre Desjardins (location profiles)

   o  Michael Hammer, Patrik Faltstrom, Richard Stastny, Martin Thomson,
      Roger Marshall, Tom Taylor, Spencer Dawkins, Keith Drage (list
      services functionality)

   o  Martin Thomson, Michael Hammer (mapping of services)

   o  Shida Schubert, James Winterbottom, Keith Drage (default service
      URN)

   o  Otmar Lendl (LoST aggregation)

   o  Tom Taylor (terminology)

   Klaus Darilion and Marc Linsner provided miscellaneous input to the
   design of the protocol.  Finally, we would like to thank Brian Rosen,
   who participated in almost every discussion thread.

   Early implementation efforts led to good feedback by two open source
   implementation groups.  We would like to thank the implementers for
   their work and for helping us to improve the quality of the
   specification:

   o  Wonsang Song

   o  Jong-Yul Kim

   o  Anna Makarowska

   o  Krzysztof Rzecki

   o  Blaszczyk Piotr

   We would like to thank Jon Peterson, Dan Romascanu, Lisa Dusseault,
   and Tim Polk for their IESG review comments.  Blocking IESG comments
   were also received from Pasi Eronen (succeeding Sam Hartman&#x27;s review)
   and Cullen Jennings.  Adjustments have been made to several pieces of
   text to satisfy these requests for changes, most notably in the
   Security Considerations and in the discussion of redirection in the
   presence of overlapping coverage areas.

20.  References

20.1.  Normative References

   [1]   Bradner, S., &quot;Key words for use in RFCs to Indicate Requirement
         Levels&quot;, BCP 14, RFC 2119, March 1997.

   [2]   Narten, T. and H. Alvestrand, &quot;Guidelines for Writing an IANA
         Considerations Section in RFCs&quot;, BCP 26, RFC 5226, May 2008.

   [3]   Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L.,
         Leach, P., and T. Berners-Lee, &quot;Hypertext Transfer Protocol --
         HTTP/1.1&quot;, RFC 2616, June 1999.

   [4]   Rescorla, E., &quot;HTTP Over TLS&quot;, RFC 2818, May 2000.

   [5]   Murata, M., St. Laurent, S., and D. Kohn, &quot;XML Media Types&quot;,
         RFC 3023, January 2001.

   [6]   Peterson, J., &quot;A Presence-based GEOPRIV Location Object
         Format&quot;, RFC 4119, December 2005.

   [7]   Freed, N. and J. Klensin, &quot;Media Type Specifications and
         Registration Procedures&quot;, BCP 13, RFC 4288, December 2005.

   [8]   Daigle, L., &quot;Domain-Based Application Service Location Using
         URIs and the Dynamic Delegation Discovery Service (DDDS)&quot;,
         RFC 4848, April 2007.

   [9]   Schulzrinne, H., &quot;A Uniform Resource Name (URN) for Emergency
         and Other Well-Known Services&quot;, RFC 5031, January 2008.

   [10]  Thomson, M. and J. Winterbottom, &quot;Revised Civic Location Format
         for Presence Information Data Format Location Object
         (PIDF-LO)&quot;, RFC 5139, February 2008.

   [11]  Cox, S., Daisey, P., Lake, R., Portele, C., and A. Whiteside,
         &quot;Geographic information - Geography Markup Language (GML)&quot;, OGC
         Standard OpenGIS 03-105r1, April 2004.

   [12]  Reed, C. and M. Thomson, &quot;GML 3.1.1 PIDF-LO Shape Application
         Schema for use by the Internet Engineering Task Force (IETF)&quot;,
         Candidate OpenGIS Implementation Specification , December 2006.

20.2.  Informative References

   [13]  Winterbottom, J., Thomson, M., and H. Tschofenig, &quot;GEOPRIV
         PIDF-LO Usage Clarification, Considerations and
         Recommendations&quot;, Work in Progress, February 2008.

   [14]  Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A.,
         Peterson, J., Sparks, R., Handley, M., and E. Schooler, &quot;SIP:
         Session Initiation Protocol&quot;, RFC 3261, June 2002.

   [15]  Saint-Andre, P., Ed., &quot;Extensible Messaging and Presence
         Protocol (XMPP): Instant Messaging and Presence&quot;, RFC 3921,
         October 2004.

   [16]  Schulzrinne, H., &quot;The tel URI for Telephone Numbers&quot;, RFC 3966,
         December 2004.

   [17]  Taylor, T., Tschofenig, H., Schulzrinne, H., and M. Shanmugam,
         &quot;Security Threats and Requirements for Emergency Call Marking
         and Mapping&quot;, RFC 5069, January 2008.

   [18]  Schulzrinne, H. and R. Marshall, &quot;Requirements for Emergency
         Context Resolution with Internet Technologies&quot;, RFC 5012,
         January 2008.

   [19]  Schulzrinne, H., &quot;Location-to-URL Mapping Architecture and
         Framework&quot;, Work in Progress, September 2007.

   [20]  Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose,
         &quot;DNS Security Introduction and Requirements&quot;, RFC 4033,
         March 2005.

   [21]  Rosen, B. and J. Polk, &quot;Best Current Practice for
         Communications Services in support of Emergency Calling&quot;, Work
         in Progress, February 2008.

   [22]  Daigle, L. and A. Newton, &quot;Domain-Based Application Service
         Location Using SRV RRs and the Dynamic Delegation Discovery
         Service (DDDS)&quot;, RFC 3958, January 2005.

   [23]  Atkins, D. and R. Austein, &quot;Threat Analysis of the Domain Name
         System (DNS)&quot;, RFC 3833, August 2004.

   [24]  &lt;http://www.tschofenig.priv.at/svn/draft-ietf-ecrit-lost/
         RelaxNG&gt;.

   [25]  Schulzrinne, H., Polk, J., and H. Tschofenig, &quot;Discovering
         Location-to-Service Translation (LoST) Servers Using the
         Dynamic Host Configuration Protocol (DHCP)&quot;, RFC 5223,
         August 2008.

Appendix A.  Non-Normative RELAX NG Schema in XML Syntax

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;grammar ns=&quot;urn:ietf:params:xml:ns:lost1&quot;
           xmlns=&quot;http://relaxng.org/ns/structure/1.0&quot;
           xmlns:a=&quot;http://relaxng.org/ns/compatibility/annotations/1.0&quot;
           datatypeLibrary=&quot;http://www.w3.org/2001/XMLSchema-datatypes&quot;&gt;

           &lt;start&gt;
       &lt;a:documentation&gt;
         Location-to-Service Translation (LoST) Protocol

         A LoST XML instance has three request types, each with
         a corresponding response type: find service, list services,
         and get service boundary.
       &lt;/a:documentation&gt;
       &lt;choice&gt;
         &lt;ref name=&quot;findService&quot;/&gt;
         &lt;ref name=&quot;listServices&quot;/&gt;
         &lt;ref name=&quot;listServicesByLocation&quot;/&gt;
         &lt;ref name=&quot;getServiceBoundary&quot;/&gt;
         &lt;ref name=&quot;findServiceResponse&quot;/&gt;
         &lt;ref name=&quot;listServicesResponse&quot;/&gt;
         &lt;ref name=&quot;listServicesByLocationResponse&quot;/&gt;
         &lt;ref name=&quot;getServiceBoundaryResponse&quot;/&gt;
         &lt;ref name=&quot;errors&quot;/&gt;
         &lt;ref name=&quot;redirect&quot;/&gt;
       &lt;/choice&gt;
           &lt;/start&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         The queries.
       &lt;/a:documentation&gt;

       &lt;define name=&quot;findService&quot;&gt;
         &lt;element name=&quot;findService&quot;&gt;
           &lt;ref name=&quot;requestLocation&quot;/&gt;
           &lt;ref name=&quot;commonRequestPattern&quot;/&gt;
           &lt;optional&gt;
             &lt;attribute name=&quot;validateLocation&quot;&gt;
               &lt;data type=&quot;boolean&quot;/&gt;
               &lt;a:defaultValue&gt;false&lt;/a:defaultValue&gt;
             &lt;/attribute&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
             &lt;attribute name=&quot;serviceBoundary&quot;&gt;

               &lt;choice&gt;
                 &lt;value&gt;reference&lt;/value&gt;
                 &lt;value&gt;value&lt;/value&gt;
               &lt;/choice&gt;
               &lt;a:defaultValue&gt;reference&lt;/a:defaultValue&gt;
             &lt;/attribute&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
             &lt;attribute name=&quot;recursive&quot;&gt;
               &lt;data type=&quot;boolean&quot;/&gt;
                 &lt;a:defaultValue&gt;false&lt;/a:defaultValue&gt;
             &lt;/attribute&gt;
           &lt;/optional&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;listServices&quot;&gt;
         &lt;element name=&quot;listServices&quot;&gt;
           &lt;ref name=&quot;commonRequestPattern&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;listServicesByLocation&quot;&gt;
         &lt;element name=&quot;listServicesByLocation&quot;&gt;
           &lt;ref name=&quot;requestLocation&quot;/&gt;
           &lt;ref name=&quot;commonRequestPattern&quot;/&gt;
           &lt;optional&gt;
             &lt;attribute name=&quot;recursive&quot;&gt;
               &lt;data type=&quot;boolean&quot;/&gt;
               &lt;a:defaultValue&gt;true&lt;/a:defaultValue&gt;
             &lt;/attribute&gt;
           &lt;/optional&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;getServiceBoundary&quot;&gt;
         &lt;element name=&quot;getServiceBoundary&quot;&gt;
           &lt;ref name=&quot;serviceBoundaryKey&quot;/&gt;
           &lt;ref name=&quot;extensionPoint&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;
     &lt;/div&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         The responses.
       &lt;/a:documentation&gt;

       &lt;define name=&quot;findServiceResponse&quot;&gt;
         &lt;element name=&quot;findServiceResponse&quot;&gt;
           &lt;oneOrMore&gt;
             &lt;ref name=&quot;mapping&quot;/&gt;
           &lt;/oneOrMore&gt;
           &lt;optional&gt;
             &lt;ref name=&quot;locationValidation&quot;/&gt;
           &lt;/optional&gt;
           &lt;ref name=&quot;commonResponsePattern&quot;/&gt;
           &lt;ref name=&quot;locationUsed&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;listServicesResponse&quot;&gt;
         &lt;element name=&quot;listServicesResponse&quot;&gt;
           &lt;ref name=&quot;serviceList&quot;/&gt;
           &lt;ref name=&quot;commonResponsePattern&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;listServicesByLocationResponse&quot;&gt;
         &lt;element name=&quot;listServicesByLocationResponse&quot;&gt;
           &lt;ref name=&quot;serviceList&quot;/&gt;
           &lt;ref name=&quot;commonResponsePattern&quot;/&gt;
           &lt;ref name=&quot;locationUsed&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;getServiceBoundaryResponse&quot;&gt;
         &lt;element name=&quot;getServiceBoundaryResponse&quot;&gt;
           &lt;ref name=&quot;serviceBoundary&quot;/&gt;
           &lt;ref name=&quot;commonResponsePattern&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;
     &lt;/div&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         A pattern common to some of the queries.
       &lt;/a:documentation&gt;

       &lt;define name=&quot;commonRequestPattern&quot;&gt;
         &lt;ref name=&quot;service&quot;/&gt;
         &lt;optional&gt;
           &lt;ref name=&quot;path&quot;/&gt;

         &lt;/optional&gt;
         &lt;ref name=&quot;extensionPoint&quot;/&gt;
       &lt;/define&gt;
     &lt;/div&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         A pattern common to responses.
       &lt;/a:documentation&gt;

       &lt;define name=&quot;commonResponsePattern&quot;&gt;
         &lt;zeroOrMore&gt;
           &lt;ref name=&quot;warnings&quot;/&gt;
         &lt;/zeroOrMore&gt;
         &lt;ref name=&quot;path&quot;/&gt;
         &lt;ref name=&quot;extensionPoint&quot;/&gt;
       &lt;/define&gt;
     &lt;/div&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         Location in Requests
       &lt;/a:documentation&gt;

       &lt;define name=&quot;requestLocation&quot;&gt;
         &lt;oneOrMore&gt;
           &lt;element name=&quot;location&quot;&gt;
             &lt;attribute name=&quot;id&quot;&gt;
               &lt;data type=&quot;token&quot;/&gt;
             &lt;/attribute&gt;
             &lt;ref name=&quot;locationInformation&quot;/&gt;
           &lt;/element&gt;
         &lt;/oneOrMore&gt;
       &lt;/define&gt;
     &lt;/div&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         Location Information
       &lt;/a:documentation&gt;

       &lt;define name=&quot;locationInformation&quot;&gt;
         &lt;oneOrMore&gt;
           &lt;ref name=&quot;extensionPoint&quot;/&gt;
         &lt;/oneOrMore&gt;
         &lt;optional&gt;
           &lt;attribute name=&quot;profile&quot;&gt;
             &lt;data type=&quot;NMTOKEN&quot;/&gt;

           &lt;/attribute&gt;
         &lt;/optional&gt;
       &lt;/define&gt;
     &lt;/div&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         Service Boundary
       &lt;/a:documentation&gt;

       &lt;define name=&quot;serviceBoundary&quot;&gt;
         &lt;oneOrMore&gt;
           &lt;element name=&quot;serviceBoundary&quot;&gt;
             &lt;ref name=&quot;locationInformation&quot;/&gt;
           &lt;/element&gt;
         &lt;/oneOrMore&gt;
       &lt;/define&gt;
     &lt;/div&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         Service Boundary Reference
       &lt;/a:documentation&gt;

       &lt;define name=&quot;serviceBoundaryReference&quot;&gt;

         &lt;element name=&quot;serviceBoundaryReference&quot;&gt;
           &lt;ref name=&quot;source&quot;/&gt;
           &lt;ref name=&quot;serviceBoundaryKey&quot;/&gt;
           &lt;ref name=&quot;extensionPoint&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;serviceBoundaryKey&quot;&gt;
         &lt;attribute name=&quot;key&quot;&gt;
           &lt;data type=&quot;token&quot;/&gt;
         &lt;/attribute&gt;
       &lt;/define&gt;
     &lt;/div&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         Path -
         Contains a list of via elements -
         places through which information flowed
       &lt;/a:documentation&gt;

       &lt;define name=&quot;path&quot;&gt;
         &lt;element name=&quot;path&quot;&gt;
           &lt;oneOrMore&gt;
             &lt;element name=&quot;via&quot;&gt;
               &lt;ref name=&quot;source&quot;/&gt;
               &lt;ref name=&quot;extensionPoint&quot;/&gt;
             &lt;/element&gt;
           &lt;/oneOrMore&gt;
         &lt;/element&gt;
       &lt;/define&gt;
     &lt;/div&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         Location Used
       &lt;/a:documentation&gt;

       &lt;define name=&quot;locationUsed&quot;&gt;
         &lt;optional&gt;
           &lt;element name=&quot;locationUsed&quot;&gt;
             &lt;attribute name=&quot;id&quot;&gt;
               &lt;data type=&quot;token&quot;/&gt;
             &lt;/attribute&gt;
           &lt;/element&gt;
         &lt;/optional&gt;
       &lt;/define&gt;
     &lt;/div&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         Expires pattern
       &lt;/a:documentation&gt;

       &lt;define name=&quot;expires&quot;&gt;
         &lt;attribute name=&quot;expires&quot;&gt;
           &lt;choice&gt;
             &lt;data type=&quot;dateTime&quot;/&gt;
             &lt;value&gt;NO-CACHE&lt;/value&gt;
             &lt;value&gt;NO-EXPIRATION&lt;/value&gt;
           &lt;/choice&gt;
         &lt;/attribute&gt;
       &lt;/define&gt;
     &lt;/div&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         A QName list
       &lt;/a:documentation&gt;

       &lt;define name=&quot;qnameList&quot;&gt;
         &lt;list&gt;
           &lt;zeroOrMore&gt;
             &lt;data type=&quot;QName&quot;/&gt;
           &lt;/zeroOrMore&gt;
         &lt;/list&gt;
       &lt;/define&gt;
     &lt;/div&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         A location-to-service mapping.
       &lt;/a:documentation&gt;

       &lt;define name=&quot;mapping&quot;&gt;
         &lt;element name=&quot;mapping&quot;&gt;
           &lt;zeroOrMore&gt;
             &lt;element name=&quot;displayName&quot;&gt;
               &lt;data type=&quot;string&quot;/&gt;
               &lt;attribute name=&quot;xml:lang&quot;&gt;
                 &lt;data type=&quot;language&quot;/&gt;
               &lt;/attribute&gt;
             &lt;/element&gt;
           &lt;/zeroOrMore&gt;
           &lt;ref name=&quot;service&quot;/&gt;
           &lt;optional&gt;
             &lt;choice&gt;
               &lt;ref name=&quot;serviceBoundary&quot;/&gt;
               &lt;ref name=&quot;serviceBoundaryReference&quot;/&gt;
             &lt;/choice&gt;
           &lt;/optional&gt;
           &lt;zeroOrMore&gt;
             &lt;element name=&quot;uri&quot;&gt;
               &lt;data type=&quot;anyURI&quot;/&gt;
             &lt;/element&gt;
           &lt;/zeroOrMore&gt;
           &lt;optional&gt;
             &lt;element name=&quot;serviceNumber&quot;&gt;
               &lt;data type=&quot;token&quot;&gt;
                 &lt;param name=&quot;pattern&quot;&gt;[0-9*#]+&lt;/param&gt;
               &lt;/data&gt;
             &lt;/element&gt;
           &lt;/optional&gt;
           &lt;ref name=&quot;extensionPoint&quot;/&gt;
           &lt;ref name=&quot;expires&quot;/&gt;
           &lt;attribute name=&quot;lastUpdated&quot;&gt;
             &lt;data type=&quot;dateTime&quot;/&gt;
           &lt;/attribute&gt;

           &lt;ref name=&quot;source&quot;/&gt;
           &lt;attribute name=&quot;sourceId&quot;&gt;
             &lt;data type=&quot;token&quot;/&gt;
           &lt;/attribute&gt;
           &lt;ref name=&quot;message&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;
     &lt;/div&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         Location validation
       &lt;/a:documentation&gt;

       &lt;define name=&quot;locationValidation&quot;&gt;
         &lt;element name=&quot;locationValidation&quot;&gt;
           &lt;optional&gt;
             &lt;element name=&quot;valid&quot;&gt;
               &lt;ref name=&quot;qnameList&quot;/&gt;
             &lt;/element&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
             &lt;element name=&quot;invalid&quot;&gt;
               &lt;ref name=&quot;qnameList&quot;/&gt;
             &lt;/element&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
             &lt;element name=&quot;unchecked&quot;&gt;
               &lt;ref name=&quot;qnameList&quot;/&gt;
             &lt;/element&gt;
           &lt;/optional&gt;
           &lt;ref name=&quot;extensionPoint&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;
     &lt;/div&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         Errors and Warnings Container.
       &lt;/a:documentation&gt;

       &lt;define name=&quot;exceptionContainer&quot;&gt;
         &lt;interleave&gt;
           &lt;optional&gt;
             &lt;ref name=&quot;badRequest&quot;/&gt;
           &lt;/optional&gt;
           &lt;optional&gt;

             &lt;ref name=&quot;internalError&quot;/&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
             &lt;ref name=&quot;serviceSubstitution&quot;/&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
             &lt;ref name=&quot;defaultMappingReturned&quot;/&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
             &lt;ref name=&quot;forbidden&quot;/&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
             &lt;ref name=&quot;notFound&quot;/&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
             &lt;ref name=&quot;loop&quot;/&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
             &lt;ref name=&quot;serviceNotImplemented&quot;/&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
             &lt;ref name=&quot;serverTimeout&quot;/&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
             &lt;ref name=&quot;serverError&quot;/&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
             &lt;ref name=&quot;locationInvalid&quot;/&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
             &lt;ref name=&quot;locationProfileUnrecognized&quot;/&gt;
           &lt;/optional&gt;
         &lt;/interleave&gt;
         &lt;ref name=&quot;extensionPoint&quot;/&gt;
         &lt;ref name=&quot;source&quot;/&gt;
       &lt;/define&gt;

       &lt;define name=&quot;errors&quot;&gt;
         &lt;element name=&quot;errors&quot;&gt;
           &lt;ref name=&quot;exceptionContainer&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;warnings&quot;&gt;
         &lt;element name=&quot;warnings&quot;&gt;
           &lt;ref name=&quot;exceptionContainer&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

     &lt;/div&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         Basic Exceptions
       &lt;/a:documentation&gt;

       &lt;define name=&quot;basicException&quot;&gt;
         &lt;a:documentation&gt;
           Exception pattern.
         &lt;/a:documentation&gt;
         &lt;ref name=&quot;message&quot;/&gt;
         &lt;ref name=&quot;extensionPoint&quot;/&gt;
       &lt;/define&gt;

       &lt;define name=&quot;badRequest&quot;&gt;
         &lt;element name=&quot;badRequest&quot;&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;internalError&quot;&gt;
         &lt;element name=&quot;internalError&quot;&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;serviceSubstitution&quot;&gt;
         &lt;element name=&quot;serviceSubstitution&quot;&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;defaultMappingReturned&quot;&gt;
         &lt;element name=&quot;defaultMappingReturned&quot;&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;forbidden&quot;&gt;
         &lt;element name=&quot;forbidden&quot;&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;notFound&quot;&gt;
         &lt;element name=&quot;notFound&quot;&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;

         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;loop&quot;&gt;
         &lt;element name=&quot;loop&quot;&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;serviceNotImplemented&quot;&gt;
         &lt;element name=&quot;serviceNotImplemented&quot;&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;serverTimeout&quot;&gt;
         &lt;element name=&quot;serverTimeout&quot;&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;serverError&quot;&gt;
         &lt;element name=&quot;serverError&quot;&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;locationInvalid&quot;&gt;
         &lt;element name=&quot;locationInvalid&quot;&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;locationValidationUnavailable&quot;&gt;
         &lt;element name=&quot;locationValidationUnavailable&quot;&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;locationProfileUnrecognized&quot;&gt;
         &lt;element name=&quot;locationProfileUnrecognized&quot;&gt;
           &lt;attribute name=&quot;unsupportedProfiles&quot;&gt;
             &lt;data type=&quot;NMTOKENS&quot;/&gt;
           &lt;/attribute&gt;
           &lt;ref name=&quot;basicException&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;
     &lt;/div&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         Redirect.
       &lt;/a:documentation&gt;

       &lt;define name=&quot;redirect&quot;&gt;
         &lt;a:documentation&gt;
           Redirect pattern
         &lt;/a:documentation&gt;
         &lt;element name=&quot;redirect&quot;&gt;
           &lt;attribute name=&quot;target&quot;&gt;
             &lt;ref name=&quot;appUniqueString&quot;/&gt;
           &lt;/attribute&gt;
           &lt;ref name=&quot;source&quot;/&gt;
           &lt;ref name=&quot;message&quot;/&gt;
           &lt;ref name=&quot;extensionPoint&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;
     &lt;/div&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         Some common patterns.
       &lt;/a:documentation&gt;

       &lt;define name=&quot;message&quot;&gt;
         &lt;optional&gt;
           &lt;group&gt;
             &lt;attribute name=&quot;message&quot;&gt;
               &lt;data type=&quot;token&quot;/&gt;
             &lt;/attribute&gt;
             &lt;attribute name=&quot;xml:lang&quot;&gt;
               &lt;data type=&quot;language&quot;/&gt;
             &lt;/attribute&gt;
           &lt;/group&gt;
         &lt;/optional&gt;
       &lt;/define&gt;

       &lt;define name=&quot;service&quot;&gt;
         &lt;optional&gt;
           &lt;element name=&quot;service&quot;&gt;
             &lt;data type=&quot;anyURI&quot;/&gt;
           &lt;/element&gt;
         &lt;/optional&gt;
       &lt;/define&gt;

       &lt;define name=&quot;appUniqueString&quot;&gt;
         &lt;data type=&quot;token&quot;&gt;
           &lt;param name=&quot;pattern&quot;&gt;([a-zA-Z0-9\-]+\.)+[a-zA-Z0-9]+&lt;/param&gt;
         &lt;/data&gt;
       &lt;/define&gt;

       &lt;define name=&quot;source&quot;&gt;
         &lt;attribute name=&quot;source&quot;&gt;
           &lt;ref name=&quot;appUniqueString&quot;/&gt;
         &lt;/attribute&gt;
       &lt;/define&gt;

       &lt;define name=&quot;serviceList&quot;&gt;
         &lt;element name=&quot;serviceList&quot;&gt;
           &lt;list&gt;
             &lt;zeroOrMore&gt;
               &lt;data type=&quot;anyURI&quot;/&gt;
             &lt;/zeroOrMore&gt;
           &lt;/list&gt;
         &lt;/element&gt;
       &lt;/define&gt;
     &lt;/div&gt;

     &lt;div&gt;
       &lt;a:documentation&gt;
         Patterns for inclusion of elements from schemas in
         other namespaces.
       &lt;/a:documentation&gt;

       &lt;define name=&quot;notLost&quot;&gt;
         &lt;a:documentation&gt;
           Any element not in the LoST namespace.
         &lt;/a:documentation&gt;
         &lt;element&gt;
           &lt;anyName&gt;
             &lt;except&gt;
               &lt;nsName ns=&quot;urn:ietf:params:xml:ns:lost1&quot;/&gt;
               &lt;nsName/&gt;
             &lt;/except&gt;
           &lt;/anyName&gt;
           &lt;ref name=&quot;anyElement&quot;/&gt;
         &lt;/element&gt;
       &lt;/define&gt;

       &lt;define name=&quot;anyElement&quot;&gt;
         &lt;a:documentation&gt;

           A wildcard pattern for including any element
           from any other namespace.
         &lt;/a:documentation&gt;
         &lt;zeroOrMore&gt;
           &lt;choice&gt;
             &lt;element&gt;
               &lt;anyName/&gt;
               &lt;ref name=&quot;anyElement&quot;/&gt;
             &lt;/element&gt;
             &lt;attribute&gt;
               &lt;anyName/&gt;
             &lt;/attribute&gt;
             &lt;text/&gt;
           &lt;/choice&gt;
         &lt;/zeroOrMore&gt;
       &lt;/define&gt;

       &lt;define name=&quot;extensionPoint&quot;&gt;
         &lt;a:documentation&gt;
           A point where future extensions
           (elements from other namespaces)
           can be added.
         &lt;/a:documentation&gt;
         &lt;zeroOrMore&gt;
           &lt;ref name=&quot;notLost&quot;/&gt;
         &lt;/zeroOrMore&gt;
       &lt;/define&gt;
     &lt;/div&gt;

   &lt;/grammar&gt;

                                 Figure 21

Appendix B.  Examples Online

   The XML examples and Relax NG schemas may be found online [24].

Authors&#x27; Addresses

   Ted Hardie
   Qualcomm, Inc.

   EMail: hardie@qualcomm.com


   Andrew Newton
   American Registry for Internet Numbers
   3635 Concorde Parkway, Suite 200
   Chantilly, VA  20151
   US

   Phone: +1 703 227 9894
   EMail: andy@hxr.us


   Henning Schulzrinne
   Columbia University
   Department of Computer Science
   450 Computer Science Building
   New York, NY  10027
   US

   Phone: +1 212 939 7004
   EMail: hgs+ecrit@cs.columbia.edu
   URI:   http://www.cs.columbia.edu


   Hannes Tschofenig
   Nokia Siemens Networks
   Linnoitustie 6
   Espoo  02600
   Finland

   Phone: +358 (50) 4871445
   EMail: Hannes.Tschofenig@nsn.com
   URI:   http://www.tschofenig.priv.at

Full Copyright Statement

   Copyright (C) The IETF Trust (2008).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   &quot;AS IS&quot; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


        </re>
        
    </body>
</html>
