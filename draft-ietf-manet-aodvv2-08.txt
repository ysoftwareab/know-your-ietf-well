



Mobile Ad hoc Networks Working Group                          C. Perkins
Internet-Draft                                                 Futurewei
Intended status: Standards Track                              S. Ratliff
Expires: September 25, 2015                                      Idirect
                                                              J. Dowdell
                                                Airbus Defence and Space
                                                           L. Steenbrink
                                           HAW Hamburg, Dept. Informatik
                                                             V. Mercieca
                                                Airbus Defence and Space
                                                          March 24, 2015


                Dynamic MANET On-demand (AODVv2) Routing
                       draft-ietf-manet-aodvv2-08

Abstract

   The revised Ad Hoc On-demand Distance Vector (AODVv2) routing
   protocol is intended for use by mobile routers in wireless, multihop
   networks.  AODVv2 determines unicast routes among AODVv2 routers
   within the network in an on-demand fashion, offering rapid
   convergence in dynamic topologies.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on September 25, 2015.

Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents



Perkins, et al.        Expires September 25, 2015               [Page 1]

Internet-Draft                   AODVv2                       March 2015


   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . . .   4
   2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   5
   3.  Data Elements and Notational Conventions  . . . . . . . . . .   9
   4.  Applicability Statement . . . . . . . . . . . . . . . . . . .  10
   5.  AODVv2 Message Transmission . . . . . . . . . . . . . . . . .  12
   6.  Data Structures . . . . . . . . . . . . . . . . . . . . . . .  12
     6.1.  Route Table Entry . . . . . . . . . . . . . . . . . . . .  12
     6.2.  Next-hop Router Adjacency Monitoring and Blacklists . . .  14
     6.3.  Router Clients and Client Networks  . . . . . . . . . . .  15
     6.4.  Sequence Numbers  . . . . . . . . . . . . . . . . . . . .  16
     6.5.  Table for Multicast RteMsgs . . . . . . . . . . . . . . .  17
   7.  Metrics . . . . . . . . . . . . . . . . . . . . . . . . . . .  18
     7.1.  The Cost() function . . . . . . . . . . . . . . . . . . .  19
     7.2.  The LoopFree() function . . . . . . . . . . . . . . . . .  19
     7.3.  Default Metric type . . . . . . . . . . . . . . . . . . .  19
     7.4.  Alternate Metrics . . . . . . . . . . . . . . . . . . . .  19
   8.  AODVv2 Protocol Operations  . . . . . . . . . . . . . . . . .  20
     8.1.  Evaluating Incoming Routing Information . . . . . . . . .  20
     8.2.  Applying Route Updates To Route Table Entries . . . . . .  22
     8.3.  Route Maintenance . . . . . . . . . . . . . . . . . . . .  23
     8.4.  Route Table Entry Timeouts  . . . . . . . . . . . . . . .  23
     8.5.  Route Discovery, Retries and Buffering  . . . . . . . . .  24
     8.6.  Suppressing Redundant RteMsgs . . . . . . . . . . . . . .  25
   9.  AODVv2 Protocol Messages  . . . . . . . . . . . . . . . . . .  26
     9.1.  RREQ Messages . . . . . . . . . . . . . . . . . . . . . .  27
       9.1.1.  RREQ Generation . . . . . . . . . . . . . . . . . . .  28
       9.1.2.  RREQ Reception  . . . . . . . . . . . . . . . . . . .  29
       9.1.3.  RREQ Regeneration . . . . . . . . . . . . . . . . . .  31
     9.2.  RREP Messages . . . . . . . . . . . . . . . . . . . . . .  32
       9.2.1.  RREP Generation . . . . . . . . . . . . . . . . . . .  33
       9.2.2.  RREP Reception  . . . . . . . . . . . . . . . . . . .  34
       9.2.3.  RREP Regeneration . . . . . . . . . . . . . . . . . .  35
     9.3.  RERR Messages . . . . . . . . . . . . . . . . . . . . . .  36
       9.3.1.  RERR Generation . . . . . . . . . . . . . . . . . . .  37
       9.3.2.  RERR Reception  . . . . . . . . . . . . . . . . . . .  39
       9.3.3.  RERR Regeneration . . . . . . . . . . . . . . . . . .  40
     9.4.  RREP_Ack Messages . . . . . . . . . . . . . . . . . . . .  41
       9.4.1.  RREP_Ack Generation . . . . . . . . . . . . . . . . .  41



Perkins, et al.        Expires September 25, 2015               [Page 2]

Internet-Draft                   AODVv2                       March 2015


       9.4.2.  RREP_Ack Reception  . . . . . . . . . . . . . . . . .  41
   10. Representing AODVv2 data elements using RFC 5444  . . . . . .  42
   11. Simple Internet Attachment  . . . . . . . . . . . . . . . . .  43
   12. Optional Features . . . . . . . . . . . . . . . . . . . . . .  44
     12.1.  Expanding Rings Multicast  . . . . . . . . . . . . . . .  45
     12.2.  Precursor Lists and Notifications  . . . . . . . . . . .  45
       12.2.1.  Overview . . . . . . . . . . . . . . . . . . . . . .  45
       12.2.2.  Precursor Notification Details . . . . . . . . . . .  45
     12.3.  Multicast RREP Response to RREQ  . . . . . . . . . . . .  46
     12.4.  Intermediate RREP  . . . . . . . . . . . . . . . . . . .  46
     12.5.  Message Aggregation Delay  . . . . . . . . . . . . . . .  46
   13. Administratively Configurable Parameters and Timer Values . .  47
     13.1.  Timers . . . . . . . . . . . . . . . . . . . . . . . . .  47
     13.2.  Protocol Constants . . . . . . . . . . . . . . . . . . .  48
     13.3.  Administrative (functional) controls . . . . . . . . . .  49
     13.4.  Other administrative parameters and lists  . . . . . . .  49
   14. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  49
     14.1.  AODVv2 Message Types Specification . . . . . . . . . . .  50
     14.2.  Message TLV Type Specification . . . . . . . . . . . . .  50
     14.3.  Address Block TLV Specification  . . . . . . . . . . . .  50
     14.4.  MetricType Number Allocation . . . . . . . . . . . . . .  50
   15. Security Considerations . . . . . . . . . . . . . . . . . . .  51
   16. Acknowledgments . . . . . . . . . . . . . . . . . . . . . . .  52
   17. References  . . . . . . . . . . . . . . . . . . . . . . . . .  52
     17.1.  Normative References . . . . . . . . . . . . . . . . . .  52
     17.2.  Informative References . . . . . . . . . . . . . . . . .  53
   Appendix A.  Example Algorithms for AODVv2 Protocol Operations  .  54
     A.1.  Subroutines for AODVv2 Operations . . . . . . . . . . . .  58
       A.1.1.  Process_Routing_Info  . . . . . . . . . . . . . . . .  58
       A.1.2.  Fetch_Route_Table_Entry . . . . . . . . . . . . . . .  59
       A.1.3.  Update_Route_Table_Entry  . . . . . . . . . . . . . .  60
       A.1.4.  Create_Route_Table_Entry  . . . . . . . . . . . . . .  60
       A.1.5.  LoopFree  . . . . . . . . . . . . . . . . . . . . . .  61
       A.1.6.  Fetch_Rte_Msg_Table_Entry . . . . . . . . . . . . . .  62
       A.1.7.  Update_Rte_Msg_Table  . . . . . . . . . . . . . . . .  62
       A.1.8.  Build_RFC_5444_message_header . . . . . . . . . . . .  64
     A.2.  Example Algorithms for AODVv2 RREQ Operations . . . . . .  64
       A.2.1.  Generate_RREQ . . . . . . . . . . . . . . . . . . . .  64
       A.2.2.  Receive_RREQ  . . . . . . . . . . . . . . . . . . . .  65
       A.2.3.  Regenerate_RREQ . . . . . . . . . . . . . . . . . . .  66
     A.3.  Example Algorithms for AODVv2 RREP Operations . . . . . .  68
       A.3.1.  Generate_RREP . . . . . . . . . . . . . . . . . . . .  68
       A.3.2.  Receive_RREP  . . . . . . . . . . . . . . . . . . . .  69
       A.3.3.  Regenerate_RREP . . . . . . . . . . . . . . . . . . .  71
     A.4.  Example Algorithms for AODVv2 RERR Operations . . . . . .  72
       A.4.1.  Generate_RERR . . . . . . . . . . . . . . . . . . . .  73
       A.4.2.  Receive_RERR  . . . . . . . . . . . . . . . . . . . .  74
       A.4.3.  Regenerate_RERR . . . . . . . . . . . . . . . . . . .  76



Perkins, et al.        Expires September 25, 2015               [Page 3]

Internet-Draft                   AODVv2                       March 2015


     A.5.  Example Algorithms for AODVv2 RREP_Ack Operations . . . .  78
       A.5.1.  Generate_RREP_Ack . . . . . . . . . . . . . . . . . .  78
       A.5.2.  Receive_RREP_Ack  . . . . . . . . . . . . . . . . . .  78
       A.5.3.  Timeout_RREP_Ack  . . . . . . . . . . . . . . . . . .  78
   Appendix B.  Changes since revision ...-06.txt  . . . . . . . . .  78
   Appendix C.  Changes between revisions 5 and 6  . . . . . . . . .  80
   Appendix D.  Changes from revision ...-04.txt . . . . . . . . . .  81
   Appendix E.  Changes from revision ...-03.txt . . . . . . . . . .  82
   Appendix F.  Changes from revision ...-02.txt . . . . . . . . . .  82
   Appendix G.  Features of IP needed by AODVv2  . . . . . . . . . .  83
   Appendix H.  Multi-homing Considerations  . . . . . . . . . . . .  84
   Appendix I.  Shifting Network Prefix Advertisement Between AODVv2
                Routers  . . . . . . . . . . . . . . . . . . . . . .  84
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  84

1.  Overview

   The revised Ad Hoc On-demand Distance Vector (AODVv2) routing
   protocol [formerly named DYMO] enables on-demand, multihop unicast
   routing among AODVv2 routers in mobile ad hoc networks
   [MANETs][RFC2501].  The basic operations of the AODVv2 protocol are
   route discovery and route maintenance.  Route discovery is performed
   when an AODVv2 router must transmit a packet towards a destination
   for which it does not have a route.  Route maintenance is performed
   to avoid prematurely expunging routes from the route table, and to
   avoid dropping packets when a route breaks.

   During route discovery, the originating AODVv2 router (RREQ_Gen)
   disseminates a Route Request message (RREQ) to find a route toward
   some target destination.  Using a hop-by-hop regeneration algorithm,
   each AODVv2 router receiving the RREQ message records a route toward
   the originator.  When the target's AODVv2 router (RREP_Gen) receives
   the RREQ, it records a route toward RREQ_Gen and generates a Route
   Reply (RREP) unicast toward RREQ_Gen.  Each AODVv2 router that
   receives the RREP stores a route toward the target, and again
   unicasts the RREP toward the originator.  When RREQ_Gen receives the
   RREP, routes have then been established between RREQ_Gen (the
   originating AODVv2 router) and RREP_Gen (the target's AODVv2 router)
   in both directions.

   Route maintenance consists of two operations: continuously extending
   the lifetime of active routes, and using Route Error (RERR) message
   to invalidate routes that cannot be used to forward packets.  In
   order to maintain routes, AODVv2 routers extend route lifetimes upon
   successfully forwarding a packet.  When a data packet is received to
   be forwarded and no valid route exists, then the upstream routers and
   AODVv2 router of the source of the packet is notified of the error by
   way of an RERR message.  Route discovery would re-establish the



Perkins, et al.        Expires September 25, 2015               [Page 4]

Internet-Draft                   AODVv2                       March 2015


   route.  RERR messages are also used to notify upstream routers when
   routes break (say, due to loss of a link to a neighbor).

   AODVv2 uses sequence numbers to assure loop freedom [Perkins99],
   similarly to AODV.  Sequence numbers enable AODVv2 routers to
   determine the temporal order of AODVv2 route discovery messages,
   thereby avoiding use of stale routing information.

   See Section 10 for the mapping of AODVv2 data elements to RFC 5444
   Address Block, Address TLV, and Message TLV formats.  Security for
   authentication of AODVv2 routers, and/or encryption of traffic is
   dealt with by the underlying transport mechanism (e.g., by using the
   techniques for Authentication, Integrity, and Confidentiality
   documented in [RFC5444]).

2.  Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   [RFC2119].  In addition, this document uses terminology from
   [RFC5444], and defines the following terms:

   Adjacency
      A bi-directional relationship between neighboring AODVv2 routers
      for the purpose of exchanging routing information.  Not every pair
      of neighboring routers will necessarily form an adjacency.
      Monitoring of adjacencies where packets are being forwarded is
      required (see Section 6.2).

   AckReq
      Request for acknowledgement (of an RREP message).

   AODVv2 Router
      An IP addressable device in the ad-hoc network that performs the
      AODVv2 protocol operations specified in this document.

   Current_Time
      The current time as maintained by the AODVv2 router.

   Data Element
      A named object used within AODVv2 protocol messages

   Disregard
      Ignore for further processing.

   Handling Router (HandlingRtr)




Perkins, et al.        Expires September 25, 2015               [Page 5]

Internet-Draft                   AODVv2                       March 2015


      HandlingRtr denotes the AODVv2 router receiving and handling an
      AODVv2 message.

   Invalid route
      A route that cannot be used for forwarding.

   MANET
      A Mobile Ad Hoc Network as defined in [RFC2501].

   MetricList
      The metrics associated with the addresses in an AddressList.

   Node
      An IP addressable device in the ad-hoc network.  A node may be an
      AODVv2 router, or it may be a device in the network that does not
      perform any AODVv2 protocol operations.  All nodes in this
      document are either AODVv2 Routers or else Router Clients.

   OrigAddr
      An IP address of the Originating Node used as a data element
      within AODVv2 messages.

   OrigAddrMetric
      The metric associated with the route to OrigAddr.

   OrigSeqNum
      The Sequence Number maintained by OrigNode for OrigAddr.

   Originating Node (OrigNode)
      The Originating Node is the node that launched the application
      requiring communication with the Target Address.  If OrigNode is a
      Router Client, its AODVv2 router (RREQ_Gen) has the responsibility
      to generate a AODVv2 RREQ message on behalf of OrigNode as
      necessary to discover a route.

   PktSource
      The source address of a packet sent to an unreachable address.

   PrefixLengthList
      The prefix lengths associated with addresses in an AddressList.

   Reactive
      A protocol operation is called "reactive" if it is performed only
      in reaction to specific events.  As used in this document,
      "reactive" is synonymous with "on-demand".

   Routable Unicast IP Address




Perkins, et al.        Expires September 25, 2015               [Page 6]

Internet-Draft                   AODVv2                       March 2015


      A routable unicast IP address is a unicast IP address that is
      scoped sufficiently to be forwarded by a router.  Globally-scoped
      unicast IP addresses and Unique Local Addresses (ULAs).[RFC4193]
      are examples of routable unicast IP addresses.

   Route Error (RERR)
      A RERR message is used to indicate that an AODVv2 router does not
      have a route toward one or more particular destinations.

   Route Reply (RREP)
      A RREP message is used to establish a route between the Target
      Address and the Originating Address, at all the AODVv2 routers
      between them.

   Route Request (RREQ)
      An AODVv2 router uses a RREQ message to discover a valid route to
      a particular destination address, called the Target Address.  An
      AODVv2 router processing a RREQ receives routing information for
      the Originating Address.

   Router Client
      A node that requires the services of an AODVv2 router for route
      discovery and maintenance.  An AODVv2 router is always its own
      client, so that its list of client IP addresses is never empty.

   Router Interface
      An interface supporting the transmission or reception of Router
      Messages.

   RREP Generating Router (RREP_Gen)
      The RREP Generating Router is the AODVv2 router that serves
      TargNode.  RREP_Gen generates the RREP message to advertise a
      route towards TargAddr from OrigAddr.

   RREQ Generating Router (RREQ_Gen)
      The RREQ Generating Router is the AODVv2 router that serves
      OrigNode.  RREQ_Gen generates the RREQ message to discover a route
      for TargAddr.

   Sequence Number (SeqNum)
      A Sequence Number is an unsigned integer maintained by an AODVv2
      router to avoid re-use of stale messages.  The router associates
      SeqNum with an IP address of one or more of its network
      interfaces.  The value zero (0) is reserved to indicate that the
      Sequence Number for an address is unknown.

   SeqNumList




Perkins, et al.        Expires September 25, 2015               [Page 7]

Internet-Draft                   AODVv2                       March 2015


      The list of Sequence Numbers associated with addresses in an
      AddressList, used in RERR messages.

   TargAddr
      An IP address of the Target Node used as a data element within
      AODVv2 messages.

   TargAddrMetric
      The metric associated with the route to TargAddr.

   TargSeqNum
      The Sequence Number maintained by TargNode for TargAddr.

   Target Node (TargNode)
      The node hosting the IP address towards which a route is needed.

   Type-Length-Value structure (TLV)
      A generic way to represent information, for example as used in
      [RFC5444].

   Unreachable Address
      An address for which a valid route is not known.

   upstream
      In the direction from TargAddr to OrigAddr.

   Valid route
      A route that can be used for forwarding.

   ValidityTime
      The duration of time for which a route should be considered to be
      a valid route.



















Perkins, et al.        Expires September 25, 2015               [Page 8]

Internet-Draft                   AODVv2                       March 2015


3.  Data Elements and Notational Conventions

   This document uses the Data Elements and conventions found in Table 1
   and Table 2.

   +--------------------+----------------------------------------------+
   | Data Elements      | Meaning                                      |
   +--------------------+----------------------------------------------+
   | msg_hop_limit      | Number of hops allowable for the message     |
   | msg_hop_count      | Number of hops traversed so far by the       |
   |                    | message                                      |
   | AckReq             | Acknowledgement Requested for RREP           |
   | PktSource          | Source address of a data packet              |
   | AddressList        | A list of IP addresses                       |
   | OrigAddr           | IP address of the Originating Node           |
   | TargAddr           | IP address of the Target Node                |
   | UnreachableAddress | An unreachable IP address                    |
   | PrefixLengthList   | Routing prefixes associated with addresses   |
   |                    | in AddressList                               |
   | SeqNum             | Sequence Number, used in RERR messages       |
   | SeqNumList         | A list of SeqNums                            |
   | OrigSeqNum         | Originating Node Sequence Number             |
   | TargSeqNum         | Target Node Sequence Number                  |
   | MetricType         | The metric type for values in MetricList     |
   | MetricList         | Metric values for routes to addresses in     |
   |                    | AddressList                                  |
   | OrigAddrMetric     | Metric value for route to OrigAddr           |
   | TargAddrMetric     | Metric value for route to TargAddr           |
   | ValidityTime       | Included in ValidityTimeList                 |
   | ValidityTimeList   | ValidityTime values for routes to Addresses  |
   |                    | in AddressList                               |
   +--------------------+----------------------------------------------+

                                  Table 1

















Perkins, et al.        Expires September 25, 2015               [Page 9]

Internet-Draft                   AODVv2                       March 2015


   +------------------------+------------------------------------------+
   | Notation               | Meaning                                  |
   +------------------------+------------------------------------------+
   | Route[Address]         | A route table entry towards Address      |
   | Route[Address].{field} | A field in such a route table entry      |
   | --                     | --                                       |
   | RREQ_Gen               | AODVv2 router originating an RREQ        |
   | RREP_Gen               | AODVv2 router responding to an RREQ      |
   | RERR_Gen               | AODVv2 router originating an RERR        |
   | RteMsg                 | Either RREQ or RREP                      |
   | RteMsg.{field}         | Field in RREQ or RREP                    |
   | AdvRte                 | A route advertised in an incoming RteMsg |
   | HandlingRtr            | Handling Router                          |
   +------------------------+------------------------------------------+

                                  Table 2

4.  Applicability Statement

   The AODVv2 routing protocol is a reactive routing protocol designed
   for stub (i.e., non-transit) or disconnected (i.e., from the
   Internet) mobile ad hoc networks (MANETs).  AODVv2 handles a wide
   variety of mobility patterns by determining routes on-demand.  AODVv2
   also handles a wide variety of traffic patterns.  In networks with a
   large number of routers, AODVv2 is best suited for relatively sparse
   traffic scenarios where any particular router forwards packets to
   only a small percentage of the AODVv2 routers in the network, due to
   the on-demand nature of route discovery and route maintenance.
   AODVv2 supports routers with multiple interfaces, as long as each
   interface has its own (unicast routeable) IP address; the set of all
   network interfaces supporting AODVv2 is administratively configured
   in a list (namely, AODVv2_INTERFACES).

   Ad Hoc networks have been deployed in many circumstances, including
   for emergency and disaster relief.  In those circumstances, it is
   sometimes the case that the simple ability to communicate is much
   more important than being assured of secure operations.  AODVv2 is
   very well suited for such reactive scenarios.  For other ad hoc
   networking applications, in which insecure operation could negate the
   value of establishing communication paths, it is important for
   neighboring AODVv2 nodes to establish security associations with one
   another.

   Although AODVv2 is closely related to AODV [RFC3561], and shares some
   features of DSR [RFC4728], AODVv2 is not interoperable with either of
   those other two protocols.





Perkins, et al.        Expires September 25, 2015              [Page 10]

Internet-Draft                   AODVv2                       March 2015


   AODVv2 is applicable to memory constrained devices, since only a
   little routing state is maintained in each AODVv2 router.  Routes
   that are not needed for forwarding data do not have to be maintained,
   in contrast to proactive routing protocols that require routing
   information to all routers within the MANET be maintained.

   In addition to routing for its own local applications, each AODVv2
   router can also route on behalf of other non-routing nodes (in this
   document, "Router Clients") that are directly reachable via its
   network interfaces.  Each AODVv2 router, if serving router clients
   other than itself, SHOULD be configured with information about the IP
   addresses of its clients, using any suitable method.  In the initial
   state, no AODVv2 router is required to have information about the
   relationship between any other AODVv2 router and its Router Clients
   (see Section 6.3).

   The coordination among multiple AODVv2 routers to distribute routing
   information correctly for a shared address (i.e. an address that is
   advertised and can be reached via multiple AODVv2 routers) is not
   described in this document.  The AODVv2 router operation of shifting
   responsibility for a routing client from one AODVv2 router to another
   is described in Appendix I.  Address assignment procedures are
   entirely out of scope for AODVv2.  A Router Client SHOULD NOT be
   served by more than one AODVv2 router at any one time.

   AODVv2 routers perform route discovery to find a route toward a
   particular destination.  AODVv2 routers MUST must be configured to
   respond to RREQs for themselves and their clients.  When AODVv2 is
   the only protocol interacting with the forwarding table, AODVv2 MAY
   be configured to perform route discovery for all unknown unicast
   destinations.  Such routers will reply for each address request.

   By default, AODVv2 only supports bidirectional links.  In the case of
   possible unidirectional links, blacklists (see Section 6.2) SHOULD be
   used, or other means (e.g.  adjacency establishment with only
   neighboring routers that have bidirectional communication as
   indicated by NHDP HELLO messages [RFC6130]) of assuring and
   monitoring bi-directionality are recommended.  Otherwise, persistent
   packet loss or persistent protocol failures could occur.  If received
   over a link that is unidirectional, metric information from incoming
   AODVv2 messages MUST NOT be used for route table updates.

   The routing algorithm in AODVv2 may be operated at layers other than
   the network layer, using layer-appropriate addresses.  The routing
   algorithm makes use of some persistent state; if there is no
   persistent storage available for this state, recovery can impose a
   performance penalty (e.g., in case of AODVv2 router reboots).




Perkins, et al.        Expires September 25, 2015              [Page 11]

Internet-Draft                   AODVv2                       March 2015


5.  AODVv2 Message Transmission

   In its default mode of operation, AODVv2 sends messages using the
   parameters for port number and IP protocol specified in [RFC5498].
   Unless otherwise specified, the address for AODVv2 multicast messages
   (for example, RREQ or RERR) is the link-local multicast address LL-
   MANET-Routers [RFC5498].  All AODVv2 routers MUST subscribe to LL-
   MANET-Routers [RFC5498] to receive AODVv2 messages.  Implementations
   are free to choose their own heuristics for reducing multicast
   overhead.  Some methods for doing so are described in [RFC6621].
   AODVv2 does not specify which method should be used to restrict the
   set of AODVv2 routers that have the responsibility to regenerate
   multicast packets.  Note that multicast packets MAY be sent via
   unicast.  For example, this may occur for certain link-types (non-
   broadcast media), for manually configured router adjacencies, or in
   order to improve robustness.

   When multiple interfaces are available, a node transmitting a
   multicast packet to LL-MANET-Routers MUST send the packet on all
   interfaces that have been configured for AODVv2 operation.
   Similarly, AODVv2 routers MUST subscribe to LL-MANET-Routers on all
   their AODVv2 interfaces.

   IP packets containing AODVv2 protocol messages SHOULD be given
   priority queuing and channel access.

6.  Data Structures

6.1.  Route Table Entry

   The route table entry is a conceptual data structure.
   Implementations MAY use any internal representation so long as it
   provides access to the information specified below.

   A route table entry has the following fields:

   Route.Address
      An address or address prefix of a node

   Route.PrefixLength
      The length of the address or prefix.  If the value of
      Route.PrefixLength is less than the length of Route.Address, the
      route can be thought of as a route to the subnet on which
      Route.Address resides.  A PrefixLength is stored for every route
      in the route table.

   Route.SeqNum




Perkins, et al.        Expires September 25, 2015              [Page 12]

Internet-Draft                   AODVv2                       March 2015


      The Sequence Number associated with Route.Address, as obtained
      from the last packet that successfully updated this route table
      entry.

   Route.NextHop
      The IP address of the adjacent AODVv2 router used for the path
      toward the Route.Address

   Route.NextHopInterface
      The interface used to send packets toward Route.Address

   Route.LastUsed
      The time that this route was last used to forward a packet

   Route.LastSeqNum
      The time that the destination SeqNum for this route was last
      updated

   Route.ExpirationTime
      The time at which this route must be marked as Invalid

   Route.MetricType
      The type of the metric for the route towards Route.Address

   Route.Metric
      The cost of the route towards Route.Address expressed in units
      consistent with Route.MetricType

   Route.State
      The last *known* state (one of Active, Idle, or Invalid) of the
      route

   Route.Timed
      TRUE if the route was specified to have a ValidityTime

   Route.Precursors (optional)
      A list of upstream neighbors using the route (see Section 12.2)

   A route table entry (i.e., a route) is in one of the following
   states:

   Active
      An Active route is in current use for forwarding packets.  An
      Active route is maintained continuously by AODVv2 and is
      considered to remain active as long as it is used at least once
      during every ACTIVE_INTERVAL, or if the Route.Timed flag is true.
      When a route that is not a timed route is no longer active the
      route becomes an Idle route.



Perkins, et al.        Expires September 25, 2015              [Page 13]

Internet-Draft                   AODVv2                       March 2015


   Idle
      An Idle route can be used for forwarding packets, even though it
      is not in current use.  If an Idle route is used to forward a
      packet, it becomes an Active route once again.  After an Idle
      route remains idle for MAX_IDLETIME, it becomes an Invalid route.

   Invalid
      A route marked as Invalid cannot be used for forwarding, but the
      sequence number information MAY be maintained until the
      destination sequence number has not had any updates for
      MAX_SEQNUM_LIFETIME; after that time, old sequence number
      information may no longer be valid and the Invalid route MUST be
      expunged.

   MAX_SEQNUM_LIFETIME is the time after a reboot during which an AODVv2
   router MUST NOT respond to any routing messages that require
   information about its Sequence Number.  Thus, if all other AODVv2
   routers expunge routes to the rebooted router after that time
   interval, the rebooted AODVv2 router's sequence number will not be
   considered stale by any other AODVv2 router in the MANET.

   The invalidation of a Timed route is controlled by the ExpirationTime
   time of the route table entry (instead of MAX_IDLETIME).  Until that
   time, a Timed route can be used for forwarding packets.  A route is
   indicated to be a Timed route by the setting of the Timed flag in the
   route table entry.  Afterwards, the route MAY be expunged; otherwise
   the route must be must be marked as Invalid.

6.2.  Next-hop Router Adjacency Monitoring and Blacklists

   Neighboring routers MAY form an adjacency based on AODVv2 messages,
   other protocols (e.g.  NDP [RFC4861] or NHDP [RFC6130]), or manual
   configuration.  Loss of a routing adjacency may also be indicated
   similarly.  AODVv2 routers SHOULD monitor connectivity to adjacent
   routers along active routes.  In the absence of other information
   about bidirectional connectivity, the default approach for AODVv2
   routers to monitor connectivity to neighboring AODVv2 routers is to
   include the AckReq data element in RREP messages, and send RREP_Ack
   messages to fulfill the requests (see Sections 9.2 and 9.4).
   However, when routers perform other operations such as those from the
   list below, these can also be used as indications of connectivity.

   o  NHDP HELLO Messages [RFC6130], if is implemented by its neighbors

   o  Route timeout

   o  Lower layer triggers, e.g. message reception or link status
      notifications



Perkins, et al.        Expires September 25, 2015              [Page 14]

Internet-Draft                   AODVv2                       March 2015


   o  TCP timeouts

   o  Promiscuous listening

   o  Other monitoring mechanisms or heuristics

   For example, receipt of a Neighborhood Discovery message would signal
   a connection to the sender.  In this case, the AODVv2 router doesn't
   need to request an acknowledgement in the RREP.  Similarly, if AODVv2
   received notification of a timeout, this may possibly be due to a
   disconnection, and the AODVv2 router SHOULD attempt to verify
   connectivity by including AckReq data element when sending a RREP to
   that neighbor.

   When a link to a neighbor is determined to be unidirectional, either
   by failure to respond with a RREP_Ack as requested, or by some other
   means, the neighbor MUST be placed in a blacklist.  However, the
   blacklisted neighbor SHOULD NOT be permanently blacklisted; after a
   certain time (MAX_BLACKLIST_TIME), it SHOULD once again be considered
   as a viable neighbor for route discovery operations.

   For this purpose, a list of blacklisted routers along with their time
   of removal SHOULD be maintained:

   Blacklist.Router
      An IP address of the router that did not verify bidirectional
      connectivity

   Blacklist.RemoveTime
      The time at which Blacklist.Router SHOULD be removed from the
      blacklist

   RREQs received from a blacklisted router, or any router over a link
   that is known to be incoming-only, MUST be disregarded.  If other
   indications are received that a blacklisted router has restored
   bidirectional connectivity, for instance receiving NHDP HELLO
   messages, then the router SHOULD be immediately removed from the
   blacklist.

6.3.  Router Clients and Client Networks

   An AODVv2 router may offer routing services to other nodes that are
   not AODVv2 routers; such nodes are called Router Clients in this
   document.

   For this purpose, CLIENT_ADDRESSES must be configured on each AODVv2
   router with the following information:




Perkins, et al.        Expires September 25, 2015              [Page 15]

Internet-Draft                   AODVv2                       March 2015


   Client IP address
      The IP address of the node that requires routing service from the
      AODVv2 router.

   Client Prefix Length
      The length of the routing prefix associated with the client IP
      address.

   The list of Routing Clients for an AODVv2 router is never empty,
   since an AODVv2 router is always its own client as well.  If the
   Client Prefix Length is not the full length of the Client IP address,
   then the prefix defines a Client Network.  If an AODVv2 router is
   configured to serve a Client Network, then the AODVv2 router MUST
   serve every node that has an address within the range defined by the
   routing prefix of the Client Network.

6.4.  Sequence Numbers

   Sequence Numbers allow AODVv2 routers to evaluate the freshness of
   routing information.  Each AODVv2 router in the network MUST maintain
   its own sequence number (SeqNum).  Each RREQ and RREP generated by an
   AODVv2 router includes its SeqNum.  Each AODVv2 router MUST ensure
   that its SeqNum is monotonically increasing.  The router can ensure
   this by incrementing SeqNum whenever it generates RREQ or RREP .

   A router receiving a RREQ or RREP message uses the Sequence Number in
   the message to determine the freshness of a route update: if a new
   Sequence Number in the message is lower than the one stored in the
   route table, the stored information for that route is considered
   stale.

   As a consequence, loop freedom is assured.

   If the router has multiple network interfaces, it can use the same
   SeqNum for the IP addresses of all of them, or it can assign
   different SeqNums for use with different IP addresses.  However, the
   router MUST NOT use multiple SeqNums for any particular IP address.
   A Router Client has the same SeqNum as the IP address of the network
   interface that the AODVv2 router uses to forward packets to that
   Router Client.  Similarly, a route to a subnet has the same SeqNum as
   the IP address of the network interface that the AODVv2 router uses
   to forward packets to that subnet.  The Sequence Number fulfills the
   same role as the "Destination Sequence Number" of DSDV [Perkins94],
   and as the AODV Sequence Number in RFC 3561[RFC3561].

   An AODVv2 router increments its SeqNum as follows.  Most of the time,
   SeqNum is incremented by simply adding one (1).  But when the SeqNum
   has the value of the largest possible number representable as a



Perkins, et al.        Expires September 25, 2015              [Page 16]

Internet-Draft                   AODVv2                       March 2015


   16-bit unsigned integer (i.e., 65,535), it MUST be incremented by
   setting to one (1).  In other words, the sequence number after 65,535
   is 1.

   An AODVv2 router SHOULD maintain its SeqNum in persistent storage.
   If an AODVv2 router's SeqNum is lost, it MUST take the following
   actions to avoid the danger of routing loops.  First, the AODVv2
   router MUST set Route.State := Invalid for each entry.  Furthermore
   the AODVv2 router MUST wait for at least MAX_SEQNUM_LIFETIME before
   transmitting or regenerating any AODVv2 RREQ or RREP messages.  If an
   AODVv2 protocol message is received during this waiting period, the
   AODVv2 router SHOULD perform normal route table entry updates, but
   not forward the message to other nodes.  If, during this waiting
   period, a data packet is received to be forwarded to another
   destination that is not among the router's Clients, then the AODVv2
   router MUST transmit a RERR message indicating that no route is
   available.  However, packets destined to a Client are forwarded as
   usual.  At the end of the waiting period the AODVv2 router sets its
   SeqNum to one (1) and begins performing AODVv2 protocol operations
   again.

6.5.  Table for Multicast RteMsgs

   Two multicast RteMsgs (i.e., RREQ or RREP) are considered to be
   "comparable" if they have the same Message Type, OrigAddr, TargAddr,
   and MetricType.  When RteMsgs are flooded in a MANET, an AODVv2
   router may well receive such comparable RteMsgs from its neighbors.
   A router, after receiving a RteMsg, MUST check against previous
   RteMsgs to assure that its response message would contain information
   that is not redundant.  Otherwise, multicast RteMsgs are likely to be
   regenerated repeatedly with almost no additional benefit, but
   generating a great deal of unnecessary signaling traffic and
   interference.  See Section 8.6 regarding suppression of redundant
   RteMsgs.

   To avoid transmission of redundant RteMsgs, while still enabling the
   proper handling of earlier RteMsgs that may have somehow been delayed
   in the network, each AODVv2 router keeps a list of certain
   information about recently received RteMsgs.  This list is called the
   AODVv2 Multicast RteMsg Table -- or, more briefly, the RteMsg Table.

   Each entry in the RteMsg Table has the following fields:

   o  Message Type (either RREQ or RREP)

   o  OrigAddr

   o  TargAddr



Perkins, et al.        Expires September 25, 2015              [Page 17]

Internet-Draft                   AODVv2                       March 2015


   o  OrigSeqNum (if present)

   o  TargSeqNum (if present)

   o  MetricType

   o  Timestamp (Current_Time at the time the entry is updated)

   The RteMsg Table is maintained so that no two entries in the RteMsg
   Table are comparable -- that is, all RteMsgs represented in the
   RteMsg Table either have different Message Types, different OrigAddr,
   different TargAddr, or different metric types.  If two RteMsgs have
   the same Message Type, MetricType, OrigAddr, and TargAddr, the
   information from the one with the older Sequence Number is not needed
   in the table; in case they have the same Sequence Number, the one
   with the greater Metric value is not needed; in case they have the
   same Metric as well, it does not matter which table entry is
   maintained.  Whenever a RteMsg Table entry is updated, its Timestamp
   field MUST also set to be the Current_Time.

7.  Metrics

   Metrics measure a cost or quality associated to a route or a link.
   They can account for various characteristics such as latency, delay,
   financial, energy, etc.  A metric value is included in each routing
   table entry.  Determining whether to use incoming information about a
   route requires comparing metric values.  Whenever an AODV router
   receives metric information in an incoming message, the received
   value of the metric is as measured by the neighbor router, and does
   not reflect the cost of traversing the link to that neighbor.

   Each metric has a MetricType, which is allocated by IANA as specified
   in [RFC6551].  Apart from its default metric type as detailed in
   Section 7.3, AODVv2 enables the use of monotonically increasing
   metrics, whose data type depends on the metric used.  Using non-
   default metrics in a RteMsg requires the inclusion of the MetricType
   data element.  Routes are looked up according to metric type, and
   intermediate routers handling a RteMsg assign the same metric type to
   all metric information in the RteMsg.

   For each type of metric, a maximum value is defined, denoted
   MAX_METRIC[i] where 'i' is the MetricType.  AODVv2 cannot store
   routes in its route table that cost more than MAX_METRIC[i].








Perkins, et al.        Expires September 25, 2015              [Page 18]

Internet-Draft                   AODVv2                       March 2015


7.1.  The Cost() function

   In order to simplify the description of storing accumulated route
   costs in the route table, a Cost() function is defined.  This
   function returns the Cost of traversing a Route ('Cost(R)') or a Link
   ('Cost(L)').  Cost(L) for DEFAULT_METRIC_TYPE is specified in
   Section 7.3.  The Cost() function for other metrics is beyond the
   scope of this document.

7.2.  The LoopFree() function

   Since determining loop freedom is known to depend on comparing the
   Cost(R1) of advertised route update information to the Cost(R2) of an
   existing stored route using the same metric type, AODVv2 invokes a
   function called "LoopFree(R1, R2)".  LoopFree(R1, R2) returns TRUE
   when R1 is guaranteed to not rely on the route R2, i.e. R2 is not a
   subroute of the route R1.  An AODVv2 router invokes LoopFree() to
   compare an advertised route to a stored route.  The advertised route
   is referred to as AdvRte and is used as parameter R1.  The stored
   route is referred to as Route and is used as parameter R2.

7.3.  Default Metric type

   The default MetricType (DEFAULT_METRIC_TYPE) is HopCount (but see
   Section 7.4).  HopCount is the only metric described in detail in
   this document.  For the HopCount metric, Cost(L) is always 1, and
   Cost(R) is the hop count between the router and the destination.

   MAX_METRIC[DEFAULT_METRIC_TYPE] is defined to be MAX_HOPCOUNT.
   MAX_HOPCOUNT MUST be larger than the AODVv2 network diameter.
   Otherwise, AODVv2 protocol messages may not reach their intended
   destinations.

   Using MetricType DEFAULT_METRIC_TYPE, LoopFree (AdvRte, Route) is
   TRUE when Cost(AdvRte) <= Cost(Route).  The specification of Cost(R)
   and LoopFree(AdvRte, Route) for metric types other than
   DEFAULT_METRIC_TYPE is beyond the scope of this document.

7.4.  Alternate Metrics

   Some applications may require metric information other than HopCount,
   which has traditionally been the default metric associated with
   routes in MANET.  It is well known that reliance on HopCount can
   cause selection of the worst possible route in some situations.  For
   this reason, AODVv2 enables route selection based on metric
   information other than HopCount -- in other words, based on
   "alternate metrics".




Perkins, et al.        Expires September 25, 2015              [Page 19]

Internet-Draft                   AODVv2                       March 2015


   The range and data type of each such alternate metric may be
   different.  For instance, the data type might be integers, or
   floating point numbers, or restricted subsets thereof.  It is out of
   the scope of this document to specify for alternate metrics the
   Cost(L) and Cost(R) functions, or their return type.  Where necessary
   these should take into account any differences in the link cost in
   each direction.

8.  AODVv2 Protocol Operations

   In this section, operations are specified for updating the route
   table using information within AODVv2 RteMsgs (either RREQ or RREP),
   and due to timeouts.  AdvRte is the route advertised by the RteMsg.
   RteMsgs include IP addresses as well as possibly the SeqNum and the
   prefix lengths associated with those IP addresses.  The AdvRte also
   includes the metric measured from the neighbor transmitting the
   RteMsg to the IP address originating the route update.  All SeqNum
   comparisons use signed 16-bit arithmetic.

8.1.  Evaluating Incoming Routing Information

   After determining that the incoming information is correctly
   formatted and contains values in the correct ranges, the AODVv2
   router will use the information to update local routing information
   if possible.  This section explains how to determine whether the
   incoming information should be used to update the route table, and
   how to perform the update.

   The incoming RteMsg may be a RREQ or a RREP.  If it is a RREQ, it
   contains information about a route to OrigAddr.  Prefix length
   information in a RREQ, if present, describes the subnet on which
   OrigAddr resides.  If it is a RREP, it contains information about a
   route to TargAddr.  AdvRte is used to denote the route information
   contained in the RteMsg.  AdvRte has the following properties:

   o  AdvRte.Address = OrigAddr (in RREQ) or TargAddr (in RREP).

   o  AdvRte.SeqNum = OrigSeqNum (in RREQ) or TargSeqNum (in RREP).

   o  AdvRte.MetricType = RteMsg.MetricType, if present, else
      DEFAULT_METRIC_TYPE.

   o  AdvRte.Metric = RteMsg.Metric.

   o  AdvRte.Cost = AdvRte.Metric + Cost(L) according to the indicated
      MetricType, where L is the link from the advertising router.

   o  AdvRte.ValidityTime = ValidityTime in the RteMsg, if present.



Perkins, et al.        Expires September 25, 2015              [Page 20]

Internet-Draft                   AODVv2                       March 2015


   In the description below, Route denotes the stored routing table
   entry and HandlingRtr is the router receiving the RteMsg.
   HandlingRtr MUST process the incoming information as follows.  If the
   routing table does not contain an entry matching AdvRte's Address and
   MetricType, create a new route table entry according to the procedure
   in Section 8.2.  Otherwise determine whether or not to use AdvRte for
   updating the route entry (Route) matching the AdvRte's Address and
   MetricType as follows:

   1.  Check whether AdvRte is stale (AdvRte.SeqNum < Route.SeqNum).

       *  If AdvRte's sequence number is newer, HandlingRtr MUST use
          AdvRte to update the Route.

       *  If stale, using the incoming information might result in a
          routing loops.  In this case the HandlingRtr MUST NOT use
          AdvRte to update the Route.

       *  If the SeqNums are equal, continue checking as below.

   2.  Check whether AdvRte advertises a more costly route (AdvRte.Cost
       >= Route.Metric).

       *  If the advertised route's cost is the same or greater than the
          stored route, and the stored route is valid, the incoming
          information does not offer any improvement and SHOULD NOT be
          used to update the stored route table entry.

       *  If the advertised route's cost is lower than the stored route,
          AdvRte offers improvement and SHOULD be used to update the
          stored route table entry.

       *  If the advertised route's cost is the same or greater than the
          stored route, but the stored route's state is Invalid,
          continue processing to see whether there is a danger of a
          routing loop.

   3.  Check whether the information is safe against loops (LoopFree
       (AdvRte, Route) == TRUE).

       *  If LoopFree (see Section 7.2) returns false, using the
          incoming information might cause a routing loop.  AdvRte MUST
          NOT be used to update the stored route table entry.

   4.  If the advertised route can be used to update the route table
       entry, follow the procedure in Section 8.2.





Perkins, et al.        Expires September 25, 2015              [Page 21]

Internet-Draft                   AODVv2                       March 2015


   To briefly summarize, AdvRte must satisfy the following conditions
   compared to the existing route table entry before it can be used:

   o  AdvRte is more recent, (i.e., AdvRte.SeqNum > Route.SeqNum) OR

   o  AdvRte is not stale and can safely restore an invalid route (i.e.
      LoopFree (AdvRte, Route) == TRUE), OR

   o  AdvRte is not stale and is less costly.

   Also see the pseudocode in Appendix A.1.1.

   If the route has been updated based on information in a received
   RREQ, the AODVv2 router MAY force regeneration of the RREQ, to ensure
   the most recent information is propagated to other routers, but it
   MAY suppress this to avoid extra control traffic.

8.2.  Applying Route Updates To Route Table Entries

   To apply the route update, a route table entry for AdvRte.Address is
   either found to already exist in the route table, or else a new route
   table entry for AdvRte.Address is created and inserted into the route
   table.  If the route table entry had to be created, or if the state
   is Invalid, the state is set to be Idle.  The fields of route table
   entry are assigned as follows:

   o  If AdvRte.PrefixLength exists, then Route.PrefixLength :=
      AdvRte.PrefixLength.  Otherwise, Route.PrefixLength := maximum
      length for address family (either 32 or 128).

   o  Route.SeqNum := AdvRte.SeqNum

   o  Route.NextHop := IP.SourceAddress (i.e., the address from which
      the RteMsg was received)

   o  Route.NextHopInterface is set to the interface on which RteMsg was
      received

   o  Route.MetricType := AdvRte.MetricType

   o  Route.Metric := AdvRte.Cost

   o  Route.LastUsed := Current_Time

   o  Route.LastSeqnum := Current_Time

   o  If RteMsg.ValidityTime is included, then




Perkins, et al.        Expires September 25, 2015              [Page 22]

Internet-Draft                   AODVv2                       March 2015


      Route.ExpirationTime := Current_Time + RteMsg.ValidityTime and
      Route.Timed := TRUE.  Otherwise, Route.Timed := FALSE and
      Route.ExpirationTime := MAXTIME.

   With these assignments to the route table entry, a route has been
   made available, and the route can be used to send any buffered data
   packets (and subsequently to forward any incoming data packets) for
   Route.Address.  An updated route entry also fulfills any outstanding
   route discovery (RREQ) attempts for Route.Address.  Any retry timers
   for the RREQ SHOULD be cancelled.

8.3.  Route Maintenance

   AODVv2 routers attempt to maintain active routes.  Before using a
   route to forward a packet, an AODVv2 router MUST check the status of
   the route as specified in Section 8.4.  If the route has been marked
   as Invalid, it cannot be used for forwarding.  Otherwise, set
   Route.LastUsed := Current_Time, Route.State := Active, and forward
   the packet to the route's next hop.

   When a routing problem is encountered, an AODVv2 router (denoted
   RERR_Gen) sends the RERR to quickly notify upstream routers.  Two
   kinds of routing problems can trigger generation of a RERR message.
   The first happens when the router receives a packet but does not have
   a valid route for the destination of the packet.  The second case
   happens immediately upon detection of a broken link (see Section 6.2)
   for an valid route.

   Optionally, if a precursor list is maintained for the route, see
   Section 12.2 for precursor lifetime operations.

8.4.  Route Table Entry Timeouts

   During normal operation, AODVv2 does not require any explicit
   timeouts to manage the lifetime of a route.  At any time, any route
   table entry can be examined and then either expunged or marked as
   Invalid according to the following rules.

   The following rules are used to manage the state of route table
   entries:

   o  If Current_Time > Route.ExpirationTime, set Route.State :=
      Invalid.

   o  If (Current_Time - Route.LastUsed) > (ACTIVE_INTERVAL +
      MAX_IDLETIME), and if (Route.Timed == FALSE), set Route.State :=
      Invalid.




Perkins, et al.        Expires September 25, 2015              [Page 23]

Internet-Draft                   AODVv2                       March 2015


   o  If (Current_Time - Route.LastUsed) > ACTIVE_INTERVAL, and if
      (Route.Timed == FALSE), set Route.State := Idle.

   o  If (Current_Time - Route.LastSeqNum > MAX_SEQNUM_LIFETIME), and
      the route is Invalid, the route table entry MUST be expunged.  If
      the route is not invalid and MAX_SEQNUM_LIFETIME has expired, the
      SeqNum information should be removed from the route, to avoid
      problems with boot sequence and lost SeqNum behaviour.

   Memory constrained devices MAY choose to expunge routes from the
   AODVv2 route table at other times, but MUST adhere to the following
   rules:

   o  An Active route MUST NOT be expunged.

   o  An Idle route SHOULD NOT be expunged.

   o  Any Invalid route MAY be expunged; least recently used Invalid
      routes SHOULD be expunged first.

   If precursor lists are maintained for the route (as described in
   Section 12.2) then the precursor lists must also be expunged at the
   same time that the route itself is expunged.

8.5.  Route Discovery, Retries and Buffering

   AODVv2 message types RREQ and RREP are together known as Routing
   Messages (RteMsgs) and are used to discover a route between an
   Originating and Target Address, denoted by OrigAddr and TargAddr.
   The constructed route is bidirectional, enabling packets to flow
   between OrigAddr and TargAddr.  RREQ and RREP have similar
   information and function, but have some differences in their rules
   for handling.  When a node receives a RREQ or a RREP, the node then
   creates or updates a route to the OrigAddr or the TargAddr
   respectively (see Section 8.1).  The main difference between the two
   messages is that, by default, RREQ messages are multicast to solicit
   a RREP, whereas RREP is unicast as a response to RREQ.

   When an AODVv2 router needs to forward a data packet from a node
   (with IP address OrigAddr) in its set of router clients, and it does
   not have a forwarding route toward the packet's IP destination
   address (TargAddr), the AODVv2 router (RREQ_Gen) generates a RREQ (as
   described in Section 9.1.1) to discover a route toward TargAddr.
   Subsequently RREQ_Gen awaits reception of an RREP message (see
   Section 9.2.1) or other route table update (see Section 8.2) to
   establish a route toward TargAddr.  The RREQ message contains routing
   information to enable RREQ recipients to route packets one hop
   towards the OrigAddr, and the RREP message contains routing



Perkins, et al.        Expires September 25, 2015              [Page 24]

Internet-Draft                   AODVv2                       March 2015


   information to enable RREP recipients to route packets one hop
   towards the TargAddr.

   After issuing a RREQ, as described above RREQ_Gen awaits a RREP
   providing a bidirectional route toward the Target Address.  If the
   RREP is not received within RREQ_WAIT_TIME, RREQ_Gen MAY retry the
   Route Discovery by generating another RREQ.  Route Discovery SHOULD
   be considered to have failed after DISCOVERY_ATTEMPTS_MAX and the
   corresponding wait time for a RREP response to the final RREQ.  After
   the attempted Route Discovery has failed, RREQ_Gen MUST wait at least
   RREQ_HOLDDOWN_TIME before attempting another Route Discovery to the
   same destination.

   To reduce congestion in a network, repeated attempts at route
   discovery for a particular Target Address SHOULD utilize a binary
   exponential backoff, as described in [RFC3561], where the initial
   wait time is RREQ_WAIT_TIME and the wait time is doubled for each
   retry based.

   Data packets awaiting a route SHOULD be buffered by RREQ_Gen.  This
   buffer SHOULD have a fixed limited size (BUFFER_SIZE_PACKETS or
   BUFFER_SIZE_BYTES).  Determining which packets to discard first is a
   matter of policy at each AODVv2 router; in the absence of policy
   constraints, by default older data packets SHOULD be discarded first.
   Buffering of data packets can have both positive and negative effects
   (albeit usually positive).  Nodes without sufficient memory available
   for buffering SHOULD be configured to disable buffering by
   configuring BUFFER_SIZE_PACKETS = 0 and BUFFER_SIZE_BYTES = 0.  This
   will affect the latency required for launching TCP applications to
   new destinations.

   If a route discovery attempt has failed (i.e., DISCOVERY_ATTEMPTS_MAX
   attempts have been made without receiving a RREP) to find a route
   toward the Target Address, any data packets buffered for the
   corresponding Target Address MUST BE dropped and a Destination
   Unreachable ICMP message (Type 3) SHOULD be delivered to the source
   of the data packet.  The code for the ICMP message is 1 (Host
   unreachable error).  If RREQ_Gen is not the source (OrigNode), then
   the ICMP is sent to OrigAddr.

8.6.  Suppressing Redundant RteMsgs

   When RREQ messages are flooded in a MANET, an AODVv2 router may
   receive similar RREQ messages from more than one of its neighbours.
   To avoid processing and transmission associated with redundant
   RteMsgs, while still enabling proper handling of earlier RteMsgs that
   may have somehow been delayed in the network, it is necessary for




Perkins, et al.        Expires September 25, 2015              [Page 25]

Internet-Draft                   AODVv2                       March 2015


   each AODVv2 router store information about RteMsgs which it has
   recently received (see the RteMsg table defined in Section 6.5).

   When a RREQ is received, it is checked against the RteMsg Table to
   see if it contains redundant information.  If so it does not need to
   be processed.

   For RREQ messages, the process for comparison is as follows:

   o  Look for a "comparable" entry in the RteMsg Table with the same
      MsgType, OrigAddr, TargAddr, and MetricType.

   o  If there is none, create an entry to store information about the
      received RREQ, and continue to regenerate the RREQ.

   o  If there is an entry, and it has a lower SeqNum for OrigAddr than
      the received RREQ, update it using the new RREQ and continue to
      regenerate the RREQ.

   o  If there is an entry and it has a higher SeqNum for OrigAddr than
      the received RREQ, do not replace the entry and do not process the
      RREQ.

   o  If there is an entry and it has the same SeqNum for OrigAddr and a
      higher Metric than the received RREQ, update it with the new RREQ
      information.

   o  If there is an entry and it has the same SeqNum for OrigAddr and a
      Metric less than or equal to the received RREQ, do not replace the
      entry and do not regenerate the RREQ.

   o  In all cases, update the timestamp field, since other comparable
      RREQs may still be traversing the network.

   The process of comparison for optional multicast RREP messages is
   analogous, substituting RREP for RREQ, and TargAddr for OrigAddr.
   Entries in the RteMsg Table MUST be deleted after
   MAX_SEQNUM_LIFETIME, but should be maintained for at least
   RteMsg_ENTRY_TIME in order to account for long-lived RREQs traversing
   the network.

9.  AODVv2 Protocol Messages

   This section specifies the data elements and values required in
   AODVv2 protocol messages, namely RREQ, RREP, RERR, and RREP_Ack.

   To avoid congestion, each AODVv2 router's rate of packet/message
   generation SHOULD be limited.  The rate and algorithm for limiting



Perkins, et al.        Expires September 25, 2015              [Page 26]

Internet-Draft                   AODVv2                       March 2015


   messages (CONTROL_TRAFFIC_LIMIT) is left to the implementor and
   should be administratively configurable.  AODVv2 messages SHOULD be
   discarded in the following order of preference: RREQ, RREP, RERR, and
   finally RREP_Ack.

   See Section 10 for the mapping of AODVv2 data elements to RFC 5444
   Message TLVs, Address Blocks, and Address TLVs.

9.1.  RREQ Messages

   RREQ messages are used in Route Discovery operations to request a
   route to a specified Target address.  RREQ messages have the
   following general structure:

     +-----------------------------------------------------------------+
     |                   msg_hop_limit, msg_hop_count                  |
     +-----------------------------------------------------------------+
     |                 AddressList := {OrigAddr, TargAddr}             |
     +-----------------------------------------------------------------+
     | PrefixLengthList := {PrefixLength for OrigAddr, null}(optional) |
     +-----------------------------------------------------------------+
     |                 OrigSeqNum, (optional) TargSeqNum               |
     +-----------------------------------------------------------------+
     |                      MetricType (optional)                      |
     +-----------------------------------------------------------------+
     |             MetricList := {Metric for OrigAddr, null}           |
     +-----------------------------------------------------------------+
     | ValidityTimeList := {ValidityTime for OrigAddr, null}(optional) |
     +-----------------------------------------------------------------+

                     Figure 1: RREQ message structure

   RREQ Data Elements

      msg_hop_limit
         The remaining number of hops allowed for dissemination of the
         RREQ message.

      msg_hop_count
         The number of hops already traversed during dissemination of
         the RREQ message.

      AddressList
         AddressList contains OrigAddr and TargAddr.

      PrefixLengthList
         PrefixLengthList contains the length of the prefix for
         OrigAddr, if OrigAddr resides on a Client Network with a prefix



Perkins, et al.        Expires September 25, 2015              [Page 27]

Internet-Draft                   AODVv2                       March 2015


         length shorter than the number of bits of the address family
         for OrigAddr.

      OrigSeqNum
         OrigSeqNum is REQUIRED and carries the destination sequence
         number associated with OrigNode.

      TargSeqNum
         TargSeqNum is optional and carries a destination sequence
         number associated with TargNode.

      MetricList
         The MetricList data element is REQUIRED, and carries the route
         metric information associated with OrigAddr.

      MetricType
         The MetricType element defines the type of Metric associated
         with the entries in the MetricList.

      ValidityTimeList
         The ValidityTimeList is optional and carries the length of time
         that the sender is willing to offer a route towards OrigAddr.

   RREQ messages carry information about OrigAddr and TargAddr, as
   identified in the context of the RREQ_Gen.  The OrigSeqNum MUST
   appear.  Both MAY appear in the same RREQ when SeqNum is available
   for both OrigAddr and TargAddr.

   The OrigSeqNum data element in a RteMsg MUST apply only to OrigAddr.
   The other address in the AddressList is TargAddr.

   If the TargSeqNum data element appears, then it MUST apply only to
   TargAddr.  The other address in the AddressList is OrigAddr.

9.1.1.  RREQ Generation

   Upon receiving an IP packet from one of its Router Clients, it often
   happens that an AODVv2 router has no valid route to the destination.
   In this case the AODVv2 router is responsible for generating a RREQ
   and associated data elements on behalf of its client OrigNode.  The
   router is referred to as RREQ_Gen.  Before creating a RREQ, RREQ_Gen
   should check if an RREQ has recently been sent for this destination
   and a response is awaited, or if the limit of AODVv2 RREQ retries has
   been reached.

   In constructing the RREQ, RREQ_Gen uses AddressList, OrigSeqNum,
   MetricList, and optionally PrefixLengthList, TargSeqNum, MetricType,
   and ValidityTime.



Perkins, et al.        Expires September 25, 2015              [Page 28]

Internet-Draft                   AODVv2                       March 2015


   RREQ_Gen follows the steps in this section.  OrigAddr MUST be a
   unicast address.  The order of data elements is illustrated
   schematically in Figure 1.  RREQ_Gen SHOULD include TargSeqNum, if a
   previous value of the TargAddr's SeqNum is known (e.g.  from an
   invalid route table entry using longest-prefix matching).  If
   TargSeqNum is not included, AODVv2 routers handling the RREQ assume
   that RREQ_Gen does not have that information.

   1.  Set msg_hop_limit to MAX_HOPCOUNT.

   2.  Set msg_hop_count to zero, if including it.

   3.  Set AddressList := {OrigAddr, TargAddr}.

   4.  For the PrefixLengthList:

       *  If OrigAddr resides on a subnet of Router Clients, set
          PrefixLengthList := { OrigAddr subnet's prefix, null }.

       *  Otherwise, the PrefixLengthList is omitted.

   5.  For the Sequence Number List:

       *  Increment the SeqNum as specified in Section 6.4.

       *  Set OrigSeqNum to the new value of SeqNum.

       *  If an Invalid route exists matching TargAddr using longest
          prefix matching, include TargSeqNum and set it to the sequence
          number on the Invalid route.  Otherwise omit TargSeqNum.

   6.  Set MetricList := { Route[OrigAddr].Metric, null }.

   7.  Include the MetricType data element if requesting a route for a
       non-default metric type.

   8.  If the RREQ_Gen wishes to limit the time that the route to
       OrigAddr may be used, include the ValidityTime data element.

9.1.2.  RREQ Reception

   Upon receiving an RREQ, an AODVv2 router performs the following
   steps.

   1.  A router MUST handle RREQs only from neighbors.  RREQs from nodes
       that are not neighbors MUST be disregarded.





Perkins, et al.        Expires September 25, 2015              [Page 29]

Internet-Draft                   AODVv2                       March 2015


   2.  Check whether the sender is on the blacklist of AODVv2 routers
       (see Section 6.2).  If not, continue processing.  Otherwise,
       check the Blacklist Remove Time.

       *  If Current_Time < Remove Time, ignore this RREQ for further
          processing.

       *  If Current_Time >= Remove Time, remove the Blacklist entry and
          continue processing.

   3.  Verify that the message contains the required data elements:
       msg_hop_limit, OrigAddr, TargAddr, OrigSeqNum, OrigAddrMetric,
       and verify that OrigAddr and TargAddr are valid addresses
       (routable and unicast).  If not, ignore this message for further
       processing.

   4.  If the MetricType data element is present, check that the
       MetricType is known.

       *  If not, ignore this RREQ for further processing.

       *  Otherwise continue processing .

   5.  Verify that OrigAddrMetric <= {MAX_METRIC[MetricType] -
       Cost(Link)}.

       *  If not, ignore this RREQ for further processing.

       *  Otherwise continue processing .

   6.  Process the route to OrigAddr as specified in Section 8.1.

   7.  Check if the message is a duplicate or redundant by comparing to
       entries in the RteMsg table as described in Section 8.6.

       *  If duplicate or redundant, ignore this RREQ for further
          processing.

       *  Otherwise save the information in the RteMsg table to identify
          future duplicates and continue processing.

   8.  Check if the TargAddr belongs to one of the Router Clients.

       *  If so, generate a RREP as specified in Section 9.2.1.

       *  Otherwise, continue to RREQ regeneration.





Perkins, et al.        Expires September 25, 2015              [Page 30]

Internet-Draft                   AODVv2                       March 2015


9.1.3.  RREQ Regeneration

   Unless the router is prepared to advertise the new route, it halts
   processing.  By sending a RREQ, a router advertises that it will
   forward packets to the OrigAddr contained in the RREQ according to
   the information enclosed.  The router MAY choose not to regenerate
   the RREQ, though this could decrease connectivity in the network or
   result in non-optimal paths.

   The circumstances under which a router MAY choose not to regenerate a
   RREQ are not specified in this document.  Some examples may include
   the router being heavily loaded and not advertising routing for more
   traffic, or being low on energy and having to reduce energy expended
   for sending AODVv2 messages or packet forwarding.

   The procedure for RREQ regeneration is as follows:

   1.  Check the msg_hop_limit.

       *  If it is zero, do not regenerate.

       *  Otherwise, decrement the value by one.

   2.  Check if msg_hop_count is present and greater than or equal to
       MAX_HOPCOUNT

       *  If so, do not regenerate.

       *  Otherwise, increment msg_hop_count by one.

   3.  Change OrigAddrMetric to match the route table entry for
       OrigAddr, which should match the advertised value in the received
       RREQ plus the cost of the link to the router which forwarded the
       RREQ.

   4.  If the incoming RREQ contains a ValidityTimeList, it MUST be
       copied into the regenerated RREQ.  If not present, and the
       regenerating router wishes to limit the time that its route to
       OrigAddr may be used, set ValidityTimeList := {ValidityTime for
       OrigAddr, null}.

   If the received RREQ was unicast, the regenerated RREQ can be unicast
   to the next hop address of the route towards TargAddr, if known.
   Otherwise, the RREQ SHOULD be multicast to the LL-MANET-Routers IP
   and MAC address [RFC5498], [RFC4291].






Perkins, et al.        Expires September 25, 2015              [Page 31]

Internet-Draft                   AODVv2                       March 2015


9.2.  RREP Messages

   RREP messages are used to offer a route to a target address, and are
   sent in response to a RREQ message.  RREP messages have the following
   general structure:

     +-----------------------------------------------------------------+
     |                   msg_hop_limit, msg_hop_count                  |
     +-----------------------------------------------------------------+
     |                       AckReq (optional)                         |
     +-----------------------------------------------------------------+
     |                 AddressList := {OrigAddr,TargAddr}              |
     +-----------------------------------------------------------------+
     | PrefixLengthList := {null, PrefixLength for TargAddr(optional)} |
     +-----------------------------------------------------------------+
     |                            TargSeqNum                           |
     +-----------------------------------------------------------------+
     |            MetricList := {null, metric for TargAddr}            |
     +-----------------------------------------------------------------+
     |                     MetricType (optional)                       |
     +-----------------------------------------------------------------+
     | ValidityTimeList := {null, ValidityTime for TargAddr}(optional) |
     +-----------------------------------------------------------------+

                     Figure 2: RREP message structure

   RREP Data Elements

      msg_hop_limit
         The remaining number of hops allowed for dissemination of the
         RREP message.

      msg_hop_count
         The number of hops already traversed during dissemination of
         the RREP message.

      AckReq
         Acknowledgement Requested by sender (optional).

      AddressList
         AddressList contains OrigAddr and TargAddr.

      PrefixLengthList
         PrefixLengthList contains the length of the prefix for
         TargAddr, if TargAddr resides on a Client Network with a prefix
         length shorter than the number of bits of the address family
         for TargAddr.




Perkins, et al.        Expires September 25, 2015              [Page 32]

Internet-Draft                   AODVv2                       March 2015


      TargSeqNum
         TargSeqNum is REQUIRED and carries the destination sequence
         number associated with TargNode.

      MetricList
         The MetricList data element is REQUIRED, and carries the route
         metric information associated with TargAddr.

      MetricType
         The MetricType element defines the type of Metric associated
         with the entries in the MetricList.

      ValidityTimeList
         The ValidityTimeList is optional and carries the length of time
         that the sender is willing to offer a route towards TargAddr.

   RREP messages carry information about OrigAddr and TargAddr, as known
   in the context of the RREP_Gen.  The TargSeqNum MUST appear.  It MUST
   apply only to TargAddr.  The other address in the AddressList is
   OrigAddr.

9.2.1.  RREP Generation

   This section specifies the generation of an RREP by an AODVv2 router
   (RREP_Gen) that provides connectivity for TargAddr, thus enabling the
   establishment of a route between OrigAddr and TargAddr.  In
   constructing the RREP, AODVv2 uses AddressList, TargSeqNumber List,
   MetricList, and optionally AckReq, PrefixLengthList and/or
   ValidityTimeList.  These elements are then used to create a RFC5444
   message; see Section 10 for details.

   The AckReq data element indicates that an acknowledgement to the RREP
   has been requested.  If no corresponding RREP_Ack is received within
   the RREP_Ack_SENT_TIMEOUT, the next hop is added to the blacklist as
   discussed in Section 6.2.

   The procedure for RREP generation is as follows:

   1.  Set msg_hop_limit to the msg_hop_count from the received RREQ
       message.

   2.  Set msg_hop_count, if including it, to zero.

   3.  Include the AckReq data element if RREP_Ack is requested from the
       next hop (as described in Section 6.2).

   4.  Include the MetricType data element and set the type accordingly.




Perkins, et al.        Expires September 25, 2015              [Page 33]

Internet-Draft                   AODVv2                       March 2015


   5.  Set the Address List := {OrigAddr, TargAddr}.

   6.  For the PrefixLengthList:

       *  If TargAddr resides on a subnet of Router Clients, set
          PrefixLengthList := {null, TargAddr subnet's prefix}.

       *  Otherwise, no PrefixLengthList is needed.

   7.  For the TargSeqNum:

       *  RREP_Gen increments its SeqNum as specified in Section 6.4.

       *  Set TargSeqNum := the new value of SeqNum.

   8.  Set MetricList := { null, Route[TargAddr].Metric }.

   9.  If the RREP_Gen wishes to limit the time that the route to
       TargAddr may be used, set ValidityTimeList := {null, TargAddr
       ValidityTime}.

   By default, the RREP is sent by unicast to the IP address of the next
   hop of the RREP_Gen's route to OrigAddr.

9.2.2.  RREP Reception

   Upon receiving an RREP, an AODVv2 router performs the following
   steps.

   1.  Verify that the RREP message contains the required data elements:
       msg_hop_limit, OrigAddr, TargAddr, TargAddrMetric, TargSeqNum,
       and verify that OrigAddr and TargAddr are valid addresses
       (routable and unicast).  If not, ignore this RREP message for
       further processing.

   2.  Check that the MetricType is known.

       *  If not, ignore this RREP for further processing.

       *  Otherwise continue processing .

   3.  Verify that TargAddrMetric <= {MAX_METRIC[MetricType] -
       Cost(Link)}.

       *  If not, ignore this RREP for further processing.

       *  Otherwise continue processing .




Perkins, et al.        Expires September 25, 2015              [Page 34]

Internet-Draft                   AODVv2                       March 2015


   4.  Process the route to TargAddr as specified in Section 8.1.

   5.  If the AckReq data element is present, send a RREP_Ack as
       specified in Section 9.4.

   6.  Check if the message is a duplicate or redundant by comparing to
       entries in the RREP table as described in Section 8.6.

       *  If duplicate or redundant, ignore this RREP for further
          processing.

       *  Otherwise save the information in the RREP table to identify
          future duplicates and continue processing.

   7.  Check if the OrigAddr belongs to one of the Router Clients.

       *  If so, the RREP satisfies a previously sent RREQ.  Processing
          is complete and data can now be forwarded along the route.
          Any packets from OrigAddr that were buffered for later
          delivery SHOULD be transmitted.

       *  Otherwise, continue to RREP regeneration.

9.2.3.  RREP Regeneration

   Similar to rules for RREQ regeneration, unless the router is prepared
   to advertise the route to TargAddr, it halts processing.  By
   forwarding a RREP, a router advertises that it will forward packets
   to the TargAddr contained in the RREP according to the information
   enclosed.  The router MAY choose not to regenerate the RREP, for the
   same reasons as mentioned under RREQ regeneration Section 9.1.3,
   though this could decrease connectivity in the network or result in
   non-optimal paths.

   If no valid route exists to OrigAddr, a RERR SHOULD be transmitted to
   TargAddr as specified in Section 9.3.1 and the RREP should not be
   regenerated.

   The procedure for RREP regeneration is as follows:

   1.  Check the msg_hop_limit.

       *  If it is zero, do not regenerate.

       *  Otherwise, decrement the value by one.

   2.  If msg_hop_count is present, then:




Perkins, et al.        Expires September 25, 2015              [Page 35]

Internet-Draft                   AODVv2                       March 2015


       *  If msg_hop_count >= MAX_HOPCOUNT, do not regenerate.

       *  Otherwise, increment msg_hop_count by one.

   3.  The RREP SHOULD be unicast to the next hop on the route to
       OrigAddr.  If no valid route exists to OrigAddr, a RERR SHOULD be
       transmitted to TargAddr as specified in Section 9.3.1.

   4.  Change TargAddrMetric to match the route table entry for
       TargAddr, which should match the advertised value in the received
       RREP plus the cost of the link to the router which forwarded the
       RREP.

   5.  Include the AckReq data element if this device requires
       acknowledgement of the RREP message.

   6.  If the incoming RREP contains a ValidityTimeList, it MUST be
       copied into the regenerated RREP.  If not present, and the
       regenerating router wishes to limit the time that its route to
       TargAddr may be used, set ValidityTimeList := {null, ValidityTime
       for TargAddr}.

   The RREP SHOULD be unicast to the next hop on the route to OrigAddr.

9.3.  RERR Messages

   An RERR message is generated by a AODVv2 router (i.e., RERR_Gen) in
   order to notify upstream routers that packets cannot be delivered to
   one or more destinations.  An RERR message has the following general
   structure:

     +-----------------------------------------------------------------+
     |                          msg_hop_limit                          |
     +-----------------------------------------------------------------+
     |                      PktSource (optional)                       |
     +-----------------------------------------------------------------+
     |                         RERR AddressList                        |
     +-----------------------------------------------------------------+
     |       PrefixLengthList for UnreachableAddresses (optional)      |
     +-----------------------------------------------------------------+
     |                SeqNumList (one entry per address)               |
     +-----------------------------------------------------------------+
     |                     MetricType (optional)                       |
     +-----------------------------------------------------------------+

                     Figure 3: RERR message structure

   RERR Data Elements



Perkins, et al.        Expires September 25, 2015              [Page 36]

Internet-Draft                   AODVv2                       March 2015


      msg_hop_limit
         The remaining number of hops allowed for dissemination of the
         RERR message.

      PktSource
         The IP address of the unreachable destination triggering RERR
         generation.  If this RERR message was triggered by a broken
         link, the PktSource data element is not required.

      RERR AddressList
         A list of IP addresses not reachable by the AODVv2 router
         transmitting the RERR.

      PrefixLengthList
         PrefixLengthList contains the prefix lengths associated with
         the addresses in the RERR AddressList, if any of them reside on
         a Client Network with a prefix length shorter than the number
         of bits of their address family.

      MetricType
         If MetricType != DEFAULT_METRIC_TYPE, the MetricType associated
         with routes affected by a broken link.

      SeqNumList
         The list of sequence numbers associated with the
         UnreachableAddresses in the RERR AddressList.

9.3.1.  RERR Generation

   There are two types of events which trigger generation of a RERR
   message.  The first is the arrival of a packet for which there is no
   route to the destination address.  This can be a packet forwarded by
   the routing process, or a RREP when there is no route to OrigAddr.
   In this case, exactly one UnreachableAddress will be included in
   RERR's AddressList (either the Destination Address of the IP header
   from a data packet, or the OrigAddr found in the AddressList of an
   RREP message).  RERR_Gen MUST discard the packet or message that
   triggered generation of the RERR.

   The second type of event happens when a link breaks.  All routes
   (whether valid or not) that use the broken link MUST be marked as
   Invalid.  If the broken link was not used by any Active route, no
   RERR message is generated.  Every Invalid route reported in the RERR
   MUST have the same MetricType.  If the broken link affects routes to
   destinations that have different MetricTypes, multiple RERR messages
   must be generated.





Perkins, et al.        Expires September 25, 2015              [Page 37]

Internet-Draft                   AODVv2                       March 2015


   If an AODVv2 router receives an ICMP packet to or from the address of
   one of its client nodes, it simply forwards the ICMP packet, and does
   not generate any RERR message.

   In constructing the RERR, AODVv2 uses MetricType, AddressList,
   SeqNumList, and in some cases PktSource and PrefixLengthList.  These
   elements are then used to create a RFC5444 message; see Section 10
   for details.

   The procedure for RERR generation is as follows:

   1.  Set msg_hop_limit to MAX_HOPCOUNT.

   2.  If the RERR was triggered by an Undeliverable Packet, the
       PktSource data element MUST be included, containing the source IP
       address of the Undeliverable Packet.

   3.  Include the MetricType data element if reporting a Invalid route
       for a non-default metric type.

   4.  For the RERR AddressList:

       *  If the RERR was triggered by an undeliverable packet, insert
          the destination IP address of the undeliverable packet, or if
          the packet was a RREP, insert the OrigAddr.

       *  If the RERR was triggered by a broken link, include the
          addresses of all previously Active routes which are now
          Invalid, up to the limit imposed by the MTU (interface
          "Maximum Transfer Unit") of the physical medium.  If there are
          too many such previously Active routes, additional RERR
          messages should be constructed and transmitted to contain the
          remaining addresses.  If the configuration option
          ENABLE_IDLE_IN_RERR is enabled, include any previously Idle
          routes which are now Invalid, as long as the packet size of
          the RERR does not exceed the MTU.

   5.  If there are destinations reported in the RERR AddressList that
       have associated subnet prefixes in the route table, insert those
       prefixes in the PrefixLengthList; otherwise, omit the
       PrefixLengthList.

   6.  If known, the sequence numbers associated with the routes to the
       addresses in the RERR AddressList SHOULD be included in the
       SeqNumList; otherwise, omit the SeqNumList.

   If the RERR is sent in response to an Undeliverable Packet:




Perkins, et al.        Expires September 25, 2015              [Page 38]

Internet-Draft                   AODVv2                       March 2015


   o  It SHOULD be sent unicast to the next hop towards the source IP
      address of the packet which triggered the RERR.

   o  Otherwise the RERR MUST be sent to the multicast IP and MAC
      address for LL-MANET-Routers.

   If the RERR is sent in response to a broken link:

   o  If precursor lists are maintained for the addresses in the RERR
      AddressList (see Section 12.2), the RERR SHOULD be unicast to the
      precursors.

   o  Otherwise the RERR MUST be sent to the multicast IP and MAC
      address for LL-MANET-Routers.

9.3.2.  RERR Reception

   Upon receiving an RERR, the following steps are performed.

   1.  If the message does not contain the msg_hop_limit and at least
       one UnreachableAddress, do not process the RERR.

   2.  If the MetricType data element is present, check that the
       MetricType is known.

       *  If not, ignore this RERR for further processing.

       *  Otherwise continue processing .

   3.  For each UnreachableAddress,

       *  Check that the address is valid (routable and unicast).

       *  Check that there is a valid route with the same MetricType
          matching the address using longest prefix matching.

       *  Check that the route's next hop is the sender of the RERR.

       *  Check that the route's next hop interface is the interface on
          which the RERR was received.

       *  Check that the Unreachable Address SeqNum is either unknown,
          or is greater than the route's SeqNum.

       *  If any of the above are false, the UnreachableAddress does not
          need to be advertised in a regenerated RERR.

       *  If all of the above are true:



Perkins, et al.        Expires September 25, 2015              [Page 39]

Internet-Draft                   AODVv2                       March 2015


          +  If the route's prefix length is the same as the
             UnreachableAddress's prefix length, set the route state to
             Invalid.

          +  If the prefix length is shorter than the original route,
             the route MUST be expunged from the routing table, since it
             is a sub-route of the larger route which is reported to be
             Invalid.

          +  If the prefix length is different, create a new route with
             the UnreachableAddress and its prefix, and set the state to
             Invalid.

   If there are no UnreachableAddresses which need to be advertised in a
   regenerated RERR, take no further action.

   Otherwise regenerate the RERR as specified in Section 9.3.3.

9.3.3.  RERR Regeneration

   The procedure for RERR regeneration is as follows:

   1.  Check the msg_hop_limit.

       *  If it is zero, do not regenerate.

       *  Otherwise, decrement the value by one.

   2.  If the PktSource data element was included in the original RERR,
       copy it into the regenerated RERR.

   3.  For the RERR AddressList, include all UnreachableAddresses which
       have been determined to need regeneration.

   4.  For the PrefixLengthList, insert the prefix lengths associated
       with the addresses in the RERR AddressList.

   5.  For the SeqNumList, include the sequence numbers corresponding to
       the addresses in the RERR AddressList.

   If the original RERR contained the PktSource data element, and a
   route exists to the source address, the regenerated RERR MUST be sent
   unicast to the next hop of the route towards PktSource.

   Otherwise, if precursor lists are maintained, the regenerated RERR
   SHOULD be sent to the active precursors of the Invalid routes as
   specified in Section 12.2.




Perkins, et al.        Expires September 25, 2015              [Page 40]

Internet-Draft                   AODVv2                       March 2015


   Otherwise the regenerated RERR MUST be sent to the multicast IP and
   MAC address for LL-MANET-Routers.

9.4.  RREP_Ack Messages

   RREP_Ack is modeled on the RREP_Ack message type from AODV [RFC3561].
   RREP_Ack messages have the following general structure:

     +-----------------------------------------------------------------+
     |                       msg_hop_limit := 1                        |
     +-----------------------------------------------------------------+

                   Figure 4: RREP_Ack message structure

   RREP_Ack Data Elements

      msg_hop_limit
         The remaining number of hops allowed for dissemination of the
         RREP_Ack message.

9.4.1.  RREP_Ack Generation

   This section specifies the generation of an RREP_Ack by an AODVv2
   router.  The procedure is as follows:

   1.  Set msg_hop_limit := 1.

   The RREP_Ack is sent by unicast to the IP address of router that
   inserted a AckReq data element into a RREP message.

9.4.2.  RREP_Ack Reception

   Upon receiving an RREP_Ack, an AODVv2 router performs the following
   steps.

   1.  The router checks whether the sender's IP address is in the
       blacklist.  If so, the IP address is deleted from the blacklist.

   2.  The router checks whether an RREP_Ack message was expected from
       the sending IP address, in response to an AckReq data element
       that the router included in a preceding RREP message as specified
       in Section 9.2.1.  If so, the router records that the required
       RREP_Ack has been received and cancels the associated timeout.








Perkins, et al.        Expires September 25, 2015              [Page 41]

Internet-Draft                   AODVv2                       March 2015


10.  Representing AODVv2 data elements using RFC 5444

   AODVv2 specifies that all control plane messages between Routers
   SHOULD use the Generalised Mobile Ad-hoc Network Packet and Message
   Format [RFC5444], which provides a multiplexed transport for multiple
   protocols.  AODVv2 therefore specifies Route Messages comprising data
   elements that map to message elements in RFC5444 but, in line with
   the concept of use, does not specify which order the messages should
   be arranged in an RFC5444 packet.  An implementation of an RFC5444
   multiplexer may choose to optimise the content of certain message
   elements to reduce control plane overhead.  For handling of messages
   that contain unknown TLV types, the multiplexer SHOULD ignore the
   information for processing, but preserve it unmodified for
   forwarding.

   Here is a brief summary of the RFC 5444 format.

   1.  A packet formatted according to RFC 5444 contains zero or more
       messages.

   2.  A message contains a message header, message TLV block, and zero
       or more address blocks.

   3.  Each address block MAY also have one TLV blocks; each TLV block
       MAY encode any number of TLVs (including zero).  Each TLV value
       in an Address TLV block is associated with exactly one of the
       addresses in the address block.

   The following table shows how AODVv2 data elements are represented in
   RFC 5444 messages.





















Perkins, et al.        Expires September 25, 2015              [Page 42]

Internet-Draft                   AODVv2                       March 2015


   +------------------------+------------------------------------------+
   | Data Element           | RFC 5444 Message Representation          |
   +------------------------+------------------------------------------+
   | msg_hop_limit          | RFC 5444 Message Header <msg-hop-limit>  |
   | msg_hop_count          | RFC 5444 Message Header <msg-hop-count>  |
   | AckReq                 | Acknowledgement Request Message TLV      |
   | PktSource              | The Packet Source Message TLV            |
   | RteMsg AddressList     | RFC 5444 Address Block                   |
   | -   OrigAddr           |                                          |
   | -   TargAddr           |                                          |
   | -   PrefixLengthList   |                                          |
   | RERR AddressList       | RFC 5444 Address Block                   |
   | -   UnreachableAddress |                                          |
   | -   PrefixLengthList   |                                          |
   | SeqNumList             | Sequence Number Address Block TLV        |
   | -   SeqNum             |                                          |
   | OrigSeqNum             | Originating Node Sequence Number Address |
   |                        | Block TLV                                |
   | TargSeqNum             | Target Node Sequence Number Address      |
   |                        | Block TLV                                |
   | MetricType             | Extension byte of Metric Address Block   |
   |                        | TLV                                      |
   | MetricList             | Metric Address Block TLV                 |
   | -   OrigAddrMetric     | - corresponds to OrigAddr                |
   | -   TargAddrMetric     | - corresponds to TargAddr                |
   | ValidityTimeList       | VALIDITY_TIME Address Block TLV          |
   | -   ValidityTime       |                                          |
   +------------------------+------------------------------------------+

                                  Table 3

   AODVv2 neither requires any inclusion nor uses any information from
   the packet header.  The length of an address (32 bits for IPv4 and
   128 bits for IPv6) inside an AODVv2 message is indicated by the msg-
   addr-length (MAL) in the msg-header.  Although the addresses in an
   Address Block may appear in any order, each TLV value in a TLV Block
   is associated with exactly one Address in the Address Block.  So, for
   instance, the ordering of the OrigAddrMetric and TargAddrMetric
   values in the MetricList is determined by the order of OrigAddr and
   TargAddr in the preceding RteMsg Address List.  See Section 14.2 for
   more information about AODVv2 Message TLVs.  See Section 14.3 for
   more information about AODVv2 Address Block TLVs.

11.  Simple Internet Attachment

   Simple Internet attachment means attachment of a stub (i.e., non-
   transit) network of AODVv2 routers to the Internet via a single
   Internet AODVv2 router (called IAR).



Perkins, et al.        Expires September 25, 2015              [Page 43]

Internet-Draft                   AODVv2                       March 2015


   As in any Internet-attached network, AODVv2 routers, and their
   clients, wishing to be reachable from hosts on the Internet MUST have
   IP addresses within the IAR's routable and topologically correct
   prefix (e.g. 191.0.2.0/24).

        /-------------------------\
       / +----------------+        \
      /  |  AODVv2 Router |         \
      |  |  191.0.2.2/32  |         |
      |  +----------------+         |            Routable
      |                       +-----+--------+   Prefix
      |                       |   Internet   |  /191.0.2/24
      |                       | AODVv2 Router| /
      |                       |  191.0.2.1   |/      /---------------\
      |                       | serving net  +------+    Internet     \
      |                       |  191.0.2/24  |      \                 /
      |                       +-----+--------+       \---------------/
      |         +----------------+  |
      |         |  AODVv2 Router |  |
      |         |  191.0.2.3/32  |  |
      \         +----------------+  /
       \                           /
        \-------------------------/

               Figure 5: Simple Internet Attachment Example

   When an AODVv2 router within the AODVv2 MANET wants to discover a
   route toward a node on the Internet, it uses the normal AODVv2 route
   discovery for that IP Destination Address.  The IAR MUST respond to
   RREQ on behalf of all Internet destinations.

   When a packet from a node on the Internet destined for a node in the
   AODVv2 MANET reaches the IAR, if the IAR does not have a route toward
   that destination it will perform normal AODVv2 route discovery for
   that destination.

12.  Optional Features

   Some optional features of AODVv2, associated with AODV, are not
   required by minimal implementations.  These features are expected to
   apply in networks with greater mobility, or larger node populations,
   or requiring reduced latency for application launches.  The optional
   features are as follows:

   o  Expanding Rings Multicast

   o  Precursor lists.




Perkins, et al.        Expires September 25, 2015              [Page 44]

Internet-Draft                   AODVv2                       March 2015


   o  Multicast RREP Response to RREQ

   o  Intermediate RREPs (iRREPs): Without iRREP, only the destination
      can respond to a RREQ.

   o  Message Aggregation Delay.

12.1.  Expanding Rings Multicast

   For multicast RREQ, msg_hop_limit MAY be set in accordance with an
   expanding ring search as described in [RFC3561] to limit the RREQ
   propagation to a subset of the local network and possibly reduce
   route discovery overhead.

12.2.  Precursor Lists and Notifications

   This section specifies an interoperable enhancement to AODVv2 (and
   possibly other reactive routing protocols) enabling more economical
   RERR notifications to traffic sources upon determination that a route
   needed to forward such traffic to its destination has become Invalid.

12.2.1.  Overview

   In many circumstances, there can be several sources of traffic for a
   certain destination.  Each such source of traffic is known as a
   "precursor" for the destination, as well as all upstream routers
   between the forwarding AODVv2 router and the traffic source.  There
   is no need to keep track of upstream routers any farther away than
   the next hop.  For each destination, an AODVv2 router MAY choose to
   keep track of the upstream neighbors that have provided traffic for
   that destination.

   Moreover, any particular link to an adjacent AODVv2 router may be a
   path component of multiple routes towards various destinations.  The
   precursors for all destinations using the next hop across any link
   are collectively known as the precursors for that next hop.

   When an AODVv2 router marks a route as Invalid, the precursors of the
   Invalid route should be notified (using RERR) about the change in
   status of their route to the destination of that Invalid route.

12.2.2.  Precursor Notification Details

   During normal operation, each AODVv2 router wishing to maintain
   precursor lists as described above, maintains a precursor table and
   updates the table whenever the node forwards traffic to one of the
   destinations in its route table.  For each precursor in the precursor
   list, a record must be maintained to indicate whether the precursor



Perkins, et al.        Expires September 25, 2015              [Page 45]

Internet-Draft                   AODVv2                       March 2015


   has been used for recent traffic (in other words, whether the
   precursor is an Active precursor).  So, when traffic arrives from a
   precursor, the Current_Time is used to mark the time of last use for
   the precursor list element associated with that precursor.

   When an AODVv2 router detects that a link is broken, then for each
   Active precursor using that next hop, the node MAY notify the
   precursor using either unicast or multicast RERR:

   unicast RERR to each Active precursor
      This option is applicable when there are few Active precursors
      compared to the number of neighboring AODVv2 routers.

   multicast RERR to RERR_PRECURSORS
      RERR_PRECURSORS is, by default, LL-MANET-Routers [RFC5498].  This
      option is typically preferable when there are many precursors,
      since fewer packet transmissions are required.

   Each neighbor receiving the RERR MAY then execute the same procedure
   until all upstream routers have received the RERR notification.

12.3.  Multicast RREP Response to RREQ

   The RREQ Target Router (RREP_Gen) MAY, as an alternative to
   unicasting a RREP, be configured to use multicast to distribute
   routing information about the route toward TargAddr.  RREP_Gen does
   this as described in Section 9.2.1, but multicasting the RREP to LL-
   MANET-Routers [RFC5498].  Routers receiving the multicast RREP must
   perform RteMsg suppression (see Section 8.6).

   Broadcast RREP response to incoming RREQ was originally specified to
   handle unidirectional links, but it is expensive.  Due to the
   significant overhead, AODVv2 routers MUST NOT use multicast RREP
   unless configured to do so by setting the administrative parameter
   USE_MULTICAST_RREP.  This technique can be used to find the best
   return path rather than follow the same path as the RREQ took.

12.4.  Intermediate RREP

   This specification has been published as a separate Internet Draft
   [I-D.perkins-irrep].

12.5.  Message Aggregation Delay

   The aggregation of multiple messages into a packet is specified in
   RFC 5444 [RFC5444].





Perkins, et al.        Expires September 25, 2015              [Page 46]

Internet-Draft                   AODVv2                       March 2015


   Implementations MAY choose to briefly delay transmission of messages
   for the purpose of aggregation (into a single packet) or to improve
   performance by using jitter [RFC5148].

13.  Administratively Configurable Parameters and Timer Values

   AODVv2 uses various configurable parameters of various types:

   o  Timers

   o  Protocol constants

   o  Administrative (functional) controls

   o  Other administrative parameters and lists

   The tables in the following sections show the parameters along their
   definitions and default values (if any).

   Note: several fields have limited size (bits or bytes).  These sizes
   and their encoding may place specific limitations on the values that
   can be set.  For example, <msg-hop-count> is a 8-bit field and
   therefore MAX_HOPCOUNT cannot be larger than 255.

13.1.  Timers

   AODVv2 requires certain timing information to be associated with
   route table entries.  The default values are as follows:

                +------------------------+---------------+
                |          Name          | Default Value |
                +------------------------+---------------+
                |    ACTIVE_INTERVAL     | 5 second      |
                |      MAX_IDLETIME      | 200 seconds   |
                |   MAX_BLACKLIST_TIME   | 200 seconds   |
                |  MAX_SEQNUM_LIFETIME   | 300 seconds   |
                |   RteMsg_ENTRY_TIME    | 12 seconds    |
                |     RREQ_WAIT_TIME     | 2 seconds     |
                | RREP_Ack_SENT_TIMEOUT  | 1 second      |
                |   RREQ_HOLDDOWN_TIME   | 10 seconds    |
                +------------------------+---------------+

                     Table 4: Timing Parameter Values

   The above timing parameter values have worked well for small and
   medium well-connected networks with moderate topology changes.  The
   timing parameters SHOULD be administratively configurable for the
   network where AODVv2 is used.  Ideally, for networks with frequent



Perkins, et al.        Expires September 25, 2015              [Page 47]

Internet-Draft                   AODVv2                       March 2015


   topology changes the AODVv2 parameters should be adjusted using
   either experimentally determined values or dynamic adaptation.  For
   example, in networks with infrequent topology changes MAX_IDLETIME
   may be set to a much larger value.

13.2.  Protocol Constants

   AODVv2 protocol constants typically do not require changes.  The
   following table lists these constants, along with their values and a
   reference to the specification describing their use.

   +------------------------+-----------------+------------------------+
   | Name                   | Default Value   | Description            |
   +------------------------+-----------------+------------------------+
   | DISCOVERY_ATTEMPTS_MAX | 3               | Section 8.5            |
   | MAX_HOPCOUNT           | 20 hops         | Section 7              |
   | MAX_METRIC[i]          | Specified only  | Section 7              |
   |                        | for HopCount    |                        |
   | MAXTIME                | [TBD]           | Maximum expressible    |
   |                        |                 | clock time Section 8.4 |
   +------------------------+-----------------+------------------------+

                         Table 5: Parameter Values

   These values MUST have the same values for all AODVv2 routers in the
   ad hoc network.  If the configured values are different, the
   following consequences may be observed:

   o  DISCOVERY_ATTEMPTS_MAX: some nodes are likely to be more
      successful at finding routes, but at the cost of additional
      control traffic for unsuccessful attempts.

   o  MAX_HOPCOUNT: If some nodes use a value that is too small, they
      would not be able to discover routes to distant addresses.

   o  MAX_METRIC[DEFAULT_METRIC_TYPE]: MUST always be the maximum
      expressible metric of type DEFAULT_METRIC_TYPE.  No
      interoperability problems due to variations on different nodes,
      but if a lesser value is used, route comparisons may exhibit
      overly restrictive behavior.

   o  MAXTIME: Variations on different nodes would not cause problems
      for interoperability.  If a lesser value is used, route state
      management may exhibit overly restrictive behavior.







Perkins, et al.        Expires September 25, 2015              [Page 48]

Internet-Draft                   AODVv2                       March 2015


13.3.  Administrative (functional) controls

   The following administrative controls may be used to change the
   operation of the network, by enabling optional behaviors.  These
   options are not required for correct routing behavior, although they
   may potentially reduce AODVv2 protocol messaging in certain
   situations.  The default behavior is typically to NOT enable the
   options.  Inconsistent settings at different nodes in the network
   will not result in protocol errors.  In the case of inconsistent
   settings for DEFAULT_METRIC_TYPE, inconsistent setting might result
   in messages specifying metric types unknown to some nodes and
   consequent poor performance.

      +------------------------+------------------------------------+
      |          Name          | Description                        |
      +------------------------+------------------------------------+
      |  DEFAULT_METRIC_TYPE   | 3 (i.e, Hop Count (see [RFC6551])) |
      |  ENABLE_IDLE_IN_RERR   | Section 9.3.1                      |
      |      ENABLE_IRREP      | Section 9.1.1                      |
      |   USE_MULTICAST_RREP   | Section 12.3                       |
      +------------------------+------------------------------------+

               Table 6: Administratively Configured Controls

13.4.  Other administrative parameters and lists

   The following table lists contains AODVv2 parameters which should be
   administratively configured for each node.

    +-----------------------+-----------------------+-----------------+
    | Name                  | Default Value         | Cross Reference |
    +-----------------------+-----------------------+-----------------+
    | AODVv2_INTERFACES     |                       | Section 4       |
    | BUFFER_SIZE_PACKETS   | 2                     | Section 8.5     |
    | BUFFER_SIZE_BYTES     | MAX_PACKET_SIZE [TBD] | Section 8.5     |
    | CLIENT_ADDRESSES      | AODVv2_INTERFACES     | Section 6.3     |
    | CONTROL_TRAFFIC_LIMIT | TBD [50 packets/sec?] | Section 9       |
    +-----------------------+-----------------------+-----------------+

                 Table 7: Other Administrative Parameters

14.  IANA Considerations

   This section specifies several RFC 5444 message types, message tlv-
   types, and address tlv-types.  Also, a new registry of 16-bit
   alternate metric types is specified.





Perkins, et al.        Expires September 25, 2015              [Page 49]

Internet-Draft                   AODVv2                       March 2015


14.1.  AODVv2 Message Types Specification

           +----------------------------------------+----------+
           |         Name of AODVv2 Message         |   Type   |
           +----------------------------------------+----------+
           |          Route Request (RREQ)          | 10 (TBD) |
           |           Route Reply (RREP)           | 11 (TBD) |
           |           Route Error (RERR)           | 12 (TBD) |
           | Route Reply Acknowledgement (RREP_Ack) | 13 (TBD) |
           +----------------------------------------+----------+

                       Table 8: AODVv2 Message Types

14.2.  Message TLV Type Specification

   +-----------------------------+----------+----------+---------------+
   | Name of Message TLV         |   Type   |  Length  | Cross         |
   |                             |          | (octets) | Reference     |
   +-----------------------------+----------+----------+---------------+
   | AckReq (Acknowledgment      | 10 (TBD) |    0     | Section 6.2   |
   | Request)                    |          |          |               |
   | PktSource (Packet Source)   | 11 (TBD) | 4 or 16  | Section 9.3.1 |
   +-----------------------------+----------+----------+---------------+

                        Table 9: Message TLV Types

14.3.  Address Block TLV Specification

   +----------------------------+-----------+------------+-------------+
   | Name of Address Block TLV  |    Type   | Length     | Value       |
   +----------------------------+-----------+------------+-------------+
   | Metric                     |  10 (TBD) | depends on | Section 9.1 |
   |                            |           | MetricType |             |
   | Sequence Number (SeqNum)   |  11 (TBD) | 2 octets   | Section 9.1 |
   | Originating Node Sequence  |  12 (TBD) | 2 octets   | Section 9.1 |
   | Number (OrigSeqNum)        |           |            |             |
   | Target Node Sequence       |  13 (TBD) | 2 octets   | Section 9.1 |
   | Number (TargSeqNum)        |           |            |             |
   | VALIDITY_TIME              |     1     | 1 octet    | [RFC5497]   |
   +----------------------------+-----------+------------+-------------+

                Table 10: Address Block TLV (AddrTLV) Types

14.4.  MetricType Number Allocation

   Metric types are identified according to the assignments as specified
   in [RFC6551].  The metric type of the Hop Count metric is assigned to




Perkins, et al.        Expires September 25, 2015              [Page 50]

Internet-Draft                   AODVv2                       March 2015


   be 3, in order to maintain compatibility with that existing table of
   values from RFC 6551.

            +-----------------------+----------+-------------+
            |   Name of MetricType  |   Type   | Metric Size |
            +-----------------------+----------+-------------+
            |      Unallocated      |  0 -- 2  |     TBD     |
            |       Hop Count       | 3 - TBD  |   1 octet   |
            |      Unallocated      | 4 -- 254 |     TBD     |
            |        Reserved       |   255    |  Undefined  |
            +-----------------------+----------+-------------+

                          Table 11: Metric Types

15.  Security Considerations

   The objective of the AODVv2 protocol is for each router to
   communicate reachability information about addresses for which it is
   responsible.  Positive routing information (i.e. a route exists) is
   distributed via RREQ and RREP messages.  Negative routing information
   (i.e. a route does not exist) is distributed via RERRs.  AODVv2
   routers store the information contained in these messages in order to
   properly forward data packets, and they generally provide this
   information to other AODVv2 routers.

   This section describes various security considerations and potential
   avenues to secure AODVv2 routing.  Security for authentication of
   AODVv2 routers, and/or encryption of traffic is dealt with by the
   underlying transport mechanism (e.g., by using the techniques for
   Authentication, Integrity, and Confidentiality documented in
   [RFC5444]).  The most important security mechanism for AODVv2 routing
   is integrity/authentication.

   In situations where routing information are suspect, integrity and
   authentication techniques SHOULD be applied to AODVv2 messages.  In
   these situations, routing information that is distributed over
   multiple hops SHOULD also verify the integrity of information based
   on originator of the routing information.

   In situations where confidentiality of AODVv2 messages is important,
   cryptographic techniques can be applied.

   In certain situations, for example sending a RREP or RERR, an AODVv2
   router could include proof that it has previously received valid
   routing information to reach the destination, at one point of time in
   the past.  In situations where routers are suspected of transmitting
   maliciously erroneous information, the original routing information
   along with its security credentials SHOULD be included.



Perkins, et al.        Expires September 25, 2015              [Page 51]

Internet-Draft                   AODVv2                       March 2015


   Note that if multicast is used, any confidentiality and integrity
   algorithms used MUST permit multiple receivers to handle the message
   [RFC7182].

   Routing protocols, however, are prime targets for impersonation
   attacks.  In networks where the node membership is not known, it is
   difficult to determine the occurrence of impersonation attacks, and
   security prevention techniques are difficult at best.  However, when
   the network membership is known and there is a danger of such
   attacks, AODVv2 messages must be protected by the use of
   authentication techniques, such as those involving generation of
   unforgeable and cryptographically strong message digests or digital
   signatures.

   Most AODVv2 messages are transmitted to the multicast address LL-
   MANET-Routers [RFC5498].  It is therefore required for security that
   AODVv2 neighbors exchange security information that can be used to
   insert an ICV [RFC7182] into the AODVv2 message block [RFC5444].
   This enables hop-by-hop security.  For destination-only RREP
   discovery procedures, AODVv2 routers that share a security
   association SHOULD use the appropriate mechanisms as specified in
   [RFC7182].  The establishment of these security associations is out
   of scope for this document.

16.  Acknowledgments

   AODVv2 is a descendant of the design of previous MANET on-demand
   protocols, especially AODV [RFC3561] and DSR [RFC4728].  Changes to
   previous MANET on-demand protocols stem from research and
   implementation experiences.  Thanks to Elizabeth Belding and Ian
   Chakeres for their long time authorship of AODV.  Additional thanks
   to Derek Atkins, Emmanuel Baccelli, Abdussalam Baryun, Ramon Caceres,
   Thomas Clausen, Christopher Dearlove, Ulrich Herberg, Henner Jakob,
   Luke Klein-Berndt, Lars Kristensen, Tronje Krop, Koojana Kuladinithi,
   Kedar Namjoshi, Alexandru Petrescu, Henning Rogge, Fransisco Ros,
   Pedro Ruiz, Christoph Sommer, Lotte Steenbrink, Romain Thouvenin,
   Richard Trefler, Jiazi Yi, Seung Yi, and Cong Yuan, for their reviews
   AODVv2 and DYMO, as well as numerous specification suggestions.

17.  References

17.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC4291]  Hinden, R. and S. Deering, "IP Version 6 Addressing
              Architecture", RFC 4291, February 2006.



Perkins, et al.        Expires September 25, 2015              [Page 52]

Internet-Draft                   AODVv2                       March 2015


   [RFC5082]  Gill, V., Heasley, J., Meyer, D., Savola, P., and C.
              Pignataro, "The Generalized TTL Security Mechanism
              (GTSM)", RFC 5082, October 2007.

   [RFC5444]  Clausen, T., Dearlove, C., Dean, J., and C. Adjih,
              "Generalized Mobile Ad Hoc Network (MANET) Packet/Message
              Format", RFC 5444, February 2009.

   [RFC5497]  Clausen, T. and C. Dearlove, "Representing Multi-Value
              Time in Mobile Ad Hoc Networks (MANETs)", RFC 5497, March
              2009.

   [RFC5498]  Chakeres, I., "IANA Allocations for Mobile Ad Hoc Network
              (MANET) Protocols", RFC 5498, March 2009.

   [RFC6551]  Vasseur, JP., Kim, M., Pister, K., Dejean, N., and D.
              Barthel, "Routing Metrics Used for Path Calculation in
              Low-Power and Lossy Networks", RFC 6551, March 2012.

17.2.  Informative References

   [I-D.perkins-irrep]
              Perkins, C. and I. Chakeres, "Intermediate RREP for
              dynamic MANET On-demand (AODVv2) Routing", draft-perkins-
              irrep-02 (work in progress), November 2012.

   [Perkins94]
              Perkins, C. and P. Bhagwat, "Highly Dynamic Destination-
              Sequenced Distance-Vector Routing (DSDV) for Mobile
              Computers", Proceedings of the ACM SIGCOMM '94 Conference
              on Communications Architectures, Protocols and
              Applications, London, UK, pp. 234-244, August 1994.

   [Perkins99]
              Perkins, C. and E. Royer, "Ad hoc On-Demand Distance
              Vector (AODV) Routing", Proceedings of the 2nd IEEE
              Workshop on Mobile Computing Systems and Applications, New
              Orleans, LA, pp. 90-100, February 1999.

   [RFC2501]  Corson, M. and J. Macker, "Mobile Ad hoc Networking
              (MANET): Routing Protocol Performance Issues and
              Evaluation Considerations", RFC 2501, January 1999.

   [RFC3561]  Perkins, C., Belding-Royer, E., and S. Das, "Ad hoc On-
              Demand Distance Vector (AODV) Routing", RFC 3561, July
              2003.





Perkins, et al.        Expires September 25, 2015              [Page 53]

Internet-Draft                   AODVv2                       March 2015


   [RFC4193]  Hinden, R. and B. Haberman, "Unique Local IPv6 Unicast
              Addresses", RFC 4193, October 2005.

   [RFC4728]  Johnson, D., Hu, Y., and D. Maltz, "The Dynamic Source
              Routing Protocol (DSR) for Mobile Ad Hoc Networks for
              IPv4", RFC 4728, February 2007.

   [RFC4861]  Narten, T., Nordmark, E., Simpson, W., and H. Soliman,
              "Neighbor Discovery for IP version 6 (IPv6)", RFC 4861,
              September 2007.

   [RFC5148]  Clausen, T., Dearlove, C., and B. Adamson, "Jitter
              Considerations in Mobile Ad Hoc Networks (MANETs)", RFC
              5148, February 2008.

   [RFC6130]  Clausen, T., Dearlove, C., and J. Dean, "Mobile Ad Hoc
              Network (MANET) Neighborhood Discovery Protocol (NHDP)",
              RFC 6130, April 2011.

   [RFC6621]  Macker, J., "Simplified Multicast Forwarding", RFC 6621,
              May 2012.

   [RFC7182]  Herberg, U., Clausen, T., and C. Dearlove, "Integrity
              Check Value and Timestamp TLV Definitions for Mobile Ad
              Hoc Networks (MANETs)", RFC 7182, April 2014.

Appendix A.  Example Algorithms for AODVv2 Protocol Operations

   The following subsections show example algorithms for protocol
   operations required by AODVv2, including RREQ, RREP, RERR, and
   RREP_Ack.

   Processing for RREQ, RREP, and RERR messages follows the following
   general outline:

   1.  Receive incoming message.

   2.  Update route table as appropriate.

   3.  Respond as needed, often regenerating the incoming message with
       updated information.

   Once the route table has been updated, the information contained
   there is known to be the most recent available information for any
   fields in the outgoing message.  For this reason, the algorithms are
   written as if outgoing message field values are assigned from the
   route table information, even though it is often equally appropriate
   to use fields from the incoming message.



Perkins, et al.        Expires September 25, 2015              [Page 54]

Internet-Draft                   AODVv2                       March 2015


   AODVv2_algorithms:

   o  Process_Routing_Info

   o  Fetch_Route_Table_Entry

   o  Update_Route_Table_Entry

   o  Create_Route_Table_Entry

   o  LoopFree

   o

   o  Update_Rte_Msg_Table

   o

   o  Generate_RREQ

   o  Receive_RREQ

   o  Regenerate_RREQ

   o

   o  Generate_RREP

   o  Receive_RREP

   o  Regenerate_RREP

   o

   o  Generate_RERR

   o  Receive_RERR

   o  Regenerate_RERR

   o

   o  Generate_RREP_Ack

   o  Receive_RREP_Ack

   o  Timeout RREP_Ack




Perkins, et al.        Expires September 25, 2015              [Page 55]

Internet-Draft                   AODVv2                       March 2015


   The following lists indicate the meaning of the field names used in
   subsequent sections to describe message processing for the above
   algorithms.

   RteMsg parameters, where rteMsg can be inRREQ, outRREQ, inRREP or
   outRREP:

      rteMsg.hopLimit

      rteMsg.hopCount

      rteMsg.ackReq (RREP only, optional)

      rteMsg.metricType (optional)

      rteMsg.origAddr

      rteMsg.targAddr

      rteMsg.origPrefixLen (optional)

      rteMsg.targPrefixLen (optional)

      rteMsg.origSeqNum (RREQ only)

      rteMsg.targSeqNum (optional in RREQ)

      rteMsg.origAddrMetric (RREQ only)

      rteMsg.targAddrMetric (RREP only)

      rteMsg.validityTime

      rteMsg.nbrIP

   AdvRte has the following properties as described in Section 8.1:

      AdvRte.Address = OrigAddr (in a RREQ) or TargAddr (in a RREP)

      AdvRte.PrefixLength = PrefixLength for OrigAddr (in a RREQ) or
      TargAddr (in a RREP), or if not present, the maximum address
      length for the address family of AdvRte.Address

      AdvRte.SeqNum = SeqNum for OrigAddr (in a RREQ) or for TargAddr
      (in a RREP)

      AdvRte.MetricType = RteMsg.MetricType




Perkins, et al.        Expires September 25, 2015              [Page 56]

Internet-Draft                   AODVv2                       March 2015


      AdvRte.Metric = RteMsg.Metric

      AdvRte.Cost = AdvRte.Metric + Cost(L) according to the indicated
      MetricType, where L is the link from the advertising router

      AdvRte.ValidityTime = ValidityTime in the RteMsg, if present

      AdvRte.NextHopIP = IP source of the RteMsg

      AdvRte.NextHopIntf = interface the RteMsg was received on

      AdvRte.HopCount = value from RteMsg header

      AdvRte.HopLimit = value from RteMsg header

      AdvRte.AckReq = true/false whether present in RteMsg (optional in
      RREP)

   A route table entry has properties as described in Section 6.1:

      Route.Address

      Route.PrefixLength

      Route.SeqNum

      Route.NextHop

      Route.NextHopInterface

      Route.LastUsed

      Route.LastSeqNum

      Route.ExpirationTime

      Route.MetricType

      Route.Metric

      Route.State

      Route.Timed

      Route.Precursors (optional)






Perkins, et al.        Expires September 25, 2015              [Page 57]

Internet-Draft                   AODVv2                       March 2015


A.1.  Subroutines for AODVv2 Operations

A.1.1.  Process_Routing_Info

     /* Compare incoming route information to stored route, maybe use
        linkMetric: either Cost(inRREQ.netif) or (inRREP.netif) */
     Process_Routing_Info (advRte)
     {
       rte := Fetch_Route_Table_Entry (advRte);
       if (!rte exists)
       {
         rte := Create_Route_Table_Entry(advRte);
         return rte;
       }

       /* rule from 8.1 */
       if (
            (AdvRte.SeqNum > Route.SeqNum)  /* stored route is stale */
              OR
             ((AdvRte.SeqNum == Route.SeqNum)  /* same SeqNum */
               AND
             [( (Route.State == Invalid)
                 AND
                (LoopFree(advRte, rte)))  /* advRte can repair stored */
               OR
          (AdvRte.Cost < Route.Metric)])) /* advRte is better */
       {
         Update_Route_Table_Entry (rte, advRte);
       }
       return rte;
     }




















Perkins, et al.        Expires September 25, 2015              [Page 58]

Internet-Draft                   AODVv2                       March 2015


A.1.2.  Fetch_Route_Table_Entry

       /* lookup a route table entry matching an advertised route */
       Fetch_Route_Table_Entry (advRte)
       {
         foreach (rteTableEntry in rteTable)
         {
            if (rteTableEntry.Address == advRte.Address AND
                rteTableEntry.MetricType == advRte.MetricType)
            return rteTableEntry;
         }
         return null;
       }

       /* lookup a route table entry matching address and metric type */
       Fetch_Route_Table_Entry (destination, metricType)
       {
         foreach (rteTableEntry in rteTable)
         {
            if (rteTableEntry.Address == destination AND
                rteTableEntry.MetricType == metricType)
            return rteTableEntry;
         }
         return null;
       }


























Perkins, et al.        Expires September 25, 2015              [Page 59]

Internet-Draft                   AODVv2                       March 2015


A.1.3.  Update_Route_Table_Entry

       /* update a route table entry using AdvRte in received RteMsg */
       Update_Route_Table_Entry (rte, advRte);
       {
         rte.SeqNum := advRte.SeqNum;
         rte.NextHop := advRte.NextHopIp;
         rte.NextHopInterface := advRte.NextHopIntf;
         rte.LastUsed := Current_Time;
         rte.LastSeqNum := Current_Time;
         if (validityTime)
         {
            rte.ExpirationTime := Current_Time + advRte.validityTime;
            rte.Timed := true;
         }
         else
         {
            rte.Timed := false;
            rte.ExpirationTime := MAXTIME;
         }

         rte.Metric := advRte.Cost;
         if (rte.State == Invalid)
           rte.State := Idle;
       }

A.1.4.  Create_Route_Table_Entry

     /* Create a route table entry from address and prefix length */
     Create_Route_Table_Entry (address, prefixLength,
                                                 seqNum, metricType)
     {
       rte := allocate_memory();
       rte.Address := address;
       rte.PrefixLength := prefixLength;
       rte.SeqNum := seqNum;
       rte.MetricType := metricType;
     }













Perkins, et al.        Expires September 25, 2015              [Page 60]

Internet-Draft                   AODVv2                       March 2015


     /* Create a route table entry from the advertised route */
     Create_Route_Table_Entry(advRte)
     {
       rte := allocate_memory();

       rte.Address := advRte.Address;
       if (advRte.PrefixLength)
         rte.PrefixLength := advRte.PrefixLength;
       else
         rte.PrefixLength := maxPrefixLenForAddressFamily;

       rte.SeqNum := advRte.SeqNum;
       rte.NextHop := advRte.NextHopIp;
       rte.NextHopInterface := advRte.NextHopIntf;
       rte.LastUsed := Current_Time
       rte.LastSeqnum := Current_Time
       if (validityTime)
       {
         rte.ExpirationTime := Current_Time + advRte.ValidityTime;
         rte.Timed := true;
       }
       else
       {
         rte.Timed := false;
         rte.ExpirationTime := MAXTIME;
       }
       rte.MetricType := advRte.MetricType;
       rte.Metric := advRte.Metric;
       rte.State := Idle;
     }

A.1.5.  LoopFree

       /* return TRUE if the route advRte is LoopFree compared to rte */
       LoopFree(advRte, rte)
       {
         if (advRte.Cost <= rte.Cost)
            return true;
         else
            return false;
       }










Perkins, et al.        Expires September 25, 2015              [Page 61]

Internet-Draft                   AODVv2                       March 2015


A.1.6.  Fetch_Rte_Msg_Table_Entry

       /* Find an entry in the RteMsg table matching the given
          message's msg-type, OrigAddr, TargAddr, MetricType   */
       Fetch_Rte_Msg_Table_Entry (rteMsg)
       {
         foreach (entry in RteMsgTable)
         {
           if (entry.msg-type == rteMsg.msg-type AND
               entry.OrigAddr == rteMsg.OrigAddr AND
               entry.TargAddr == rteMsg.TargAddr AND
               entry.MetricType == rteMsg.MetricType)
           {
             return entry;
           }
         }
         return NULL;
       }

A.1.7.  Update_Rte_Msg_Table

       /* update the multicast route message suppression table based
          on the received RteMsg, return true if it was created or
          the SeqNum was updated (i.e. it needs to be regenerated) */
       Update_Rte_Msg_Table(rteMsg)
       {
         /* search for a comparable entry */
         entry := Fetch_Rte_Msg_Table_Entry(rteMsg)

         /* if there is none, create one (see 6.5 and 8.6) */
         if (entry does not exist)
         {
           entry.MessageType := rteMsg.msg_type
           entry.OrigAddr := rteMsg.OrigAddr
           entry.TargAddr := rteMsg.TargAddr
           entry.OrigSeqNum := rteMsg.origSeqNum (if present)
           entry.TargSeqNum := rteMsg.targSeqNum (if present)
           entry.MetricType := rteMsg.MetricType
           entry.Metric := rteMsg.origAddrMetric(for RREQ)
                        or rteMsg.targAddrMetric(for RREP)
           entry.Timestamp := Current_Time
           return true;
         }








Perkins, et al.        Expires September 25, 2015              [Page 62]

Internet-Draft                   AODVv2                       March 2015


         /* if current entry is stale */
         if ( (rteMsg.msg-type == RREQ AND
                           entry.OrigSeqNum < rteMsg.OrigSeqNum)
              OR
              (rteMsg.msg-type == RREP AND
                           entry.TargSeqNum < rteMsg.TargSeqNum))
         {
           entry.OrigSeqNum := rteMsg.OrigSeqNum (if present)
           entry.TargSeqNum := rteMsg.TargSeqNum (if present)
           entry.Timestamp := Current_Time
           return true;
         }

         /* if received rteMsg is stale */
         if ( (rteMsg.msg-type == RREQ AND
                           entry.OrigSeqNum > rteMsg.OrigSeqNum)
              OR
              (rteMsg.msg-type == RREP AND
                           entry.TargSeqNum > rteMsg.TargSeqNum))
         {
           entry.Timestamp := Current_Time
           return false;
         }

         /* if same SeqNum but rteMsg has lower metric */
         if (entry.Metric > rteMsg.Metric)
           entry.Metric := rteMsg.Metric

         entry.Timestamp := Current_Time
         return false;
       }




















Perkins, et al.        Expires September 25, 2015              [Page 63]

Internet-Draft                   AODVv2                       March 2015


A.1.8.  Build_RFC_5444_message_header

      /* This pseudocode shows possible RFC 5444 actions, and
         would not be performed by the AODVv2 implementation.
         It is shown only to provide more understanding about
         the AODVv2 message that will be constructed by RFC 5444 */
      Build_RFC_5444_message_header (msgType, Flags,
                    AddrFamily, Size, hopLimit, hopCount, tlvLength)
      {
         /* Build RFC 5444 message header fields */
         msg-type := msgType
         MF (Message Flags) := Flags
         MAL (Message Address Length) := 3 for IPv4, 15 for IPv6
         msg-size := Size (octets - counting MsgHdr, AddrBlk, AddrTLVs)
         msg-hop-limit := hopLimit
         if (hopCount != 0)    /* hopCount == 0 means do not include */
           msg-hop-count := hopCount
         msg.tlvs-length := tlvLength
      }

A.2.  Example Algorithms for AODVv2 RREQ Operations

A.2.1.  Generate_RREQ

       Generate_RREQ
       {
         /* Increment sequence number */
         mySeqNum := (1 + mySeqNum) /* from nonvolatile storage */

         /* Marshall parameters */
         outRREQ.hopLimit := MAX_HOPCOUNT   /* RFC 5444 */
         outRREQ.hopCount := (if included) 0
         outRREQ.metricType := if not DEFAULT_METRIC_TYPE,
                                 metric type needed by application
         outRREQ.origAddr := IP address of Router Client which generated
                                 the packet to be forwarded
         outRREQ.targAddr := destination IP address in
                                 the packet to be forwarded
         outRREQ.origPrefixLen := if included, the prefix length
                                 associated with the Router Client
         outRREQ.origSeqNum := mySeqNum
         outRREQ.targSeqNum := if known from route table,
                                 target sequence number
         outRREQ.origAddrMetric := 0 (default) or
                                       MIN_METRIC(outRREQ.metricType)
         outRREQ.validityTime := if included, the validity time
                                 for route to OrigAddr




Perkins, et al.        Expires September 25, 2015              [Page 64]

Internet-Draft                   AODVv2                       March 2015


         /* Build Address Blk */
         AddrBlk := outRREQ.origAddr and outRREQ.targAddr addresses
               /* using prefix length information from
                  outRREQ.origPrefixLen if necessary */

         /* Include each available Sequence Number in appropriate
            Address Block TLV */
         /* OrigSeqNum Address Block TLV */
         origSeqNumAddrBlkTlv.value := outRREQ.origSeqNum

         /* TargSeqNum Address Block TLV */
         if (outRREQ.targSeqNum is known)
         {
           targSeqNumAddrBlkTlv.value := outRREQ.targSeqNum
         }

         /* Build Metric Address Block TLV */
         metricAddrBlkTlv.value := outRREQ.origAddrMetric
         if (outRREQ.metricType != DEFAULT_METRIC_TYPE)
         { /* include Metric AddrBlkTlv Extension byte */
           metricAddrBlkTlv.typeExtension := outRREQ.MetricType
         }

         if (outRREQ.validityTime is required)
         {
           /* Build VALIDITY_TIME Address Block TLV */
           VALIDITY_TIMEAddrBlkTlv.value := outRREQ.validityTime
         }

         /* multicast RFC 5444 message to LL-MANET-Routers */
       }

A.2.2.  Receive_RREQ

      Receive_RREQ (inRREQ)
      {
        if (inRREQ.nbrIP present in blacklist) {
             if (blacklist_expiration_time < current_time)
                return;   /* don't process or regenerate RREQ... */
             else
               remove nbrIP from blacklist;
           }
        if (inRREQ does not contain msg_hop_limit, OrigAddr,
                                TargAddr, OrigSeqNum, OrigAddrMetric)
             return;

        if (inRREQ.origAddr and inRREQ.targAddr are not valid
                                routable and unicast addresses)



Perkins, et al.        Expires September 25, 2015              [Page 65]

Internet-Draft                   AODVv2                       March 2015


             return;

        if (inRREQ.metricType is present but an unknown value)
             return;

        if (inRREQ.origAddrMetric >
                          MAX_METRIC[inRREQ.metricType] - Cost(Link)
             return;

        /* Extract inRREQ values */
        advRte.Address = inRREQ.origAddr
        advRte.PrefixLength = inRREQ.origPrefixLen (if present),
                                or the maximum address length for the
                                address family of advRte.Address
        advRte.SeqNum = inRREQ.origSeqNum
        advRte.MetricType = inRREQ.metricType
        advRte.Metric = inRREQ.origAddrMetric
        advRte.Cost = inRREQ.origAddrMetric + Cost(L)
                       according to the indicated MetricType, where
                       L is the link from the advertising router
        advRte.ValidityTime = inRREQ.validityTime (if present)
        advRte.NextHopIP = inRREQ.nbrIP
        advRte.NextHopIntf = interface the RteMsg was received on
        advRte.HopCount = inRREQ.hopCount
        advRte.HopLimit = inRREQ.hopLimit

        rte = Process_Routing_Info (advRte)

        /* update the RteMsgTableand determine if the RREQ needs
           to be regenerated */
        regenerate = Update_Rte_Msg_Table(inRREQ)

        if (inRREQ.targAddr is in Router Client list)
           Generate_RREP(inRREQ, rte)
        else if (regenerate)
           Regenerate_RREQ(inRREQ, rte)
       }

A.2.3.  Regenerate_RREQ

       Regenerate_RREQ (inRREQ, rte) /* called from receive_RREQ(),
                                   rte is the route to OrigAddr */
       {
         outRREQ.hopLimit := inRREQ.hopLimit - 1
         if (outRREQ.hopLimit == 0)
           return; /* don't regenerate */

         if (inRREQ.hopCount exists)



Perkins, et al.        Expires September 25, 2015              [Page 66]

Internet-Draft                   AODVv2                       March 2015


         {
           if (inRREQ.hopCount >= MAX_HOPCOUNT)
             return; /* don't regenerate */
           outRREQ.hopCount := inRREQ.hopCount + 1
         }

         /* Marshall parameters */
         outRREQ.metricType := rte.MetricType
         outRREQ.origAddr := rte.Address
         outRREQ.targAddr := inRREQ.targAddr
         outRREQ.origPrefixLen := rte.PrefixLength
                                 (if not equal to address length)
         outRREQ.origSeqNum := rte.SeqNum
         outRREQ.targSeqNum := inRREQ.targSeqNum /* if present */
         outRREQ.origAddrMetric := rte.Metric
         outRREQ.validityTime := rte.ValidityTime or length of time
                    HandlingRtr wishes to advertise route to OrigAddr


         /* Build Address Block */
         AddrBlk := outRREQ.origAddr and outRREQ.targAddr addresses
              using prefix length information from outRREQ.origPrefixLen
              if necessary

         /* Include available Sequence Numbers in Address Block TLV */
         /* OrigSeqNum Address Block TLV */
         origSeqNumAddrBlkTlv.value := outRREQ.origSeqNum

         /* TargSeqNum Address Block TLV */
         if (outRREQ.targSeqNum is known) {
           targSeqNumAddrBlkTlv.value := outRREQ.targSeqNum
         }

         /* Build Metric Address Block TLV */
         metricAddrBlkTlv.value = outRREQ.origAddrMetric
         if (outRREQ.metricType != DEFAULT_METRIC_TYPE)
         { /* include Metric AddrBlkTlv extension byte */
           metricAddrBlkTlv.typeExtension := outRREQ.MetricType
         }

         if (outRREQ.validityTime is required)
         {
           /* Build VALIDITY_TIME Address Block TLV */
           VALIDITY_TIMEAddrBlkTlv.value = outRREQ.validityTime
         }
         Build_RFC_5444_message_header (RREQ, 4, IPv4 or IPv6, NN,
                   outRREQ.hopLimit, outRREQ.hopCount, tlvLength)




Perkins, et al.        Expires September 25, 2015              [Page 67]

Internet-Draft                   AODVv2                       March 2015


         /* multicast RFC 5444 message to LL-MANET-Routers, or if
            inRREQ was unicast the message can be unicast to the next
            hop on the route to TargAddr, if known */
       }

A.3.  Example Algorithms for AODVv2 RREP Operations

A.3.1.  Generate_RREP

       Generate_RREP(inRREQ, rte)
       {
         /* Increment Sequence Number */
         mySeqNum := (1 + mySeqNum) /* from nonvolatile storage */

         /* Marshall parameters */
         outRREP.hopLimit := inRREQ.hopCount
         outRREP.hopCount := 0
         /* Include the AckReq when:
            - previous RREP does not seem to enable any data flow, OR
            - when RREQ is received from same OrigAddr after RREP was
              unicast to rte.nextHop
         */
         outRREP.ackReq := if included, TRUE otherwise FALSE

         if (rte.metricType != DEFAULT_METRIC_TYPE)
              outRREP.metricType := rte.metricType
         outRREP.origAddr := rte.Address
         outRREP.targAddr := inRREQ.targAddr
         outRREP.targPrefixLen := rte.PrefixLength
                                (if not equal to address length)
         outRREP.targSeqNum := mySeqNum
         outRREP.targAddrMetric := 0 (default) or
                                   MIN_METRIC(rte.metricType)

         outRREP.validityTime := (if included) the validity time
                                for route to TargAddr

         if (outRREP.ackReq == TRUE)
         {
            /* include AckReq Message TLV */
         }

         /* Build Address Block */
         AddrBlk := outRREP.origAddr and outRREP.targAddr addresses
              using prefix length information from outRREP.targPrefixLen
              if necessary

         /* TargSeqNum Address Block TLV */



Perkins, et al.        Expires September 25, 2015              [Page 68]

Internet-Draft                   AODVv2                       March 2015


         targSeqNumAddrBlkTlv.value := outRREP.targSeqNum

         /* Build Metric Address Block TLV containing TargAddr metric */
         metricAddrBlkTlv.value := outRREP.targAddrMetric
         if (outRREP.metricType != DEFAULT_METRIC_TYPE)
         { /* include Metric AddrBlkTlv extension byte */
           metricAddrBlkTlv.typeExtension := outRREP.MetricType
         }

         if (outRREP.validityTime is required)
         {
           /* Build VALIDITY_TIME Address Block TLV */
           VALIDITY_TIMEAddrBlkTlv.value = outRREP.validityTime
         }

         Build_RFC_5444_message_header (RREP, 4, IPv4 or IPv6, NN,
                   outRREP.hopLimit, outRREQ.hopCount, tlvLength)
         /* unicast RFC 5444 message to rte[OrigAddr].NextHop */
       }

A.3.2.  Receive_RREP

       Receive_RREP (inRREP)
       {
         if (inRREP.nbrIP present in blacklist) {
           if (blacklist_expiration_time < current_time)
              return;   /* don't process or regenerate RREQ... */
           else
              remove nbrIP from blacklist;
           }

         if (inRREP does not contain msg_hop_limit, OrigAddr,
                           TargAddr, TargSeqNum, TargAddrMetric)
           return;

         if (inRREP.origAddr and inRREQ.targAddr are not
                           valid routable and unicast addresses)
           return;

         if (inRREP.metricType is present but an unknown value)
           return;
         if (inRREP.targAddrMetric >
                               MAX_METRIC[MetricType] - Cost(Link)
           return;

         /* Extract inRREP values */
         advRte.Address := inRREP.targAddr
         advRte.PrefixLength := inRREP.targPrefixLen f present), or the



Perkins, et al.        Expires September 25, 2015              [Page 69]

Internet-Draft                   AODVv2                       March 2015


           maximum address length for address family of advRte.Address
         advRte.SeqNum := inRREP.targSeqNum
         advRte.MetricType := inRREP.metricType
         advRte.Metric := inRREP.targAddrMetric
         advRte.Cost := inRREP.targAddrMetric + Cost(L) according to
          inRREP's MetricType. L is the link from the advertising router
         advRte.ValidityTime := inRREP.validityTime (if present)
         advRte.NextHopIP := inRREP.nbrIP
         advRte.NextHopIntf := interface the RteMsg was received on
         advRte.HopCount := inRREP.hopCount
         advRte.HopLimit := inRREP.hopLimit (if included)

         rte := Process_Routing_Info (advRte)

         if (inRREP includes AckReq data element)
           Generate_RREP_Ack(inRREP)

         /* update the RteMsgTable and determine if the RREP needs
            to be regenerated */
         regenerate := Update_Rte_Msg_Table(inRREP)

         if (inRREP.targAddr is in the Router Client list)
           send_buffered_packets(rte)    /* start to use the route */
         else if (regenerate)
           Regenerate_RREP(inRREP, rte)
       }

























Perkins, et al.        Expires September 25, 2015              [Page 70]

Internet-Draft                   AODVv2                       March 2015


A.3.3.  Regenerate_RREP

       Regenerate_RREP(inRREP, rte)
       {
         if (rte does not exist)
         {
           Generate_RERR(inRREP)
           return;
         }

         outRREP.hopLimit := inRREP.hopLimit - 1
         if (outRREP.hopLimit == 0) /* don't regenerate */
           return;

         if (inRREP.hopCount exists)
         {
           if (inRREP.hopCount >= MAX_HOPCOUNT)
             return; /* don't regenerate */
           outRREP.hopCount := inRREP.hopCount + 1
         }

         /* Marshall parameters */
         /* Include the AckReq when:
            - previous unicast RREP seems not to enable data flow, OR
            - when RREQ is received from same OrigAddr after RREP
                 was unicast to rte.nextHop
         */
         outRREP.ackReq := true or false whether to include
               /* if included, set timeout RREP_Ack_SENT_TIMEOUT */
         if (rte.metricType != DEFAULT_METRIC_TYPE)
              outRREP.metricType := rte.metricType
         outRREP.origAddr := inRREP.origAddr
         outRREP.targAddr := rte.Address
         outRREP.targPrefixLen := rte.PrefixLength
                                (if not equal to address length)
         outRREP.targSeqNum := rte.SeqNum
         outRREP.targAddrMetric := rte.Metric
         outRREP.validityTime := (if included) the validity time
                                for route to TargAddr

         outRREP.nextHop := rte.nextHop

         if (outRREP.ackReq == TRUE)
         {
           /* include AckReq Message TLV */
           /* set timeout RREP_Ack_SENT_TIMEOUT */
         }




Perkins, et al.        Expires September 25, 2015              [Page 71]

Internet-Draft                   AODVv2                       March 2015


         /* Build Address Block */
         AddrBlk := {outRREP.origAddr and outRREP.targAddr}
                using prefix length information from
                outRREP.targPrefixLen if necessary

         /* TargSeqNum Address Block TLV */
         targSeqNumAddrBlkTlv.value := outRREP.targSeqNum

         /* Build Metric Address Block TLV containing TargAddrMetric*/
         metricAddrBlkTlv.value := outRREP.targAddrMetric
         if (outRREP.metricType != DEFAULT_METRIC_TYPE)
         { /* include Metric AddrBlkTlv extension byte */
           metricAddrBlkTlv.typeExtension := outRREP.MetricType
         }

         if (outRREP.validityTime is required)
         {
           /* Build VALIDITY_TIME Address Block TLV */
           VALIDITY_TIMEAddrBlkTlv.value := outRREP.validityTime
         }

         Build_RFC_5444_message_header (RREP, 4, IPv4 or IPv6, NN,
                   outRREP.hopLimit, 0, tlvLength)
         /* unicast RFC 5444 message to rte[OrigAddr].NextHop */
       }

A.4.  Example Algorithms for AODVv2 RERR Operations

   RERR message parameters, where RERR can be inRERR or outRERR:

      RERR.hopLimit := the maximum number of hops this RERR can traverse

      RERR.pktSource := source IP of unforwardable packet (if present)

      RERR.metricType := metric type for routes to unreachable
      destinations

      RERR.unreachableAddressList[] := addresses of unreachable
      destinations

      RERR.prefixLengthList[] := prefix lengths of unreachable
      destinations

      RERR.seqNumList[] := sequence numbers for unreachable destinations

      RERR.intf := the interface on which the RERR was received





Perkins, et al.        Expires September 25, 2015              [Page 72]

Internet-Draft                   AODVv2                       March 2015


A.4.1.  Generate_RERR

   There are two parts to this function, based on whether it was
   triggered by an undeliverable packet or a broken link to neighboring
   AODVv2 router.

       Generate_RERR(errorType, triggerPkt, brokenLinkNbrIp)
          /* errorType is either undeliverablePacket or brokenLink */
       {
         switch (errorType)
         {
           case (brokenLink):
                /* a RERR will be required for each MetricType */
           foreach metric type in use
           {
             doGenerate := FALSE
             num-broken-addr := 0
             precursors[] := new empty precursor list
             outRERR.hopLimit := MAX_HOPCOUNT
             outRERR.metricType := the metric type for this loop
             /* find routes which are now Invalid */
             foreach (rte in route table)
             {
               if (brokenLinkNbrIp == rte.nextHop AND
                             rte.MetricType == outRERR.metricType AND
                  (rte.State == Active OR
                  (rte.State == Idle AND ENABLE_IDLE_IN_RERR)))
               {
                  if (rte.State == Active)
                  {
                    doGenerate := TRUE
                  }
                  rte.State := Invalid
                  precursors += rte.Precursors (if any)
                  outRERR.unreachableAddressList[num-broken-addr] :=
                                                     rte.Address
                  outRERR.prefixLengthList[num-broken-addr] :=
                                                     rte.PrefixLength
                  outRERR.seqNumList[num-broken-addr] := rte.SeqNum
                  num-broken-addr := num-broken-addr + 1
               }
             }
             if (doGenerate == TRUE)
             { /* build and send RFC5444 message as below, then
                  repeat loop for other MetricTypes */           }
           }
           case (undeliverablePacket):
             num-broken-addr := 1



Perkins, et al.        Expires September 25, 2015              [Page 73]

Internet-Draft                   AODVv2                       March 2015


             outRERR.hopLimit := MAX_HOPCOUNT
             outRERR.pktSource := triggerPkt.srcIP or
                           triggerPkt.targAddr if packet was a RREP
             /* optional to include outRERR.metricType */
             outRERR.unreachableAddressList[0] := triggerPkt.destIP or
                           triggerPkt.origAddr if packet was a RREP
         }
         if (triggerPkt exists)
         { /* Build PktSource Message TLV */
           pktSourceMessageTlv.value := outRERR.pktSource
         }

         /* The remaining steps add address, prefix length
            and sequence number information for each
            UnreachableAddress, while conforming to the allowed MTU.
            If the MTU is reached, a new message MUST be created. */
         /* Build Address Block */
         AddrBlk := outRERR.unreachableAddressList[]
                  using prefix length information from
                  outRERR.prefixLengthList[] if necessary

         /* Add SeqNum Address Block TLV including index values */
         seqNumAddrBlkTLV := outRERR.seqNumList[]

         if (outRERR.metricType != DEFAULT_METRIC_TYPE)
         { /* include Metric AddrBlkTlv extension byte */
           metricAddrBlkTlv.typeExtension := outRERR.MetricType
         }

         Build_RFC_5444_message_header (RERR, 4, IPv4 or IPv6, NN,
                   outRERR.hopLimit, 0, tlvLength)
         if (undeliverablePacket)
           /* unicast outRERR to rte[outRERR.pktSource].NextHop */
         else if (brokenLink)
           /* unicast to precursors, or multicast to LL-MANET-Routers */
       }

A.4.2.  Receive_RERR

       Receive_RERR (inRERR)
       {
         if (inRERR does not contain msg_hop_limit and at least
                                         one UnreachableAddress)
           return;

         if (inRERR.metricType is present but an unknown value)
           return;




Perkins, et al.        Expires September 25, 2015              [Page 74]

Internet-Draft                   AODVv2                       March 2015


         /* Extract inRERR values, copy relevant UnreachableAddresses,
            their prefix lengths, and sequence numbers to outRERR */
         num-broken-addr := 0;
         precursors[] := new empty list of type precursors/;

         foreach (unreachableAddress in inRERR.unreachableAddressList)
         {
           if (unreachableAddress is not valid routable
                                                   and unicast address)
             continue;
           /* find a matching route table entry, assume
                      DEFAULT_METRIC_TYPE if no MetricType included */
           rte := Fetch_Route_Table_Entry (unreachableAddress,
                                              inRERR.metricType)
           if (rte does not exist)
             continue;
           if (rte.State == Invalid)/* ignore already invalid routes */
             continue;
           if (rte.NextHop != inRERR.nbrIP OR
                                   rte.NextHopInterface != inRERR.intf)
             continue;
           if (unreachableAddress SeqNum (if known) < rte.SeqNum)
             continue;

           /* keep a note of all precursors of newly Invalid routes */
           precursors += rte.Precursors (if any)

           /* assume prefix length is address length if not included*/
           if (rte.PrefixLength != unreachableAddress prefixLength)
           {
             /* create new route with unreachableAddress information */
             invalidRte := Create_Route_Table_Entry(unreachableAddress,
                   unreachableAddress prefixLength,
                   unreachableAddress seqNum, inRERR.metricType)
             invalidRte.State := Invalid

             if (rte.PrefixLength > unreachableAddress prefixLength)
               expunge_route(rte);
             rte := invalidRte;
           }
           else if (rte.PrefixLength == unreachableAddress prefixLength)
             rte.State := Invalid;

           outRERR.unreachableAddressList[num-broken-addr] :=rte.Address
           outRERR.prefixLengthList[num-broken-addr] := rte.PrefixLength
           outRERR.seqNumList[num-broken-addr] := rte.SeqNum
           num-broken-addr := num-broken-addr + 1
         }



Perkins, et al.        Expires September 25, 2015              [Page 75]

Internet-Draft                   AODVv2                       March 2015


         if (num-broken-addr)
           Regenerate_RERR(outRERR, inRERR, precursors)
       }




























A.4.3.  Regenerate_RERR



















Perkins, et al.        Expires September 25, 2015              [Page 76]

Internet-Draft                   AODVv2                       March 2015


       Regenerate_RERR (outRERR, inRERR, precursors)
       {
         /* Marshal parameters */
         outRERR.hopLimit := inRERR.hopLimit - 1
         if (outRERR.hopLimit == 0) /* don't regenerate */
           return;

         outRERR.pktSource := inRERR.pktSource (if included)
         outRERR.metricType := inRERR.MetricType (if included)
                              or DEFAULT_METRIC_TYPE
         /* UnreachableAddressList[], SeqNumList[], and
            PrefixLengthList[] are already up-to-date */

         if (outRERR.pktSource exists)
         {
           /* Build PktSource Message TLV */
           pktSourceMessageTlv.value := outRERR.pktSource
         }
         if (outRERR.metricType != DEFAULT_METRIC_TYPE)
         {
           /* Build MetricType Message TLV */
           metricMsgTlv.value := outRERR.metricType
         }

         /* Build Address Block */

         AddrBlk := outRERR.unreachableAddressList[] using prefix length
               information from outRERR.prefixLengthList[] if necessary

         /* Add SeqNum AddressBlock TLV including index values */
         seqNumAddrTLV := outRERR.seqNumList[]

         Build_RFC_5444_message_header (RERR, 4, IPv4 or IPv6, NN,
                   outRERR.hopLimit, 0, tlvLength)
         if (outRERR.pktSource exists) {
           /* unicast RFC 5444 message to outRERR.pktSource */
         } else if (number of precursors == 1) {
           /* unicast RFC 5444 message to precursors[0] */
         } else if (number of precursors > 1) {
           /* unicast RFC 5444 message to all precursors, or multicast
              RFC 5444 message to RERR_PRECURSORS if preferable */
         } else {
           /* multicast RFC 5444 message to LL-MANET-Routers */
         }
       }






Perkins, et al.        Expires September 25, 2015              [Page 77]

Internet-Draft                   AODVv2                       March 2015


A.5.  Example Algorithms for AODVv2 RREP_Ack Operations

A.5.1.  Generate_RREP_Ack

       /* To be sent when RREP includes the AckReq data element */
       Generate_RREP_Ack(inRREP)
       {
         Build_RFC_5444_message_header (RREP_Ack, 4, IPv4 or IPv6, NN,
                   1, 0, 0)
         /* unicast RFC 5444 message to inRREP.nbrIP */
       }

A.5.2.  Receive_RREP_Ack


       Receive_RREP_Ack(inRREP_Ack)
       {
         /* cancel timeout event for the node sending RREP_Ack */
       }


A.5.3.  Timeout_RREP_Ack

       Timeout_RREP_Ack(outRREP)
       {
         /* insert unresponsive node into blacklist */
       }

Appendix B.  Changes since revision ...-06.txt

   This section lists the changes since AODVv2 revision ...-06.txt

   o  Added Victoria Mercieca as co-author.

   o  Reorganized protocol message descriptions into major subsections
      for each protocol message.  For protocol messages, organized
      processing into Generation, Reception, and Regeneration
      subsections.

   o  Separated RREQ and RREP message processing description into
      separate major subsection which had previously been combined into
      RteMsg description.

   o  Enlarged RREQ Table function to include similar processing for
      optional flooded RREP messages.  The table name has been
      correspondingly been changed to be the Table for Multicast
      RteMsgs.




Perkins, et al.        Expires September 25, 2015              [Page 78]

Internet-Draft                   AODVv2                       March 2015


   o  Moved sections for Multiple Interfaces and AODVv2 Control Message
      Generation Limits to be major subsections of the AODVv2 Protocol
      Operations section.

   o  Reorganized the protocol message processing steps into the
      subsections as previously described, adopting a more step-by-step
      presentation.

   o  Coalesced the router states Broken and Expired into a new combined
      state named the Invalid state.  No changes in processing are
      required for this.

   o  Merged the sections describing Next-hop Router Adjacency
      Monitoring and Blacklists.

   o  Specified that routes created during Route Discovery are marked as
      Idle routes.  If they are used for carrying data they become
      Active routes.

   o  Added Route.LastSeqnum information to route table, so that route
      activity and sequence number validity can be tracked separately.
      An active route can still forward traffic even if the sequence
      number has not been refreshed within MAX_SEQNUM_LIFETIME.

   o  Mandated implementation of RREP_Ack as response to AckReq Message
      TLV in RREP messages.  Added field to RREP_Ack to ensure
      correspondence to the correct AckReq message.

   o  Added explanations for what happens if protocol constants are
      given different values on different AODVv2 routers.

   o  Specified that AODVv2 implementations are free to choose their own
      heuristics for reducing multicast overhead, including RFC 6621.

   o  Added appendix to identify AODVv2 requirements from OS
      implementation of IP and ICMP.

   o  Deleted appendix showing example RFC 5444 packet formats.

   o  Clarification on the use of RFC 5497 VALIDITY_TIME.

   o  In Terminology, deleted superfluous definitions, added missing
      definitions.

   o  Numerous editorial improvements and clarifications.






Perkins, et al.        Expires September 25, 2015              [Page 79]

Internet-Draft                   AODVv2                       March 2015


Appendix C.  Changes between revisions 5 and 6

   This section lists the changes between AODVv2 revisions ...-05.txt
   and ...-06.txt.

   o  Added Lotte Steenbrink as co-author.

   o  Reorganized section on Metrics to improve readability by putting
      specific topics into subsections.

   o  Introduced concept of data element, which is used to clarify the
      method of enabling RFC 5444 representation for AODVv2 data
      elements.  A list of Data Elements was introduced in section 3,
      which provides a better understanding of their role than was
      previously supplied by the table of notational devices.

   o  Replaced instances of OrigNode by OrigAddr whenever the more
      specific meaning is appropriate.  Similarly for instances of other
      node versus address terminology.

   o  Introduced concepts of PrefixLengthList and MetricList in order to
      avoid use of index-based terminology such as OrigNdx and TargNdx.

   o  Added section 5, "AODVv2 Message Transmission", describing the
      intended interface to RFC 5444.

   o  Included within the main body of the specification the mandatory
      setting of the TLV flag thassingleindex for TLVs OrigSeqNum and
      TargSeqNum.

   o  Removed the Route.Timed state.  Created a new flag for route table
      entries known as Route.Timed.  This flag can be set when the route
      is in the active state.  Previous description would require that
      the route table entry be in two states at the same time, which
      seems to be misleading.  The new flag is used to clarify other
      specification details for Timed routes.

   o  Created table 3 to show the correspondence between AODVv2 data
      elements and RFC 5444 message components.

   o  Replaced "invalid" terminology by the more specific terms "broken"
      or "expired" where appropriate.

   o  Eliminated the instance of duplicate specification for inclusion
      of OrigNode (now, OrigAddr) in the message.






Perkins, et al.        Expires September 25, 2015              [Page 80]

Internet-Draft                   AODVv2                       March 2015


   o  Corrected the terminology to be Mid instead of Tail for the
      trailing address bits of OrigAddr and TargAddr for the example
      message formats in the appendices.

   o  Repaired remaining instances of phraseology that could be
      construed as indicating that AODV only supports a single network
      interface.

   o  Numerous editorial improvements and clarifications.

Appendix D.  Changes from revision ...-04.txt

   This section lists the changes between AODVv2 revisions ...-04.txt
   and ...-05.txt.

   o  Normative text moved out of definitions into the relevant section
      of the body of the specification.

   o  Editorial improvements and improvements to consistent terminology
      were made.  Replaced "retransmit" by the slightly more accurate
      term "regenerate".

   o  Issues were resolved as discussed on the mailing list.

   o  Changed definition of LoopFree as suggested by Kedar Namjoshi and
      Richard Trefler to avoid the failure condition that they have
      described.  In order to make understanding easier, replaced
      abstract parameters R1 by RteMsg and R2 by Route to reduce the
      level of abstraction when the function LoopFree is discussed.

   o  Added text to clarify that different metrics may have different
      data types and different ranges of acceptable values.

   o  Added text to section "RteMsg Structure" to emphasize the proper
      use of RFC 5444.

   o  Included within the main body of the specification the mandatory
      setting of the TLV flag thassingleindex for TLVs OrigSeqNum and
      TargSeqNum.

   o  Made more extensive use of the AdvRte terminology, in order to
      better distinguish between the incoming RREQ or RREP message
      (i.e., RteMsg) versus the route advertised by the RteMsg (i.e.,
      AdvRte).







Perkins, et al.        Expires September 25, 2015              [Page 81]

Internet-Draft                   AODVv2                       March 2015


Appendix E.  Changes from revision ...-03.txt

   This section lists the changes between AODVv2 revisions ...-03.txt
   and ...-04.txt.

   o  An appendix was added to exhibit algorithmic code for
      implementation of AODVv2 functions.

   o  Numerous editorial improvements and improvements to consistent
      terminology were made.  Terminology related to prefix lengths was
      made consistent.  Some items listed in "Notational Conventions"
      were no longer used, and so deleted.

   o  Issues were resolved as discussed on the mailing list.

   o  Appropriate instances of "may" were changed to "MAY".

   o  Definition inserted for "upstream".

   o  Route.Precursors included as an *optional* route table field

   o  Reworded text to avoid use of "relevant".

   o  Deleted references to "DestOnly" flag.

   o  Refined statements about MetricType TLV to allow for omission when
      MetricType == HopCount.

   o  Bulletized list in section 8.1

   o  ENABLE_IDLE_UNREACHABLE renamed to be ENABLE_IDLE_IN_RERR

   o  Transmission and subscription to LL-MANET-Routers converted to
      MUST from SHOULD.

Appendix F.  Changes from revision ...-02.txt

   This section lists the changes between AODVv2 revisions ...-02.txt
   and ...-03.txt.

   o  The "Added Node" feature was removed.  This feature was intended
      to enable additional routing information to be carried within a
      RREQ or a RREP message, thus increasing the amount of topological
      information available to nodes along a routing path.  However,
      enlarging the packet size to include information which might never
      be used can increase congestion of the wireless medium.  The
      feature can be included as an optional feature at a later date




Perkins, et al.        Expires September 25, 2015              [Page 82]

Internet-Draft                   AODVv2                       March 2015


      when better algorithms are understood for determining when the
      inclusion of additional routing information might be worthwhile.

   o  Numerous editorial improvements and improvements to consistent
      terminology were made.  Instances of OrigNodeNdx and TargNodeNdx
      were replaced by OrigNdx and TargNdx, to be consistent with the
      terminology shown in Table 2.

   o  Example RREQ and RREP message formats shown in the Appendices were
      changed to use OrigSeqNum and TargSeqNum message TLVs instead of
      using the SeqNum message TLV.

   o  Inclusion of the OrigNode's SeqNum in the RREP message is not
      specified.  The processing rules for the OrigNode's SeqNum were
      incompletely specified in previous versions of the draft, and very
      little benefit is foreseen for including that information, since
      reverse path forwarding is used for the RREP.

   o  Additional acknowledgements were included, and contributors names
      were alphabetized.

   o  Definitions in the Terminology section capitalize the term to be
      defined.

   o  Uncited bibliographic entries deleted.

   o  Ancient "Changes" sections were deleted.

Appendix G.  Features of IP needed by AODVv2

   AODVv2 needs the following:

   o  information that IP routes are requested

   o  information that packets are flowing

   o  the ability to queue packets.

   A reactive protocol reacts when a route is needed.  One might say
   that a route is requested when an application tries to send a packet.
   The fundamental concept of reactive routing is to avoid creating
   routes that are not needed, and the way that has been used to know
   whether a route is needed is when an application tries to send a
   packet.

   If an application tries to send a packet, and the route is not
   available, the packet has to wait until the route is available.




Perkins, et al.        Expires September 25, 2015              [Page 83]

Internet-Draft                   AODVv2                       March 2015


Appendix H.  Multi-homing Considerations

   This non-normative information is provided simply to document the
   results of previous efforts to enable multi-homing.  The intention is
   to simplify the task of future specification if multihoming becomes
   needed for reactive protocol operation.

   Multi-homing is not supported by the AODVv2 specification.  There has
   been previous work indicating that it can be supported by expanding
   the sequence number to include the AODVv2 router's IP address as a
   parsable field of the SeqNum.  Otherwise, comparing sequence numbers
   would not work to evaluate freshness.  Even when the IP address is
   included, there isn't a good way to compare sequence numbers from
   different IP addresses, but at least a handling node can determine
   whether the two given sequence numbers are comparable.  If the route
   table can store multiple routes for the same destination, then multi-
   homing can work with sequence numbers augmented by IP addresses.

   This non-normative information is provided simply to document the
   results of previous efforts to enable multi-homing.  The intention is
   to simplify the task of future specification if multihoming becomes
   needed for reactive protocol operation.

Appendix I.  Shifting Network Prefix Advertisement Between AODVv2
             Routers

   Only one AODVv2 router within a MANET SHOULD be responsible for a
   particular address at any time.  If two AODVv2 routers dynamically
   shift the advertisement of a network prefix, correct AODVv2 routing
   behavior must be observed.  The AODVv2 router adding the new network
   prefix must wait for any existing routing information about this
   network prefix to be purged from the network.  Therefore, it must
   wait at least ROUTER_SEQNUM_AGE_MAX_TIMEOUT after the previous AODVv2
   router for this address stopped advertising routing information on
   its behalf.

Authors' Addresses

   Charles E. Perkins
   Futurewei Inc.
   2330 Central Expressway
   Santa Clara, CA  95050
   USA

   Phone: +1-408-330-4586
   Email: charliep@computer.org





Perkins, et al.        Expires September 25, 2015              [Page 84]

Internet-Draft                   AODVv2                       March 2015


   Stan Ratliff
   Idirect
   13861 Sunrise Valley Drive, Suite 300
   Herndon, VA  20171
   USA

   Email: ratliffstan@gmail.com


   John Dowdell
   Airbus Defence and Space
   Celtic Springs
   Newport, Wales  NP10 8FZ
   United Kingdom

   Email: john.dowdell@airbus.com


   Lotte Steenbrink
   HAW Hamburg, Dept. Informatik
   Berliner Tor 7
   D-20099 Hamburg
   Germany

   Email: lotte.steenbrink@haw-hamburg.de


   Victoria Mercieca
   Airbus Defence and Space
   Celtic Springs
   Newport, Wales  NP10 8FZ
   United Kingdom

   Email: victoria.mercieca@airbus.com

















Perkins, et al.        Expires September 25, 2015              [Page 85]

