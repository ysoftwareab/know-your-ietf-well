<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="robots" content="index,follow" />

        <link rel="icon" href="./css/images/rfc.png" type="image/png" />
        <link rel="shortcut icon" href="./css/images/rfc.png" type="image/png" />
        <title>rfc5717</title>
    
        <link rel="stylesheet" type="text/css" href="./css/errata-base.css"/>
        <link rel="stylesheet" type="text/css" href="./css/errata-color.css" title="Default: Basic Colors"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-monochrome.css" title="Monochrome"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-printer.css" title="Printer"/>

        <script src="./css/errata.js"></script>
    </head>
    <body>
        <div class='Verified-headnote-styling'>
<span style="font-weight: bold;">This is a purely informative rendering of an RFC that includes verified errata.  This rendering may not be used as a reference.</span>
<br/>
<br/>
The following 'Verified' errata have been incorporated in this document:
 <a href='#btn_1978'>EID 1978</a>,  <a href='#btn_2746'>EID 2746</a>
</div>

        <pre>
Network Working Group                                         B. Lengyel
Request for Comments: 5717                                      Ericsson
Category: Standards Track                                   M. Bjorklund
                                                          Tail-f Systems
                                                           December 2009


          Partial Lock Remote Procedure Call (RPC) for NETCONF

Abstract

   The Network Configuration protocol (NETCONF) defines the lock and
   unlock Remote Procedure Calls (RPCs), used to lock entire
   configuration datastores.  In some situations, a way to lock only
   parts of a configuration datastore is required.  This document
   defines a capability-based extension to the NETCONF protocol for
   locking portions of a configuration datastore.

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (c) 2009 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified

   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
     1.1.  Definition of Terms  . . . . . . . . . . . . . . . . . . .  3
   2.  Partial Locking Capability . . . . . . . . . . . . . . . . . .  3
     2.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . .  3
       2.1.1.  Usage Scenarios  . . . . . . . . . . . . . . . . . . .  4
     2.2.  Dependencies . . . . . . . . . . . . . . . . . . . . . . .  5
     2.3.  Capability Identifier  . . . . . . . . . . . . . . . . . .  5
     2.4.  New Operations . . . . . . . . . . . . . . . . . . . . . .  5
       2.4.1.  &lt;partial-lock&gt; . . . . . . . . . . . . . . . . . . . .  5
       2.4.2.  &lt;partial-unlock&gt; . . . . . . . . . . . . . . . . . . . 10
     2.5.  Modifications to Existing Operations . . . . . . . . . . . 10
     2.6.  Interactions with Other Capabilities . . . . . . . . . . . 11
       2.6.1.  Candidate Configuration Capability . . . . . . . . . . 11
       2.6.2.  Confirmed Commit Capability  . . . . . . . . . . . . . 11
       2.6.3.  Distinct Startup Capability  . . . . . . . . . . . . . 11
   3.  Security Considerations  . . . . . . . . . . . . . . . . . . . 12
   4.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 12
   5.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 13
   6.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 13
     6.1.  Normative References . . . . . . . . . . . . . . . . . . . 13
     6.2.  Informative References . . . . . . . . . . . . . . . . . . 13
   Appendix A.  XML Schema for Partial Locking (Normative)  . . . . . 14
   Appendix B.  YANG Module for Partial Locking (Non-Normative) . . . 17
   Appendix C.  Usage Example - Reserving Nodes for Future
                Editing (Non-Normative) . . . . . . . . . . . . . . . 19

1.  Introduction

   The [NETCONF] protocol describes the lock and unlock operations that
   operate on entire configuration datastores.  Often, multiple
   management sessions need to be able to modify the configuration of a
   managed device in parallel.  In these cases, locking only parts of a
   configuration datastore is needed.  This document defines a
   capability-based extension to the NETCONF protocol to support partial
   locking of the NETCONF running datastore using a mechanism based on
   the existing XPath filtering mechanisms.

1.1.  Definition of Terms

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;NOT RECOMMENDED&quot;, &quot;MAY&quot;, and
   &quot;OPTIONAL&quot; in this document are to be interpreted as described in BCP
   14, [RFC2119].

   Additionally, the following terms are defined:

   o  Instance Identifier: an XPath expression identifying a specific
      node in the conceptual XML datastore.  It contains an absolute
      path expression in abbreviated syntax, where predicates are used
      only to specify values for nodes defined as keys to distinguish
      multiple instances.

   o  Scope of the lock: initially, the set of nodes returned by the
      XPath expressions in a successful partial-lock operation.  The set
      might be modified if some of the nodes are deleted by the session
      owning the lock.

   o  Protected area: the set of nodes that are protected from
      modification by the lock.  This set consists of nodes in the scope
      of the lock and nodes in subtrees under them.

2.  Partial Locking Capability

2.1.  Overview

   The :partial-lock capability indicates that the device supports the
   locking of its configuration with a more limited scope than a
   complete configuration datastore.  The scope to be locked is
   specified by using restricted or full XPath expressions.  Partial
   locking only affects configuration data and only the running
   datastore.  The candidate or the start-up datastore are not affected.

   The system MUST ensure that configuration resources covered by the
   lock are not modified by other NETCONF or non-NETCONF management
   operations such as Simple Network Management Protocol (SNMP) and the
   Command Line Interface (CLI).

   The duration of the partial lock begins when the partial lock is
   granted and lasts until (1) either the corresponding &lt;partial-unlock&gt;
   operation succeeds or (2) the NETCONF session terminates.

   A NETCONF session MAY have multiple parts of the running datastore
   locked using partial lock operations.

   The &lt;partial-lock&gt; operation returns a lock-id to identify each
   successfully acquired lock.  The lock-id is unique at any given time
   for a NETCONF server for all partial-locks granted to any NETCONF or
   non-NETCONF sessions.

2.1.1.  Usage Scenarios

   In the following, we describe a few scenarios for partial locking.
   Besides the two described here, there are many other usage scenarios
   possible.

2.1.1.1.  Multiple Managers Handling the Writable Running Datastore with
          Overlapping Sections

   Multiple managers are handling the same NETCONF agent simultaneously.
   The agent is handled via the writable running datastore.  Each
   manager has his or her own task, which might involve the modification
   of overlapping sections of the datastore.

   After collecting and analyzing input and preparing the NETCONF
   operations off-line, the manager locks the areas that are important
   for his task using one single &lt;partial-lock&gt; operation.  The manager
   executes a number of &lt;edit-config&gt; operations to modify the
   configuration, then releases the partial-lock.  The lock should be
   held for the shortest possible time (e.g., seconds rather than
   minutes).  The manager should collect all human input before locking
   anything.  As each manager locks only a part of the data model,
   usually multiple operators can execute the &lt;edit-config&gt; operations
   simultaneously.

2.1.1.2.  Multiple Managers Handling the Writable Running Datastore,
          Distinct Management Areas

   Multiple managers are handling the same NETCONF agent simultaneously.
   The agent is handled via the writable running datastore.  The agent&#x27;s
   data model contains a number of well-defined separate areas that can
   be configured without impacting other areas.  An example can be a
   server with multiple applications running on it, or a number of
   network elements with a common NETCONF agent for management.

   Each manager has his or her own task, which does not involve the
   modification of overlapping sections of the datastore.

   The manager locks his area with a &lt;partial-lock&gt; operation, uses a
   number of &lt;edit-config&gt; commands to modify it, and later releases the
   lock.  As each manager has his functional area assigned to him, and
   he locks only that area, multiple managers can edit the configuration
   simultaneously.  Locks can be held for extended periods (e.g.,
   minutes, hours), as this will not hinder other managers.

   This scenario assumes that the global lock operation from [NETCONF]
   is not used.

2.2.  Dependencies

   The device MUST support restricted XPath expressions in the select
   element, as described in Section 2.4.1.  Optionally, if the :xpath
   capability is also supported (as defined in [NETCONF], Section 8.9.
   &quot;XPath Capability&quot;), the device MUST also support using any XPath 1.0
   expression in the select element.

2.3.  Capability Identifier

   urn:ietf:params:netconf:capability:partial-lock:1.0

2.4.  New Operations

2.4.1.  &lt;partial-lock&gt;

   The &lt;partial-lock&gt; operation allows the client to lock a portion of
   the running datastore.  The portion to lock is specified with XPath
   expressions in the &quot;select&quot; elements in the &lt;partial-lock&gt; operation.
   Each XPath expression MUST return a node set.

   When a NETCONF session holds a lock on a node, no other session or
   non-NETCONF mechanism of the system can change that node or any node
   in the hierarchy of nodes beneath it.

   Locking a node protects the node itself and the complete subtree
   under the node from modification by others.  The set of locked nodes
   is called the scope of the lock, while all the locked nodes and the
   nodes in the subtrees under them make up the protected area.

   The XPath expressions are evaluated only once: at lock time.
   Thereafter, the scope of the lock is maintained as a set of nodes,
   i.e., the returned nodeset, and not by the XPath expression.  If the
   configuration data is later altered in a way that would make the
   original XPath expressions evaluate to a different set of nodes, this
   does not affect the scope of the partial lock.

   Let&#x27;s say the agent&#x27;s data model includes a list of interface nodes.
   If the XPath expression in the partial-lock operation covers all
   interface nodes at locking, the scope of the lock will be maintained
   as the list of interface nodes at the time when the lock was granted.
   If someone later creates a new interface, this new interface will not
   be included in the locked-nodes list created previously so the new
   interface will not be locked.

   A &lt;partial-lock&gt; operation MUST be handled atomically by the NETCONF
   server.  The server either locks all requested parts of the datastore
   or none.  If during the &lt;partial-lock&gt; operation one of the requested
   parts cannot be locked, the server MUST unlock all parts that have
   already been locked during that operation.

   If a node in the scope of the lock is deleted by the session owning
   the lock, it is removed from the scope of the lock, so any other
   session or non-NETCONF mechanism can recreate it.  If all nodes in
   the scope of the lock are deleted, the lock will still be present.
   However, its scope will become empty (since the lock will not cover
   any nodes).

   A NETCONF server that supports partial locking MUST be able to grant
   multiple simultaneous partial locks to a single NETCONF session.  If
   the protected area of the individual locks overlap, nodes in the
   common area MUST be protected until all of the overlapping locks are
   released.

   A &lt;partial-lock&gt; operation MUST fail if:

   o  Any NETCONF session (including the current session) owns the
      global lock on the running datastore.

   o  Any part of the area to be protected is already locked (or
      protected by partial locking) by another management session,
      including other NETCONF sessions using &lt;partial-lock&gt; or any other
      non-NETCONF management method.

   o  The requesting user is not successfully authenticated.

   o  The NETCONF server implements access control and the locking user
      does not have sufficient access rights.  The exact handling of
      access rights is outside the scope of this document, but it is
      assumed that there is an access control system that MAY deny or
      allow the &lt;partial-lock&gt; operation.

   The &lt;partial-lock&gt; operation is designed for simplicity, so when a
   partial lock is executed, you get what you asked for: a set of nodes
   that are locked for writing.

   As a consequence, users must observe the following:

   o  Locking does not affect read operations.

   o  If part of the running datastore is locked, this has no effect on
      any unlocked parts of the datastore.  If this is a problem (e.g.,
      changes depend on data values or nodes outside the protected part
      of the datastore), these nodes SHOULD be included in the protected
      area of the lock.

   o  Configuration data can be edited both inside and outside the
      protected area of a lock.  It is the responsibility of the NETCONF
      client application to lock all relevant parts of the datastore
      that are crucial for a specific management action.

   Note: The &lt;partial-lock&gt; operation does not modify the global &lt;lock&gt;
   operation defined in the base NETCONF protocol [NETCONF].  If part of
   the running datastore is already locked by &lt;partial-lock&gt;, then a
   global lock for the running datastore MUST fail even if the global
   lock is requested by the NETCONF session that owns the partial lock.

2.4.1.1.  Parameters, Results, Examples

   Parameters:

   select:  One or more &#x27;select&#x27; elements, each containing an XPath
            expression.  The XPath expression is evaluated in a context
            where the context node is the root of the server&#x27;s
            conceptual data model, and the set of namespace declarations
            are those in scope on the select element.

   The nodes returned from the select expressions are reported in the
       rpc-reply message.

   Each select expression MUST return a node set, and at least one of
       the node sets MUST be non-empty.

   If the device supports the :xpath capability, any valid XPath 1.0
       expression can be used.  If the device does not support the
       :xpath capability, the XPath expression MUST be limited to an
       Instance Identifier expression.  An Instance Identifier is an
       absolute path expression in abbreviated syntax, where predicates
       are used only to specify values for nodes defined as keys to
       distinguish multiple instances.

   Example: Lock virtual router 1 and interface eth1

    &lt;nc:rpc
      xmlns=&quot;urn:ietf:params:xml:ns:netconf:partial-lock:1.0&quot;
      xmlns:nc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
      message-id=&quot;135&quot;&gt;
        &lt;partial-lock&gt;
            &lt;select xmlns:rte=&quot;http://example.com/ns/route&quot;&gt;
                /rte:routing/rte:virtualRouter[rte:routerName=&#x27;router1&#x27;]
            &lt;/select&gt;
            &lt;select xmlns:if=&quot;http://example.com/ns/interface&quot;&gt;
                /if:interfaces/if:interface[if:id=&#x27;eth1&#x27;]
            &lt;/select&gt;
         &lt;/partial-lock&gt;
    &lt;/nc:rpc&gt;

    &lt;nc:rpc-reply
      xmlns:nc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
      xmlns=&quot;urn:ietf:params:xml:ns:netconf:partial-lock:1.0&quot;
      message-id=&quot;135&quot;&gt;
        &lt;lock-id&gt;127&lt;/lock-id&gt;
        &lt;locked-node xmlns:rte=&quot;http://example.com/ns/route&quot;&gt;
            /rte:routing/rte:virtualRouter[rte:routerName=&#x27;router1&#x27;]
        &lt;/locked-node&gt;
        &lt;locked-node xmlns:if=&quot;http://example.com/ns/interface&quot;&gt;
            /if:interfaces/if:interface[if:id=&#x27;eth1&#x27;]
        &lt;/locked-node&gt;
    &lt;/nc:rpc-reply&gt;

   Note: The XML Schema in [NETCONF] has a known bug that requires the
   &lt;data&gt; XML element in a &lt;rpc-reply&gt;.  This means that the above
   examples will not validate using the XML Schema found in [NETCONF].

   Positive Response:

   If the device was able to satisfy the request, an &lt;rpc-reply&gt; is sent
   with a &lt;lock-id&gt; element (lock identifier) in the &lt;rpc-reply&gt;
   element.  A list of locked nodes is also returned in Instance
   Identifier format.

   Negative Response:

   If any select expression is an invalid XPath expression, the &lt;error-
   tag&gt; is &#x27;invalid-value&#x27;.

   If any select expression returns something other than a node set, the
   &lt;error-tag&gt; is &#x27;invalid-value&#x27;, and the &lt;error-app-tag&gt; is &#x27;not-a-
   node-set&#x27;.

   If all the select expressions return an empty node set, the &lt;error-
   tag&gt; is &#x27;operation-failed&#x27;, and the &lt;error-app-tag&gt; is &#x27;no-matches&#x27;.

   If the :xpath capability is not supported and the XPath expression is
   not an Instance Identifier, the &lt;error-tag&gt; is &#x27;invalid-value&#x27;, the
   &lt;error-app-tag&gt; is &#x27;invalid-lock-specification&#x27;.

   If access control denies the partial lock, the &lt;error-tag&gt; is
   &#x27;access-denied&#x27;.  Access control SHOULD be checked before checking
   for conflicting locks to avoid giving out information about other
   sessions to an unauthorized client.

   If a lock is already held by another session on any node within the
   subtrees to be locked, the &lt;error-tag&gt; element is &#x27;lock-denied&#x27; and
   the &lt;error-info&gt; element includes the &lt;session-id&gt; of the lock owner.
   If the lock is held by a non-NETCONF session, a &lt;session-id&gt; of 0
   (zero) SHOULD be included.  The same error response is returned if
   the requesting session already holds the (global) lock for the
   running datastore.

   If needed, the returned session-id may be used to &lt;kill-session&gt; the
   NETCONF session holding the lock.

2.4.1.2.  Deadlock Avoidance

   As with most locking systems, it is possible that two management
   sessions trying to lock different parts of the configuration could
   become deadlocked.  To avoid this situation, clients SHOULD lock
   everything they need in one operation.  If locking fails, the client
   MUST back-off, release any previously acquired locks, and SHOULD
   retry the procedure after waiting some randomized time interval.

2.4.2.  &lt;partial-unlock&gt;

   The operation unlocks the parts of the running datastore that were
   previously locked using &lt;partial-lock&gt; during the same session.  The
   operation unlocks the parts that are covered by the lock identified
   by the lock-id parameter.  In case of multiple potentially
   overlapping locks, only the lock identified by the lock-id is
   removed.

   Parameters:

   lock-id:  Identity of the lock to be unlocked.  This lock-id MUST
             have been received as a response to a lock request by the
             manager during the current session, and MUST NOT have been
             sent in a previous unlock request.

   Example: Unlock a previously created lock

      &lt;nc:rpc xmlns=&quot;urn:ietf:params:xml:ns:netconf:partial-lock:1.0&quot;
        xmlns:nc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
        message-id=&quot;136&quot;&gt;
          &lt;partial-unlock&gt;
            &lt;lock-id&gt;127&lt;/lock-id&gt;
          &lt;/partial-unlock&gt;
      &lt;/nc:rpc&gt;

   Positive Response:

   If the device was able to satisfy the request, an &lt;rpc-reply&gt; is sent
   that contains an &lt;ok&gt; element.  A positive response MUST be sent even
   if all of the locked parts of the datastore have already been
   deleted.

   Negative Response:

   If the &lt;lock-id&gt; parameter does not identify a lock that is owned by
   the session, an &#x27;invalid-value&#x27; error is returned.

2.5.  Modifications to Existing Operations

   A successful partial lock will cause a subsequent operation to fail
   if that operation attempts to modify nodes in the protected area of
   the lock and is executed in a NETCONF session other than the session
   that has been granted the lock.  The &lt;error-tag&gt; &#x27;in-use&#x27; and the
   &lt;error-app-tag&gt; &#x27;locked&#x27; is returned.  All operations that modify the

   running datastore are affected, including: &lt;edit-config&gt;, &lt;copy-
   config&gt;, &lt;delete-config&gt;, &lt;commit&gt;, and &lt;discard-changes&gt;.  If
   partial lock prevents &lt;edit-config&gt; from modifying some data, but the
   operation includes the continue-on-error option, modification of
   other parts of the datastore, which are not protected by partial
   locking, might still succeed.

   If the datastore contains nodes locked by partial lock, this will
   cause the (global) &lt;lock&gt; operation to fail.  The &lt;error-tag&gt; element
   &#x27;lock-denied&#x27; and an &lt;error-info&gt; element including the &lt;session-id&gt;
   of the lock owner will be returned.  If the lock is held by a non-
   NETCONF session, a &lt;session-id&gt; of 0 (zero) is returned.

   All of these operations are affected only if they are targeting the
   running datastore.

2.6.  Interactions with Other Capabilities

2.6.1.  Candidate Configuration Capability

   The candidate datastore cannot be locked using the &lt;partial-lock&gt;
   operation.

2.6.2.  Confirmed Commit Capability

   If:

   o  a partial lock is requested for the running datastore, and

   o  the NETCONF server implements the :confirmed-commit capability,
      and

   o  there was a recent confirmed &lt;commit&gt; operation where the
      confirming &lt;commit&gt; operation has not been received

   then the lock MUST be denied, because if the confirmation does not
   arrive, the running datastore MUST be rolled back to its state before
   the commit.  The NETCONF server might therefore need to modify the
   configuration.

   In this case, the &lt;error-tag&gt; &#x27;in-use&#x27; and the &lt;error-app-tag&gt;
   &#x27;outstanding-confirmed-commit&#x27; is returned.

2.6.3.  Distinct Startup Capability

   The startup datastore cannot be locked using the &lt;partial-lock&gt;
   operation.

3.  Security Considerations

   The same considerations are relevant as for the base NETCONF protocol
   [NETCONF]. &lt;partial-lock&gt; and &lt;partial-unlock&gt; RPCs MUST only be
   allowed for an authenticated user. &lt;partial-lock&gt; and &lt;partial-
   unlock&gt; RPCs SHOULD only be allowed for an authorized user.  However,
   as NETCONF access control is not standardized and not a mandatory
   part of a NETCONF implementation, it is strongly recommended, but
   OPTIONAL (although nearly all implementations include some kind of
   access control).

   A lock (either a partial lock or a global lock) might prevent other
   users from configuring the system.  The following mechanisms are in
   place to prevent the misuse of this possibility:

      A user, that is not successfully authenticated, MUST NOT be
      granted a partial lock.

      Only an authorized user SHOULD be able to request a partial lock.

      The partial lock is automatically released when a session is
      terminated regardless of how the session ends.

      The &lt;kill-session&gt; operation makes it possible to terminate other
      users&#x27; sessions.

      The NETCONF server MAY log partial lock requests in an audit
      trail.

   A lock that is hung for some reason (e.g., a broken TCP connection
   that the server has not yet recognized) can be released using another
   NETCONF session by explicitly killing the session owning that lock
   using the &lt;kill-session&gt; operation.

   Partial locking is not an authorization mechanism; it SHOULD NOT be
   used to provide security or access control.  Partial locking SHOULD
   only be used as a mechanism for providing consistency when multiple
   managers are trying to configure the node.  It is vital that users
   easily understand the exact scope of a lock.  This is why the scope
   is determined when granting a lock and is not modified thereafter.

4.  IANA Considerations

   This document registers one capability identifier URN from the
   &quot;Network Configuration Protocol (NETCONF) Capability URNs&quot; registry,
   and one URI for the NETCONF XML namespace in the &quot;IETF XML registry&quot;
   [RFC3688].  Note that the capability URN is compliant to [NETCONF],
   Section 10.3.

   Index           Capability Identifier
   -------------   ---------------------------------------------------
   :partial-lock   urn:ietf:params:netconf:capability:partial-lock:1.0

   URI: urn:ietf:params:xml:ns:netconf:partial-lock:1.0

   Registrant Contact: The IESG.

   XML: N/A, the requested URI is an XML namespace.

5.  Acknowledgements

   Thanks to Andy Bierman, Sharon Chisholm, Phil Shafer, David
   Harrington, Mehmet Ersue, Wes Hardaker, Juergen Schoenwaelder, Washam
   Fan, and many other members of the NETCONF WG for providing important
   input to this document.

6.  References

6.1.  Normative References

   [NETCONF]  Enns, R., &quot;NETCONF Configuration Protocol&quot;, RFC 4741,
              December 2006.

   [RFC2119]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, BCP 14, RFC 2119, March 1997.

   [RFC3688]  Mealling, M., &quot;The IETF XML Registry&quot;, BCP 81, RFC 3688,
              January 2004.

6.2.  Informative References

   [YANG]     Bjorklund, M., &quot;YANG - A data modeling language for
              NETCONF&quot;, Work in Progress, December 2009.

Appendix A.  XML Schema for Partial Locking (Normative)

   The following XML Schema defines the &lt;partial-lock&gt; and &lt;partial-
   unlock&gt; operations:

   &lt;CODE BEGINS&gt;

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
    xmlns=&quot;urn:ietf:params:xml:ns:netconf:partial-lock:1.0&quot;
    xmlns:nc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
    targetNamespace=&quot;urn:ietf:params:xml:ns:netconf:partial-lock:1.0&quot;
    elementFormDefault=&quot;qualified&quot; attributeFormDefault=&quot;unqualified&quot;&gt;

    &lt;xs:annotation&gt;
        &lt;xs:documentation&gt;
            Schema defining the partial-lock and unlock operations.
            organization &quot;IETF NETCONF Working Group&quot;

            contact
            Netconf Working Group
            Mailing list: netconf@ietf.org
            Web: http://www.ietf.org/html.charters/netconf-charter.html

            Balazs Lengyel
            balazs.lengyel@ericsson.com

            revision 2009-10-19
            description Initial version, published as RFC 5717.
        &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;

    &lt;xs:import namespace=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
        schemaLocation=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;/&gt;

    &lt;xs:simpleType name=&quot;lock-id-type&quot;&gt;
        &lt;xs:annotation&gt;
            &lt;xs:documentation&gt;
                A number identifying a specific
                partial-lock granted to a session.
                It is allocated by the system, and SHOULD
                be used in the unlock operation.
            &lt;/xs:documentation&gt;
        &lt;/xs:annotation&gt;
        &lt;xs:restriction base=&quot;xs:unsignedInt&quot;/&gt;
    &lt;/xs:simpleType&gt;

    &lt;xs:complexType name=&quot;partialLockType&quot;&gt;
        &lt;xs:annotation&gt;
            &lt;xs:documentation&gt;
                A NETCONF operation that locks parts of
                  the running datastore.
            &lt;/xs:documentation&gt;
        &lt;/xs:annotation&gt;
        &lt;xs:complexContent&gt;
            &lt;xs:extension base=&quot;nc:rpcOperationType&quot;&gt;
                &lt;xs:sequence&gt;
                    &lt;xs:element name=&quot;select&quot; type=&quot;xs:string&quot;
                        maxOccurs=&quot;unbounded&quot;&gt;
                        &lt;xs:annotation&gt;
                          &lt;xs:documentation&gt;
                            XPath expression that specifies the scope
                            of the lock.  An Instance Identifier
                            expression must be used unless the :xpath
                            capability is supported in which case any
                            XPath 1.0 expression is allowed.
                          &lt;/xs:documentation&gt;
                        &lt;/xs:annotation&gt;
                    &lt;/xs:element&gt;
                &lt;/xs:sequence&gt;
            &lt;/xs:extension&gt;
        &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;

    &lt;xs:complexType name=&quot;partialUnLockType&quot;&gt;
        &lt;xs:annotation&gt;
            &lt;xs:documentation&gt;
                A NETCONF operation that releases a previously acquired
                partial-lock.
            &lt;/xs:documentation&gt;
        &lt;/xs:annotation&gt;
        &lt;xs:complexContent&gt;
            &lt;xs:extension base=&quot;nc:rpcOperationType&quot;&gt;
                &lt;xs:sequence&gt;
                    &lt;xs:element name=&quot;lock-id&quot; type=&quot;lock-id-type&quot;&gt;
                        &lt;xs:annotation&gt;
                          &lt;xs:documentation&gt;
                            Identifies the lock to be released.  MUST
                            be the value received in the response to
                            the partial-lock operation.
                          &lt;/xs:documentation&gt;
                        &lt;/xs:annotation&gt;
                    &lt;/xs:element&gt;
                &lt;/xs:sequence&gt;
            &lt;/xs:extension&gt;

        &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;

    &lt;!-- &lt;partial-lock&gt; operation --&gt;
    &lt;xs:element name=&quot;partial-lock&quot; type=&quot;partialLockType&quot;
        substitutionGroup=&quot;nc:rpcOperation&quot;/&gt;

    &lt;!-- &lt;partial-unlock&gt; operation --&gt;
    &lt;xs:element name=&quot;partial-unlock&quot; type=&quot;partialUnLockType&quot;
        substitutionGroup=&quot;nc:rpcOperation&quot;/&gt;

    <span class="Verified-inline-styling" id='inline-1978'>    &lt;!-- reply to &lt;partial-lock&gt; --&gt; <button id="btn_1978" target="expand_1978" onclick='hideFunction("expand_1978")'>Expand</button>

    &lt;xs:complexType name=&quot;contentPartInPartialLockReplyType&quot;&gt;
        &lt;xs:annotation&gt;
            &lt;xs:documentation&gt;
                The content of the reply to a successful
                partial-lock request MUST conform to this complex type.
            &lt;/xs:documentation&gt;
        &lt;/xs:annotation&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name=&quot;lock-id&quot; type=&quot;lock-id-type&quot;&gt;
              &lt;xs:annotation&gt;
                &lt;xs:documentation&gt;
                 Identifies the lock, if granted.  This lock-id must
                 be used in the partial-unlock operation.
                &lt;/xs:documentation&gt;
              &lt;/xs:annotation&gt;
            &lt;/xs:element&gt;
            </span id__locate=1978>
<div class="nodeCloseClass" id='expand_1978'><div class='Verified-endnote-styling' id='eid1978'>
<pre>
<b><i><a href='https://www.rfc-editor.org/errata/eid1978'>EID 1978</a> (Verified) is as follows:</i></b>

<b>Section:</b> App. A, p.16

<b>Original Text:</b>

    &lt;!-- reply to &lt;partial-lock&gt; --&gt;

    &lt;xs:complexType name=&quot;contentPartInPartialLockReplyType&quot;&gt;
        &lt;xs:annotation&gt;
            &lt;xs:documentation&gt;
                The content of the reply to a successful
                partial-lock request MUST conform to this complex type.
            &lt;/xs:documentation&gt;
        &lt;/xs:annotation&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name=&quot;lock-id&quot; type=&quot;lock-id-type&quot;&gt;
              &lt;xs:annotation&gt;
                &lt;xs:documentation&gt;
|                 Identifies the lock to be released.  Must be the value
|                 received in the response to a partial-lock operation.
                &lt;/xs:documentation&gt;
              &lt;/xs:annotation&gt;
            &lt;/xs:element&gt;
            [...]

<b>Corrected Text:</b>

    &lt;!-- reply to &lt;partial-lock&gt; --&gt;

    &lt;xs:complexType name=&quot;contentPartInPartialLockReplyType&quot;&gt;
        &lt;xs:annotation&gt;
            &lt;xs:documentation&gt;
                The content of the reply to a successful
                partial-lock request MUST conform to this complex type.
            &lt;/xs:documentation&gt;
        &lt;/xs:annotation&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name=&quot;lock-id&quot; type=&quot;lock-id-type&quot;&gt;
              &lt;xs:annotation&gt;
                &lt;xs:documentation&gt;
|                 Identifies the lock, if granted.  This lock-id must
|                 be used in the partial-unlock operation.
                &lt;/xs:documentation&gt;
              &lt;/xs:annotation&gt;
            &lt;/xs:element&gt;
            [...]
</pre>
<b>Notes:</b><br/>
Rationale:<br/>  The clause in the RFC apparently has been copied from page 15<br/>  (bottom part), where the partialUnLockType is getting defined,<br/>  without the necessary changes in semantics for the context of<br/>  the reply to a partial-lock operation.<br/>  The replacement text has been crafted in the spirit of the<br/>  corresponding description in the YANG module in Appendix B.
</div>
</div>            &lt;xs:element name=&quot;locked-node&quot; type=&quot;xs:string&quot;
                maxOccurs=&quot;unbounded&quot;&gt;
                &lt;xs:annotation&gt;
                    &lt;xs:documentation&gt;
                        List of locked nodes in the running datastore.
                    &lt;/xs:documentation&gt;
                &lt;/xs:annotation&gt;
            &lt;/xs:element&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;

   &lt;CODE ENDS&gt;

Appendix B.  YANG Module for Partial Locking (Non-Normative)

   The following YANG module defines the &lt;partial-lock&gt; and &lt;partial-
   unlock&gt; operations.  The YANG language is defined in [YANG].

   &lt;CODE BEGINS&gt;

module ietf-netconf-partial-lock {

  namespace urn:ietf:params:xml:ns:netconf:partial-lock:1.0;
  prefix pl;

  organization &quot;IETF Network Configuration (netconf) Working Group&quot;;

  contact
   &quot;Netconf Working Group
    Mailing list: netconf@ietf.org
    Web: http://www.ietf.org/html.charters/netconf-charter.html

    Balazs Lengyel
    Ericsson
    balazs.lengyel@ericsson.com&quot;;

  description
   &quot;This YANG module defines the &lt;partial-lock&gt; and
    &lt;partial-unlock&gt; operations.&quot;;

  revision 2009-10-19 {
    description
     &quot;Initial version, published as RFC 5717.&quot;;
  }

  typedef lock-id-type {
    type uint32;
    description
     &quot;A number identifying a specific partial-lock granted to a session.
      It is allocated by the system, and SHOULD be used in the
      partial-unlock operation.&quot;;
  }

  rpc partial-lock {
    description
     &quot;A NETCONF operation that locks parts of the running datastore.&quot;;
    input {
      leaf-list select {
        type string;
        min-elements 1;
        description

         &quot;XPath expression that specifies the scope of the lock.
          An Instance Identifier expression MUST be used unless the
          :xpath capability is supported, in which case any XPath 1.0
          expression is allowed.&quot;;
      }
    }
    output {
      leaf lock-id {
        type lock-id-type;
        description
         &quot;Identifies the lock, if granted.  The lock-id SHOULD be
          used in the partial-unlock rpc.&quot;;
      }
      leaf-list locked-node {
        type instance-identifier;
        min-elements 1;
        description
         &quot;List of locked nodes in the running datastore&quot;;
      }
    }
  }

  rpc partial-unlock {
    description
     &quot;A NETCONF operation that releases a previously acquired
      partial-lock.&quot;;
    input {
      leaf lock-id {
        type lock-id-type;
        description
         &quot;Identifies the lock to be released.  MUST be the value
          received in the response to a partial-lock operation.&quot;;
      }
    }
  }
}

   &lt;CODE ENDS&gt;

Appendix C.  Usage Example - Reserving Nodes for Future Editing
             (Non-Normative)

   Partial lock cannot be used to lock non-existent nodes, which would
   effectively attempt to reserve them for future use.  To guarantee
   that a node cannot be created by some other session, the parent node
   should be locked, the top-level node of the new subtree created, and
   then locked with another &lt;partial-lock&gt; operation.  After this, the
   lock on the parent node should be removed.

   In this section, an example illustrating the above is given.

   We want to create &lt;user&gt; Joe under &lt;users&gt;, and start editing it.
   Editing might take a number of minutes.  We want to immediately lock
   Joe so no one will touch it before we are finished with the editing.

   We also want to minimize locking other parts of the running datastore
   as multiple managers might be adding users near simultaneously.

   First, we check what users are already defined.

   Step 1 - Read existing users

   &lt;rpc message-id=&quot;101&quot;
       xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
     &lt;get-config&gt;
       &lt;source&gt;
         &lt;running/&gt;
       &lt;/source&gt;
       &lt;filter type=&quot;subtree&quot;&gt;
         &lt;top xmlns=&quot;http://example.com/users&quot;&gt;
           &lt;users/&gt;
         &lt;/top&gt;
       &lt;/filter&gt;
     &lt;/get-config&gt;
   &lt;/rpc&gt;

   The NETCONF server sends the following reply.

   Step 2 - Receiving existing data

   &lt;rpc-reply message-id=&quot;101&quot;
        xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
     &lt;data&gt;
       &lt;top xmlns=&quot;http://example.com/users&quot;&gt;
         &lt;users&gt;
           &lt;user&gt;
             &lt;name&gt;fred&lt;/name&gt;
             &lt;phone&gt;8327&lt;/phone&gt;
           &lt;/user&gt;
         &lt;/users&gt;
       &lt;/top&gt;
     &lt;/data&gt;
   &lt;/rpc-reply&gt;

   We want to add the new user Joe and immediately lock him using
   partial locking.  The way to do this, is to first lock all &lt;user&gt;
   nodes by locking the &lt;users&gt; node.

   Note that if we would lock all the &lt;user&gt; nodes using the select
   expression &#x27;/usr:top/usr:users/usr:user&#x27;; this would not lock the new
   user Joe, which we will create after locking.  So we rather have to
   lock the &lt;users&gt; node.

   Step 3 - Lock users

   &lt;nc:rpc
     xmlns:nc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
     xmlns=&quot;urn:ietf:params:xml:ns:netconf:partial-lock:1.0&quot;
         message-id=&quot;102&quot;&gt;
     &lt;partial-lock&gt;
       &lt;select xmlns:usr=&quot;http://example.com/users&quot;&gt;
         /usr:top/usr:users
       &lt;/select&gt;
     &lt;/partial-lock&gt;
   &lt;/nc:rpc&gt;

   The NETCONF server grants the partial lock.  The scope of the lock
   includes only the &lt;users&gt; node.  The lock protects the &lt;users&gt; node
   and all &lt;user&gt; nodes below it from modification (by other sessions).

   Step 4 - Receive lock

   &lt;nc:rpc-reply
     xmlns:nc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
     xmlns=&quot;urn:ietf:params:xml:ns:netconf:partial-lock:1.0&quot;
     message-id=&quot;102&quot;&gt;
       &lt;lock-id&gt;1&lt;/lock-id&gt;
       &lt;locked-node xmlns:usr=&quot;http://example.com/users&quot;&gt;
           /usr:top/usr:users
       &lt;/locked-node&gt;
   &lt;/nc:rpc-reply&gt;

   Next we create user Joe.  Joe is protected by the lock received
   above, as it is under the subtree rooted at the &lt;users&gt; node.

   Step 5 - Create user Joe

   &lt;rpc message-id=&quot;103&quot;
        xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
     &lt;edit-config&gt;
       &lt;target&gt;
         &lt;running/&gt;
       &lt;/target&gt;
       &lt;config&gt;
         &lt;top xmlns:usr=&quot;http://example.com/users&quot;&gt;
           &lt;users&gt;
             &lt;user&gt;
               &lt;name&gt;Joe&lt;/name&gt;
             &lt;/user&gt;
           &lt;/users&gt;
         &lt;/top&gt;
       &lt;/config&gt;
     &lt;/edit-config&gt;
   &lt;/rpc&gt;

   We receive a positive reply to the &lt;edit-config&gt; (not shown).  Next
   we request a lock, that locks only &lt;user&gt; Joe, and release the lock
   on the &lt;users&gt; node.  This will allow other managers to create
   additional new users.

   <span class="Verified-inline-styling" id='inline-2746'>   Step 6 - Lock user Joe <button id="btn_2746" target="expand_2746" onclick='hideFunction("expand_2746")'>Expand</button>

   &lt;nc:rpc
     xmlns:nc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
     xmlns=&quot;urn:ietf:params:xml:ns:netconf:partial-lock:1.0&quot;
         message-id=&quot;104&quot;&gt;
     &lt;partial-lock&gt;
        &lt;select xmlns:usr=&quot;http://example.com/users&quot;&gt;
          /usr:top/usr:users/usr:user[usr:name=&quot;Joe&quot;]
        &lt;/select&gt;
     &lt;/partial-lock&gt;
   &lt;/nc:rpc&gt;

   The NETCONF server grants the partial lock.  The scope of this second
   lock includes only the &lt;user&gt; node with name Joe.  The lock protects
   all data below this particular &lt;user&gt; node.

   Step 7 - Receive lock

   &lt;nc:rpc-reply
     xmlns:nc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
     xmlns=&quot;urn:ietf:params:xml:ns:netconf:partial-lock:1.0&quot;
     message-id=&quot;104&quot;&gt;
       &lt;lock-id&gt;2&lt;/lock-id&gt;
        &lt;locked-node xmlns:usr=&quot;http://example.com/users&quot;&gt;
            /usr:top/usr:users/usr:user[usr:name=&quot;Joe&quot;]
        &lt;/locked-node&gt;
   &lt;/nc:rpc-reply&gt;
</span id__locate=2746>
<div class="nodeCloseClass" id='expand_2746'><div class='Verified-endnote-styling' id='eid2746'>
<pre>
<b><i><a href='https://www.rfc-editor.org/errata/eid2746'>EID 2746</a> (Verified) is as follows:</i></b>

<b>Section:</b> Appendix C

<b>Original Text:</b>

   Step 6 - Lock user Joe

   &lt;nc:rpc
     xmlns:nc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
     xmlns=&quot;urn:ietf:params:xml:ns:netconf:partial-lock:1.0&quot;
         message-id=&quot;104&quot;&gt;
     &lt;partial-lock&gt;
       &lt;select xmlns:usr=&quot;http://example.com/users&quot;&gt;
         /usr:top/usr:users/user[usr:name=&quot;Joe&quot;]&quot;
       &lt;/select&gt;
     &lt;/partial-lock&gt;
   &lt;/nc:rpc&gt;

   The NETCONF server grants the partial lock.  The scope of this second
   lock includes only the &lt;user&gt; node with name Joe.  The lock protects
   all data below this particular &lt;user&gt; node.

   Step 7 - Receive lock

   &lt;nc:rpc-reply
     xmlns:nc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
     xmlns=&quot;urn:ietf:params:xml:ns:netconf:partial-lock:1.0&quot;
     message-id=&quot;104&quot;&gt;
       &lt;lock-id&gt;2&lt;/lock-id&gt;
       &lt;locked-node xmlns:usr=&quot;http://example.com/users&quot;&gt;
           /usr:top/usr:users/user[usr:name=&quot;Joe&quot;]&quot;
       &lt;/locked-node&gt;
   &lt;/nc:rpc-reply&gt;

<b>Corrected Text:</b>

   Step 6 - Lock user Joe

   &lt;nc:rpc
     xmlns:nc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
     xmlns=&quot;urn:ietf:params:xml:ns:netconf:partial-lock:1.0&quot;
         message-id=&quot;104&quot;&gt;
     &lt;partial-lock&gt;
        &lt;select xmlns:usr=&quot;http://example.com/users&quot;&gt;
          /usr:top/usr:users/usr:user[usr:name=&quot;Joe&quot;]
        &lt;/select&gt;
     &lt;/partial-lock&gt;
   &lt;/nc:rpc&gt;

   The NETCONF server grants the partial lock.  The scope of this second
   lock includes only the &lt;user&gt; node with name Joe.  The lock protects
   all data below this particular &lt;user&gt; node.

   Step 7 - Receive lock

   &lt;nc:rpc-reply
     xmlns:nc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
     xmlns=&quot;urn:ietf:params:xml:ns:netconf:partial-lock:1.0&quot;
     message-id=&quot;104&quot;&gt;
       &lt;lock-id&gt;2&lt;/lock-id&gt;
        &lt;locked-node xmlns:usr=&quot;http://example.com/users&quot;&gt;
            /usr:top/usr:users/usr:user[usr:name=&quot;Joe&quot;]
        &lt;/locked-node&gt;
   &lt;/nc:rpc-reply&gt;
</pre>
<b>Notes:</b><br/>
- Appendix C is non-normative.<br/>- The instance identifier: /usr:top/usr:users/user[usr:name=&quot;Joe&quot;]&quot; <br/>must be replaced with:     /usr:top/usr:users/usr:user[usr:name=&quot;Joe&quot;]
</div>
</div>
   The scope of the second lock is the &lt;user&gt; node Joe.  It protects
   this &lt;user&gt; node and any data below it (e.g., phone number).  At this
   point of time, these nodes are protected both by the first and second
   lock.  Next, we unlock the other &lt;user&gt;s and the &lt;users&gt; node, to
   allow other managers to work on them.  We still keep the second lock,
   so the &lt;user&gt; node Joe and the subtree below is still protected.

   Step 8 - Release lock on &lt;users&gt;

   &lt;nc:rpc xmlns=&quot;urn:ietf:params:xml:ns:netconf:partial-lock:1.0&quot;
       xmlns:nc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
       message-id=&quot;105&quot;&gt;
     &lt;partial-unlock&gt;
       &lt;lock-id&gt;1&lt;/lock-id&gt;
     &lt;/partial-unlock&gt;
   &lt;/nc:rpc&gt;

Authors&#x27; Addresses

   Balazs Lengyel
   Ericsson

   EMail: balazs.lengyel@ericsson.com


   Martin Bjorklund
   Tail-f Systems

   EMail: mbj@tail-f.com


        </re>
        
    </body>
</html>
