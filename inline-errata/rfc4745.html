<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="robots" content="index,follow" />

        <link rel="icon" href="./css/images/rfc.png" type="image/png" />
        <link rel="shortcut icon" href="./css/images/rfc.png" type="image/png" />
        <title>rfc4745</title>
    
        <link rel="stylesheet" type="text/css" href="./css/errata-base.css"/>
        <link rel="stylesheet" type="text/css" href="./css/errata-color.css" title="Default: Basic Colors"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-monochrome.css" title="Monochrome"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-printer.css" title="Printer"/>

        <script src="./css/errata.js"></script>
    </head>
    <body>
        <div class='Verified-headnote-styling'>
<span style="font-weight: bold;">This is a purely informative rendering of an RFC that includes verified errata.  This rendering may not be used as a reference.</span>
<br/>
<br/>
The following 'Verified' errata have been incorporated in this document:
 <a href='#btn_1455'>EID 1455</a>
</div>

        <pre>
Network Working Group                                     H. Schulzrinne
Request for Comments: 4745                                   Columbia U.
Category: Standards Track                                  H. Tschofenig
                                           Siemens Networks GmbH &amp; Co KG
                                                               J. Morris
                                                                     CDT
                                                              J. Cuellar
                                                                 Siemens
                                                                 J. Polk
                                                            J. Rosenberg
                                                                   Cisco
                                                           February 2007


  Common Policy: A Document Format for Expressing Privacy Preferences

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The IETF Trust (2007).

Abstract

   This document defines a framework for authorization policies
   controlling access to application-specific data.  This framework
   combines common location- and presence-specific authorization
   aspects.  An XML schema specifies the language in which common policy
   rules are represented.  The common policy framework can be extended
   to other application domains.

Table of Contents

   1. Introduction ....................................................3
   2. Terminology .....................................................4
   3. Modes of Operation ..............................................4
      3.1. Passive Request-Response - PS as Server (Responder) ........5
      3.2. Active Request-Response - PS as Client (Initiator) .........5
      3.3. Event Notification .........................................5
   4. Goals and Assumptions ...........................................6
   5. Non-Goals .......................................................7
   6. Basic Data Model and Processing .................................8
      6.1. Identification of Rules ....................................9
      6.2. Extensions .................................................9
   7. Conditions .....................................................10
      7.1. Identity Condition ........................................10
           7.1.1. Overview ...........................................10
           7.1.2. Matching One Entity ................................11
           7.1.3. Matching Multiple Entities .........................11
      7.2. Single Entity .............................................14
      7.3. Sphere ....................................................15
      7.4. Validity ..................................................16
   8. Actions ........................................................17
   9. Transformations ................................................18
   10. Procedure for Combining Permissions ...........................18
      10.1. Introduction .............................................18
      10.2. Combining Rules (CRs) ....................................18
      10.3. Example ..................................................19
   11. Meta Policies .................................................21
   12. Example .......................................................21
   13. XML Schema Definition .........................................22
   14. Security Considerations .......................................25
   15. IANA Considerations ...........................................25
      15.1. Common Policy Namespace Registration .....................25
      15.2. Content-type Registration for
            &#x27;application/auth-policy+xml&#x27; ............................26
      15.3. Common Policy Schema Registration ........................27
   16. References ....................................................27
      16.1. Normative References .....................................27
      16.2. Informative References ...................................28
   Appendix A. Contributors ..........................................29
   Appendix B. Acknowledgments .......................................29

1.  Introduction

   This document defines a framework for creating authorization policies
   for access to application-specific data.  This framework is the
   result of combining the common aspects of single authorization
   systems that more specifically control access to presence and
   location information and that previously had been developed
   separately.  The benefit of combining these two authorization systems
   is two-fold.  First, it allows building a system that enhances the
   value of presence with location information in a natural way and
   reuses the same underlying authorization mechanism.  Second, it
   encourages a more generic authorization framework with mechanisms for
   extensibility.  The applicability of the framework specified in this
   document is not limited to policies controlling access to presence
   and location information data, but can be extended to other
   application domains.

   The general framework defined in this document is intended to be
   accompanied and enhanced by application-specific policies specified
   elsewhere.  The common policy framework described here is enhanced by
   domain-specific policy documents, including presence [7] and location
   [8].  This relationship is shown in Figure 1.

                           +-----------------+
                           |                 |
                           |     Common      |
                           |     Policy      |
                           |                 |
                           +---+---------+---+
                              /|\       /|\
                               |         |
      +-------------------+    |         |    +-------------------+
      |                   |    | enhance |    |                   |
      | Location-specific |    |         |    | Presence-specific |
      |      Policy       |----+         +----|      Policy       |
      |                   |                   |                   |
      +-------------------+                   +-------------------+

                   Figure 1: Common Policy Enhancements

   This document starts with an introduction to the terminology in
   Section 2, an illustration of basic modes of operation in Section 3,
   a description of goals (see Section 4) and non-goals (see Section 5)
   of the policy framework, followed by the data model in Section 6.
   The structure of a rule, namely, conditions, actions, and
   transformations, is described in Sections 7, 8, and 9.  The procedure
   for combining permissions is explained in Section 10 and used when
   conditions for more than one rule are satisfied.  A short description

   of meta policies is given in Section 11.  An example is provided in
   Section 12.  The XML schema will be discussed in Section 13.  IANA
   considerations in Section 15 follow security considerations in
   Section 14.

2.  Terminology

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;,&quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [1].

   This document introduces the following terms:

   PT - Presentity / Target:  The PT is the entity about whom
        information has been requested.

   RM - Rule Maker:  The RM is an entity that creates the authorization
        rules that restrict access to data items.

   PS - (Authorization) Policy Server:  This entity has access to both
        the authorization policies and the data items.  In location-
        specific applications, the entity PS is labeled as location
        server (LS).

   WR - Watcher / Recipient:  This entity requests access to data items
        of the PT.  An access operation might be a read, a write, or any
        other operation.

   A policy is given by a &#x27;rule set&#x27; that contains an unordered list of
   &#x27;rules&#x27;.  A &#x27;rule&#x27; has a &#x27;conditions&#x27;, an &#x27;actions&#x27;, and a
   &#x27;transformations&#x27; part.

   The term &#x27;permission&#x27; indicates the action and transformation
   components of a &#x27;rule&#x27;.

   The term &#x27;using protocol&#x27; is defined in [9].  It refers to the
   protocol used to request access to and to return privacy-sensitive
   data items.

3.  Modes of Operation

   The abstract sequence of operations can roughly be described as
   follows.  The PS receives a query for data items for a particular PT,
   via the using protocol.  The using protocol (or more precisely, the
   authentication protocol) provides the identity of the requestor,
   either at the time of the query or at the subscription time.  The
   authenticated identity of the WR, together with other information
   provided by the using protocol or generally available to the server,
   is then used for searching through the rule set.  All matching rules
   are combined according to a permission combining algorithm described
   in Section 10.  The combined rules are applied to the application
   data, resulting in the application of privacy based on the
   transformation policies.  The resulting application data is returned
   to the WR.

   Three different modes of operation can be distinguished:

3.1.  Passive Request-Response - PS as Server (Responder)

   In a passive request-response mode, the WR queries the PS for data
   items about the PT.  Examples of protocols following this mode of
   operation include HTTP, FTP, LDAP, finger, and various remote
   procedure call (RPC) protocols, including Sun RPC, Distributed
   Computing Environment (DCE), Distributed Component Object Model
   (DCOM), common object request broker architecture (Corba), and Simple
   Object Access Protocol (SOAP).  The PS uses the rule set to determine
   whether the WR is authorized to access the PT&#x27;s information, refusing
   the request if necessary.  Furthermore, the PS might filter
   information by removing elements or by reducing the resolution of
   elements.

3.2.  Active Request-Response - PS as Client (Initiator)

   Alternatively, the PS may contact the WR and convey data items.
   Examples include HTTP, SIP session setup (INVITE request), H.323
   session setup or SMTP.

3.3.  Event Notification

   Event notification adds a subscription phase to the &quot;Active Request-
   Response - PS as Client (Initiator)&quot; mode of operation.  A watcher or
   subscriber asks to be added to the notification list for a particular
   presentity or event.  When the presentity changes state or the event
   occurs, the PS sends a message to the WR containing the updated
   state.  (Presence is a special case of event notification; thus, we
   often use the term interchangeably.)

   In addition, the subscriber may itself add a filter to the
   subscription, limiting the rate or content of the notifications.  If
   an event, after filtering by the rule-maker-provided rules and by the
   subscriber-provided rules, only produces the same notification
   content that was sent previously, no event notification is sent.

   A single PS may authorize access to data items in more than one mode.
   Rather than having different rule sets for different modes all three
   modes are supported with a one rule set schema.  Specific instances
   of the rule set can omit elements that are only applicable to the
   subscription model.

4.  Goals and Assumptions

   Below, we summarize our design goals and constraints.

   Table representation:

      Each rule must be representable as a row in a relational database.
      This design goal should allow efficient policy implementation by
      utilizing standard database optimization techniques.

   Permit only:

      Rules only provide permissions rather than denying them.  Removing
      a rule can never increase permissions.  Depending on the
      interpretation of &#x27;deny&#x27; and &#x27;permit&#x27; rules, the ordering of rules
      might matter, making updating rule sets more complicated since
      such update mechanisms would have to support insertion at specific
      locations in the rule set.  Additionally, it would make
      distributed rule sets more complicated.  Hence, only &#x27;permit&#x27;
      actions are allowed that result in more efficient rule processing.
      This also implies that rule ordering is not important.
      Consequently, to make a policy decision requires processing all
      rules.

   Additive permissions:

      A query for access to data items is matched against the rules in
      the rule database.  If several rules match, then the overall
      permissions granted to the WR are the union of those permissions.
      A more detailed discussion is provided in Section 10.

   Upgradeable:

      It should be possible to add additional rules later, without
      breaking PSs that have not been upgraded.  Any such upgrades must
      not degrade privacy constraints, but PSs not yet upgraded may
      reveal less information than the rule maker would have chosen.

   Capability support:

      In addition to the previous goal, a RM should be able to determine
      which extensions are supported by the PS.  The mechanism used to
      determine the capability of a PS is outside the scope of this
      specification.

   Protocol-independent:

      The rule set supports constraints on both notifications or queries
      as well as subscriptions for event-based systems such as presence
      systems.

   No false assurance:

      It appears more dangerous to give the user the impression that the
      system will prevent disclosure automatically, but fail to do so
      with a significant probability of operator error or
      misunderstanding, than to force the user to explicitly invoke
      simpler rules.  For example, rules based on weekday and time-of-
      day ranges seem particularly subject to misinterpretation and
      false assumptions on part of the RM.  (For example, a non-
      technical RM would probably assume that the rules are based on the
      time zone of his current location, which may not be known to other
      components of the system.)

5.  Non-Goals

   We explicitly decided that a number of possibly worthwhile
   capabilities are beyond the scope of this first version.  Future
   versions may include these capabilities, using the extension
   mechanism described in this document.  Non-goals include:

   No external references:

      Attributes within specific rules cannot refer to external rule
      sets, databases, directories, or other network elements.  Any such
      external reference would make simple database implementation
      difficult and hence they are not supported in this version.

   No regular expressions:

      Conditions are matched on equality or &#x27;greater-than&#x27;-style
      comparisons, not regular expressions, partial matches such as the
      SQL LIKE operator (e.g., LIKE &quot;%foo%&quot;), or glob-style matches
      (&quot;*@example.com&quot;).  Most of these are better expressed as explicit
      elements.

   No repeat times:

      Repeat times (e.g., every day from 9 am to 4 pm) are difficult to
      make work correctly, due to the different time zones that PT, WR,
      PS, and RM may occupy.  It appears that suggestions for including
      time intervals are often based on supporting work/non-work
      distinctions, which unfortunately are difficult to capture by time
      alone.  Note that this feature must not be confused with the
      &#x27;Validity&#x27; element that provides a mechanism to restrict the
      lifetime of a rule.

6.  Basic Data Model and Processing

   A rule set (or synonymously, a policy) consists of zero or more
   rules.  The ordering of these rules is irrelevant.  The rule set can
   be stored at the PS and conveyed from RM to PS as a single document,
   in subsets or as individual rules.  A rule consists of three parts:
   conditions (see Section 7), actions (see Section 8), and
   transformations (see Section 9).

   The conditions part is a set of expressions, each of which evaluates
   to either TRUE or FALSE.  When a WR asks for information about a PT,
   the PS goes through each rule in the rule set.  For each rule, it
   evaluates the expressions in the conditions part.  If all of the
   expressions evaluate to TRUE, then the rule is applicable to this
   request.  Generally, each expression specifies a condition based on
   some variable that is associated with the context of the request.
   These variables can include the identity of the WR, the domain of the
   WR, the time of day, or even external variables, such as the
   temperature or the mood of the PT.

   Assuming that the rule is applicable to the request, the actions and
   transformations (commonly referred to as permissions) in the rule
   specify how the PS is supposed to handle this request.  If the
   request is to view the location of the PT, or to view its presence,
   the typical action is &quot;permit&quot;, which allows the request to proceed.

   Assuming the action allows the request to proceed, the
   transformations part of the rule specifies how the information about
   the PT -- their location information, their presence, etc. -- is
   modified before being presented to the WR.  These transformations are
   in the form of positive permissions.  That is, they always specify a
   piece of information that is allowed to be seen by the WR.  When a PS
   processes a request, it takes the transformations specified across
   all rules that match, and creates the union of them.  For computing
   this union, the data type, such as Integer, Boolean, Set, or the
   Undef data type, plays a role.  The details of the algorithm for
   combining permissions is described in Section 10.  The resulting

   union effectively represents a &quot;mask&quot; -- it defines what information
   is exposed to the WR.  This mask is applied to the actual location or
   presence data for the PT, and the data that is permitted by the mask
   is shown to the WR.  If the WR requests a subset of information only
   (such as city-level civic location data only, instead of the full
   civic location information), the information delivered to the WR MUST
   be the intersection of the permissions granted to the WR and the data
   requested by the WR.

   Rules are encoded in XML.  To this end, Section 13 contains an XML
   schema defining the Common Policy Markup Language.  This, however, is
   purely an exchange format between RM and PS.  The format does not
   imply that the RM or the PS use this format internally, e.g., in
   matching a query with the policy rules.  The rules are designed so
   that a PS can translate the rules into a relational database table,
   with each rule represented by one row in the database.  The database
   representation is by no means mandatory; we will use it as a
   convenient and widely-understood example of an internal
   representation.  The database model has the advantage that operations
   on rows have tightly defined meanings.  In addition, it appears
   plausible that larger-scale implementations will employ a backend
   database to store and query rules, as they can then benefit from
   existing optimized indexing, access control, scaling, and integrity
   constraint mechanisms.  Smaller-scale implementations may well choose
   different implementations, e.g., a simple traversal of the set of
   rules.

6.1.  Identification of Rules

   Each rule is equipped with a parameter that identifies the rule.
   This rule identifier is an opaque token chosen by the RM.  A RM MUST
   NOT use the same identifier for two rules that are available to the
   PS at the same time for a given PT.  If more than one RM modifies the
   same rule set, then it needs to be ensured that a unique identifier
   is chosen for each rule.  A RM can accomplish this goal by retrieving
   the already specified rule set and choosing a new identifier for a
   rule that is different from the existing rule set.

6.2.  Extensions

   The policy framework defined in this document is meant to be
   extensible towards specific application domains.  Such an extension
   is accomplished by defining conditions, actions, and transformations
   that are specific to the desired application domain.  Each extension
   MUST define its own namespace.

   Extensions cannot change the schema defined in this document, and
   this schema is not expected to change except via revision to this
   specification.  Therefore, no versioning procedures for this schema
   or namespace are provided.

7.  Conditions

   The access to data items needs to be matched with the rule set stored
   at the PS.  Each instance of a request has different attributes
   (e.g., the identity of the requestor) that are used for
   authorization.  A rule in a rule set might have a number of
   conditions that need to be met before executing the remaining parts
   of a rule (i.e., actions and transformations).  Details about rule
   matching are described in Section 10.  This document specifies only a
   few conditions (i.e., identity, sphere, and validity).  Further
   condition elements can be added via extensions to this document.  If
   a child element of the &lt;conditions&gt; element is in a namespace that is
   not known or not supported, then this child element evaluates to
   FALSE.

   As noted in Section 5, conditions are matched on equality or &quot;greater
   than&quot; style comparisons, rather than regular expressions.  Equality
   is determined according to the rules for the data type associated
   with the element in the schema given in Section 13, unless explicit
   comparison steps are included in this document.  For xs:anyURI types,
   readers may wish to consult [2] for its discussion xs:anyURI, as well
   as the text in Section 13.

7.1.  Identity Condition

7.1.1.  Overview

   The identity condition restricts matching of a rule either to a
   single entity or a group of entities.  Only authenticated entities
   can be matched; acceptable means of authentication are defined in
   protocol-specific documents.  If the &lt;identity&gt; element is absent,
   identities are not considered, and thus, other conditions in the rule
   apply to any user, authenticated or not.

   The &lt;identity&gt; condition is considered TRUE if any of its child
   elements (e.g., the &lt;one/&gt; and the &lt;many/&gt; elements defined in this
   document) evaluate to TRUE, i.e., the results of the individual child
   element are combined using a logical OR.

   If a child element of the &lt;identity&gt; element is in a namespace that
   is not known or not supported, then this child element evaluates to
   FALSE.

7.1.2.  Matching One Entity

   The &lt;one&gt; element matches the authenticated identity (as contained in
   the &#x27;id&#x27; attribute) of exactly one entity or user.  For
   considerations regarding the &#x27;id&#x27; attribute, refer to Section 7.2.

   An example is shown below:

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;ruleset xmlns=&quot;urn:ietf:params:xml:ns:common-policy&quot;&gt;

       &lt;rule id=&quot;f3g44r1&quot;&gt;
           &lt;conditions&gt;
               &lt;identity&gt;
                   &lt;one id=&quot;sip:alice@example.com&quot;/&gt;
                   &lt;one id=&quot;tel:+1-212-555-1234&quot; /&gt;
                   &lt;one id=&quot;mailto:bob@example.net&quot; /&gt;
               &lt;/identity&gt;
           &lt;/conditions&gt;
           &lt;actions/&gt;
           &lt;transformations/&gt;
       &lt;/rule&gt;

   &lt;/ruleset&gt;

   This example matches if the authenticated identity of the WR is
   either sip:alice@example.com, tel:+1-212-555-1234, or
   mailto:bob@example.net.

7.1.3.  Matching Multiple Entities

   The &lt;many&gt; element is a mechanism to perform authorization decisions
   based on the domain part of the authenticated identity.  As such, it
   allows matching a large and possibly unknown number of users within a
   domain.

   Furthermore, it is possible to include one or multiple &lt;except&gt;
   elements to exclude either individual users or users belonging to a
   specific domain.  Excluding individual entities is implemented using
   a &lt;except id=&quot;...&quot;/&gt; statement.  The semantic of the &#x27;id&#x27; attribute
   of the &lt;except&gt; element has the same meaning as the &#x27;id&#x27; attribute of
   the &lt;one&gt; element (see Section 7.2).  Excluding users belonging to a
   specific domain is implemented using the &lt;except domain=&quot;...&quot;/&gt;
   element that excludes any user from the indicated domain.

   If multiple &lt;except&gt; elements are listed as child elements of the
   &lt;many&gt; element, then the result of each &lt;except&gt; element is combined
   using a logical OR.

   Common policy MUST either use UTF-8 or UTF-16 to store domain names
   in the &#x27;domain&#x27; attribute.  For non-IDNs (Internationalized Domain
   Names), lowercase ASCII SHOULD be used.  For the comparison operation
   between the value stored in the &#x27;domain&#x27; attribute and the domain
   value provided via the using protocol (referred to as &quot;protocol
   domain identifier&quot;), the following rules are applicable:

   1.  Translate percent-encoding for either string.

   2.  Convert both domain strings using the ToASCII operation described
       in RFC 3490 [3].

   3.  Compare the two domain strings for ASCII equality, for each
       label.  If the string comparison for each label indicates
       equality, the comparison succeeds.  Otherwise, the domains are
       not equal.

   If the conversion fails in step (2), the domains are not equal.

7.1.3.1.  Matching Any Authenticated Identity

   The &lt;many/&gt; element without any child elements or attributes matches
   any authenticated user.

   The following example shows such a rule that matches any
   authenticated user:

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;ruleset xmlns=&quot;urn:ietf:params:xml:ns:common-policy&quot;&gt;

       &lt;rule id=&quot;f3g44r5&quot;&gt;
           &lt;conditions&gt;
               &lt;identity&gt;
                 &lt;many/&gt;
               &lt;/identity&gt;
           &lt;/conditions&gt;
           &lt;actions/&gt;
           &lt;transformations/&gt;
       &lt;/rule&gt;

   &lt;/ruleset&gt;

7.1.3.2.  Matching Any Authenticated Identity Except Enumerated
          Domains/Identities

   The &lt;many&gt; element enclosing one or more &lt;except domain=&quot;...&quot;/&gt;
   elements matches any user from any domain except those enumerated.
   The &lt;except id=&quot;...&quot;/&gt; element excludes particular users.  The
   semantics of the &#x27;id&#x27; attribute of the &lt;except&gt; element is described
   in Section 7.2.  The results of the child elements of the &lt;many&gt;
   element are combined using a logical OR.

   An example is shown below:

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;ruleset xmlns=&quot;urn:ietf:params:xml:ns:common-policy&quot;&gt;

       &lt;rule id=&quot;f3g44r1&quot;&gt;
           &lt;conditions&gt;
               &lt;sphere value=&quot;work&quot;/&gt;
               &lt;identity&gt;
                   &lt;many&gt;
                       &lt;except domain=&quot;example.com&quot;/&gt;
                       &lt;except domain=&quot;example.org&quot;/&gt;
                       &lt;except id=&quot;sip:alice@bad.example.net&quot;/&gt;
                       &lt;except id=&quot;sip:bob@good.example.net&quot;/&gt;
                       &lt;except id=&quot;tel:+1-212-555-1234&quot; /&gt;
                       &lt;except id=&quot;sip:alice@example.com&quot;/&gt;
                   &lt;/many&gt;
               &lt;/identity&gt;
               &lt;validity&gt;
                   &lt;from&gt;2003-12-24T17:00:00+01:00&lt;/from&gt;
                   &lt;until&gt;2003-12-24T19:00:00+01:00&lt;/until&gt;
               &lt;/validity&gt;
           &lt;/conditions&gt;
           &lt;actions/&gt;
           &lt;transformations/&gt;
       &lt;/rule&gt;

   &lt;/ruleset&gt;

   This example matches all users except any user in example.com, or any
   user in example.org or the particular users alice@bad.example.net,
   bob@good.example.net, and the user with the telephone number
   &#x27;tel:+1-212-555-1234&#x27;.  The last &#x27;except&#x27; element is redundant since
   alice@example.com is already excluded through the first line.

7.1.3.3.  Matching Any Authenticated Identity within a Domain Except
          Enumerated Identities

   The &lt;many&gt; element with a &#x27;domain&#x27; attribute and zero or more &lt;except
   id=&quot;...&quot;/&gt; elements matches any authenticated user from the indicated
   domain except those explicitly enumerated.  The semantics of the &#x27;id&#x27;
   attribute of the &lt;except&gt; element is described in Section 7.2.

   It is nonsensical to have domains in the &#x27;id&#x27; attribute that do not
   match the value of the &#x27;domain&#x27; attribute in the enclosing &lt;many&gt;
   element.

   An example is shown below:

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;ruleset xmlns=&quot;urn:ietf:params:xml:ns:common-policy&quot;&gt;

       &lt;rule id=&quot;f3g44r1&quot;&gt;
           &lt;conditions&gt;
               &lt;identity&gt;
                   &lt;many domain=&quot;example.com&quot;&gt;
                       &lt;except id=&quot;sip:alice@example.com&quot;/&gt;
                       &lt;except id=&quot;sip:bob@example.com&quot;/&gt;
                   &lt;/many&gt;
               &lt;/identity&gt;
           &lt;/conditions&gt;
           &lt;actions/&gt;
           &lt;transformations/&gt;
       &lt;/rule&gt;

   &lt;/ruleset&gt;

   This example matches any user within example.com (such as
   carol@example.com) except alice@example.com and bob@example.com.

7.2.  Single Entity

   The &#x27;id&#x27; attribute used in the &lt;one&gt; and in the &lt;except&gt; element
   refers to a single entity.  In the subsequent text, we use the term
   &#x27;single-user entity&#x27; as a placeholder for the &lt;one&gt; and the &lt;except&gt;
   element.  The &lt;except&gt; element fulfills the purpose of excluding
   elements from the solution set.

   A single-user entity matches the authenticated identity (as contained
   in the &#x27;id&#x27; attribute) of exactly one entity or user.  If there is a
   match, the single-user entity is considered TRUE.  The single-user
   entity MUST NOT contain a &#x27;domain&#x27; attribute.

   The &#x27;id&#x27; attribute contains an identity that MUST first be expressed
   as a URI.  Applications using this framework must describe how the
   identities they are using can be expressed as URIs.

7.3.  Sphere

   The &lt;sphere&gt; element belongs to the group of condition elements.  It
   can be used to indicate a state (e.g., &#x27;work&#x27;, &#x27;home&#x27;, &#x27;meeting&#x27;,
   &#x27;travel&#x27;) the PT is currently in.  A sphere condition matches only if
   the PT is currently in the state indicated.  The state may be
   conveyed by manual configuration or by some protocol.  For example,
   RPID [10] provides the ability to inform the PS of its current
   sphere.  The application domain needs to describe in more detail how
   the sphere state is determined.  Switching from one sphere to another
   causes a switch between different modes of visibility.  As a result,
   different subsets of rules might be applicable.

   The content of the &#x27;value&#x27; attribute of the &lt;sphere&gt; element MAY
   contain more than one token.  The individual tokens MUST be separated
   by a blank character.  A logical OR is used for the matching the
   tokens against the sphere settings of the PT.  As an example, if the
   content of the &#x27;value&#x27; attribute in the sphere attribute contains two
   tokens &#x27;work&#x27; and &#x27;home&#x27; then this part of the rule matches if the
   sphere for a particular PT is either &#x27;work&#x27; OR &#x27;home&#x27;.  To compare
   the content of the &#x27;value&#x27; attribute in the &lt;sphere&gt; element with the
   stored state information about the PT&#x27;s sphere setting a
   case-insensitive string comparison MUST be used for each individual
   token.  There is neither a registry for these values nor a language-
   specific indication of the sphere content.  As such, the tokens are
   treated as opaque strings.

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;ruleset xmlns=&quot;urn:ietf:params:xml:ns:common-policy&quot;&gt;

     &lt;rule id=&quot;f3g44r2&quot;&gt;
       &lt;conditions&gt;
         &lt;sphere value=&quot;work&quot;/&gt;
         &lt;identity&gt;
           &lt;one id=&quot;sip:andrew@example.com&quot;/&gt;
         &lt;/identity&gt;
       &lt;/conditions&gt;
       &lt;actions/&gt;
       &lt;transformations/&gt;
     &lt;/rule&gt;

     &lt;rule id=&quot;y6y55r2&quot;&gt;
       &lt;conditions&gt;
         &lt;sphere value=&quot;home&quot;/&gt;
         &lt;identity&gt;
           &lt;one id=&quot;sip:allison@example.com&quot;/&gt;
         &lt;/identity&gt;
       &lt;/conditions&gt;
       &lt;actions/&gt;
       &lt;transformations/&gt;
     &lt;/rule&gt;

     &lt;rule id=&quot;z6y55r2&quot;&gt;
       &lt;conditions&gt;
         &lt;identity&gt;
              &lt;one id=&quot;sip:john@doe.example.com&quot;/&gt;
         &lt;/identity&gt;
         &lt;sphere value=&quot;home work&quot;/&gt;
       &lt;/conditions&gt;
       &lt;actions/&gt;
       &lt;transformations/&gt;
     &lt;/rule&gt;
   &lt;/ruleset&gt;

   The rule example above illustrates that the rule with the entity
   andrew@example.com matches if the sphere is been set to &#x27;work&#x27;.  In
   the second rule, the entity allison@example.com matches if the sphere
   is set to &#x27;home&#x27;.  The third rule also matches since the value in the
   sphere element also contains the token &#x27;home&#x27;.

7.4.  Validity

   The &lt;validity&gt; element is the third condition element specified in
   this document.  It expresses the rule validity period by two
   attributes, a starting and an ending time.  The validity condition is
   TRUE if the current time is greater than or equal to at least one
   &lt;from&gt; child, but less than the &lt;until&gt; child after it.  This
   represents a logical OR operation across each &lt;from&gt; and &lt;until&gt;
   <span class="Verified-inline-styling" id='inline-1455'>   pair.  Times are expressed in XML dateTime [W3C-Schema] format with a <button id="btn_1455" target="expand_1455" onclick='hideFunction("expand_1455")'>Expand</button>
   mandatory timezone.</span id__locate=1455>  A rule maker
<div class="nodeCloseClass" id='expand_1455'><div class='Verified-endnote-styling' id='eid1455'>
<pre>
<b><i><a href='https://www.rfc-editor.org/errata/eid1455'>EID 1455</a> (Verified) is as follows:</i></b>

<b>Section:</b> 7.4

<b>Original Text:</b>

   pair.  Times are expressed in XML dateTime format.

<b>Corrected Text:</b>

   pair.  Times are expressed in XML dateTime [W3C-Schema] format with a
   mandatory timezone.
</pre>
<b>Notes:</b><br/>
The reference to W3C Schema is normative.  The timezone needs to be mandatory<br/>in order to ensure interoperability.  An alternative would be to reference<br/>RFC 3339 normatively.
</div>
</div>   might not always have access to the PS to invalidate some rules that
   grant permissions.  Hence, this mechanism allows invalidating granted
   permissions automatically without further interaction between the
   rule maker and the PS.  The PS does not remove the rules; instead the
   rule maker has to clean them up.

   An example of a rule fragment is shown below:

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;ruleset xmlns=&quot;urn:ietf:params:xml:ns:common-policy&quot;&gt;

     &lt;rule id=&quot;f3g44r3&quot;&gt;
       &lt;conditions&gt;
           &lt;validity&gt;
               &lt;from&gt;2003-08-15T10:20:00.000-05:00&lt;/from&gt;
               &lt;until&gt;2003-09-15T10:20:00.000-05:00&lt;/until&gt;
           &lt;/validity&gt;
       &lt;/conditions&gt;
       &lt;actions/&gt;
       &lt;transformations/&gt;
     &lt;/rule&gt;
   &lt;/ruleset&gt;

   The &lt;validity&gt; element MUST have the &lt;from&gt; and &lt;until&gt; subelements
   in pairs.  Multiple &lt;from&gt; and &lt;until&gt; elements might appear in pairs
   (i.e., without nesting of &lt;from&gt; and &lt;until&gt; elements).  Using
   multiple &lt;validity&gt; elements as subelements of the &lt;conditions&gt;
   element is not useful since all subelements of the &lt;conditions&gt;
   element are combined as a logical AND.

8.  Actions

   While conditions are the &#x27;if&#x27;-part of rules, actions and
   transformations form their &#x27;then&#x27;-part.  The actions and
   transformations parts of a rule determine which operations the PS
   MUST execute after having received from a WR a data access request
   that matches all conditions of this rule.  Actions and
   transformations only permit certain operations; there is no &#x27;deny&#x27;
   functionality.  Transformations exclusively specify PS-side
   operations that lead to a modification of the data items requested by
   the WR.  Regarding location data items, for instance, a
   transformation could force the PS to lower the precision of the
   location information that is returned to the WR.

   Actions, on the other hand, specify all remaining types of operations
   the PS is obliged to execute, i.e., all operations that are not of
   transformation type.  Actions are defined by application-specific
   usages of this framework.  The reader is referred to the
   corresponding extensions to see examples of such elements.

9.  Transformations

   Two sub-parts follow the conditions part of a rule: transformations
   and actions.  As defined in Section 8, transformations specify
   operations that the PS MUST execute and that modify the result that
   is returned to the WR.  This functionality is particularly helpful in
   reducing the granularity of information provided to the WR, as, for
   example, required for location privacy.  Transformations are defined
   by application-specific usages of this framework.

   A simple transformation example is provided in Section 10.

10.  Procedure for Combining Permissions

10.1.  Introduction

   This section describes how rules are selected and how actions and
   permissions are determined.  When a PS receives a request for access
   to privacy-sensitive data, the request is matched against the rule
   set.  A rule matches if all conditions contained as child elements in
   the &lt;conditions&gt; element of a rule evaluate to TRUE.  Each type of
   condition defines when it is TRUE.  All rules where the conditions
   match the request form the matching rule set.  The permissions in the
   matching rule set are combined using a set of combining rules (CRs)
   described in Section 10.2.

10.2.  Combining Rules (CRs)

   Each type of permission is combined across all matching rules.  Each
   type of action or transformation is combined separately and
   independently.  The combining rules generate a combined permission.
   The combining rules depend only on the data type of permission.  If a
   particular permission type has no value in a rule, it assumes the
   lowest possible value for that permission for the purpose of
   computing the combined permission.  That value is given by the data
   type for booleans (FALSE) and sets (empty set), and MUST be defined
   by any extension to the Common Policy for other data types.

   For boolean permissions, the resulting permission is TRUE if and only
   if at least one permission in the matching rule set has a value of
   TRUE and FALSE otherwise.  For integer, real-valued and date-time
   permissions, the resulting permission is the maximum value across the
   permission values in the matching set of rules.  For sets, it is the
   union of values across the permissions in the matching rule set.

10.3.  Example

   In the following example we illustrate the process of combining
   permissions.  We will consider three conditions for our purpose,
   namely those of name identity (WR-ID), sphere, and validity
   (from,until).  The ID column is used as a rule identifier.  For
   editorial reasons we omit the domain part of the WR&#x27;s identity.

   We use two actions in our example, namely X and Y.  The values of X
   and Y are of data types Boolean and Integer, respectively.

   The transformation, referred to as Z, uses values that can be set
   either to &#x27;+&#x27; (or 3), &#x27;o&#x27; (or 2) or &#x27;-&#x27; (or 1).  Permission Z allows
   us to show the granularity reduction whereby a value of &#x27;+&#x27; shows the
   corresponding information unrestricted, and &#x27;-&#x27; shows nothing.  This
   permission might be related to location information or other presence
   attributes like mood.  Internally, we use the data type Integer for
   computing the permission of this attribute.

   The label &#x27;NULL&#x27; in the table indicates that no value is available
   for a particular cell.

         Conditions                  Actions/Transformations
     +---------------------------------+---------------------+
     | Id  WR-ID    sphere  from until |  X       Y     Z    |
     +---------------------------------+---------------------+
     |  1   bob      home    A1    A2  |  TRUE    10    o    |
     |  2   alice    work    A1    A2  |  FALSE   5     +    |
     |  3   bob      work    A1    A2  |  TRUE    3     -    |
     |  4   tom      work    A1    A2  |  TRUE    5     +    |
     |  5   bob      work    A1    A3  |  NULL    12    o    |
     |  6   bob      work    B1    B2  |  FALSE   10    -    |
     +---------------------------------+---------------------+

   Again for editorial reasons, we use the following abbreviations for
   the two &lt;validity&gt; attributes &#x27;from&#x27; and &#x27;until&#x27;:

     A1=2003-12-24T17:00:00+01:00
     A2=2003-12-24T21:00:00+01:00
     A3=2003-12-24T23:30:00+01:00
     B1=2003-12-22T17:00:00+01:00
     B2=2003-12-23T17:00:00+01:00

   Note that B1 &lt; B2 &lt; A1 &lt; A2 &lt; A3.

   The entity &#x27;bob&#x27; acts as a WR and requests data items.  The rule set
   consists of the six rules shown in the table and identified by the
   values 1 to 6 in the &#x27;Id&#x27; column.  The PS receives the query at

   2003-12-24T17:15:00+01:00, which falls between A1 and A2.  In our
   example, we assume that the sphere value of the PT is currently set
   to &#x27;work&#x27;.

   As a first step, it is necessary to determine which rules fire by
   evaluating the conditions part of each of them.

   Rule 1 does not match since the sphere condition does not match.
   Rule 2 does not match as the identity of the WR (here &#x27;alice&#x27;) does
   not equal &#x27;bob&#x27;.  Rule 3 matches since all conditions evaluate to
   TRUE.  Rule 4 does not match as the identity of the WR (here &#x27;tom&#x27;)
   does not equal &#x27;bob&#x27;.  Rule 5 matches.  Rule 6 does not match since
   the rule is not valid anymore.

   Only rules 3 and 5 fire.  We use the actions and transformations part
   of these two rules to determine the combined permission, as shown
   below.

             Actions/Transformations
     +-----+-----------------------+
     | Id  |  X       Y      Z     |
     +-----+-----------------------+
     |  3  |  TRUE     3     -     |
     |  5  |  NULL    12     o     |
     +-----+-----------------------+

   Each column is treated independently.  The combined value of X is set
   to TRUE since the NULL value equals FALSE according to the
   description in Section 10.2.  For the column with the name Y, we
   apply the maximum of 3 and 12, so that the combined value of Y is 12.
   For column Z, we again compute the maximum of &#x27;o&#x27; and &#x27;-&#x27; (i.e., 2
   and 1) which is &#x27;o&#x27; (2).

   The combined permission for all three columns is therefore:

             Actions/Transformations
           +-----------------------+
           |  X       Y      Z     |
           +-----------------------+
           |  TRUE    12     o     |
           +-----------------------+

11.  Meta Policies

   Meta policies authorize a rule maker to insert, update, or delete a
   particular rule or an entire rule set.  Some authorization policies
   are required to prevent unauthorized modification of rule sets.  Meta
   policies are outside the scope of this document.

   A simple implementation could restrict access to the rule set only to
   the PT but more sophisticated mechanisms could be useful.  As an
   example of such policies, one could think of parents configuring the
   policies for their children.

12.  Example

   This section gives an example of an XML document valid with respect
   to the XML schema defined in Section 13.  Semantically richer
   examples can be found in documents that extend this schema with
   application-domain-specific data (e.g., location or presence
   information).

   Below a rule is shown with a condition that matches for a given
   authenticated identity (bob@example.com) and within a given time
   period.  Additionally, the rule matches only if the target has set
   its sphere to &#x27;work&#x27;.

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;ruleset xmlns=&quot;urn:ietf:params:xml:ns:common-policy&quot;&gt;

       &lt;rule id=&quot;f3g44r1&quot;&gt;
           &lt;conditions&gt;
               &lt;identity&gt;
                   &lt;one id=&quot;sip:bob@example.com&quot;/&gt;
               &lt;/identity&gt;
               &lt;sphere value=&quot;work&quot;/&gt;
               &lt;validity&gt;
                   &lt;from&gt;2003-12-24T17:00:00+01:00&lt;/from&gt;
                   &lt;until&gt;2003-12-24T19:00:00+01:00&lt;/until&gt;
               &lt;/validity&gt;
           &lt;/conditions&gt;
           &lt;actions/&gt;
           &lt;transformations/&gt;
       &lt;/rule&gt;
   &lt;/ruleset&gt;

13.  XML Schema Definition

   This section provides the XML schema definition for the common policy
   markup language described in this document.

&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;xs:schema targetNamespace=&quot;urn:ietf:params:xml:ns:common-policy&quot;
    xmlns:cp=&quot;urn:ietf:params:xml:ns:common-policy&quot;
    xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
    elementFormDefault=&quot;qualified&quot; attributeFormDefault=&quot;unqualified&quot;&gt;
    &lt;!-- /ruleset --&gt;
    &lt;xs:element name=&quot;ruleset&quot;&gt;
        &lt;xs:complexType&gt;
            &lt;xs:complexContent&gt;
                &lt;xs:restriction base=&quot;xs:anyType&quot;&gt;
                    &lt;xs:sequence&gt;
                        &lt;xs:element name=&quot;rule&quot; type=&quot;cp:ruleType&quot;
                        minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
                    &lt;/xs:sequence&gt;
                &lt;/xs:restriction&gt;
            &lt;/xs:complexContent&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
    &lt;!-- /ruleset/rule --&gt;
    &lt;xs:complexType name=&quot;ruleType&quot;&gt;
        &lt;xs:complexContent&gt;
            &lt;xs:restriction base=&quot;xs:anyType&quot;&gt;
                &lt;xs:sequence&gt;
                    &lt;xs:element name=&quot;conditions&quot;
                    type=&quot;cp:conditionsType&quot; minOccurs=&quot;0&quot;/&gt;
                    &lt;xs:element name=&quot;actions&quot;
                    type=&quot;cp:extensibleType&quot; minOccurs=&quot;0&quot;/&gt;
                    &lt;xs:element name=&quot;transformations&quot;
                    type=&quot;cp:extensibleType&quot; minOccurs=&quot;0&quot;/&gt;
                &lt;/xs:sequence&gt;
                &lt;xs:attribute name=&quot;id&quot; type=&quot;xs:ID&quot; use=&quot;required&quot;/&gt;
            &lt;/xs:restriction&gt;
        &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
    &lt;!-- //rule/conditions --&gt;
    &lt;xs:complexType name=&quot;conditionsType&quot;&gt;
        &lt;xs:complexContent&gt;
            &lt;xs:restriction base=&quot;xs:anyType&quot;&gt;
                &lt;xs:choice maxOccurs=&quot;unbounded&quot;&gt;
                    &lt;xs:element name=&quot;identity&quot;
                    type=&quot;cp:identityType&quot; minOccurs=&quot;0&quot;/&gt;
                    &lt;xs:element name=&quot;sphere&quot;
                    type=&quot;cp:sphereType&quot; minOccurs=&quot;0&quot;/&gt;

                    &lt;xs:element name=&quot;validity&quot;
                    type=&quot;cp:validityType&quot; minOccurs=&quot;0&quot;/&gt;
                    &lt;xs:any namespace=&quot;##other&quot; processContents=&quot;lax&quot;
                    minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
                &lt;/xs:choice&gt;
            &lt;/xs:restriction&gt;
        &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
    &lt;!-- //conditions/identity --&gt;
    &lt;xs:complexType name=&quot;identityType&quot;&gt;
        &lt;xs:complexContent&gt;
            &lt;xs:restriction base=&quot;xs:anyType&quot;&gt;
                &lt;xs:choice  minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;&gt;
                    &lt;xs:element name=&quot;one&quot; type=&quot;cp:oneType&quot;/&gt;
                    &lt;xs:element name=&quot;many&quot; type=&quot;cp:manyType&quot;/&gt;
                    &lt;xs:any namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;
                &lt;/xs:choice&gt;
            &lt;/xs:restriction&gt;
        &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
    &lt;!-- //identity/one --&gt;
    &lt;xs:complexType name=&quot;oneType&quot;&gt;
        &lt;xs:complexContent&gt;
            &lt;xs:restriction base=&quot;xs:anyType&quot;&gt;
                &lt;xs:sequence&gt;
                    &lt;xs:any namespace=&quot;##other&quot;
                    minOccurs=&quot;0&quot; processContents=&quot;lax&quot;/&gt;
                &lt;/xs:sequence&gt;
                &lt;xs:attribute name=&quot;id&quot;
                type=&quot;xs:anyURI&quot; use=&quot;required&quot;/&gt;
            &lt;/xs:restriction&gt;
        &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
    &lt;!-- //identity/many --&gt;
    &lt;xs:complexType name=&quot;manyType&quot;&gt;
        &lt;xs:complexContent&gt;
            &lt;xs:restriction base=&quot;xs:anyType&quot;&gt;
                &lt;xs:choice minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
                    &lt;xs:element name=&quot;except&quot; type=&quot;cp:exceptType&quot;/&gt;
                    &lt;xs:any namespace=&quot;##other&quot;
                    minOccurs=&quot;0&quot; processContents=&quot;lax&quot;/&gt;
                &lt;/xs:choice&gt;
                &lt;xs:attribute name=&quot;domain&quot;
                use=&quot;optional&quot; type=&quot;xs:string&quot;/&gt;
            &lt;/xs:restriction&gt;
        &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
    &lt;!-- //many/except --&gt;

    &lt;xs:complexType name=&quot;exceptType&quot;&gt;
        &lt;xs:attribute name=&quot;domain&quot; type=&quot;xs:string&quot; use=&quot;optional&quot;/&gt;
        &lt;xs:attribute name=&quot;id&quot; type=&quot;xs:anyURI&quot; use=&quot;optional&quot;/&gt;
    &lt;/xs:complexType&gt;
    &lt;!-- //conditions/sphere --&gt;
    &lt;xs:complexType name=&quot;sphereType&quot;&gt;
        &lt;xs:complexContent&gt;
            &lt;xs:restriction base=&quot;xs:anyType&quot;&gt;
                &lt;xs:attribute name=&quot;value&quot;
                type=&quot;xs:string&quot; use=&quot;required&quot;/&gt;
            &lt;/xs:restriction&gt;
        &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
    &lt;!-- //conditions/validity --&gt;
    &lt;xs:complexType name=&quot;validityType&quot;&gt;
        &lt;xs:complexContent&gt;
            &lt;xs:restriction base=&quot;xs:anyType&quot;&gt;
                &lt;xs:sequence minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;&gt;
                    &lt;xs:element name=&quot;from&quot; type=&quot;xs:dateTime&quot;/&gt;
                    &lt;xs:element name=&quot;until&quot; type=&quot;xs:dateTime&quot;/&gt;
                &lt;/xs:sequence&gt;
            &lt;/xs:restriction&gt;
        &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
    &lt;!-- //rule/actions or //rule/transformations --&gt;
    &lt;xs:complexType name=&quot;extensibleType&quot;&gt;
        &lt;xs:complexContent&gt;
            &lt;xs:restriction base=&quot;xs:anyType&quot;&gt;
                &lt;xs:sequence&gt;
                    &lt;xs:any namespace=&quot;##other&quot; processContents=&quot;lax&quot;
                    minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
                &lt;/xs:sequence&gt;
            &lt;/xs:restriction&gt;
        &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
&lt;/xs:schema&gt;

14.  Security Considerations

   This document describes a framework for policies.  This framework is
   intended to be enhanced elsewhere by application-domain-specific
   data.  Security considerations are to a great extent application-data
   dependent, and therefore need to be covered by documents that extend
   the framework defined in this specification.  However, new action and
   transformation permissions along with their allowed values must be
   defined in a way so that the usage of the permissions combining rules
   of Section 10 does not lower the level of privacy protection.  See
   Section 10 for more details on this privacy issue.

15.  IANA Considerations

   This section registers a new XML namespace, a new XML schema, and a
   new MIME type.  This section registers a new XML namespace per the
   procedures in [4].

15.1.  Common Policy Namespace Registration

   URI:  urn:ietf:params:xml:ns:common-policy

   Registrant Contact:  IETF GEOPRIV working group, Henning Schulzrinne
      (hgs+geopriv@cs.columbia.edu).

   XML:

   BEGIN
   &lt;?xml version=&quot;1.0&quot;?&gt;
   &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML Basic 1.0//EN&quot;
     &quot;http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd&quot;&gt;
   &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
   &lt;head&gt;
     &lt;meta http-equiv=&quot;content-type&quot;
           content=&quot;text/html;charset=iso-8859-1&quot;/&gt;
     &lt;title&gt;Common Policy Namespace&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
     &lt;h1&gt;Namespace for Common Authorization Policies&lt;/h1&gt;
     &lt;h2&gt;urn:ietf:params:xml:ns:common-policy&lt;/h2&gt;
   &lt;p&gt;See &lt;a href=&quot;ftp://ftp.rfc-editor.org/in-notes/rfc4745.txt&quot;&gt;
      RFC 4745&lt;/a&gt;.&lt;/p&gt;
   &lt;/body&gt;
   &lt;/html&gt;
   END

15.2.  Content-type Registration for &#x27;application/auth-policy+xml&#x27;

   This specification requests the registration of a new MIME type
   according to the procedures of RFC 4288 [5] and guidelines in RFC
   3023 [6].

   MIME media type name:  application

   MIME subtype name:  auth-policy+xml

   Mandatory parameters:  none

   Optional parameters:  charset

      Indicates the character encoding of enclosed XML.

   Encoding considerations:

      Uses XML, which can employ 8-bit characters, depending on the
      character encoding used.  See RFC 3023 [6], Section 3.2.

   Security considerations:

      This content type is designed to carry authorization policies.
      Appropriate precautions should be adopted to limit disclosure of
      this information.  Please refer to Section 14 of RFC 4745 and to
      the security considerations described in Section 10 of RFC 3023
      [6] for more information.

   Interoperability considerations:  None

   Published specification:  RFC 4745

   Applications which use this media type:

      Presence- and location-based systems

   Additional information:

      Magic Number:  None

      File Extension:  .apxml

      Macintosh file type code:  &#x27;TEXT&#x27;

   Personal and email address for further information:
      Hannes Tschofenig, Hannes.Tschofenig@siemens.com

   Intended usage:  LIMITED USE

   Author:

      This specification is a work item of the IETF GEOPRIV working
      group, with mailing list address &lt;geopriv@ietf.org&gt;.

   Change controller:

      The IESG &lt;iesg@ietf.org&gt;

15.3.  Common Policy Schema Registration

   URI:  urn:ietf:params:xml:schema:common-policy

   Registrant Contact:  IETF GEOPRIV working group, Henning Schulzrinne
      (hgs+geopriv@cs.columbia.edu).

   XML:  The XML schema to be registered is contained in Section 13.
      Its first line is

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

   and its last line is

   &lt;/xs:schema&gt;

16.  References

16.1.  Normative References

   [1]  Bradner, S., &quot;Key words for use in RFCs to Indicate Requirement
        Levels&quot;, BCP 14, RFC 2119, March 1997.

   [2]  Duerst, M. and M. Suignard, &quot;Internationalized Resource
        Identifiers (IRIs)&quot;, RFC 3987, January 2005.

   [3]  Faltstrom, P., Hoffman, P., and A. Costello, &quot;Internationalizing
        Domain Names in Applications (IDNA)&quot;, RFC 3490, March 2003.

   [4]  Mealling, M., &quot;The IETF XML Registry&quot;, BCP 81, RFC 3688,
        January 2004.

   [5]  Freed, N. and J. Klensin, &quot;Media Type Specifications and
        Registration Procedures&quot;, BCP 13, RFC 4288, December 2005.

   [6]  Murata, M., St. Laurent, S., and D. Kohn, &quot;XML Media Types&quot;,
        RFC 3023, January 2001.

16.2.  Informative References

   [7]  Rosenberg, J., &quot;Presence Authorization Rules&quot;, Work in Progress,
        June 2006.

   [8]  Schulzrinne, H., Tschofenig, H., Morris, J., Cuellar, J., and J.
        Polk, &quot;A Document Format for Expressing Privacy Preferences for
        Location Information&quot;, Work in Progress, February 2006.

   [9]  Cuellar, J., Morris, J., Mulligan, D., Peterson, J., and J.
        Polk, &quot;Geopriv Requirements&quot;, RFC 3693, February 2004.

   [10] Schulzrinne, H., Gurbani, V., Kyzivat, P., and J. Rosenberg,
        &quot;RPID: Rich Presence Extensions to the Presence Information Data
        Format (PIDF)&quot;, RFC 4480, July 2006.

Appendix A.  Contributors

   We would like to thank Christian Guenther for his help with initial
   versions of this document.

Appendix B.  Acknowledgments

   This document is partially based on the discussions within the IETF
   GEOPRIV working group.  Discussions at the Geopriv Interim Meeting
   2003 in Washington, D.C., helped the working group to make progress
   on the authorization policies based on the discussions among the
   participants.

   We particularly want to thank Allison Mankin &lt;mankin@psg.com&gt;,
   Randall Gellens &lt;rg+ietf@qualcomm.com&gt;, Andrew Newton
   &lt;anewton@ecotroph.net&gt;, Ted Hardie &lt;hardie@qualcomm.com&gt;, and Jon
   Peterson &lt;jon.peterson@neustar.biz&gt; for discussing a number of
   details with us.  They helped us to improve the quality of this
   document.  Allison, Ted, and Andrew also helped us to make good
   progress with the internationalization support of the identifier/
   domain attributes.

   Furthermore, we would like to thank the IETF SIMPLE working group for
   their discussions of J. Rosenberg&#x27;s draft on presence authorization
   policies.  We would also like to thank Stefan Berg, Murugaraj
   Shanmugam, Christian Schmidt, Martin Thomson, Markus Isomaki, Aki
   Niemi, Eva Maria Leppanen, Josip Matanovic, and Mark Baker for their
   comments.  Martin Thomson helped us with the XML schema.  Mark Baker
   provided a review of the media type.  Scott Brim provided a review on
   behalf of the General Area Review Team.

Authors&#x27; Addresses

   Henning Schulzrinne
   Columbia University
   Department of Computer Science
   450 Computer Science Building
   New York, NY  10027
   USA

   Phone: +1 212 939 7042
   EMail: schulzrinne@cs.columbia.edu
   URI:   http://www.cs.columbia.edu/~hgs


   Hannes Tschofenig
   Siemens Networks GmbH &amp; Co KG
   Otto-Hahn-Ring 6
   Munich, Bavaria  81739
   Germany

   EMail: Hannes.Tschofenig@siemens.com
   URI:   http://www.tschofenig.com


   John B. Morris, Jr.
   Center for Democracy and Technology
   1634 I Street NW, Suite 1100
   Washington, DC  20006
   USA

   EMail: jmorris@cdt.org
   URI:   http://www.cdt.org


   Jorge R. Cuellar
   Siemens
   Otto-Hahn-Ring 6
   Munich, Bavaria  81739
   Germany

   EMail: Jorge.Cuellar@siemens.com

   James Polk
   Cisco
   2200 East President George Bush Turnpike
   Richardson, Texas  75082
   USA

   EMail: jmpolk@cisco.com


   Jonathan Rosenberg
   Cisco Systems
   600 Lanidex Plaza
   Parsippany, New York  07054
   USA

   EMail: jdrosen@cisco.com
   URI:   http://www.jdrosen.net

Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   &quot;AS IS&quot; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.


        </re>
        
    </body>
</html>
