<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Use of TESLA in the ALC and NORM Protocols</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Use of TESLA in the ALC and NORM Protocols">
<meta name="keywords" content="TESLA, FLUTE, ALC, NORM">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">MSEC</td><td class="header">V. Roca</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">A. Francillon</td></tr>
<tr><td class="header">Intended status: Experimental</td><td class="header">S. Faurite</td></tr>
<tr><td class="header">Expires: April 29, 2010</td><td class="header">INRIA</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">October 26, 2009</td></tr>
</table></td></tr></table>
<h1><br />Use of TESLA in the ALC and NORM Protocols<br />draft-ietf-msec-tesla-for-alc-norm-10</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.
This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November
10, 2008. The person(s) controlling the copyright in some of this
material may not have granted the IETF Trust the right to allow
modifications of such material outside the IETF Standards Process.
Without obtaining an adequate license from the person(s) controlling
the copyright in such materials, this document may not be modified
outside the IETF Standards Process, and derivative works of it may
not be created outside the IETF Standards Process, except to format
it for publication as an RFC or to translate it into languages other
than English.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on April 29, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>
		This document details the TESLA packet source authentication and packet integrity
		verification protocol and its integration within the ALC and NORM content delivery
		protocols.
		This document only considers the authentication/integrity verification of the packets
		generated by the session's sender. The authentication and integrity verification of
		the packets sent by receivers, if any, is out of the scope of this document.
                
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#intro">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#scope">1.1.</a>&nbsp;
Scope of this Document<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor1">1.2.</a>&nbsp;
Conventions Used in this Document<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.3.</a>&nbsp;
Terminology and Notations<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.3.1.</a>&nbsp;
Notations and Definitions Related to Cryptographic Functions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">1.3.2.</a>&nbsp;
Notations and Definitions Related to Time<br />
<a href="#using_tesla_with_cdp">2.</a>&nbsp;
Using TESLA with ALC and NORM: General Operations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#alc_norm_specificities">2.1.</a>&nbsp;
ALC and NORM Specificities that Impact TESLA<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:intro_to_bootstrap">2.2.</a>&nbsp;
Bootstrapping TESLA<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">2.2.1.</a>&nbsp;
Bootstrapping TESLA with an Out-Of-Band Mechanism<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:intro_to_inband_boostrap">2.2.2.</a>&nbsp;
Bootstrapping TESLA with an In-Band Mechanism<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:need_for_time_sync">2.3.</a>&nbsp;
Setting Up a Secure Time Synchronization<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:intro_to_direct_time_sync">2.3.1.</a>&nbsp;
Direct Time Synchronization<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:intro_to_indirect_time_sync">2.3.2.</a>&nbsp;
Indirect Time Synchronization<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#delay_bound">2.4.</a>&nbsp;
Determining the Delay Bounds<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:delay_bound_calc_direct_sync">2.4.1.</a>&nbsp;
Delay Bound Calculation in Direct Time Synchronization Mode<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:delay_bound_calc_indirect_sync">2.4.2.</a>&nbsp;
Delay Bound Calculation in Indirect time Synchronization Mode<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:crypto_param_values">2.5.</a>&nbsp;
Cryptographic parameter values<br />
<a href="#anchor8">3.</a>&nbsp;
Sender Operations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">3.1.</a>&nbsp;
TESLA Parameters<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:time_intervals">3.1.1.</a>&nbsp;
Time Intervals<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:key_chains">3.1.2.</a>&nbsp;
Key Chains<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:time_int_schedule">3.1.3.</a>&nbsp;
Time Interval Schedule<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:timing_params">3.1.4.</a>&nbsp;
Timing Parameters<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">3.2.</a>&nbsp;
TESLA Signaling Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:bootstrap_info">3.2.1.</a>&nbsp;
Bootstrap Information<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:direct_synch_response">3.2.2.</a>&nbsp;
Direct Time Synchronization Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">3.3.</a>&nbsp;
TESLA Authentication Information<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:auth_tag">3.3.1.</a>&nbsp;
Authentication Tags<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:rsa_signatures">3.3.2.</a>&nbsp;
Digital Signatures<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:group_auth_tag">3.3.3.</a>&nbsp;
Group MAC Tags<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">3.4.</a>&nbsp;
Format of TESLA Messages and Authentication Tags<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:bootstrap_info_format">3.4.1.</a>&nbsp;
Format of a Bootstrap Information Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:direct_synch_response_format">3.4.2.</a>&nbsp;
Format of a Direct Time Synchronization Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:auth_tag_format">3.4.3.</a>&nbsp;
Format of a Standard Authentication Tag<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:auth_tag_wo_key_discl_format">3.4.4.</a>&nbsp;
Format of an Authentication Tag Without Key Disclosure<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:auth_tag_format_new_kcc">3.4.5.</a>&nbsp;
Format of an Authentication Tag with a ``New Key Chain'' Commitment<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:auth_tag_format_old_kck">3.4.6.</a>&nbsp;
Format of an Authentication Tag with a ``Last Key of Old Chain'' Disclosure<br />
<a href="#anchor16">4.</a>&nbsp;
Receiver Operations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:verif_auth_info">4.1.</a>&nbsp;
Verification of the Authentication Information<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:verif_group_mac">4.1.1.</a>&nbsp;
Processing the Group MAC Tag<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">4.1.2.</a>&nbsp;
Processing the Digital Signature<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">4.1.3.</a>&nbsp;
Processing the Authentication Tag<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">4.2.</a>&nbsp;
Initialization of a Receiver<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:recv_process_bootstrap">4.2.1.</a>&nbsp;
Processing the Bootstrap Information Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:rx_time_synchro">4.2.2.</a>&nbsp;
Performing Time Synchronization<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:auth_received_pkts_guidelines">4.3.</a>&nbsp;
Authentication of Received Packets<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">4.3.1.</a>&nbsp;
Discarding Unnecessary Packets Earlier<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:flushing_pkts_of_prev_key_chain">4.4.</a>&nbsp;
Flushing the Non Authenticated Packets of a Previous Key Chain<br />
<a href="#sec:alc_norm_integration">5.</a>&nbsp;
Integration in the ALC and NORM Protocols<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:auth_he_format">5.1.</a>&nbsp;
Authentication Header Extension Format<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:auth_he_use">5.2.</a>&nbsp;
Use of Authentication Header Extensions<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:auth_he_use_bootstrap">5.2.1.</a>&nbsp;
EXT_AUTH Header Extension of Type Bootstrap Information<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:auth_he_use_auth_info">5.2.2.</a>&nbsp;
EXT_AUTH Header Extension of Type Authentication Tag<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:auth_he_use_direct_synch_req">5.2.3.</a>&nbsp;
EXT_AUTH Header Extension of Type Direct Time Synchronization Request<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:auth_he_use_direct_synch_resp">5.2.4.</a>&nbsp;
EXT_AUTH Header Extension of Type Direct Time Synchronization Response<br />
<a href="#anchor22">6.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">6.1.</a>&nbsp;
Dealing With DoS Attacks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">6.2.</a>&nbsp;
Dealing With Replay Attacks<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">6.2.1.</a>&nbsp;
Impacts of Replay Attacks on TESLA<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">6.2.2.</a>&nbsp;
Impacts of Replay Attacks on NORM<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">6.2.3.</a>&nbsp;
Impacts of Replay Attacks on ALC<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">6.3.</a>&nbsp;
Security of the Back Channel<br />
<a href="#sec:iana">7.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor29">8.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">9.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">9.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">9.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
Many applications using multicast and broadcast communications
require that each receiver be able to authenticate the source of any
packet it receives as well as the integrity of these packets.
This is the case with ALC <a class='info' href='#RMT-PI-ALC'>[RMT&#8209;PI&#8209;ALC]<span> (</span><span class='info'>Luby, M., Watson, M., and L. Vicisano, &ldquo;Asynchronous Layered Coding (ALC) Protocol Instantiation,&rdquo; October&nbsp;2009.</span><span>)</span></a> and
NORM <a class='info' href='#RMT-PI-NORM'>[RMT&#8209;PI&#8209;NORM]<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol,&rdquo; September&nbsp;2009.</span><span>)</span></a>,
two Content Delivery Protocols (CDP) designed to transfer reliably
objects (e.g., files) between a session's sender and several receivers.
The NORM protocol is based on bidirectional transmissions.
Each receiver acknowledges data received or, in case of packet erasures,
asks for retransmissions.
On the opposite, the ALC protocol is based on purely unidirectional transmissions.
Reliability is achieved by means of the cyclic transmission of the content
within a carousel and/or by the use of proactive Forward Error Correction
codes (FEC).

Both protocols have in common the fact that they operate at application
level, on top of an erasure channel (e.g., the Internet) where packets
can be lost (erased) during the transmission.

</p>
<p>
The goal of this document is to counter attacks where 
an attacker impersonates the ALC or NORM session's sender and injects
forged packets to the receivers, thereby corrupting the objects reconstructed
by the receivers.

</p>
<p>
Preventing this attack is much more complex in case of group communications
than it is with unicast communications.
Indeed, with unicast communications a simple solution exists: the sender
and the receiver share a secret key to compute a Message Authentication
Code (MAC) of all messages exchanged.
This is no longer feasible in case of multicast and broadcast
communications since sharing a group key between the sender and all
receivers implies that any group member can impersonate the sender and send
forged messages to other receivers.

</p>
<p>
The usual solution to provide the source authentication and message
integrity services in case of multicast and broadcast communications
consists in relying on asymmetric cryptography and using digital signatures.
Yet this solution is limited by high computational costs and high
transmission overheads.
The Timed Efficient Stream Loss-tolerant Authentication protocol (TESLA)
is an alternative solution that provides the two required services,
while being compatible with high rate transmissions over lossy channels.

</p>
<p>
This document explains how to integrate the TESLA source authentication and
packet integrity protocol to the ALC and NORM CDP.
Any application built on top of ALC and NORM will directly benefit from the
services offered by TESLA at the transport layer.
In particular, this is the case of FLUTE.

</p>
<p>
For more information on the TESLA protocol and its principles, please refer to
<a class='info' href='#RFC4082'>[RFC4082]<span> (</span><span class='info'>Perrig, A., Song, D., Canetti, R., Tygar, J., and B. Briscoe, &ldquo;Timed Efficient Stream Loss-Tolerant Authentication (TESLA):           Multicast Source Authentication Transform Introduction,&rdquo; June&nbsp;2005.</span><span>)</span></a><a class='info' href='#Perrig04'>[Perrig04]<span> (</span><span class='info'>Perrig, A. and J. Tygar, &ldquo;Secure Broadcast Communication in Wired and Wireless Networks,&rdquo; 2004.</span><span>)</span></a>.
For more information on ALC and NORM, please refer to
<a class='info' href='#RMT-PI-ALC'>[RMT&#8209;PI&#8209;ALC]<span> (</span><span class='info'>Luby, M., Watson, M., and L. Vicisano, &ldquo;Asynchronous Layered Coding (ALC) Protocol Instantiation,&rdquo; October&nbsp;2009.</span><span>)</span></a>, <a class='info' href='#RFC5651'>[RFC5651]<span> (</span><span class='info'>Luby, M., Watson, M., and L. Vicisano, &ldquo;Layered Coding Transport (LCT) Building Block,&rdquo; October&nbsp;2009.</span><span>)</span></a>
and <a class='info' href='#RMT-PI-NORM'>[RMT&#8209;PI&#8209;NORM]<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol,&rdquo; September&nbsp;2009.</span><span>)</span></a> respectively.
For more information on FLUTE, please refer to <a class='info' href='#RMT-FLUTE'>[RMT&#8209;FLUTE]<span> (</span><span class='info'>Paila, T., Walsh, R., Luby, M., Lehtonen, R., and V. Roca, &ldquo;FLUTE - File Delivery over Unidirectional Transport,&rdquo; August&nbsp;2009.</span><span>)</span></a>.

</p>
<a name="scope"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Scope of this Document</h3>

<p>
This specification only considers the authentication and integrity verification
of the packets generated by the session's sender.
This specification does not consider the packets that may be sent by receivers,
for instance NORM's feedback packets.
<a class='info' href='#RMT-SIMPLE-AUTH'>[RMT&#8209;SIMPLE&#8209;AUTH]<span> (</span><span class='info'>Roca, V., &ldquo;Simple Authentication Schemes for the ALC and NORM Protocols,&rdquo; October&nbsp;2009.</span><span>)</span></a> describes several techniques that can be used 
to that purpose.
Since this is usually a low-rate flow (unlike the downstream flow),
using computing intensive techniques like digital signatures, possibly combined
with a Group MAC scheme, is often acceptable.
Finally, the <a class='info' href='#sec:alc_norm_integration'>Section&nbsp;5<span> (</span><span class='info'>Integration in the ALC and NORM Protocols</span><span>)</span></a> explains how to use several
authentication schemes in a given session thanks to the ASID (Authentication
Scheme IDentifier) field.

</p>
<p>
This specification relies on several external mechanisms, for instance:
</p>
<ul class="text">
<li>to communicate securely the public key or a certificate for the session's sender
		(<a class='info' href='#sec:intro_to_inband_boostrap'>Section&nbsp;2.2.2<span> (</span><span class='info'>Bootstrapping TESLA with an In-Band Mechanism</span><span>)</span></a>);
</li>
<li>to communicate securely and confidentially the group key, K_g, used
		by the Group MAC feature, when applicable
		(<a class='info' href='#sec:group_auth_tag'>Section&nbsp;3.3.3<span> (</span><span class='info'>Group MAC Tags</span><span>)</span></a>). In some situations, this
		group key will have to be periodically refreshed;
</li>
<li>to perform secure time synchronization in indirect mode
		(<a class='info' href='#sec:intro_to_indirect_time_sync'>Section&nbsp;2.3.2<span> (</span><span class='info'>Indirect Time Synchronization</span><span>)</span></a>)
		or in direct mode (<a class='info' href='#sec:intro_to_direct_time_sync'>Section&nbsp;2.3.1<span> (</span><span class='info'>Direct Time Synchronization</span><span>)</span></a>)
		to carry the request/response messages with ALC which is purely
		unidirectional;
</li>
</ul><p> 
These mechanisms are required in order to bootstrap TESLA at a sender and
at a receiver and must be deployed in parallel to TESLA.
Besides, the randomness of the Primary Key of the key chain
(<a class='info' href='#sec:key_chains'>Section&nbsp;3.1.2<span> (</span><span class='info'>Key Chains</span><span>)</span></a>) is vital to the security of TESLA.
Therefore the sender needs an appropriate mechanism to generate this random key.

</p>
<p>

Several technical details of TESLA, like the most appropriate way to alternate
between the transmission of a key disclosure and a commitment to a new key chain,
or the transmission of a key disclosure and the last key of the previous key chain,
or the disclosure of a key and the compact flavor that does not disclose any key,
are specific to the target use-case (<a class='info' href='#sec:key_chains'>Section&nbsp;3.1.2<span> (</span><span class='info'>Key Chains</span><span>)</span></a>).
For instance, it depends on the number of packets sent per time interval, on
the desired robustness and the acceptable transmission overhead, which can only
be optimized after taking into account the use-case specificities.

</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Conventions Used in this Document</h3>

<p>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL",
"SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
and "OPTIONAL" in this document are to be interpreted as
described in <a class='info' href='#RFC2119'>[RFC2119]<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a>.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
Terminology and Notations</h3>

<p>
The following notations and definitions are used throughout this document.

</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3.1"></a><h3>1.3.1.&nbsp;
Notations and Definitions Related to Cryptographic Functions</h3>

<p>
Notations and definitions related to cryptographic functions
<a class='info' href='#RFC4082'>[RFC4082]<span> (</span><span class='info'>Perrig, A., Song, D., Canetti, R., Tygar, J., and B. Briscoe, &ldquo;Timed Efficient Stream Loss-Tolerant Authentication (TESLA):           Multicast Source Authentication Transform Introduction,&rdquo; June&nbsp;2005.</span><span>)</span></a><a class='info' href='#RFC4383'>[RFC4383]<span> (</span><span class='info'>Baugher, M. and E. Carrara, &ldquo;The Use of Timed Efficient Stream Loss-Tolerant Authentication (TESLA) in the Secure Real-time Transport Protocol (SRTP),&rdquo; February&nbsp;2006.</span><span>)</span></a>:
</p>
<ul class="text">
<li>PRF is the Pseudo Random Function;
</li>
<li>MAC is the Message Authentication Code;
</li>
<li>HMAC is the keyed-Hash Message Authentication Code;
</li>
<li>F is the one-way function used to create the key chain
		(<a class='info' href='#sec:key_chains_principles'>Section&nbsp;3.1.2.1<span> (</span><span class='info'>Principles</span><span>)</span></a>);
</li>
<li>F' is the one-way function used to derive the HMAC keys
		(<a class='info' href='#sec:key_chains_principles'>Section&nbsp;3.1.2.1<span> (</span><span class='info'>Principles</span><span>)</span></a>);
</li>
<li>n_p is the length, in bits, of the F function's output.
		This is therefore the length of the keys in the key chain;
</li>
<li>n_f is the length, in bits, of the F' function's output.
		This is therefore the length of the HMAC keys;
</li>
<li>n_m is the length, in bits, of the truncated output of the MAC <a class='info' href='#RFC2104'>[RFC2104]<span> (</span><span class='info'>Krawczyk, H., Bellare, M., and R. Canetti, &ldquo;HMAC: Keyed-Hashing for Message Authentication,&rdquo; February&nbsp;1997.</span><span>)</span></a>.
		Only the n_m most significant bits of the MAC output are kept;
</li>
<li>N is the length of a key chain.
		There are N+1 keys in a key chain: K_0, K_1, .. K_N.
		When several chains are used, all the chains MUST have the same length
		and keys are numbered consecutively, following the time interval numbering;
</li>
<li>n_c is the number of keys in a key chain. Therefore: n_c = N+1;
</li>
<li>n_tx_lastkey is the number of additional intervals during which the last key of
		the old key chain SHOULD be sent, after switching to a new key
		chain and after waiting for the disclosure delay d. These extra transmissions
		take place after the interval during which the last key is normally
		disclosed. The n_tx_lastkey value is either 0 (no extra disclosure) or larger.
		This parameter is sender specific and is not communicated to the receiver;
</li>
<li>n_tx_newkcc is the number of intervals during which the commitment to
		a new key chain SHOULD be sent, before switching to the new key chain.
		The n_tx_newkcc value is either 0 (no commitment sent within authentication tags)
		or larger.
		This parameter is sender specific and is not communicated to the receiver;
</li>
<li>K_g is a shared group key, communicated to all group members, confidentially,
		during the TESLA bootstrapping (<a class='info' href='#sec:intro_to_bootstrap'>Section&nbsp;2.2<span> (</span><span class='info'>Bootstrapping TESLA</span><span>)</span></a>);
</li>
<li>n_w is the length, in bits, of the truncated output of the MAC of the optional
		group authentication scheme:
		only the n_w most significant bits of the MAC output are kept.
		n_w is typically small, multiple of 32 bits (e.g., 32 bits);
</li>
</ul>

<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3.2"></a><h3>1.3.2.&nbsp;
Notations and Definitions Related to Time</h3>

<p>
Notations and definitions related to time:
</p>
<ul class="text">
<li>i is the time interval index. Interval numbering starts at 0 and
		increases consecutively. Since the interval index is stored as a 32 bit
		unsigned integer, wrapping to 0 might take place in long sessions.
</li>
<li>t_s is the sender local time value at some absolute time (in NTP timestamp format);
</li>
<li>t_r is the receiver local time value at the same absolute time (in NTP timestamp format);
</li>
<li>T_0 is the start time corresponding to the beginning of the session, i.e., the
		beginning of time interval 0 (in NTP timestamp format);
</li>
<li>T_int is the interval duration (in milliseconds);
</li>
<li>d is the key disclosure delay (in number of intervals);
</li>
<li>D_t is the upper bound of the lag of the receiver's clock with respect to
		the clock of the sender;
</li>
<li>S_sr is an estimated bound of the clock drift between the sender and a receiver
		throughout the duration of the session;
</li>
<li>D^O_t is the upper bound of the lag of the sender's clock with respect to
		the time reference in indirect time synchronization mode;
</li>
<li>D^R_t is the upper bound of the lag of the receiver's clock with respect to
		the time reference in indirect time synchronization mode;
</li>
<li>D_err is an upper bound of the time error between all the time references,
		in indirect time synchronization mode;
</li>
<li>NTP timestamp format consists in a 64-bit unsigned fixed-point number,
		in seconds relative to 0h on 1 January 1900. The integer part is in
		the first 32 bits and the fraction part in the last 32 bits
		<a class='info' href='#RFC1305'>[RFC1305]<span> (</span><span class='info'>Mills, D., &ldquo;Network Time Protocol (Version 3) Specification, Implementation,&rdquo; March&nbsp;1992.</span><span>)</span></a>;
</li>
</ul>

<a name="using_tesla_with_cdp"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Using TESLA with ALC and NORM: General Operations</h3>

<a name="alc_norm_specificities"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
ALC and NORM Specificities that Impact TESLA</h3>

<p>The ALC and NORM protocols have features and requirements that largely impact
the way TESLA can be used.
</p>
<p>In case of ALC:
</p>
<ul class="text">
<li>ALC is massively scalable:
	nothing in the protocol specification limits the number of receivers
	that join a session.
	Therefore an ALC session potentially includes a huge number (e.g., millions
	or more) of receivers;
	
</li>
<li>ALC can work on top of purely unidirectional transport channels:
	this is one of the assets of ALC, and examples of unidirectional channels
	include satellite (even if a back channel might exist in some use cases)
	and broadcasting networks like DVB-H/SH;
	
</li>
<li>ALC defines an on-demand content delivery model <a class='info' href='#RMT-PI-ALC'>[RMT&#8209;PI&#8209;ALC]<span> (</span><span class='info'>Luby, M., Watson, M., and L. Vicisano, &ldquo;Asynchronous Layered Coding (ALC) Protocol Instantiation,&rdquo; October&nbsp;2009.</span><span>)</span></a>
	where receivers can arrive at any time, at their own discretion,
	download the content and leave the session.
	Other models (e.g., push or streaming) are also defined;
	
</li>
<li>ALC sessions are potentially very long:
	a session can last several days or months during which the
	content is continuously transmitted within a carousel.
	The content can be either static (e.g., a software update) or
	dynamic (e.g., a web site).
</li>
</ul><p>
Depending on the use case, some of the above features may not apply.
For instance ALC can also be used over a bidirectional channel or
with a limited number of receivers.

</p>
<p>In case of NORM:
</p>
<ul class="text">
<li>NORM has been designed for medium size sessions:
	indeed, NORM relies on feedback messages and the sender
	may collapse if the feedback message rate is too high;
	
</li>
<li>NORM requires a bidirectional transport channel:
	the back channel is not necessarily a high data rate channel since
	the control traffic sent over it by a single receiver is an order
	of magnitude lower than the downstream traffic.
	Networks with an asymmetric connectivity (e.g., a high rate satellite
	downlink and a low-rate RTC based return channel) are appropriate;
	
</li>
</ul><p>

</p>
<a name="sec:intro_to_bootstrap"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Bootstrapping TESLA</h3>

<p>
In order to initialize the TESLA component at a receiver, the sender MUST
communicate some key information in a secure way, so that the receiver can check
the source of the information and its integrity.
Two general methods are possible:
</p>
<ul class="text">
<li>	by using an out-of-band mechanism, or
	
</li>
<li>	by using an in-band mechanism.
	
</li>
</ul><p>
The current specification does not recommend any mechanism to bootstrap
TESLA. Choosing between an in-band and out-of-band scheme is left to
the implementer, depending on the target use-case.
However, it is RECOMMENDED that TESLA implementations support the use of
the in-band mechanism for interoperability purposes.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2.1"></a><h3>2.2.1.&nbsp;
Bootstrapping TESLA with an Out-Of-Band Mechanism</h3>

<p>
For instance <a class='info' href='#RFC4442'>[RFC4442]<span> (</span><span class='info'>Fries, S. and H. Tschofenig, &ldquo;Bootstrapping Timed Efficient Stream Loss-Tolerant Authentication (TESLA),&rdquo; March&nbsp;2006.</span><span>)</span></a> describes the use of the MIKEY 
(Multimedia Internet Keying) protocol to bootstrap TESLA.
As a side effect, MIKEY also provides a loose time synchronization
feature, that TESLA can benefit.
Other solutions, for instance based on an extended session description,
are possible, on condition these solutions provide the required security
level.

</p>
<a name="sec:intro_to_inband_boostrap"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2.2"></a><h3>2.2.2.&nbsp;
Bootstrapping TESLA with an In-Band Mechanism</h3>

<p>
This specification describes an in-band mechanism.
In some use-cases, it might be desired that bootstrap take place
without requiring the use of an additional external mechanism.
For instance each device may feature a clock with a known time-drift
that is negligible in front of the time accuracy required by TESLA,
and each device may embed the public key of the sender.
It is also possible that the use-case does not feature a bidirectional
channel which prevents the use of out-of-band protocols like MIKEY.
For these two examples, the exchange of a bootstrap information message
(described in <a class='info' href='#sec:bootstrap_info_format'>Section&nbsp;3.4.1<span> (</span><span class='info'>Format of a Bootstrap Information Message</span><span>)</span></a>) and the knowledge
of a few additional parameters (listed below) are sufficient to bootstrap
TESLA at a receiver.

</p>
<p>
Some parameters cannot be communicated in-band.
In particular:
</p>
<ul class="text">
<li>	the sender or group controller MUST either communicate the public key of the sender or a certificate
	(which also means that a PKI has been setup) to all receivers, so that
	each receiver be able to verify the signature of the bootstrap message and direct time
	synchronization response messages (when applicable).

	
</li>
<li>	when time synchronization is performed with NTP/SNTP,
	the sender or group controller MUST communicate the list of valid
	NTP/SNTP servers to all the session members (sender included), so that
	they all be able to synchronize themselves on
	the same NTP/SNTP servers.
</li>
<li>	when the Group MAC feature is used,
	the sender or group controller MUST communicate the K_g group key to
	all the session members (sender included).
	This group key may be periodically refreshed.
</li>
</ul><p>
The way these parameters are communicated is out of the scope of this document.

</p>
<a name="sec:need_for_time_sync"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Setting Up a Secure Time Synchronization</h3>

<p>
The security offered by TESLA heavily relies on time.
Therefore the session's sender and each receiver need to be time synchronized
in a secure way.
To that purpose, two general methods exist:
</p>
<ul class="text">
<li>direct time synchronization, and
</li>
<li>indirect time synchronization.
</li>
</ul><p>
It is also possible that a given session include receivers that use the direct
time synchronization mode while others use the indirect time synchronization mode.

</p>
<a name="sec:intro_to_direct_time_sync"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.1"></a><h3>2.3.1.&nbsp;
Direct Time Synchronization</h3>

<p>
When direct time synchronization is used, each receiver asks the sender for
a time synchronization. To that purpose, a receiver sends a "Direct Time Synchronization
Request" (<a class='info' href='#sec:direct_synch_request_format'>Section&nbsp;4.2.2.1<span> (</span><span class='info'>Direct Time Synchronization</span><span>)</span></a>).
The sender then directly answers to each request with a "Direct Time Synchronization
Response" (<a class='info' href='#sec:direct_synch_response_format'>Section&nbsp;3.4.2<span> (</span><span class='info'>Format of a Direct Time Synchronization Response</span><span>)</span></a>), signing this reply.
Upon receiving this response, a receiver first verifies the signature, and then calculates
an upper bound of the lag of his clock with respect to the clock of the sender, D_t.
The details on how to calculate D_t are given in <a class='info' href='#sec:delay_bound_calc_direct_sync'>Section&nbsp;2.4.1<span> (</span><span class='info'>Delay Bound Calculation in Direct Time Synchronization Mode</span><span>)</span></a>.

</p>
<p>
This synchronization method is both simple and secure.
Yet there are two potential issues:
</p>
<ul class="text">
<li>a bidirectional channel must exist between the sender and each receiver, and
</li>
<li>the sender may collapse if the incoming request rate is too high.
</li>
</ul><p>

</p>
<p>
Relying on direct time synchronization is not expected to be an issue with NORM since
(1) bidirectional communications already take place, and (2) NORM scalability is anyway limited.
Yet it can be required that a mechanism, that is out of the scope of this document, be used
to spread the transmission of "Direct time synchronization request" messages over the
time if there is a risk that the sender may collapse.

</p>
<p>
But direct time synchronization is potentially incompatible with ALC since (1) there
might not be a back channel and (2) there are potentially
a huge number of receivers and therefore a risk that the sender collapses.

</p>
<a name="sec:intro_to_indirect_time_sync"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.2"></a><h3>2.3.2.&nbsp;
Indirect Time Synchronization</h3>

<p>
When indirect time synchronization is used, the sender and each receiver must
synchronize securely via an external time reference.
Several possibilities exist:
</p>
<ul class="text">
<li>sender and receivers can synchronize through a NTPv3
	(Network Time Protocol version 3) <a class='info' href='#RFC1305'>[RFC1305]<span> (</span><span class='info'>Mills, D., &ldquo;Network Time Protocol (Version 3) Specification, Implementation,&rdquo; March&nbsp;1992.</span><span>)</span></a>
	hierarchy of servers.
	The authentication mechanism of NTPv3 MUST be used in order
	to authenticate each NTP message individually. It prevents
	for instance an attacker to impersonate a NTP server;
</li>
<li>they can synchronize through a NTPv4
	(Network Time Protocol version 4) <a class='info' href='#NTP-NTPv4'>[NTP&#8209;NTPv4]<span> (</span><span class='info'>Burbank, J., Kasch, W., Martin, J., and D. Mills, &ldquo;The Network Time Protocol Version 4 Protocol Specification,&rdquo; September&nbsp;2008.</span><span>)</span></a>
	hierarchy of servers.
	The Autokey security protocol of NTPv4 MUST be used in order
	to authenticate each NTP message individually;
</li>
<li>they can synchronize through a SNTPv4
	(Simple Network Time Protocol version 4) <a class='info' href='#RFC4330'>[RFC4330]<span> (</span><span class='info'>Mills, D., &ldquo;Simple Network Time Protocol (SNTP) Version 4 for IPv4, IPv6 and OSI,&rdquo; January&nbsp;2006.</span><span>)</span></a>
	hierarchy of servers.
	The authentication features of SNTPv4 must then be used.
	Note that TESLA only needs a loose (but secure) time
	synchronization, which is in line with the time synchronization
	service offered by SNTP;
</li>
<li>they can synchronize through a GPS or Galileo (or similar) device
	that also provides a high precision time reference.
	Spoofing attacks on the GPS system have recently been reported.
	Depending on the use case, the security achieved will be or not
	acceptable;
</li>
<li>they can synchronize thanks to a dedicated hardware,
	embedded on each sender and receiver, that provides a clock
	with a time-drift that is negligible in front of the TESLA time
	accuracy requirements. This feature enables a device to synchronize
	its embedded clock with the official time reference from time to
	time (in an extreme case once, at manufacturing time),
	and then to remain autonomous for a duration that depends on the
	known maximum clock drift.
</li>
</ul><p>
A bidirectional channel is required by the NTP/SNTP schemes.
On the opposite, with the GPS/Galileo and high precision clock schemes,
no such assumption is made.
In situations where ALC is used on purely unidirectional transport
channels (<a class='info' href='#alc_norm_specificities'>Section&nbsp;2.1<span> (</span><span class='info'>ALC and NORM Specificities that Impact TESLA</span><span>)</span></a>), using the NTP/SNTP
schemes is not possible.
Another aspect is the scalability requirement of ALC, and to a lesser
extent of NORM. 
From this point of view, the above mechanisms usually do not raise any
problem, unlike the direct time synchronization schemes.
Therefore, using indirect time synchronization can be a good choice.
It should be noted that the NTP/SNTP schemes assume that each client trusts
the sender and accepts to align its NTP/SNTP configuration to that of the
sender. If this assumption does not hold, the sender SHOULD offer an
alternative solution.

</p>
<p>
The details on how to calculate an upper bound of the lag of a receiver's
clock with respect to the clock of the sender, D_t, are given in
<a class='info' href='#sec:delay_bound_calc_indirect_sync'>Section&nbsp;2.4.2<span> (</span><span class='info'>Delay Bound Calculation in Indirect time Synchronization Mode</span><span>)</span></a>.

</p>
<a name="delay_bound"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4"></a><h3>2.4.&nbsp;
Determining the Delay Bounds</h3>

<p>
Let us assume that a secure time synchronization has been set up.
This section explains how to define the various timing parameters that
are used during the authentication of received packets.

</p>
<a name="sec:delay_bound_calc_direct_sync"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4.1"></a><h3>2.4.1.&nbsp;
Delay Bound Calculation in Direct Time Synchronization Mode</h3>

<p>
In direct time synchronization mode, synchronization between a receiver and the
sender follows the following protocol <a class='info' href='#RFC4082'>[RFC4082]<span> (</span><span class='info'>Perrig, A., Song, D., Canetti, R., Tygar, J., and B. Briscoe, &ldquo;Timed Efficient Stream Loss-Tolerant Authentication (TESLA):           Multicast Source Authentication Transform Introduction,&rdquo; June&nbsp;2005.</span><span>)</span></a>:
</p>
<ul class="text">
<li> The receiver sends a "Direct Time Synchronization Request" message to the sender,
	that includes t_r, the receiver local time at the moment of sending
	(<a class='info' href='#sec:direct_synch_request_format'>Section&nbsp;4.2.2.1<span> (</span><span class='info'>Direct Time Synchronization</span><span>)</span></a>).
</li>
<li> Upon receipt of this message, the sender records its local time, t_s,
	and sends to the receiver a "Direct Time Synchronization Response" that includes
	t_r (taken from the request) and t_s, signing this reply
	(<a class='info' href='#sec:direct_synch_response_format'>Section&nbsp;3.4.2<span> (</span><span class='info'>Format of a Direct Time Synchronization Response</span><span>)</span></a>).
</li>
<li> Upon receiving this response, the receiver first verifies that he actually
	sent a request with t_r and then checks the signature.
	Then he calculates D_t = t_s - t_r + S_sr, where S_sr is an estimated bound of the
	clock drift between the sender and the receiver throughout the duration of the
	session.
	This document does not specify how S_sr is estimated.
	
</li>
</ul><p>
After this initial synchronization, at any point throughout the session, the receiver
knows that: T_s &lt; T_r + D_t, where T_s is the current time at the sender and T_r is
the current time at the receiver.

</p>
<a name="sec:delay_bound_calc_indirect_sync"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4.2"></a><h3>2.4.2.&nbsp;
Delay Bound Calculation in Indirect time Synchronization Mode</h3>

<p>
In indirect time synchronization, the sender and the receivers must synchronize
indirectly using one or several time references.

</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4.2.1"></a><h3>2.4.2.1.&nbsp;
Single time reference</h3>

<p>
Let us assume that there is a single time reference.
</p>
<ol class="text">
<li> The sender calculates D^O_t, the upper bound of the lag of the sender's clock
	with respect to the time reference.
	This D^O_t value is then be communicated to the receivers
	(<a class='info' href='#sec:bootstrap_info'>Section&nbsp;3.2.1<span> (</span><span class='info'>Bootstrap Information</span><span>)</span></a>).
</li>
<li> Similarly, a receiver R calculates D^R_t, the upper bound of the lag of
	the receiver's clock with respect to the time reference.
</li>
<li> Then, for receiver R, the overall upper bound of the lag of the receiver's clock
	with respect to the clock of the sender, D_t, is the sum:
		D_t = D^O_t + D^R_t.
</li>
</ol><p>
The D^O_t and D^R_t calculation depends on the time synchronization mechanism
used (<a class='info' href='#sec:intro_to_indirect_time_sync'>Section&nbsp;2.3.2<span> (</span><span class='info'>Indirect Time Synchronization</span><span>)</span></a>).
In some cases, the synchronization scheme specifications provide these values.
In other cases, these parameters can be calculated by means of a scheme similar to
the one specified in <a class='info' href='#sec:delay_bound_calc_direct_sync'>Section&nbsp;2.4.1<span> (</span><span class='info'>Delay Bound Calculation in Direct Time Synchronization Mode</span><span>)</span></a>, for instance
when synchronization is achieved via a group controller <a class='info' href='#RFC4082'>[RFC4082]<span> (</span><span class='info'>Perrig, A., Song, D., Canetti, R., Tygar, J., and B. Briscoe, &ldquo;Timed Efficient Stream Loss-Tolerant Authentication (TESLA):           Multicast Source Authentication Transform Introduction,&rdquo; June&nbsp;2005.</span><span>)</span></a>.

</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.4.2.2"></a><h3>2.4.2.2.&nbsp;
Multiple time references</h3>

<p>
Let us now assume that there are several time references (e.g., several NTP/SNTP servers).
The sender and receivers first synchronize with the various time references, independently.
It results in D^O_t and D^R_t.
Let D_err be an upper bound of the time error between all the time references.
Then, the overall value of D_t within receiver R is set to the sum:
	D_t = D^O_t + D^R_t + D_err.

</p>
<p>
In some cases, the D_t value is part of the time synchronization scheme specifications.
For instance NTPv3 <a class='info' href='#RFC1305'>[RFC1305]<span> (</span><span class='info'>Mills, D., &ldquo;Network Time Protocol (Version 3) Specification, Implementation,&rdquo; March&nbsp;1992.</span><span>)</span></a> defines algorithms that are
"capable of accuracies in the order of a millisecond, even after extended
periods when synchronization to primary reference sources has been lost".
In practice, depending on the NTP server stratum, the accuracy might be a little bit
worse.
In that case, D_t = security_factor * (1ms + 1ms), where the security_factor is
meant to compensate several sources of inaccuracy in NTP.
The choice of the security_factor value is left to the implementer, depending on
the target use-case.

</p>
<a name="sec:crypto_param_values"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.5"></a><h3>2.5.&nbsp;
Cryptographic parameter values</h3>

<p>
The F (resp. F') function output length is given by the n_p (resp. n_f) parameter.
The n_p and n_f values depend on the PRF function chosen, as specified below:

</p>
<p style='text-align: center'>
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="center"><col align="center">
<tr><th align="center">PRF name</th><th align="center">n_p and n_f</th></tr>
<tr>
<td align="center">HMAC-SHA-1</td>
<td align="center">160 bits (20 bytes)</td>
</tr>
<tr>
<td align="center">HMAC-SHA-224</td>
<td align="center">224 bits (28 bytes)</td>
</tr>
<tr>
<td align="center">HMAC-SHA-256 (default)</td>
<td align="center">256 bits (32 bytes)</td>
</tr>
<tr>
<td align="center">HMAC-SHA-384</td>
<td align="center">384 bits (48 bytes)</td>
</tr>
<tr>
<td align="center">HMAC-SHA-512</td>
<td align="center">512 bits (64 bytes)</td>
</tr>
</table>
<br clear="all" />

<p>
The computing of regular MAC (resp. Group MAC) makes use of the n_m (resp. n_w) parameter,
i.e., the length of the truncated output of the function.
The n_m and n_w values depend on the MAC function chosen, as specified below:

</p>
<p style='text-align: center'>
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="center"><col align="center"><col align="center">
<tr><th align="center">MAC name</th><th align="center">n_m (regular MAC)</th><th align="center">n_w (Group MAC)</th></tr>
<tr>
<td align="center">HMAC-SHA-1</td>
<td align="center">80 bits (10 bytes)</td>
<td align="center">32 bits (4 bytes)</td>
</tr>
<tr>
<td align="center">HMAC-SHA-224</td>
<td align="center">112 bits (14 bytes)</td>
<td align="center">32 bits (4 bytes)</td>
</tr>
<tr>
<td align="center">HMAC-SHA-256 (default)</td>
<td align="center">128 bits (16 bytes)</td>
<td align="center">32 bits (4 bytes)</td>
</tr>
<tr>
<td align="center">HMAC-SHA-384</td>
<td align="center">192 bits (24 bytes)</td>
<td align="center">32 bits (4 bytes)</td>
</tr>
<tr>
<td align="center">HMAC-SHA-512</td>
<td align="center">256 bits (32 bytes)</td>
<td align="center">32 bits (4 bytes)</td>
</tr>
</table>
<br clear="all" />

<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Sender Operations</h3>

<p>
This section describes the TESLA operations at a sender.
For more information on the TESLA protocol and its principles, please refer to
<a class='info' href='#RFC4082'>[RFC4082]<span> (</span><span class='info'>Perrig, A., Song, D., Canetti, R., Tygar, J., and B. Briscoe, &ldquo;Timed Efficient Stream Loss-Tolerant Authentication (TESLA):           Multicast Source Authentication Transform Introduction,&rdquo; June&nbsp;2005.</span><span>)</span></a><a class='info' href='#Perrig04'>[Perrig04]<span> (</span><span class='info'>Perrig, A. and J. Tygar, &ldquo;Secure Broadcast Communication in Wired and Wireless Networks,&rdquo; 2004.</span><span>)</span></a>.

</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
TESLA Parameters</h3>

<a name="sec:time_intervals"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.1"></a><h3>3.1.1.&nbsp;
Time Intervals</h3>

<p>
The sender divides the time into uniform intervals of duration T_int.
Time interval numbering starts at 0 and is incremented consecutively.
The interval index MUST be stored in an unsigned 32 bit integer
so that wrapping to 0 takes place only after 2^^32 intervals.
For instance, if T_int is equal to 0.5 seconds, then wrapping takes place
after approximately 68 years.

</p>
<a name="sec:key_chains"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.2"></a><h3>3.1.2.&nbsp;
Key Chains</h3>

<a name="sec:key_chains_principles"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.2.1"></a><h3>3.1.2.1.&nbsp;
Principles</h3>

<p>
The sender computes a one-way key chain of n_c = N+1 keys, and assigns
one key from the chain to each interval, consecutively but in reverse order.
Key numbering starts at 0 and is incremented consecutively, following the
time interval numbering: K_0, K_1 .. K_N.

</p>
<p>
In order to compute this chain, the sender must first select a Primary Key,
K_N, and a PRF function, f (<a class='info' href='#sec:iana'>Section&nbsp;7<span> (</span><span class='info'>IANA Considerations</span><span>)</span></a>, TESLA-PRF).
The randomness of the Primary Key, K_N, is vital to the security and no one
should be able to guess it.

</p>
<p>
The function F is a one-way function that is defined as:
F(k) = f_k(0), where f_k(0) is the result of the application
of the PRF f to k and 0.
When f is a HMAC (<a class='info' href='#sec:iana'>Section&nbsp;7<span> (</span><span class='info'>IANA Considerations</span><span>)</span></a>),
k is used as the key, and 0 as the message, using the algorithm described in
<a class='info' href='#RFC2104'>[RFC2104]<span> (</span><span class='info'>Krawczyk, H., Bellare, M., and R. Canetti, &ldquo;HMAC: Keyed-Hashing for Message Authentication,&rdquo; February&nbsp;1997.</span><span>)</span></a>.
Similarly, the function F' is a one-way function that is defined as:
F'(k) = f_k(1), where f_k(1) is the result of the application
of the same PRF f to k and 1.

</p>
<p>
The sender then computes all the keys of the chain, recursively, starting with K_N,
using: K_{i-1} = F(K_i).
Therefore: K_i = F^{N-i}(K_N), where F^i(x) is the execution of function F with
the argument x, i times.
The receiver can then compute any value in the key chain from K_N,
even if it does not have intermediate values <a class='info' href='#RFC4082'>[RFC4082]<span> (</span><span class='info'>Perrig, A., Song, D., Canetti, R., Tygar, J., and B. Briscoe, &ldquo;Timed Efficient Stream Loss-Tolerant Authentication (TESLA):           Multicast Source Authentication Transform Introduction,&rdquo; June&nbsp;2005.</span><span>)</span></a>.
The key for MAC calculation can then be derived from the corresponding K_i
key by K'_i = F'(K_i).

</p>
<p>The key chain has a finite length, N, which corresponds to a maximum time
duration of (N + 1) * T_int.
The content delivery session has a duration T_delivery, which may either be
known in advance, or not.
A first solution consists in having a single key chain of an appropriate
length, so that the content delivery session finishes before the end of the key chain,
i.e., T_delivery &le; (N + 1) * T_int.
But the longer the key chain, the higher the memory and computation required
to cope with it.
Another solution consists in switching to a new key chain, of the same length,
when necessary <a class='info' href='#Perrig04'>[Perrig04]<span> (</span><span class='info'>Perrig, A. and J. Tygar, &ldquo;Secure Broadcast Communication in Wired and Wireless Networks,&rdquo; 2004.</span><span>)</span></a>.

</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.2.2"></a><h3>3.1.2.2.&nbsp;
Using Multiple Key Chains</h3>

<p>
When several key chains are needed, all of them MUST be of the same length.
Switching from the current key chain to the next one requires that a commitment
to the new key chain be communicated in a secure way to the receiver.
This can be done by using either an out-of-band mechanism, or an in-band
mechanism.
This document only specifies the in-band mechanism.

</p>
<p>
<br /><hr class="insert" />
<a name="fig:key_chain_switch"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
&lt; -------- old key chain --------- &gt;||&lt; -------- new key chain --...
+-----+-----+ .. +-----+-----+-----+||+-----+-----+-----+-----+-----+
   0     1    ..   N-2   N-1    N   ||  N+1   N+2   N+3   N+4   N+5
                                    ||
Key disclosures:                    ||
  N/A   N/A   ..  K_N-4 K_N-3 K_N-2 || K_N-1  K_N  K_N+1 K_N+2 K_N+3
                 |                  ||            |                 |
                 |&lt; -------------- &gt;||            |&lt; ------------- &gt;|
Additional key        F(K_N+1)      ||                   K_N
disclosures        (commitment to   ||              (last key of the
(in parallel):      the new chain)  ||                 old chain)
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Switching to the second key chain
with the in-band mechanism, assuming that d=2, n_tx_newkcc=3, n_tx_lastkey=3.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />



<p>
<a class='info' href='#fig:key_chain_switch'>Figure&nbsp;1<span> (</span><span class='info'>Switching to the second key chain with the in-band mechanism, assuming that d=2, n_tx_newkcc=3, n_tx_lastkey=3.</span><span>)</span></a> illustrates the switch to the
new key chain, using the in-band mechanism.
Let us say that the old key chain stops at K_N and the new key chain
starts at K_{N+1} (i.e., F(K_{N+1}) and K_N are two different keys).
Then the sender includes the commitment F(K_{N+1}) to the new key chain
into packets authenticated with the old key chain
(see <a class='info' href='#sec:auth_tag_format_new_kcc'>Section&nbsp;3.4.5<span> (</span><span class='info'>Format of an Authentication Tag with a ``New Key Chain'' Commitment</span><span>)</span></a>).
This commitment SHOULD be sent during n_tx_newkcc time intervals before the end
of the old key chain.
Since several packets are usually sent during an interval, the sender
SHOULD alternate between sending a disclosed key of the old key chain
and the commitment to the new key chain.
The details of how to alternate between the disclosure and commitment
are out of the scope of this document.

</p>
<p>The receiver will keep the commitment until the key K_{N+1} is disclosed,
at interval N+1+d.
Then the receiver will be able to test the validity of that key by computing
F(K_{N+1}) and comparing it to the commitment.
</p>
<p>When the key chain is changed, it becomes impossible to recover a previous
key from the old key chain.
This is a problem if the receiver lost the packets disclosing the last key of
the old key chain.
A solution consists in re-sending the last key, K_N, of the old key chain
(see <a class='info' href='#sec:auth_tag_format_old_kck'>Section&nbsp;3.4.6<span> (</span><span class='info'>Format of an Authentication Tag with a ``Last Key of Old Chain'' Disclosure</span><span>)</span></a>). 
This SHOULD be done during n_tx_lastkey additional time intervals after the
end of the time interval where K_N is disclosed.
Since several packets are usually sent during an interval, the sender
SHOULD alternate between sending a disclosed key of the new key chain,
and the last key of the old key chain.
The details of how to alternate between the two disclosures
are out of the scope of this document.

</p>
<p>
In some cases a receiver having experienced a very long disconnection might
have lost the commitment of the new chain.
Therefore this receiver will not be able to authenticate any packet related to
the new chain and all the following ones.
The only solution for this receiver to catch up consists in receiving an additional
bootstrap information message.
This can happen by waiting for the next periodic transmission (if sent in-band)
or through an external mechanism (<a class='info' href='#sec:bootstrap_info'>Section&nbsp;3.2.1<span> (</span><span class='info'>Bootstrap Information</span><span>)</span></a>).

</p>
<a name="sec:value_of_tx_lastkey_tx_newkcc"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.2.3"></a><h3>3.1.2.3.&nbsp;
Values of the n_tx_lastkey and n_tx_newkcc Parameters</h3>

<p>
When several key chains and the in-band commitment mechanism are used,
a sender MUST initialize the n_tx_lastkey
and n_tx_newkcc parameters in such a way that no overlapping occur.
In other words, once a sender starts transmitting commitments for a new
key chain, he MUST NOT send a disclosure for the last key of the old
key chain any more.
Therefore, the following property MUST be verified:
	</p>
<blockquote class="text">
<p>d + n_tx_lastkey + n_tx_newkcc &le; N + 1
</p>
</blockquote><p>

</p>
<p>
It is RECOMMENDED, for robustness purposes, that, once n_tx_lastkey has
been chosen, then:
	</p>
<blockquote class="text">
<p>n_tx_newkcc = N + 1 - n_tx_lastkey - d
</p>
</blockquote><p>
In other words, the sender starts transmitting a commitment to the following
key chain immediately after having sent all the disclosures of the last
key of the previous key chain.
Doing so increases the probability that a receiver gets a commitment for
the following key chain.

</p>
<p>
In any case, these two parameters are sender specific and need not be
transmitted to the receivers.
Of course, as explained above, the sender alternates between the disclosure
of a key of the current key chain and the commitment to the new key chain
(or the last key of the old key chain).

</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.2.4"></a><h3>3.1.2.4.&nbsp;
The Particular Case of the Session Start</h3>

<p>
Since a key cannot be disclosed before the disclosure delay, d, no key will
be disclosed during the first d time intervals (intervals 0 and 1 in
<a class='info' href='#fig:key_chain_switch'>Figure&nbsp;1<span> (</span><span class='info'>Switching to the second key chain with the in-band mechanism, assuming that d=2, n_tx_newkcc=3, n_tx_lastkey=3.</span><span>)</span></a>) of the session.
To that purpose, the sender uses the Authentication Tag Without Key Disclosure
<a class='info' href='#sec:auth_tag_wo_key_discl_format'>Section&nbsp;3.4.4<span> (</span><span class='info'>Format of an Authentication Tag Without Key Disclosure</span><span>)</span></a>.
The following key chains, if any, are not concerned since they will
disclose the last d keys of the previous chain.

</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.2.5"></a><h3>3.1.2.5.&nbsp;
Managing Silent Periods</h3>

<p>
An ALC or NORM sender may stop transmitting packets for some time.
For instance it can be the end of the session and all packets have already been sent,
or the use-case may consist in a succession of busy periods (when fresh
objects are available) followed by silent periods.
In any case, this is an issue since the authentication of the packets
sent during the last d intervals requires that the associated keys be
disclosed, which will take place during d additional time intervals.

</p>
<p>
To solve this problem, it is recommended that the sender transmit empty
packets (i.e., without payload) containing the TESLA EXT_AUTH header
extension along with a Standard Authentication Tag during at
least d time intervals after the end of the regular ALC or NORM packet transmissions.
The number of such packets and the duration during which they are sent
must be sufficient for all receivers to receive, with a high probability,
at least one packet disclosing the last useful key (i.e., the key used for
the last non-empty packet sent).

</p>
<a name="sec:time_int_schedule"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.3"></a><h3>3.1.3.&nbsp;
Time Interval Schedule</h3>

<p>
The sender must determine the following parameters:
</p>
<ul class="text">
<li>T_0, the start time corresponding to the beginning of the session, i.e., the
		beginning of time interval 0 (in NTP timestamp format);
</li>
<li>T_int, the interval duration (in milliseconds), usually ranging from 100 milliseconds to 1 
		second;
</li>
<li>d, the key disclosure delay (in number of intervals). It is the time to wait
		before disclosing a key;
</li>
<li>N, the length of a key chain;
</li>
</ul>

<p>
The correct choice of T_int, d, and N is crucial for the efficiency of the scheme.
For instance, a T_int * d product that is too long will cause excessive delay in the
authentication process. 
A T_int * d product that is too short prevents many receivers from verifying packets.
A N * T_int product that is too small will cause the sender to switch too often to
new key chains.
A N that is too long with respect to the expected session duration (if known)
will require the sender to compute too many useless keys.
<a class='info' href='#RFC4082'>[RFC4082]<span> (</span><span class='info'>Perrig, A., Song, D., Canetti, R., Tygar, J., and B. Briscoe, &ldquo;Timed Efficient Stream Loss-Tolerant Authentication (TESLA):           Multicast Source Authentication Transform Introduction,&rdquo; June&nbsp;2005.</span><span>)</span></a> sections 3.2 and 3.6 give general guidelines for
initializing these parameters.

</p>
<p>
The T_0, T_int, d and N parameters MUST NOT be changed during the lifetime of the session.
This restriction is meant to prevent introducing vulnerabilities.
For instance if a sender was authorized to change the key disclosure schedule, a receiver that did
not receive the change notification would still believe in the old key disclosure schedule,
thereby creating vulnerabilities <a class='info' href='#RFC4082'>[RFC4082]<span> (</span><span class='info'>Perrig, A., Song, D., Canetti, R., Tygar, J., and B. Briscoe, &ldquo;Timed Efficient Stream Loss-Tolerant Authentication (TESLA):           Multicast Source Authentication Transform Introduction,&rdquo; June&nbsp;2005.</span><span>)</span></a>.

</p>
<a name="sec:timing_params"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1.4"></a><h3>3.1.4.&nbsp;
Timing Parameters</h3>

<p>
In indirect time synchronization mode, 
the sender must determine the following parameter:
</p>
<ul class="text">
<li> D^O_t, the upper bound of the lag of the sender's clock with respect
	to the time reference.
</li>
</ul><p>
The D^O_t parameter MUST NOT be changed during the lifetime of the session.

</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
TESLA Signaling Messages</h3>

<p>
At a sender, TESLA produces two types of signaling information:
</p>
<ul class="text">
<li>The bootstrap information:
	it can be either sent out-of-band or in-band.
	In the latter case, a digitally signed packet contains all the 
	information required to bootstrap TESLA at a receiver;
</li>
<li>The direct time synchronization response, which enables a receiver to finish a
	direct time synchronization;
</li>
</ul><p>

</p>
<a name="sec:bootstrap_info"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.1"></a><h3>3.2.1.&nbsp;
Bootstrap Information</h3>

<p>
In order to initialize the TESLA component at a receiver, the sender must
communicate some key information in a secure way.
This information can be sent in-band or out-of-band, as discussed in
<a class='info' href='#sec:intro_to_bootstrap'>Section&nbsp;2.2<span> (</span><span class='info'>Bootstrapping TESLA</span><span>)</span></a>.
In this section we only consider the in-band scheme.

</p>
<p>
The TESLA bootstrap information message MUST be digitally signed
(<a class='info' href='#sec:rsa_signatures'>Section&nbsp;3.3.2<span> (</span><span class='info'>Digital Signatures</span><span>)</span></a>).
The goal is to enable a receiver to check the packet source and packet integrity.
Then, the bootstrap information can be:
</p>
<ul class="text">
<li> unicast to a receiver during a direct time synchronization request/response exchange;
</li>
<li> broadcast to all receivers.
	This is typically the case in indirect time synchronization mode.
	It can also be used in direct time synchronization mode, for instance
	when a large number of clients arrive at the same time, in which case
	it is more efficient to answer globally.
</li>
</ul><p>

</p>
<p>
Let us consider situations where the bootstrap information is broadcast.
This message should be broadcast at the beginning of the session, before
data packets are actually sent.
This is particularly important with ALC or NORM sessions in "push" mode,
when all clients join the session in advance.
For improved reliability, bootstrap information might be sent a certain
number of times.

</p>
<p>
A periodic broadcast of the bootstrap information message
could also be useful when:
</p>
<ul class="text">
<li>the ALC session uses an "on-demand" mode, clients arriving at their own
	discretion;
</li>
<li>some clients experience an intermittent connectivity.
	This is particularly important when several key chains are used in an
	ALC or NORM session, since there is a risk that a receiver
	loses all the commitments to the new key chain.
</li>
</ul><p>
A balance must be found between the signaling overhead and the maximum initial
waiting time at the receiver before starting the delayed authentication process.
A period of a few seconds for the transmission of this bootstrap information
is often a reasonable value.

</p>
<a name="sec:direct_synch_response"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2.2"></a><h3>3.2.2.&nbsp;
Direct Time Synchronization Response</h3>

<p>
In Direct Time Synchronization, upon receipt of a synchronization request, the sender
records its local time, t_s, and sends a response message that contains both t_r and t_s
(<a class='info' href='#sec:delay_bound_calc_direct_sync'>Section&nbsp;2.4.1<span> (</span><span class='info'>Delay Bound Calculation in Direct Time Synchronization Mode</span><span>)</span></a>).
This message is unicast to the receiver.
This Direct Time Synchronization Response message MUST be digitally signed in order to
enable a receiver to check the packet source and packet integrity
(<a class='info' href='#sec:rsa_signatures'>Section&nbsp;3.3.2<span> (</span><span class='info'>Digital Signatures</span><span>)</span></a>).
The receiver MUST also be able to associate this response and his request, which
is the reason why t_r is included in the response message.

</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
TESLA Authentication Information</h3>

<p>
At a sender, TESLA produces three types of security tags:
</p>
<ul class="text">
<li>an authentication tag, in case of data packets, and which contains
	the MAC of the packet;
</li>
<li>a digital signature, in case of one of the two TESLA signaling packets,
	namely a Bootstrap Information Message or a Direct Time Synchronization
	Response; and
</li>
<li>an optional group authentication tag, that can be added
	to all the packets to mitigate attacks coming from outside
	of the group.
</li>
</ul><p>

</p>
<p>
Because of interdependencies, their computation MUST follow a strict
order:
</p>
<ul class="text">
<li>first of all, compute the authentication tag (with data packet) or the
	digital signature (with signaling packet);
</li>
<li>finally compute the Group Mac;
</li>
</ul><p>

</p>
<a name="sec:auth_tag"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1"></a><h3>3.3.1.&nbsp;
Authentication Tags</h3>

<p>
All the data packets sent MUST have an authentication tag containing:
</p>
<ul class="text">
<li> the interval index, i, which is also the index of the key
	used for computing the MAC of this packet;
</li>
<li> the MAC of the message: MAC(K'_i, M), where K'_i=F'(K_i);
</li>
<li> either a disclosed key (that belongs to the current key chain or the
	previous key chain), or a commitment to a new key chain,
	or no key at all;
</li>
</ul><p>

</p>
<p>
The computation of MAC(K'_i, M) MUST include the ALC or NORM header (with the
various header extensions) and the payload (when applicable).
The UDP/IP headers MUST NOT be included.
During this computation, the MAC(K'_i, M) field of the authentication tag 
MUST be set to 0.

</p>
<a name="sec:rsa_signatures"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.2"></a><h3>3.3.2.&nbsp;
Digital Signatures</h3>

<p>
The Bootstrap Information message (with the in-band bootstrap scheme)
and Direct Time Synchronization Response message (with the indirect time
synchronization scheme) both need to be signed by the sender.
These two messages contain a "Signature" field to hold the digital signature.
The bootstrap information message also contains the "Signature Encoding Algorithm",
the "Signature Cryptographic Function", and the "Signature Length" fields that
enable a receiver to process the "Signature" field.
Note that there is no such "Signature Encoding Algorithm", "Signature Cryptographic Function" and
"Signature Length" fields in case of a Direct Time Synchronization Response
message since it is assumed that these parameters are already known
(i.e., the receiver either received a bootstrap information message before,
or these values have been communicated out-of-band).

</p>
<p>
Several "Signature Encoding Algorithms" can be used, including
RSASSA-PKCS1-v1_5, the default, and RSASSA-PSS (<a class='info' href='#sec:iana'>Section&nbsp;7<span> (</span><span class='info'>IANA Considerations</span><span>)</span></a>).
With these encodings, SHA-256 is the default "Signature Cryptographic Function".

</p>
<p>
The computation of the signature MUST include the ALC or NORM header (with the
various header extensions) and the payload when applicable.
The UDP/IP headers MUST NOT be included.
During this computation, the "Signature" field MUST be set to 0 as well as
the optional Group MAC, when present, since this Group MAC is calculated later on.

</p>
<p>
More specifically, from <a class='info' href='#RFC4359'>[RFC4359]<span> (</span><span class='info'>Weis, B., &ldquo;The Use of RSA/SHA-1 Signatures within Encapsulating Security Payload (ESP) and Authentication Header (AH),&rdquo; January&nbsp;2006.</span><span>)</span></a>:
digital signature generation is performed as described in
<a class='info' href='#RFC3447'>[RFC3447]<span> (</span><span class='info'>Jonsson, J. and B. Kaliski, &ldquo;Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1,&rdquo; February&nbsp;2003.</span><span>)</span></a>, Section 8.2.1 for RSASSA-PKCS1-v1_5 and
Section 8.1.1 for RSASSA-PSS.
The authenticated portion of the packet is used as the message M,
which is passed to the signature generation function.
The signer's RSA private key is passed as K.
In summary (when SHA-256 is used), the signature generation process computes
a SHA-256 hash of the authenticated packet bytes, signs the SHA-256 hash using
the private key, and encodes the result with the specified RSA encoding type.
This process results in a value S, which is the digital signature to
be included in the packet.

</p>
<p>
With RSASSA-PKCS1-v1_5 and RSASSA-PSS signatures,
the size of the signature is equal to the "RSA modulus", unless the "RSA modulus"
is not a multiple of 8 bits. In that case, the signature MUST be prepended with
between 1 and 7 bits set to zero such that the signature is a multiple of 8 bits
<a class='info' href='#RFC4359'>[RFC4359]<span> (</span><span class='info'>Weis, B., &ldquo;The Use of RSA/SHA-1 Signatures within Encapsulating Security Payload (ESP) and Authentication Header (AH),&rdquo; January&nbsp;2006.</span><span>)</span></a>.
The key size, which in practice is also equal to the "RSA modulus", has major security
implications.
<a class='info' href='#RFC4359'>[RFC4359]<span> (</span><span class='info'>Weis, B., &ldquo;The Use of RSA/SHA-1 Signatures within Encapsulating Security Payload (ESP) and Authentication Header (AH),&rdquo; January&nbsp;2006.</span><span>)</span></a> explains how to choose this value depending on the maximum
expected lifetime of the session.
This choice is out of the scope of this document.

</p>
<a name="sec:group_auth_tag"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.3"></a><h3>3.3.3.&nbsp;
Group MAC Tags</h3>

<p>
An optional Group MAC can be used to mitigate DoS attacks coming from attackers
that are not group members <a class='info' href='#RFC4082'>[RFC4082]<span> (</span><span class='info'>Perrig, A., Song, D., Canetti, R., Tygar, J., and B. Briscoe, &ldquo;Timed Efficient Stream Loss-Tolerant Authentication (TESLA):           Multicast Source Authentication Transform Introduction,&rdquo; June&nbsp;2005.</span><span>)</span></a>. 
This feature assumes that a group key, K_g, is shared by the sender and all receivers.
When the attacker is not a group member, the benefits of adding a group MAC to every
packet sent are threefold:
</p>
<ul class="text">
<li> a receiver can immediately drop faked packets, without
	having to wait for the disclosure delay, d;
	
</li>
<li> a sender can immediately drop faked direct time synchronization requests,
	and avoid to check the digital signature, a computation intensive task;
	
</li>
<li> a receiver can immediately drop faked direct time synchronization response
	and bootstrap messages, without having to verify the digital signature, a computation
	intensive task;
	
</li>
</ul><p>

</p>
<p>
The computation of the group MAC, MAC(K_g, M), MUST include the ALC or NORM header
(with the various header extensions) and the payload when applicable.
The UDP/IP headers MUST NOT be included.
During this computation, the Group MAC field MUST be set to 0.
However the digital signature (e.g., of a bootstrap message) and the MAC fields
(e.g., of an authentication tag), when present, MUST have been calculated since 
they are included in the Group MAC calculation itself.
Then the sender truncates the MAC output to keep the n_w most significant bits
and stores the result in the Group MAC field.

</p>
<p>
This scheme features a few limits:
</p>
<ul class="text">
<li>it is of no help if a group member (who knows K_g) impersonates
	the sender and sends forged messages to other receivers;
</li>
<li>it requires an additional MAC computing for each packet,
	both at the sender and receiver sides;
</li>
<li>it increases the size of the TESLA authentication headers.
	In order to limit this problem, the length of the truncated output of the
	MAC, n_w, SHOULD be kept small (e.g., 32 bits)
	(see <a class='info' href='#RFC3711'>[RFC3711]<span> (</span><span class='info'>Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;The Secure Real-time Transport Protocol (SRTP),&rdquo; March&nbsp;2004.</span><span>)</span></a> section 9.5).
	As a side effect, the authentication service is significantly weakened:
	the probability that any forged packet be successfully authenticated
	becomes one in 2^32.
	Since the group MAC check is only a pre-check that must be followed
	by the standard TESLA authentication check, this is not considered to
	be an issue.
</li>
</ul><p>
For a given use-case, the benefits brought by the group MAC must be balanced
against these limitations.

</p>
<p>
Note that the Group MAC function can be different from the TESLA MAC function
(e.g., it can use a weaker but faster MAC function).
Note also that the mechanism by which the group key, K_g, is communicated to all
group members, and perhaps periodically updated, is out of the scope of this document.

</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4"></a><h3>3.4.&nbsp;
Format of TESLA Messages and Authentication Tags</h3>

<p>
This section specifies the format of the various kinds of TESLA messages
and authentication tags sent by the session's sender.
Because these TESLA messages are carried as EXT_AUTH header extensions
of the ALC or NORM packets (<a class='info' href='#sec:alc_norm_integration'>Section&nbsp;5<span> (</span><span class='info'>Integration in the ALC and NORM Protocols</span><span>)</span></a>),
the following formats do not start on 32 bit word boundaries.

</p>
<a name="sec:bootstrap_info_format"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.1"></a><h3>3.4.1.&nbsp;
Format of a Bootstrap Information Message</h3>

<p>
When bootstrap information is sent in-band, the following message is
used:
<br /><hr class="insert" />
<a name="fig:bootstrap_info_format"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                                +-+-+-+-+-+-+-+-+  ---
                                                | V |resvd|S|G|A|  ^
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |
|       d       |    PRF Type   | MAC Func Type |Gr MAC Fun Type|  | f
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  | i
|   SigEncAlgo  | SigCryptoFunc |       Signature Length        |  | x
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  | e
|            Reserved           |             T_int             |  | d
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |
|                                                               |  | l
+                  T_0 (NTP timestamp format)                   +  | e
|                                                               |  | n
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  | g
|                      N (Key Chain Length)                     |  | t
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  | h
|                    Current Interval Index i                   |  v
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  ---
|                                                               |
~                 Current Key Chain Commitment  +-+-+-+-+-+-+-+-+
|                                               |   Padding     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                                                               +
~                           Signature                           ~
+                                               +-+-+-+-+-+-+-+-+
|                                               |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|P|                                                             |
+-+       D^O_t Extension (optional, present if A==1)           +
|    (NTP timestamp diff, positive if P==1, negative if P==0)   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
~                      Group MAC (optional)                     ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2: Bootstrap information format.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />



<p>
The format of the bootstrap information is depicted in
<a class='info' href='#fig:bootstrap_info_format'>Figure&nbsp;2<span> (</span><span class='info'>Bootstrap information format.</span><span>)</span></a>.
The fields are:
</p>
<p>"V" (Version) field (2 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	The "V" field contains the version number of the protocol.
	For this specification, the value of 0 MUST be used.

</p>
</blockquote>

<p>"Reserved" field (3 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	This is a reserved field that MUST be set to zero in this specification.

</p>
</blockquote>

<p>"S" (Single Key Chain) flag (1 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	The "S" flag indicates whether this TESLA session is restricted to a single
	key chain (S==1) or relies on one or multiple key chains (S==0).

</p>
</blockquote>

<p>"G" (Group MAC Present) flag (1 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	The "G" flag indicates whether the Group MAC feature is used
	(G==1) or not (G==0). When it is used, a "Group MAC" field
	is added to all the packets containing a  TESLA EXT_AUTH Header Extension
	(including this bootstrap message).

</p>
</blockquote>

<p>"A" flag (1 bit):
</p>
<p></p>
<blockquote class="text">
<p>
	The "A" flag indicates whether the P flag and D^O_t fields are present
	(A==1) or not (A==0).
	In indirect time synchronization mode, A MUST be equal to 1 since these
	fields are needed.

</p>
</blockquote>

<p>"d" field (8 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	d is an unsigned integer that defines the key disclosure delay (in number of intervals).
	d MUST be greater or equal to 2.

</p>
</blockquote>

<p>"PRF Type" field (8 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	The "PRF Type" is the reference number of the f function used to derive
        the F (for key chain) and F' (for MAC keys) functions (<a class='info' href='#sec:iana'>Section&nbsp;7<span> (</span><span class='info'>IANA Considerations</span><span>)</span></a>).

</p>
</blockquote>

<p>"MAC Function Type" field (8 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	The "MAC Function Type" is the reference number of the function used to compute
	the MAC of the packets (<a class='info' href='#sec:iana'>Section&nbsp;7<span> (</span><span class='info'>IANA Considerations</span><span>)</span></a>).

</p>
</blockquote>

<p>"Group MAC Function Type" field (8 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	When G==1, this field contains the reference number of the cryptographic MAC function
	used to compute the group MAC (<a class='info' href='#sec:iana'>Section&nbsp;7<span> (</span><span class='info'>IANA Considerations</span><span>)</span></a>).
	When G==0, this field MUST be set to zero.

</p>
</blockquote>

<p>"Signature Encoding Algorithm" field (8 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	The "Signature Encoding Algorithm" is the reference number (<a class='info' href='#sec:iana'>Section&nbsp;7<span> (</span><span class='info'>IANA Considerations</span><span>)</span></a>) of the digital
	signature used to authenticate this bootstrap information and included in the
	"Signature" field.

</p>
</blockquote>

<p>"Signature Cryptographic Function" field (8 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	The "Signature Cryptographic Function" is the reference number (<a class='info' href='#sec:iana'>Section&nbsp;7<span> (</span><span class='info'>IANA Considerations</span><span>)</span></a>)
	of the cryptographic function used within the digital signature.

</p>
</blockquote>

<p>"Signature Length" field (16 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	The "Signature Length" is an unsigned integer that indicates the signature field size in bytes
	in the "Signature Extension" field.
	This is also the signature key length, since both parameters are equal.

</p>
</blockquote>

<p>"Reserved" fields (16 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	This is a reserved field that MUST be set to zero in this specification.

</p>
</blockquote>

<p>"T_int" field (16 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	T_int is an unsigned 16 bit integer that defines the interval duration (in milliseconds).

</p>
</blockquote>

<p>"T_0" field (64 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	"T_0" is a timestamp in NTP timestamp format that indicates the beginning of the session, i.e., the
		beginning of time interval 0.

</p>
</blockquote>

<p>"N" field (32 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	"N" is an unsigned integer that indicates the key chain length.
	There are N + 1 keys per chain.

</p>
</blockquote>

<p>"i" (Interval Index of K_i) field (32 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	"i" is an unsigned integer that indicates the current interval index
	when this bootstrap information message is sent.

</p>
</blockquote>

<p>"Current Key Chain Commitment" field (variable size, padded if necessary for 32 bit word alignment):
</p>
<p></p>
<blockquote class="text">
<p>
	"Key Chain Commitment" is the commitment to the current key chain,
	i.e., the key chain corresponding to interval i.
	For instance, with the first key chain, this commitment is equal to F(K_0),
	with the second key chain, this commitment is equal to F(K_{N+1}), etc.).
	If need be, this field is padded (with 0) up to a multiple of 32 bits.

</p>
</blockquote>

<p>"Signature" field (variable size, padded if necessary for 32 bit word alignment):
</p>
<p></p>
<blockquote class="text">
<p>
	The "Signature" field is mandatory.
	It contains a digital signature of this message, as specified by the
	encoding algorithm, cryptographic function and key length parameters.
	If the signature length is not multiple of 32 bits, this field is padded
	with 0.

</p>
</blockquote>

<p>"P" flag (optional, 1 bit if present):
</p>
<p></p>
<blockquote class="text">
<p>
	The "P" flag is optional and only present if the A flag is equal to 1..
	It is only used in indirect time synchronization mode.
	This flag indicates whether the D^O_t NTP timestamp difference is positive
	(P==1) or negative (P==0).

</p>
</blockquote>

<p>"D^O_t" field (optional, 63 bits if present):
</p>
<p></p>
<blockquote class="text">
<p>
	The "D^O_t" field is optional and only present if the A flag is equal to 1.
	It is only used in indirect time synchronization mode.
	It is the upper bound of the lag of the sender's clock with
	respect to the time reference.
	When several time references are specified (e.g., several NTP servers), then
	D^O_t is the maximum upper bound of the lag with each time reference.
	D^O_t is composed of two unsigned integers, as with NTP timestamps:
	the first 31 bits give the time difference in seconds and the remaining 32 bits
	give the sub-second time difference.


</p>
</blockquote>

<p>"Group MAC" field (optional, variable length, multiple of 32 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	This field contains the group MAC, calculated with the group key, K_g,
	shared by all group members.
	The field length, in bits, is given by n_w which is known once the
	group MAC function type is known (<a class='info' href='#sec:iana'>Section&nbsp;7<span> (</span><span class='info'>IANA Considerations</span><span>)</span></a>).

</p>
</blockquote>

<p>
Note that the first byte and the following seven 32-bit words are mandatory fixed
length fields.
The Current Key Chain Commitment and Signature fields are mandatory but variable length fields.
The remaining D^O_t and Group MAC fields are optional.

</p>
<p>
In order to prevent attacks, some parameters MUST NOT be changed during the lifetime of the session
(<a class='info' href='#sec:time_int_schedule'>Section&nbsp;3.1.3<span> (</span><span class='info'>Time Interval Schedule</span><span>)</span></a>, <a class='info' href='#sec:timing_params'>Section&nbsp;3.1.4<span> (</span><span class='info'>Timing Parameters</span><span>)</span></a>).
The following table summarizes the parameters status:

</p>
<p style='text-align: center'>
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="center" width="35%"><col align="center">
<tr><th align="center">Parameter</th><th align="center">Status</th></tr>
<tr>
<td align="center">V</td>
<td align="center">set to 0 in this specification</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">static (during whole session)</td>
</tr>
<tr>
<td align="center">G</td>
<td align="center">static (during whole session)</td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">static (during whole session)</td>
</tr>
<tr>
<td align="center">T_O</td>
<td align="center">static (during whole session)</td>
</tr>
<tr>
<td align="center">T_int</td>
<td align="center">static (during whole session)</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">static (during whole session)</td>
</tr>
<tr>
<td align="center">N</td>
<td align="center">static (during whole session)</td>
</tr>
<tr>
<td align="center">D^O_t (if present)</td>
<td align="center">static (during whole session)</td>
</tr>
<tr>
<td align="center">PRF Type</td>
<td align="center">static (during whole session)</td>
</tr>
<tr>
<td align="center">MAC Function Type</td>
<td align="center">static (during whole session)</td>
</tr>
<tr>
<td align="center">Signature Encoding Algorithm</td>
<td align="center">static (during whole session)</td>
</tr>
<tr>
<td align="center">Signature Crypto. Function</td>
<td align="center">static (during whole session)</td>
</tr>
<tr>
<td align="center">Signature Length</td>
<td align="center">static (during whole session)</td>
</tr>
<tr>
<td align="center">Group MAC Func. Type</td>
<td align="center">static (during whole session)</td>
</tr>
<tr>
<td align="center">i</td>
<td align="center">dynamic (related to current key chain)</td>
</tr>
<tr>
<td align="center">K_i</td>
<td align="center">dynamic (related to current key chain)</td>
</tr>
<tr>
<td align="center">signature</td>
<td align="center">dynamic, packet dependent</td>
</tr>
<tr>
<td align="center">Group MAC (if present)</td>
<td align="center">dynamic, packet dependent</td>
</tr>
</table>
<br clear="all" />

<a name="sec:direct_synch_response_format"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.2"></a><h3>3.4.2.&nbsp;
Format of a Direct Time Synchronization Response</h3>

<p>
<br /><hr class="insert" />
<a name="fig:direct_synch_response_format"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                                 +-+-+-+-+-+-+-+-+
                                                 |    Reserved   |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 +                     t_s (NTP timestamp)                       +
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 +                     t_r (NTP timestamp)                       +
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 +                                                               +
 ~                           Signature                           ~
 +                                               +-+-+-+-+-+-+-+-+
 |                                               |    Padding    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 ~                     Group MAC (optional)                      ~
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3: Format of a Direct Time Synchronization Response&nbsp;</b></font><br /></td></tr></table><hr class="insert" />



<p>The response to a direct time synchronization request contains the following
information:
</p>
<p>"Reserved" fields (8 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	This is a reserved field that MUST be set to zero in this specification.

</p>
</blockquote>

<p>"t_s" (NTP timestamp, 64 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	t_s is a timestamp in NTP timestamp format that corresponds to the sender local time value when receiving
	the direct time synchronization request message.

</p>
</blockquote>

<p>"t_r" (NTP timestamp, 64 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	t_r is a timestamp in NTP timestamp format that contains the receiver local time value received
	in the direct time synchronization request message.

</p>
</blockquote>

<p>"Signature" field (variable size, padded if necessary for 32 bit word alignment):
</p>
<p></p>
<blockquote class="text">
<p>
	The "Signature" field is mandatory.
	It contains a digital signature of this message, as specified by the
	encoding algorithm, cryptographic function and key length parameters
	communicated in the  bootstrap information message (if applicable) or out-of-band.
	If the signature length is not multiple of 32 bits, this field is padded
	with 0.

</p>
</blockquote>

<p>"Group MAC" field (optional, variable length, multiple of 32 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	This field contains the Group MAC, calculated with the group key, K_g,
	shared by all group members.
	The field length, in bits, is given by n_w, which is known once the
	group MAC function type is known (<a class='info' href='#sec:iana'>Section&nbsp;7<span> (</span><span class='info'>IANA Considerations</span><span>)</span></a>).

</p>
</blockquote>

<a name="sec:auth_tag_format"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.3"></a><h3>3.4.3.&nbsp;
Format of a Standard Authentication Tag</h3>

<p>
<br /><hr class="insert" />
<a name="fig:authentication_tag"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                                 +-+-+-+-+-+-+-+-+
                                                 |   Reserved    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                i (Interval Index of K'_i)                     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 ~                    Disclosed Key K_{i-d}                      ~
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 ~                       MAC(K'_i, M)            +-+-+-+-+-+-+-+-+
 |                                               |   Padding     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 ~                     Group MAC (optional)                      ~
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4: Format of the  Standard Authentication Tag&nbsp;</b></font><br /></td></tr></table><hr class="insert" />



<p>
<a class='info' href='#fig:authentication_tag'>Figure&nbsp;4<span> (</span><span class='info'>Format of the  Standard Authentication Tag</span><span>)</span></a> shows the format of the Standard Authentication Tag:
</p>
<p>"Reserved" field (8 bits):
</p>
<p></p>
<blockquote class="text">
<p>
 	The "Reserved" field is not used in the current specification
	and MUST be set to zero by the sender.

</p>
</blockquote>

<p>"i" (Interval Index) field (32 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	i is the interval index associated to the key (K'_i) used to compute
	the MAC of this packet.

</p>
</blockquote>

<p>"Disclosed Key" (variable size, non padded):
</p>
<p></p>
<blockquote class="text">
<p>
	The "Disclosed Key" is the key used for interval i-d: K_{i-d}.
	There is no padding between the "Disclosed Key" and "MAC(K'_i, M)"
	fields, and the latter MAY not start on a 32 bit boundary,
	depending on the n_p parameter.

</p>
</blockquote>

<p>"MAC(K'_i, M)" (variable size, padded if necessary for 32 bit word alignment):
</p>
<p></p>
<blockquote class="text">
<p>
	MAC(K'_i, M) is the truncated message authentication code of the current packet.
	Only the n_m most significant bits of the MAC output are kept <a class='info' href='#RFC2104'>[RFC2104]<span> (</span><span class='info'>Krawczyk, H., Bellare, M., and R. Canetti, &ldquo;HMAC: Keyed-Hashing for Message Authentication,&rdquo; February&nbsp;1997.</span><span>)</span></a>.

</p>
</blockquote>

<p>"Group MAC" field (optional, variable length, multiple of 32 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	This field contains the Group MAC, calculated with a group key, K_g, shared
	by all group members.
	The field length is given by n_w, in bits.

</p>
</blockquote>

<p>
Note that because a key cannot be disclosed before the disclosure delay, d,
the sender MUST NOT use this tag during the first d intervals of the session:
{0 .. d-1} (inclusive).
Instead the sender MUST use an Authentication Tag Without Key Disclosure.

</p>
<a name="sec:auth_tag_wo_key_discl_format"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.4"></a><h3>3.4.4.&nbsp;
Format of an Authentication Tag Without Key Disclosure</h3>

<p>
The authentication tag without key disclosure is meant to be used in situations where a
high number of packets are sent in a given time interval.
In such a case, it can be advantageous to disclose the K_{i-d} key only in a subset of the
packets sent, using a Standard Authentication Tag, and use the shortened version that
does not disclose the K_{i-d} key in the remaining packets.
It is left to the implementer to decide how many packets should disclose the K_{i-d}
key.
This Authentication Tag Without Key Disclosure MUST also be used during the first
d intervals: {0 .. d-1} (inclusive).

</p>
<p>
<br /><hr class="insert" />
<a name="fig:authentication_tag_wo_key_discl"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                                 +-+-+-+-+-+-+-+-+
                                                 |   Reserved    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                i (Interval Index of K'_i)                     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 ~                       MAC(K'_i, M)            +-+-+-+-+-+-+-+-+
 |                                               |   Padding     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 ~                     Group MAC (optional)                      ~
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5: Format of the Authentication Tag Without Key Disclosure&nbsp;</b></font><br /></td></tr></table><hr class="insert" />



<a name="sec:auth_tag_format_new_kcc"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.5"></a><h3>3.4.5.&nbsp;
Format of an Authentication Tag with a ``New Key Chain'' Commitment</h3>

<p>
During the last n_tx_newkcc intervals of the current key chain, the sender
SHOULD send commitments to the next key chain.
This is done by replacing the disclosed key of the 
authentication tag with the new key chain commitment, F(K_{N+1})
(or F(K_{2N+2}) in case of a switch between the second and third key chains, etc.).
<a class='info' href='#fig:new_comm_tag'>Figure&nbsp;6<span> (</span><span class='info'>Format of the Authentication Tag with a New         Key Chain Commitment</span><span>)</span></a> shows the corresponding format.

</p>
<p>
Note that since there is no padding between the "F(K_{N+1})" and "MAC(K'_i, M)"
fields, this latter MAY not start on a 32 bit boundary,
depending on the n_p parameter.

</p>
<p>
<br /><hr class="insert" />
<a name="fig:new_comm_tag"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                                 +-+-+-+-+-+-+-+-+
                                                 |   Reserved    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                i (Interval Index of K'_i)                     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 ~              New Key Commitment F(K_{N+1})                    ~
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 ~                       MAC(K'_i, M)            +-+-+-+-+-+-+-+-+
 |                                               |   Padding     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 ~                     Group MAC (optional)                      ~
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6: Format of the Authentication Tag with a New
        Key Chain Commitment&nbsp;</b></font><br /></td></tr></table><hr class="insert" />



<a name="sec:auth_tag_format_old_kck"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.4.6"></a><h3>3.4.6.&nbsp;
Format of an Authentication Tag with a ``Last Key of Old Chain'' Disclosure</h3>

<p>
During the first n_tx_lastkey intervals of the new key chain after
the disclosing interval, d, the sender SHOULD disclose the last key
of the old key chain.
This is done by replacing the disclosed key of the 
authentication tag with the last key of the old chain, K_N
(or K_{2N+1} in case of a switch between the second and third key chains, etc.).
<a class='info' href='#fig:old_comm_tag'>Figure&nbsp;7<span> (</span><span class='info'>Format of the authentication tag with an old chain last key disclosure</span><span>)</span></a> shows the corresponding format.

</p>
<p>
Note that since there is no padding between the "K_N" and "MAC(K'_i, M)"
fields, this latter MAY not start on a 32 bit boundary,
depending on the n_p parameter.

</p>
<p>
<br /><hr class="insert" />
<a name="fig:old_comm_tag"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                                                 +-+-+-+-+-+-+-+-+
                                                 |   Reserved    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                i (Interval Index of K'_i)                     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 ~                  Last Key of Old Chain, K_N                   ~
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 ~                       MAC(K'_i, M)            +-+-+-+-+-+-+-+-+
 |                                               |   Padding     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 ~                     Group MAC (optional)                      ~
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7: Format of the authentication tag with an old chain
last key disclosure&nbsp;</b></font><br /></td></tr></table><hr class="insert" />



<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Receiver Operations</h3>

<p>
This section describes the TESLA operations at a receiver.

</p>
<a name="sec:verif_auth_info"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Verification of the Authentication Information</h3>

<p>
This section details the computation steps required to verify
each of the three possible authentication information of an
incoming packet.
The verification MUST follow a strict order:
</p>
<ul class="text">
<li>first of all, if the Group MAC is present and if the session uses this feature
	(e.g., if the G bit is set in the bootstrap information message), then verify
	the Group MAC.
	A packet that does not contain a Group MAC tag whereas the session uses
	this feature MUST be immediately dropped.
	On the opposite, if a packet contains a Group MAC tag whereas the session does
	not use this feature, this tag MUST be ignored;
</li>
<li>then verify the digital signature (with TESLA signaling
	packets) or enter the TESLA authentication process
	(with data packets)
</li>
</ul><p>

</p>
<a name="sec:verif_group_mac"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.1"></a><h3>4.1.1.&nbsp;
Processing the Group MAC Tag</h3>

<p>
Upon receiving a packet containing a Group MAC Tag, the receiver
recomputes the Group MAC and compares it to the value carried in the packet.
If the check fails, the packet MUST be immediately dropped.

</p>
<p>
More specifically, recomputing the Group MAC requires to save the
value of the Group MAC field, to set this field to 0, and to do
the same computation as a sender does (see <a class='info' href='#sec:group_auth_tag'>Section&nbsp;3.3.3<span> (</span><span class='info'>Group MAC Tags</span><span>)</span></a>).

</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.2"></a><h3>4.1.2.&nbsp;
Processing the Digital Signature</h3>

<p>
Upon receiving a packet containing a digital signature, the receiver
verifies the signature as follows.

</p>
<p>
The computation of the signature MUST include the ALC or NORM header (with the
various header extensions) and the payload when applicable.
The UDP/IP headers MUST NOT be included.
During this computation, the "Signature" field MUST be set to 0 as well as
the optional Group MAC, when present.

</p>
<p>
From <a class='info' href='#RFC4359'>[RFC4359]<span> (</span><span class='info'>Weis, B., &ldquo;The Use of RSA/SHA-1 Signatures within Encapsulating Security Payload (ESP) and Authentication Header (AH),&rdquo; January&nbsp;2006.</span><span>)</span></a>:
Digital signature verification is performed as described in
<a class='info' href='#RFC3447'>[RFC3447]<span> (</span><span class='info'>Jonsson, J. and B. Kaliski, &ldquo;Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1,&rdquo; February&nbsp;2003.</span><span>)</span></a>, Section 8.2.2 (RSASSA-PKCS1-v1_5) and
<a class='info' href='#RFC3447'>[RFC3447]<span> (</span><span class='info'>Jonsson, J. and B. Kaliski, &ldquo;Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1,&rdquo; February&nbsp;2003.</span><span>)</span></a>, Section 8.1.2 (RSASSA-PSS).
Upon receipt, the digital signature is passed to the
verification function as S.
The authenticated portion of the packet is used as the message M,
and the RSA public key is passed as (n, e).
In summary (when SHA-256 is used), the verification function computes a SHA-256
hash of the authenticated packet bytes, decrypts the SHA-256 hash in
the packet, and validates that the appropriate encoding was applied.

The two SHA-256 hashes are compared, and if they are identical the
validation is successful.

</p>
<p>
It is assumed that the receivers have the possibility
to retrieve the sender's public key required to check this digital signature
(<a class='info' href='#sec:intro_to_bootstrap'>Section&nbsp;2.2<span> (</span><span class='info'>Bootstrapping TESLA</span><span>)</span></a>).
This document does not specify how the public key of the sender is
communicated reliably and in a secure way to all possible receivers.

</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1.3"></a><h3>4.1.3.&nbsp;
Processing the Authentication Tag</h3>

<p>
When a receiver wants to authenticate a packet using an Authentication Tag and
when he has the key for the associated time interval (i.e., after the disclosing
delay, d), the receiver recomputes the MAC and compares it to the value carried
in the packet.
If the check fails, the packet MUST be immediately dropped.

</p>
<p>
More specifically, recomputing the MAC requires to save the
value of the MAC field, to set this field to 0, and to do
the same computation as a sender does (see <a class='info' href='#sec:auth_tag'>Section&nbsp;3.3.1<span> (</span><span class='info'>Authentication Tags</span><span>)</span></a>).

</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Initialization of a Receiver</h3>

<p>
A receiver MUST be initialized before being able to authenticate the source
of incoming packets.
This can be done by an out-of-band mechanism or an in-band mechanism
(<a class='info' href='#sec:intro_to_bootstrap'>Section&nbsp;2.2<span> (</span><span class='info'>Bootstrapping TESLA</span><span>)</span></a>).
Let us focus on the in-band mechanism.
Two actions must be performed:
</p>
<ul class="text">
<li>receive and process a bootstrap information message, and
</li>
<li>calculate an  upper bound of the sender's local time. 
	To that purpose, the receiver must perform time synchronization.
</li>
</ul><p>

</p>
<a name="sec:recv_process_bootstrap"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
Processing the Bootstrap Information Message</h3>

<p>
A receiver must first receive a packet containing the bootstrap
information, digitally signed by the sender.
Once the bootstrap information has been authenticated (sec
<a class='info' href='#sec:verif_auth_info'>Section&nbsp;4.1<span> (</span><span class='info'>Verification of the Authentication Information</span><span>)</span></a>), the receiver can initialize its TESLA
component.
The receiver MUST then ignore the following bootstrap information messages,
if any.
There is an exception though: when a new key chain is used and if a receiver
missed all the commitments for this new key chain, then this receiver
MUST process one of the future Bootstrap information messages (if any) in
order to be able to authenticate the incoming packets associated to this
new key chain.

</p>
<p>
Before TESLA has been initialized, a receiver MUST discard incoming packets
other than the bootstrap information message and direct time synchronization response.


</p>
<a name="sec:rx_time_synchro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
Performing Time Synchronization</h3>

<p>
First of all, the receiver must know whether the ALC or NORM session
relies on direct or indirect time synchronization.
This information is communicated by an out-of-band mechanism (for instance when
describing the various parameters of an ALC or NORM session.
In some cases, both mechanisms might be available and the receiver can choose
the preferred technique.

</p>
<a name="sec:direct_synch_request_format"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2.1"></a><h3>4.2.2.1.&nbsp;
Direct Time Synchronization</h3>

<p>
In case of a direct time synchronization, a receiver MUST synchronize
with the sender.
To that purpose, the receiver sends a direct time synchronization request message.
This message includes the local time (in NTP timestamp format) at the receiver when sending
the message.
This timestamp will be copied in the sender's response for the receiver to
associate the response to the request.

</p>
<p>
The direct time synchronization request message format is the following:

</p>
<p>
<br /><hr class="insert" />
<a name="fig:direct_synch_request_format"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 +                     t_r (NTP timestamp)                       +
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 ~                     Group MAC (optional)                      ~
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;8: Format of a Direct Time Synchronization Request&nbsp;</b></font><br /></td></tr></table><hr class="insert" />



<p>The direct time synchronization request (<a class='info' href='#fig:direct_synch_request_format'>Figure&nbsp;8<span> (</span><span class='info'>Format of a Direct Time Synchronization Request</span><span>)</span></a>)
contains the following information:
</p>
<p>"t_r" (NTP timestamp, 64 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	t_r is a timestamp in NTP timestamp format that contains the receiver local time value when
	sending this direct time synchronization request message;

</p>
</blockquote>

<p>"Group MAC" field (optional, variable length, multiple of 32 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	This field contains the Group MAC, calculated with the group key, K_g, shared
	by all group members.
	The field length, in bits, is given by n_w, which is known once the Group MAC
	function type is known (Section 7).

</p>
</blockquote>

<p>

The receiver then awaits a response message (<a class='info' href='#sec:direct_synch_response_format'>Section&nbsp;3.4.2<span> (</span><span class='info'>Format of a Direct Time Synchronization Response</span><span>)</span></a>).
Upon receiving this message, the receiver:
</p>
<blockquote class="text">
<p>	checks that this response relates to the request, by comparing the t_r fields;
</p>
<p>	checks the Group MAC if present;
</p>
<p>	checks the signature;
</p>
<p>	retrieves the t_s value and calculates D_t
	(<a class='info' href='#sec:delay_bound_calc_direct_sync'>Section&nbsp;2.4.1<span> (</span><span class='info'>Delay Bound Calculation in Direct Time Synchronization Mode</span><span>)</span></a>);
</p>
</blockquote><p>

</p>
<p>
Note that in an ALC session, the direct time synchronization request message
is sent to the sender by an out-of-band mechanism that is not specified by
the current document.

</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2.2"></a><h3>4.2.2.2.&nbsp;
Indirect Time Synchronization</h3>

<p>
With the indirect time synchronization method, the sender MAY provide out-of-band
the URL or IP address of the NTP server(s) he trusts along with an OPTIONAL certificate
for each NTP server.
When several NTP servers are specified, a receiver MUST choose one of them.
This document does not specify how the choice is made, but for the sake
of scalability, the clients SHOULD NOT use the same server if several
possibilities are offered.
The NTP synchronization between the NTP server and the receiver
MUST be authenticated, either using the certificate provided by the server,
or another certificate the client may obtain for this NTP server.

</p>
<p>
Then the receiver computes the time offset between itself and the NTP
server chosen. 
Note that the receiver does not need to update the local time, 
(which often requires root privileges), computing the
time offset is sufficient.

</p>
<p>
Since the offset between the server and the time reference, D^O_t, is indicated
in the bootstrap information message (or communicated out-of-band), the receiver
can now calculate an upper bound of the sender's local time
(<a class='info' href='#sec:delay_bound_calc_indirect_sync'>Section&nbsp;2.4.2<span> (</span><span class='info'>Delay Bound Calculation in Indirect time Synchronization Mode</span><span>)</span></a>).

</p>
<p>
Note that this scenario assumes that each client trusts the sender and accepts to
align its NTP configuration to that of the sender, using one of the NTP server(s)
suggested. If this assumption does not hold, the client MUST NOT use the NTP indirect
time synchronization method (<a class='info' href='#sec:intro_to_indirect_time_sync'>Section&nbsp;2.3.2<span> (</span><span class='info'>Indirect Time Synchronization</span><span>)</span></a>).

</p>
<a name="sec:auth_received_pkts_guidelines"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Authentication of Received Packets</h3>

<p>
The receiver can now authenticate incoming packets (other than bootstrap information and
direct time synchronization response packets).
To that purpose, he MUST follow different steps (see <a class='info' href='#RFC4082'>[RFC4082]<span> (</span><span class='info'>Perrig, A., Song, D., Canetti, R., Tygar, J., and B. Briscoe, &ldquo;Timed Efficient Stream Loss-Tolerant Authentication (TESLA):           Multicast Source Authentication Transform Introduction,&rdquo; June&nbsp;2005.</span><span>)</span></a> section 3.5):
</p>
<ol class="text">
<li>The receiver parses the different packet headers.
	If none of the four TESLA authentication tags is present, the receiver MUST
	discard the packet.
	If the session is in "Single Key Chain" mode (e.g., when the "S" flag is set
	in the bootstrap information message), then the receiver MUST discard
	any packet containing an Authentication Tag With a New Key Chain Commitment
	or an Authentication Tag With a Last Key of Old Chain Disclosure.

</li>
<li> Safe packet test:
	When the receiver receives packet P_j, it first records the
	local time T at which the packet arrived.
	The receiver then computes an upper bound t_j on the sender's
        clock at the time when the packet arrived: t_j = T + D_t.
	The receiver then computes the highest interval the sender
	could possibly be in: highest_i = floor((t_j - T_0) / T_int).

	He also retrieves the "i" interval index from the
	authentication tag.
	The receiver can now proceed with the "safe packet" test.
	If highest_i < i + d, then the sender is not yet in the interval
	during which it discloses the key K_i. The packet is safe (but
	not necessarily authentic).
	If the test fails, the packet is unsafe, and the receiver MUST
	discard the packet.

</li>
<li> Group MAC test: if the optional Group MAC tag is present and if the
	session uses this feature, then verify the Group MAC
	(<a class='info' href='#sec:verif_group_mac'>Section&nbsp;4.1.1<span> (</span><span class='info'>Processing the Group MAC Tag</span><span>)</span></a>).
	If the verification fails, the packet MUST be immediately dropped.
	A packet that does not contain a Group MAC tag whereas the session uses
	this feature MUST be immediately dropped.
	On the opposite, if a packet contains a Group MAC tag whereas the session does
	not use this feature, this tag MUST be ignored.

</li>
<li> Disclosed Key processing:
	When the packet discloses a key (i.e., with a Standard Authentication Tag, or
	with an Authentication Tag with a ``Last Key of Old Chain'' Disclosure),
	the following tests are performed:
	
<ul class="text">
<li> New key index test: the receiver checks whether a legitimate key 
		already exists with the same index (i.e., i-d).
		
		If such a legitimate key exists, the receiver compares its
		value with the current disclosed key and if they are identical,
		skips the "Unverifiable key test" and "Key verification test".
		If such a legitimate key exists but the values differ, the
		receiver MUST discard the packet.
	
</li>
<li> Unverifiable key test: when the disclosed key index is new, it is
		possible that no earlier disclosed and legitimate key exists
		for this key chain, thereby preventing the verification of the
		disclosed key.
		This happens when the disclosed key belongs to the old
		key chain and no commitment to this old key chain has
		ever been received (e.g., because the first bootstrap packet
		received by a latecomer is for the current key chain, and
		therefore includes a commitment to the current key chain, not
		the previous one).
		
		When this happens, the receiver MUST ignore the disclosed key
		(anyway useless) and skip the "Key verification test".
	
</li>
<li> Key verification test: If the disclosed key index is new and the
		key can be verified, the receiver checks the legitimacy of
		K_{i-d} by verifying, for some earlier disclosed and legitimate
		key K_v (with v < i-d), that K_v and F^{i-d-v}(K_{i-d}) are identical.
		In other words, the receiver checks the disclosed key by
		computing the necessary number of PRF functions to obtain a
		previously disclosed and legitimate (i.e., verified) key.

		If the key verification fails, the receiver MUST discard the packet.
		If the key verification succeeds, this key is said legitimate and
		is stored by the receiver, as well as all the keys between indexes
		v and i-d.
	
</li>
</ul>
	
</li>
<li>When applicable, the receiver performs any congestion control related action
	(i.e., the ALC or NORM headers are used by the associated congestion control
	building block, if any), even if the packet has not yet been
	authenticated <a class='info' href='#RFC5651'>[RFC5651]<span> (</span><span class='info'>Luby, M., Watson, M., and L. Vicisano, &ldquo;Layered Coding Transport (LCT) Building Block,&rdquo; October&nbsp;2009.</span><span>)</span></a>.
	If this feature leads to a potential DoS attack (the attacker can send
	a faked packet with a wrong sequence number to simulate packet losses),
	it does not compromise the security features offered by TESLA and enables
	a rapid reaction in front of actual congestion problems.

</li>
<li>The receiver then buffers the packet for a later authentication, once the corresponding
	key will be disclosed (after d time intervals) or deduced from another key
	(if all packets disclosing this key are lost).
	In some situations, this packet might also be discarded later on, if
	it turns out that the receiver will never be able to deduce the associated key.

</li>
<li>Authentication test:
	Let v be the smallest index of the legitimate keys known by the receiver
	so far. For all the new keys K_w, with v < w &le; i-d, that have been
	either disclosed by this packet (i.e., K_{i-d}) or derived by K_{i-d}
	(i.e., keys in interval {v+1,.. i-d-1}), the receiver verifies the
	authenticity of the safe packets buffered for the corresponding
	interval w.

	To authenticate one of the buffered packets P_h containing
	message M_h protected with a MAC that used key index w, the
	receiver will compute K'_w = F'(K_w) from which it can
	compute MAC( K'_w, M_h).

	If this MAC does not equal the MAC stored in the packet, the receiver
	MUST discard the packet.

	If the two MAC are equal, the packet is successfully authenticated and the
	receiver continues processing it.

</li>
<li>Authenticated new key chain commitment processing:
	If the authenticated packet contains a new key chain commitment and if
	no verified commitment already exists, then the receiver stores the
	commitment to the new key chain.
	Then, if there are non authenticated packets for a previous chain
	(i.e., the key chain before the current one), all these packets can be
	discarded (<a class='info' href='#sec:flushing_pkts_of_prev_key_chain'>Section&nbsp;4.4<span> (</span><span class='info'>Flushing the Non Authenticated Packets of a Previous Key Chain</span><span>)</span></a>).

</li>
<li>The receiver continues the ALC or NORM processing of all the packets
	authenticated during the authentication test.

</li>
</ol>

<p>
In this specification, a receiver using TESLA MUST immediately drop unsafe packets.
But the receiver MAY also decide, at any time, to continue an ALC or NORM session in
unsafe (insecure) mode, ignoring TESLA extensions. There SHOULD be an explicit
user action to that purpose.

</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.1"></a><h3>4.3.1.&nbsp;
Discarding Unnecessary Packets Earlier</h3>

<p>
Following strictly the above steps can lead to excessive processing overhead
in certain situations.
This is the case when a receiver receives packets for an unwanted object with
the ALC or NORM protocols, i.e., an object for which the application (or the
end user) explicitly mentioned it is not interested in.
This is also the case when a receiver receives packets for an already decoded
object, or when this object has been partitioned in several blocks, for an
already decoded block.
When such a packet is received, which is easily identified by looking at the
receiver's status for the incoming ALC or NORM packet, the receiver MUST also
check that the packet is a pure data packet that does not contain any signaling
information of importance for the session.

</p>
<p>
With ALC, a packet containing a "A" flag ("Close Session") or a "B" flag
("Close Object") MUST NOT be discarded before having been authenticated
and processed normally.
Otherwise, the receiver can safely discard the incoming packet for instance
just after step 1 of <a class='info' href='#sec:auth_received_pkts_guidelines'>Section&nbsp;4.3<span> (</span><span class='info'>Authentication of Received Packets</span><span>)</span></a>.
This optimization can dramatically reduce the processing overhead, by
avoiding many useless authentication checks.

</p>
<a name="sec:flushing_pkts_of_prev_key_chain"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Flushing the Non Authenticated Packets of a Previous Key Chain</h3>

<p>
In some cases a receiver having experienced a very long disconnection might
have lost all the disclosures of the last key(s) of a previous key chain.
Let j be the index of this key chain for which there remains non authenticated
packets.
This receiver can flush all the packets of the key chain j if he determines that:
</p>
<ul class="text">
<li>he has just switched to a chain of index j+2 (inclusive) or higher; 
</li>
<li>the sender has sent a commitment to the new key chain of index j+2
	(<a class='info' href='#sec:value_of_tx_lastkey_tx_newkcc'>Section&nbsp;3.1.2.3<span> (</span><span class='info'>Values of the n_tx_lastkey and n_tx_newkcc Parameters</span><span>)</span></a>).
	This situation requires that the receiver has received a packet containing
	such a commitment and that he has been able to check its integrity.
	In some cases it might require to receive a bootstrap information message
	for the current key chain.
</li>
</ul><p>
If one of the above two tests succeeds, the sender can discard all the awaiting
packets since there is no way to authenticate them.

</p>
<a name="sec:alc_norm_integration"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Integration in the ALC and NORM Protocols</h3>

<a name="sec:auth_he_format"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Authentication Header Extension Format</h3>

<p>
The integration of TESLA in ALC or NORM is similar and relies on the 
header extension mechanism defined in both protocols.
More precisely this document details the EXT_AUTH==1 header extension defined
in <a class='info' href='#RFC5651'>[RFC5651]<span> (</span><span class='info'>Luby, M., Watson, M., and L. Vicisano, &ldquo;Layered Coding Transport (LCT) Building Block,&rdquo; October&nbsp;2009.</span><span>)</span></a>.

</p>
<p>
Several fields are added in addition to the HET (Header Extension Type) and HEL
(Header Extension Length) fields (<a class='info' href='#lct_integration'>Figure&nbsp;9<span> (</span><span class='info'>Format of the TESLA EXT_AUTH header extension.</span><span>)</span></a>).

</p>
<p>
<br /><hr class="insert" />
<a name="lct_integration"></a>
</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   HET (=1)    |      HEL      |  ASID |  Type |               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+               +
 |                                                               |
 ~                                                               ~
 |                            Content                            |
 ~                                                               ~
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><p>
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;9: Format of the TESLA EXT_AUTH header extension.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />


</p>
<p>
The fields of the TESLA EXT_AUTH header extension are:
</p>
<p>"ASID" (Authentication Scheme IDentifier) field (4 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	The "ASID" identifies the source authentication scheme or protocol
	in use.
	The association between the "ASID" value and the actual authentication
	scheme is defined out-of-band, at session startup.

</p>
</blockquote>

<p>"Type" field (4 bits):
</p>
<p></p>
<blockquote class="text">
<p>
	The "Type" field identifies the type of TESLA information carried
	in this header extension.
	This specification defines the following types:
	</p>
<ul class="text">
<li>0: Bootstrap Information, sent by the sender periodically
		or after a direct time synchronization request;
</li>
<li>1: Standard Authentication Tag for the on-going key chain, sent by
		the sender along with a packet;
</li>
<li>2: Authentication Tag Without Key Disclosure, sent by
		the sender along with a packet;
</li>
<li>3: Authentication Tag with a New Key Chain Commitment,
		sent by the sender when approaching the end of a key chain;
</li>
<li>4: Authentication Tag with a Last Key of Old Chain Disclosure,
		sent by the sender some time after moving to a new key chain;
</li>
<li>5: Direct Time Synchronization Request, sent by a NORM receiver.
		This type of message is invalid in case of an ALC session
		since ALC is restricted to unidirectional transmissions.
		Yet an external mechanism may provide the direct time
		synchronization functionality;
</li>
<li>6: Direct Time Synchronization Response, sent by a NORM sender.
		This type of message is invalid in case of an ALC session
		since ALC is restricted to unidirectional transmissions.
		Yet an external mechanism may provide the direct time
		synchronization functionality;
</li>
</ul>


</blockquote>

<p>"Content" field (variable length):
</p>
<p></p>
<blockquote class="text">
<p>
	This is the TESLA information carried in the header extension, whose
	type is given by the "Type" field.

</p>
</blockquote>

<a name="sec:auth_he_use"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Use of Authentication Header Extensions</h3>

<p>
Each packet sent by the session's sender MUST contain exactly one
TESLA EXT_AUTH header extension.

</p>
<p>
All receivers MUST recognize EXT_AUTH but MAY not be able to parse its content,
for instance because they do not support TESLA.
In that case these receivers MUST ignore the TESLA EXT_AUTH extensions.
In case of NORM, the packets sent by receivers MAY contain a direct
synchronization request but MUST NOT contain any of the other five
TESLA EXT_AUTH header extensions.

</p>
<a name="sec:auth_he_use_bootstrap"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.1"></a><h3>5.2.1.&nbsp;
EXT_AUTH Header Extension of Type Bootstrap Information</h3>

<p>
The "bootstrap information" TESLA EXT_AUTH (Type==0) MUST be sent in
a stand-alone control packet, rather than in a packet containing application data.
The reason for that is the large size of this bootstrap information.
By using stand-alone packets, the maximum payload size of data packets is only
affected by the (mandatory) authentication information header extension.

</p>
<p>
With ALC, the "bootstrap information" TESLA EXT_AUTH MUST be sent in a
control packet, i.e., containing no encoding symbol.

</p>
<p>
With NORM, the "bootstrap information" TESLA EXT_AUTH MUST be sent in a
NORM_CMD(APPLICATION) message.

</p>
<p>
<br /><hr class="insert" />
<a name="fig:bootstrap_with_1024b_sig"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  ---
|   HET (=1)    |    HEL (=46)  |  ASID |   0   | 0 |  0  |0|1|0|  ^
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |
|       d       |       2       |       2       |       2       |  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |
|       1       |       3       |              128              |  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |
|         0 (reserved)          |             T_int             |  |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |
|                                                               |  |
+                  T_0 (NTP timestamp format)                   +  | 5
|                                                               |  | 2
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |
|                      N (Key Chain Length)                     |  | b
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  | y
|                    Current Interval Index i                   |  | t
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  | e
|                                                               |  | s
+                                                               +  |
|                                                               |  |
+                 Current Key Chain Commitment                  +  |
|                          (20 bytes)                           |  |
+                                                               +  |
|                                                               |  |
+                                                               +  |
|                                                               |  v
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  ---
|                                                               |  ^ 1
+                                                               +  | 2
|                                                               |  | 8
.                                                               .  |
.                           Signature                           .  | b
.                          (128 bytes)                          .  | y
|                                                               |  | t
+                                                               +  | e
|                                                               |  v s
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  ---
|                           Group MAC                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;10: Example: Format of the bootstrap information message (Type 0),
		using SHA-256/1024 bit signatures, the default HMAC-SHA-256 and a Group MAC.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />



<p>
For instance <a class='info' href='#fig:bootstrap_with_1024b_sig'>Figure&nbsp;10<span> (</span><span class='info'>Example: Format of the bootstrap information message (Type 0), 		using SHA-256/1024 bit signatures, the default HMAC-SHA-256 and a Group MAC.</span><span>)</span></a> shows the bootstrap information
message when using the HMAC-SHA-256 transform for the PRF, MAC, and Group MAC functions,
along with SHA-256/128 byte (1024 bit) key digital signatures (which also means that the signature
field is 128 byte long).
The TESLA EXT_AUTH header extension is then 184 byte long (i.e., 46 words of 32 bits).

</p>
<a name="sec:auth_he_use_auth_info"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.2"></a><h3>5.2.2.&nbsp;
EXT_AUTH Header Extension of Type Authentication Tag</h3>

<p>
The four "authentication tag" TESLA EXT_AUTH (Type 1, 2, 3, and 4)
MUST be attached to the ALC or NORM packet (data or control packet) that
they protect.

</p>
<p>
<br /><hr class="insert" />
<a name="fig:example_authentication_tag"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   HET (=1)    |   HEL (=10)   |  ASID |   1   |   Reserved    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                i (Interval Index of K'_i)                     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 +                                                               +
 |                                                               |
 +                     Disclosed Key K_{i-d}                     +
 |                          (20 bytes)                           |
 +                                                               +
 |                                                               |
 +                                                               +
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 +                                                               +
 |                         MAC(K'_i, M)                          |
 +                          (16 bytes)                           +
 |                                                               |
 +                                                               +
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;11: Example: Format of the Standard Authentication Tag (Type 1), using the default HMAC-SHA-256.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />



<p>
<br /><hr class="insert" />
<a name="fig:example_authentication_tag_wo_key_discl"></a>

<p>
</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  0                   1                   2                   3
  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |   HET (=1)    |   HEL (=5)    |  ASID |   2   |   Reserved    |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                i (Interval Index of K'_i)                     |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 |                                                               |
 +                                                               +
 |                         MAC(K'_i, M)                          |
 +                          (16 bytes)                           +
 |                                                               |
 +                                                               +
 |                                                               |
 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;12: Example: Format of the Authentication Tag Without Key Disclosure (Type 2),
	using the default HMAC-SHA-256.&nbsp;</b></font><br /></td></tr></table><hr class="insert" />



<p>
For instance, <a class='info' href='#fig:example_authentication_tag'>Figure&nbsp;11<span> (</span><span class='info'>Example: Format of the Standard Authentication Tag (Type 1), using the default HMAC-SHA-256.</span><span>)</span></a> and
<a class='info' href='#fig:example_authentication_tag_wo_key_discl'>Figure&nbsp;12<span> (</span><span class='info'>Example: Format of the Authentication Tag Without Key Disclosure (Type 2), 	using the default HMAC-SHA-256.</span><span>)</span></a>
show the format of the authentication tags, respectively with and without
the K_{i-d} key disclosure, when using the (default) HMAC-SHA-256 transform for the PRF
and MAC functions.
In this example, the Group MAC feature is not used.

</p>
<a name="sec:auth_he_use_direct_synch_req"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.3"></a><h3>5.2.3.&nbsp;
EXT_AUTH Header Extension of Type Direct Time Synchronization Request</h3>

<p>
With NORM, the "direct time synchronization request" TESLA EXT_AUTH (Type==7)
MUST be sent by a receiver in a NORM_CMD(APPLICATION) NORM packet.

</p>
<p>
With ALC, the "direct time synchronization request" TESLA EXT_AUTH cannot be
included in an ALC packet, since ALC is restricted to unidirectional
transmissions, from the session's sender to the receivers.
An external mechanism must be used with ALC for carrying direct time synchronization
requests to the session's sender.

</p>
<p>
In case of direct time synchronization, it is RECOMMENDED that the
receivers spread the transmission of direct time synchronization
requests over the time (<a class='info' href='#sec:intro_to_direct_time_sync'>Section&nbsp;2.3.1<span> (</span><span class='info'>Direct Time Synchronization</span><span>)</span></a>).

</p>
<a name="sec:auth_he_use_direct_synch_resp"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2.4"></a><h3>5.2.4.&nbsp;
EXT_AUTH Header Extension of Type Direct Time Synchronization Response</h3>

<p>
With NORM, the "direct time synchronization response" TESLA EXT_AUTH (Type==8)
MUST be sent by the sender in a NORM_CMD(APPLICATION) message.

</p>
<p>
With ALC, the "direct time synchronization response" TESLA EXT_AUTH can be sent
in an ALC control packet (i.e., containing no encoding symbol) or through the 
external mechanism use to carry the direct time synchronization request.

</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Security Considerations</h3>

<p>
<a class='info' href='#RFC4082'>[RFC4082]<span> (</span><span class='info'>Perrig, A., Song, D., Canetti, R., Tygar, J., and B. Briscoe, &ldquo;Timed Efficient Stream Loss-Tolerant Authentication (TESLA):           Multicast Source Authentication Transform Introduction,&rdquo; June&nbsp;2005.</span><span>)</span></a> discusses the security of TESLA in general.
These considerations apply to the present specification, namely:
</p>
<ul class="text">
<li>great care must be taken to the timing aspects. In particular the D_t parameter
	is critical and must be correctly initialized;
</li>
<li>if the sender realizes that the key disclosure schedule is not
	appropriate, then the current session MUST be closed and a new one
	created. Indeed <a class='info' href='#sec:time_int_schedule'>Section&nbsp;3.1.3<span> (</span><span class='info'>Time Interval Schedule</span><span>)</span></a> requires that
	these parameters be fixed during the whole session.
	
</li>
<li>when the verifier that authenticates the incoming packets and the application
	that uses the data are two different components, there is a risk that an
	attacker located between these components inject faked data.
	Similarly, when the verifier and the secure timing system are two
	different components, there is a risk that an attacker located between
	these components inject faked timing information.
	For instance, when the verifier reads the local time by means of a
	dedicated system call (e.g., gettimeofday()), if an attacker controls
	the host, he may catch the system call and return a faked time information.
	
</li>
</ul><p> 
The current specification discusses additional aspects with more details.

</p>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Dealing With DoS Attacks</h3>

<p>
TESLA introduces new opportunities for an attacker to mount DoS attacks.
For instance an attacker can try to saturate the processing
capabilities of the receiver (faked packets are easy to create but checking
them requires to compute a MAC over the packet or sometimes check a digital
signature as with the bootstrap and direct time synchronization response messages).
An attacker can also try to saturate the receiver's memory (since authentication
is delayed and non-authenticated packets will accumulate), or to make the receiver
believe that a congestion has happened (since congestion control MUST be performed
before authenticating incoming packets, <a class='info' href='#sec:auth_received_pkts_guidelines'>Section&nbsp;4.3<span> (</span><span class='info'>Authentication of Received Packets</span><span>)</span></a>).

</p>
<p>
In order to mitigate these attacks, it is RECOMMENDED to use the Group MAC
scheme (<a class='info' href='#sec:group_auth_tag'>Section&nbsp;3.3.3<span> (</span><span class='info'>Group MAC Tags</span><span>)</span></a>).
No mitigation is possible if a group member acts as an attacker with Group MAC.

</p>
<p>
Generally, it is RECOMMENDED that the amount of memory used to store
incoming packets waiting to be authenticated be limited to a reasonable
value.

</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Dealing With Replay Attacks</h3>

<p>
Replay attacks, whereby an attacker stores a valid message and replays it later
on, can have significant impacts, depending on the message type.
Two levels of impacts must be distinguished:
</p>
<ul class="text">
<li> within the TESLA protocol, and
</li>
<li> within the ALC or NORM protocol.
</li>
</ul><p>

</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.1"></a><h3>6.2.1.&nbsp;
Impacts of Replay Attacks on TESLA</h3>

<p>
Replay attacks can impact the TESLA component itself.
We review here the potential impacts of such an attack depending on the TESLA message type:
</p>
<ul class="text">
<li> bootstrap information:
		since most parameters contained in a bootstrap information message
		are static, replay attacks have no consequences.
		The fact that the "i" and "K_i" fields can be updated in subsequent
		bootstrap information messages does not create a problem either,
		since all "i" and "K_i" fields sent remain valid.
		Finally, a receiver that successfully initialized its TESLA component
		MUST ignore the following messages (see <a class='info' href='#sec:recv_process_bootstrap'>Section&nbsp;4.2.1<span> (</span><span class='info'>Processing the Bootstrap Information Message</span><span>)</span></a>
		for an exception to this rule),
		which voids replay attacks, unless he missed all the commitments to a new
		key chain (e.g., after a long disconnection) (<a class='info' href='#sec:bootstrap_info'>Section&nbsp;3.2.1<span> (</span><span class='info'>Bootstrap Information</span><span>)</span></a>).
	
</li>
<li> direct time synchronization request:
		If the Group MAC scheme is used, an attacker that is not a member of
		the group can replay a packet and oblige the sender to respond, which
		requires to digitally sign the response, a time-consuming process.
		If the Group MAC scheme is not used, an attacker can anyway easily
		forge a request.
		In both cases, the attack will not compromise the TESLA component, but might
		create a DoS.
		If this is a concern, it is RECOMMENDED, when the Group MAC scheme is used,
		that the sender verify the "t_r" NTP timestamp contained in the request
		and respond only if this value is strictly larger than the previous one
		received from this receiver.
		When the Group MAC scheme is not used, this attack can be mitigated
		by limiting the number of requests per second that will be processed.
	
</li>
<li> direct time synchronization response:
		Upon receiving a response, a receiver who has no pending request
		MUST immediately drop the packet.
		If this receiver has previously issued a request, he first checks
		the Group MAC (if applicable), then the "t_r" field, to be sure
		it is a response to his request, and finally the digital signature.
		A replayed packet will be dropped during these verifications, without
		compromising the TESLA component.
	
</li>
<li> other messages, containing an authentication tag:
		Replaying a packet containing a TESLA authentication tag will never
		compromise the TESLA component itself (but perhaps the underlying
		ALC or NORM component, see below).
	
</li>
</ul><p>
To conclude, TESLA itself is robust in front of replay attacks.

</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.2"></a><h3>6.2.2.&nbsp;
Impacts of Replay Attacks on NORM</h3>

<p>
We review here the potential impacts of a replay attack on the NORM component.
Note that we do not consider here the protocols that could be used along with
NORM, for instance the congestion control protocols.

</p>
<p>
First, let us consider replay attacks within a given NORM session.
NORM defines a "sequence" field that can be used to protect against replay
attacks <a class='info' href='#RMT-PI-NORM'>[RMT&#8209;PI&#8209;NORM]<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol,&rdquo; September&nbsp;2009.</span><span>)</span></a> within a given NORM session.
This "sequence" field is a 16-bit value that is set by the message
originator (sender or receiver) as a monotonically increasing number
incremented with each NORM message transmitted.
It is RECOMMENDED that a receiver check this sequence field and drop messages considered
as replayed.
Similarly, it is RECOMMENDED that a sender check this sequence, for each known receiver,
and drop messages considered as replayed.
In both cases, checking this sequence field SHOULD be done before
TESLA processing of the packet: if the sequence field has not been
corrupted, the replay attack will immediately be identified, and
otherwise the packet will fail the TESLA authentication test.
This analysis shows that NORM itself is robust in front of replay attacks
within the same session.

</p>
<p>
Now let us consider replay attacks across several NORM sessions.
Since the key chain used in each session MUST differ, a packet replayed in a
subsequent session will be identified as unauthentic.
Therefore NORM is robust in front of replay attacks across different sessions.

</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2.3"></a><h3>6.2.3.&nbsp;
Impacts of Replay Attacks on ALC</h3>

<p>
We review here the potential impacts of a replay attack on the ALC component.
Note that we do not consider here the protocols that could be used along with
ALC, for instance the layered or wave based congestion control protocols.

</p>
<p>
First, let us consider replay attacks within a given ALC session:
</p>
<ul class="text">
<li>Regular packets containing an authentication tag: a replayed message
	containing an encoding symbol will be detected once authenticated, thanks to
	the object/block/symbol identifiers, and will be silently discarded.
	This kind of replay attack is only penalizing in terms of memory and
	processing load, but does not compromise the ALC behavior.
	
</li>
<li>Control packets containing an authentication tag:
	ALC control packets, by definition, do not include any encoding symbol
	and therefore do not include any object/block/symbol identifier that would
	enable a receiver to identify duplicates.
	However, a sender has a very limited number of reasons to send control packets.
	More precisely:
	
<ul class="text">
<li>At the end of the session, a "close session" (A flag) packet is sent.
		Replaying this packet has no impact since the receivers already left.
</li>
<li>Similarly, replaying a packet containing a "close object" (B flag)
		has no impact since this object is probably already marked as closed
		by the receiver.
</li>
</ul>
	
</li>
</ul><p>
This analysis shows that ALC itself is robust in front of replay attacks
within the same session.

</p>
<p>
Now let us consider replay attacks across several ALC sessions.
Since the key chain used in each session MUST differ, a packet replayed in a
subsequent session will be identified as unauthentic.
Therefore ALC is robust in front of replay attacks across different sessions.

</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
Security of the Back Channel</h3>

<p>
As specified in <a class='info' href='#scope'>Section&nbsp;1.1<span> (</span><span class='info'>Scope of this Document</span><span>)</span></a>, this specification does not consider
the packets that may be sent by receivers, for instance NORM's feedback packets.
When a back channel is used, its security is critical to the global security,
and an appropriate security mechanism MUST be used.
<a class='info' href='#RMT-SIMPLE-AUTH'>[RMT&#8209;SIMPLE&#8209;AUTH]<span> (</span><span class='info'>Roca, V., &ldquo;Simple Authentication Schemes for the ALC and NORM Protocols,&rdquo; October&nbsp;2009.</span><span>)</span></a> describes several techniques that can be used 
to that purpose.
However, the authentication and integrity verification of the packets sent by receivers
on the back channel, if any, is out of the scope of this document.

</p>
<a name="sec:iana"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
IANA Considerations</h3>

<p>This document requires a IANA registration for the following attributes.
The registries are provided by <a class='info' href='#RFC4442'>[RFC4442]<span> (</span><span class='info'>Fries, S. and H. Tschofenig, &ldquo;Bootstrapping Timed Efficient Stream Loss-Tolerant Authentication (TESLA),&rdquo; March&nbsp;2006.</span><span>)</span></a> under the "Timed Efficient Stream
Loss-tolerant Authentication (TESLA) Parameters" registry <a class='info' href='#TESLA-REG'>[TESLA&#8209;REG]<span> (</span><span class='info'>, &ldquo;TESLA Parameters IANA Registry,&rdquo; .</span><span>)</span></a>.
Following the policies outlined in <a class='info' href='#RFC4442'>[RFC4442]<span> (</span><span class='info'>Fries, S. and H. Tschofenig, &ldquo;Bootstrapping Timed Efficient Stream Loss-Tolerant Authentication (TESLA),&rdquo; March&nbsp;2006.</span><span>)</span></a>, the values in the range
up to 240 (including 240) for the following attributes are assigned after
expert review by the MSEC working group or its designated successor.
The values in the range from 241 to 255 are reserved for private use.

</p>
<p>Cryptographic Pseudo-Random Function, TESLA-PRF:
	All implementations MUST support HMAC-SHA-256 (default).
</p>
<p style='text-align: center'>
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="center"><col align="center">
<tr><th align="center">PRF name</th><th align="center">Value</th></tr>
<tr>
<td align="center">HMAC-SHA-1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">HMAC-SHA-224</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">HMAC-SHA-256 (default)</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">HMAC-SHA-384</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">HMAC-SHA-512</td>
<td align="center">4</td>
</tr>
</table>
<br clear="all" />

<p>Cryptographic Message Authentication Code (MAC) Function, TESLA-MAC:
	All implementations MUST support HMAC-SHA-256 (default).
	These MAC schemes are used both for the computing of regular
	MAC and the Group MAC (if applicable).
</p>
<p style='text-align: center'>
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="center"><col align="center">
<tr><th align="center">MAC name</th><th align="center">Value</th></tr>
<tr>
<td align="center">HMAC-SHA-1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">HMAC-SHA-224</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">HMAC-SHA-256 (default)</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">HMAC-SHA-384</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">HMAC-SHA-512</td>
<td align="center">4</td>
</tr>
</table>
<br clear="all" />

<p>Furthermore, this document requires IANA to create two new registries.
Here also, the values in the range up to 240 (including 240) for the following
attributes are assigned after expert review by the MSEC working group or its
designated successor.
The values in the range from 241 to 255 are reserved for private use.

</p>
<p>Signature Encoding Algorithm, TESLA-SIG-ALGO:
	All implementations MUST support RSASSA-PKCS1-v1_5 (default).
</p>
<p style='text-align: center'>
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="center"><col align="center">
<tr><th align="center">Signature Algorithm Name</th><th align="center">Value</th></tr>
<tr>
<td align="center">INVALID</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">RSASSA-PKCS1-v1_5 (default)</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">RSASSA-PSS</td>
<td align="center">2</td>
</tr>
</table>
<br clear="all" />

<p>Signature Cryptographic Function, TESLA-SIG-CRYPTO-FUNC:
	All implementations MUST support SHA-256 (default).
</p>
<p style='text-align: center'>
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="center"><col align="center">
<tr><th align="center">Cryptographic Function Name</th><th align="center">Value</th></tr>
<tr>
<td align="center">INVALID		</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">SHA-1		</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">SHA-224		</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">SHA-256 (default)	</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">SHA-384		</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">SHA-512		</td>
<td align="center">5</td>
</tr>
</table>
<br clear="all" />

<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Acknowledgments</h3>

<p>
The authors are grateful to Yaron Sheffer, Brian Weis, Ramu Panayappan, Ran Canetti,
David L. Mills, Brian Adamson and Lionel Giraud for their valuable comments while
preparing this document.
The authors are also grateful to Brian Weis for the digital signature details.

</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC1305">[RFC1305]</a></td>
<td class="author-text">Mills, D., &ldquo;<a href="http://tools.ietf.org/html/rfc1305">Network Time Protocol (Version 3) Specification, Implementation</a>,&rdquo; RFC&nbsp;1305, March&nbsp;1992 (<a href="ftp://ftp.isi.edu/in-notes/rfc1305.txt">TXT</a>, <a href="ftp://ftp.isi.edu/in-notes/rfc1305.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text">Bradner, S., &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; RFC&nbsp;2119, BCP&nbsp;14, March&nbsp;1997.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4082">[RFC4082]</a></td>
<td class="author-text">Perrig, A., Song, D., Canetti, R., Tygar, J., and B. Briscoe, &ldquo;<a href="http://tools.ietf.org/html/rfc4082">Timed Efficient Stream Loss-Tolerant Authentication (TESLA):
          Multicast Source Authentication Transform Introduction</a>,&rdquo; RFC&nbsp;4082, June&nbsp;2005 (<a href="ftp://ftp.isi.edu/in-notes/rfc4082.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5651">[RFC5651]</a></td>
<td class="author-text">Luby, M., Watson, M., and L. Vicisano, &ldquo;<a href="http://tools.ietf.org/html/rfc5651">Layered Coding Transport (LCT) Building Block</a>,&rdquo; RFC&nbsp;5651, October&nbsp;2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="RMT-PI-ALC">[RMT-PI-ALC]</a></td>
<td class="author-text">Luby, M., Watson, M., and L. Vicisano, &ldquo;Asynchronous Layered Coding (ALC) Protocol Instantiation,&rdquo; &nbsp;draft-ietf-rmt-pi-alc-revised-09.txt (work in progress), October&nbsp;2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="RMT-PI-NORM">[RMT-PI-NORM]</a></td>
<td class="author-text">Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol,&rdquo; &nbsp;draft-ietf-rmt-pi-norm-revised-14.txt (work in progress), September&nbsp;2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="TESLA-REG">[TESLA-REG]</a></td>
<td class="author-text">&ldquo;TESLA Parameters IANA Registry,&rdquo; &nbsp;http://www.iana.org/assignments/tesla-parameters/.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>9.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="NTP-NTPv4">[NTP-NTPv4]</a></td>
<td class="author-text">Burbank, J., Kasch, W., Martin, J., and D. Mills, &ldquo;The Network Time Protocol Version 4 Protocol Specification,&rdquo; &nbsp;draft-ietf-ntp-ntpv4-proto-11.txt (work in progress), September&nbsp;2008.</td></tr>
<tr><td class="author-text" valign="top"><a name="Perrig04">[Perrig04]</a></td>
<td class="author-text">Perrig, A. and J. Tygar, &ldquo;Secure Broadcast Communication in Wired and Wireless Networks,&rdquo; Kluwer Academic Publishers&nbsp;ISBN 0-7923-7650-1, 2004.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2104">[RFC2104]</a></td>
<td class="author-text">Krawczyk, H., Bellare, M., and R. Canetti, &ldquo;<a href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</a>,&rdquo; RFC&nbsp;2104, February&nbsp;1997 (<a href="ftp://ftp.isi.edu/in-notes/rfc2104.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3447">[RFC3447]</a></td>
<td class="author-text">Jonsson, J. and B. Kaliski, &ldquo;<a href="http://tools.ietf.org/html/rfc3447">Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1</a>,&rdquo; RFC&nbsp;3447, February&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3447.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3711">[RFC3711]</a></td>
<td class="author-text">Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;<a href="http://tools.ietf.org/html/rfc3711">The Secure Real-time Transport Protocol (SRTP)</a>,&rdquo; RFC&nbsp;3711, March&nbsp;2004 (<a href="ftp://ftp.isi.edu/in-notes/rfc3711.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4330">[RFC4330]</a></td>
<td class="author-text">Mills, D., &ldquo;<a href="http://tools.ietf.org/html/rfc4330">Simple Network Time Protocol (SNTP) Version 4 for IPv4, IPv6 and OSI</a>,&rdquo; RFC&nbsp;4330, January&nbsp;2006 (<a href="ftp://ftp.isi.edu/in-notes/rfc4330.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4359">[RFC4359]</a></td>
<td class="author-text">Weis, B., &ldquo;<a href="http://tools.ietf.org/html/rfc4359">The Use of RSA/SHA-1 Signatures within Encapsulating Security Payload (ESP) and Authentication Header (AH)</a>,&rdquo; RFC&nbsp;4359, January&nbsp;2006 (<a href="ftp://ftp.isi.edu/in-notes/rfc4359.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4383">[RFC4383]</a></td>
<td class="author-text">Baugher, M. and E. Carrara, &ldquo;<a href="http://tools.ietf.org/html/rfc4383">The Use of Timed Efficient Stream Loss-Tolerant Authentication (TESLA) in the Secure Real-time Transport Protocol (SRTP)</a>,&rdquo; RFC&nbsp;4383, February&nbsp;2006 (<a href="ftp://ftp.isi.edu/in-notes/rfc4383.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4442">[RFC4442]</a></td>
<td class="author-text">Fries, S. and H. Tschofenig, &ldquo;<a href="http://tools.ietf.org/html/rfc4442">Bootstrapping Timed Efficient Stream Loss-Tolerant Authentication (TESLA)</a>,&rdquo; RFC&nbsp;4442, March&nbsp;2006 (<a href="ftp://ftp.isi.edu/in-notes/rfc4442.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RMT-FLUTE">[RMT-FLUTE]</a></td>
<td class="author-text">Paila, T., Walsh, R., Luby, M., Lehtonen, R., and V. Roca, &ldquo;FLUTE - File Delivery over Unidirectional Transport,&rdquo; &nbsp;draft-ietf-rmt-flute-revised-07.txt (work in progress), August&nbsp;2009.</td></tr>
<tr><td class="author-text" valign="top"><a name="RMT-SIMPLE-AUTH">[RMT-SIMPLE-AUTH]</a></td>
<td class="author-text">Roca, V., &ldquo;Simple Authentication Schemes for the ALC and NORM Protocols,&rdquo; &nbsp;draft-ietf-rmt-simple-auth-for-alc-norm-02.txt (work in progress), October&nbsp;2009.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Vincent Roca</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">INRIA</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">655, av. de l'Europe</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Inovallee; Montbonnot</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">ST ISMIER cedex  38334</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">France</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:vincent.roca@inria.fr">vincent.roca@inria.fr</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://planete.inrialpes.fr/~roca/">http://planete.inrialpes.fr/~roca/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Aurelien Francillon</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">INRIA</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">655, av. de l'Europe</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Inovallee; Montbonnot</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">ST ISMIER cedex  38334</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">France</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:aurelien.francillon@inria.fr">aurelien.francillon@inria.fr</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://planete.inrialpes.fr/~francill/">http://planete.inrialpes.fr/~francill/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Sebastien Faurite</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">INRIA</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">655, av. de l'Europe</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Inovallee; Montbonnot</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">ST ISMIER cedex  38334</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">France</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:faurite@lcpc.fr">faurite@lcpc.fr</a></td></tr>
</table>
</body></html>
