<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>State Machines for Protocol for Carrying Authentication for Network Access (PANA)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="State Machines for Protocol for Carrying Authentication for Network Access (PANA)">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">PANA Working Group</td><td class="header">V. Fajardo, Ed.</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Y. Ohba</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">TARI</td></tr>
<tr><td class="header">Expires: October 22, 2009</td><td class="header">R. Lopez</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Univ. of Murcia</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">April 20, 2009</td></tr>
</table></td></tr></table>
<h1><br />State Machines for Protocol for Carrying Authentication for Network Access (PANA)<br />draft-ietf-pana-statemachine-11</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on October 22, 2009.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>
	This document defines the conceptual state machines for the
	Protocol for Carrying Authentication for Network Access
	(PANA).  The state machines consist of the PANA Client (PaC)
	state machine and the PANA Authentication Agent (PAA) state
	machine.  The two state machines show how PANA can interface
	with the EAP state machines.  The state machines and associated
        model are informative only. Implementations may achieve the
        same results using different methods.
      
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Terminology<br />
<a href="#anchor3">3.</a>&nbsp;
Interface Between PANA and EAP<br />
<a href="#anchor4">4.</a>&nbsp;
Document Authority<br />
<a href="#anchor5">5.</a>&nbsp;
Notations<br />
<a href="#anchor6">6.</a>&nbsp;
Common Rules<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">6.1.</a>&nbsp;
Common Procedures<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">6.2.</a>&nbsp;
Common Variables<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">6.3.</a>&nbsp;
Configurable Values<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor10">6.4.</a>&nbsp;
Common Message Initialization Rules<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">6.5.</a>&nbsp;
Common Retransmition Rules<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">6.6.</a>&nbsp;
Common State Transitions<br />
<a href="#section-pac-statemachine">7.</a>&nbsp;
PaC State Machine<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">7.1.</a>&nbsp;
Interface between PaC and EAP Peer<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor14">7.1.1.</a>&nbsp;
Delivering EAP Messages from PaC to EAP Peer<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor15">7.1.2.</a>&nbsp;
Delivering EAP Messages from EAP Peer to PaC<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor16">7.1.3.</a>&nbsp;
EAP Restart Notification from PaC to EAP Peer<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor17">7.1.4.</a>&nbsp;
EAP Authentication Result Notification from EAP Peer to PaC<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor18">7.1.5.</a>&nbsp;
Alternate Failure Notification from PaC to EAP Peer<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor19">7.2.</a>&nbsp;
Configurable Values<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor20">7.3.</a>&nbsp;
Variables<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">7.4.</a>&nbsp;
Procedures<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">7.5.</a>&nbsp;
PaC State Transition Table<br />
<a href="#section-paa-statemachine">8.</a>&nbsp;
PAA State Machine<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">8.1.</a>&nbsp;
Interface between PAA and EAP Authenticator<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">8.1.1.</a>&nbsp;
EAP Restart Notification from PAA to EAP Authenticator<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">8.1.2.</a>&nbsp;
Delivering EAP Responses from PAA to EAP Authenticator<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">8.1.3.</a>&nbsp;
Delivering EAP Messages from EAP Authenticator to PAA<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">8.1.4.</a>&nbsp;
EAP Authentication Result Notification from EAP Authenticator to PAA<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">8.2.</a>&nbsp;
Variables<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">8.3.</a>&nbsp;
Procedures<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">8.4.</a>&nbsp;
PAA State Transition Table<br />
<a href="#anchor31">9.</a>&nbsp;
Implementation Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">9.1.</a>&nbsp;
PAA and PaC Interface to Service Management Entity<br />
<a href="#anchor33">10.</a>&nbsp;
Security Considerations<br />
<a href="#anchor34">11.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor35">12.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">13.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">13.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">13.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
	This document defines the state machines for Protocol Carrying
	Authentication for Network Access (PANA) <a class='info' href='#RFC5191'>[RFC5191]<span> (</span><span class='info'>Forsberg, D., Ohba, Y., Patil, B., Tschofenig, H., and A. Yegin, &ldquo;Protocol for Carrying Authentication for Network Access (PANA),&rdquo; May&nbsp;2008.</span><span>)</span></a>.  There are state machines for
	the PANA client (PaC) and for the PANA Authentication Agent
	(PAA).  Each state machine is specified through a set of
	variables, procedures and a state transition table. The state
        machines and associated models described in this document are
        informative only. Implementations may achieve similar results
        using different models and/or methods.
      
</p>
<p>
	A PANA protocol execution consists of several exchanges to
	carry authentication information.  Specifically, EAP PDUs are
	transported inside PANA PDUs between PaC and PAA, that is PANA
	represents a lower layer for EAP protocol.  Thus, a PANA state
	machine bases its execution on an EAP state machine execution
	and vice versa.  Thus this document also shows for each of PaC
	and PAA an interface between an EAP state machine and a PANA
	state machine and how this interface allows to exchange
	information between them.  Thanks to this interface, a PANA
	state machine can be informed about several events generated
	in an EAP state machine and make its execution conditional to
	its events.
      
</p>
<p>
	The details of EAP state machines are out of the scope of this
	document.  Additional information can be found in
        <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a>.  Nevertheless PANA
	state machines presented here have been coordinated with state
	machines shown by <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a>.
      
</p>
<p>
	This document, apart from defining PaC and PAA state machines
	and their interfaces to EAP state machines (running on top of
	PANA), provides some implementation considerations, taking
	into account that it is not a specification but an
	implementation guideline.
      
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p> This document reuses the terminology used in <a class='info' href='#RFC5191'>[RFC5191]<span> (</span><span class='info'>Forsberg, D., Ohba, Y., Patil, B., Tschofenig, H., and A. Yegin, &ldquo;Protocol for Carrying Authentication for Network Access (PANA),&rdquo; May&nbsp;2008.</span><span>)</span></a>.
      
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Interface Between PANA and EAP</h3>

<p>
	PANA carries EAP messages exchanged between an EAP peer and an
	EAP authenticator (see <a class='info' href='#figure-pana-model'>Figure&nbsp;1<span> (</span><span class='info'>Interface between PANA and EAP</span><span>)</span></a>).
	Thus a PANA state machine interacts with an EAP state
	machine.
      
</p>
<p>
	Two state machines are defined in this document : the PaC
	state machine (see <a class='info' href='#section-pac-statemachine'>Section&nbsp;7<span> (</span><span class='info'>PaC State Machine</span><span>)</span></a>)
	and the PAA state machine (see <a class='info' href='#section-paa-statemachine'>Section&nbsp;8<span> (</span><span class='info'>PAA State Machine</span><span>)</span></a>).  The definition of each
	state machine consists of a set of variables, procedures and a
	state transition table.  A subset of these variables and
	procedures defines the interface between a PANA state machine
	and an EAP state machine and the state transition table
	defines the PANA state machine behavior based on results
	obtained through them.
      
</p>
<p>
	On the one hand, the PaC state machine interacts with an EAP
	peer state machine in order to carry out the PANA protocol on
	the PaC side.  On the other hand, the PAA state machine
	interacts with an EAP authenticator state machine to run the
	PANA protocol on the PAA side.
      
</p><br /><hr class="insert" />
<a name="figure-pana-model"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                  Peer             |EAP            Auth
                  EAP    &lt;---------|------------&gt;  EAP
                 ^ |               |              ^ |
                 | |               | EAP-Message  | |  EAP-Message
    EAP-Message    | |EAP-Message  |                | |
                   | v             |PANA            | v
                  PaC    &lt;---------|------------&gt;  PAA
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: Interface between PANA and EAP&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
	Thus two interfaces are needed between PANA state machines and
	EAP state machines, namely:
	</p>
<ul class="text">
<li>
	    Interface between the PaC state machine and the EAP peer
	    state machine
	  
</li>
<li>
	    Interface between the PAA state machine and the EAP
	    authenticator state machine
	  
</li>
</ul><p>
       
</p>
<p>
        In general, the PaC and PAA state machines present EAP messages to
        the EAP peer and authenticator state machines through the
        interface, respectively.  The EAP peer and authenticator state
        machines process these messages and sends EAP messages through
        the PaC and PAA state machines that is responsible for actually
        transmitting this message, respectively.
       
</p>
<p>
	For example, <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a>
	specifies four interfaces to lower layers: (i) an interface
	between the EAP peer state machine and a lower layer, (ii) an
	interface between the EAP standalone authenticator state
	machine and a lower layer, (iii) an interface between the EAP
	full authenticator state machine and a lower layer and (iv) an
	interface between the EAP backend authenticator state machine
	and a lower layer.  In this document, the PANA protocol is the
	lower layer of EAP and only the first three interfaces are of
	interest to PANA.  The second and third interfaces are the
	same.  In this regard, the EAP standalone authenticator or the
	EAP full authenticator and its state machine in <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a> are referred to as the
	EAP authenticator and the EAP authenticator state machine,
	respectively, in this document.  If an EAP peer and an EAP
	authenticator follow the state machines defined in <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a>, the interfaces between
	PANA and EAP could be based on that document.  Detailed
	definition of interfaces between PANA and EAP are described in
	the subsequent sections.
      
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Document Authority</h3>

<p>
        This document is intended to comply with the technical
        contents of any of the related documents (<a class='info' href='#RFC5191'>[RFC5191]<span> (</span><span class='info'>Forsberg, D., Ohba, Y., Patil, B., Tschofenig, H., and A. Yegin, &ldquo;Protocol for Carrying Authentication for Network Access (PANA),&rdquo; May&nbsp;2008.</span><span>)</span></a> and <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a>). When there is
        a discrepancy, the related documents are considered
        authoritative and they take precedence over this document.
      
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Notations</h3>

<p>
	The following state transition tables are completed mostly
	based on the conventions specified in <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a>.  The complete text is
	described below.
      
</p>
<p>
	State transition tables are used to represent the operation of
	the protocol by a number of cooperating state machines each
	comprising a group of connected, mutually exclusive states.
	Only one state of each machine can be active at any given
	time.
      
</p>
<p>
	All permissible transitions from a given state to other states
	and associated actions performed when the transitions occur
	are represented by using triplets of (exit condition, exit
	action, exit state).  All conditions are expressions that
	evaluate to TRUE or FALSE; if a condition evaluates to TRUE,
	then the condition is met.  A state "ANY" is a wildcard state
	that matches any state in each state machine except those
        explicity enumerated as exception states.  The exit conditions 
        of a wildcard state are evaluated after all other exit conditions 
        of specific to the current state are met.
      
</p>
<p>
	On exit from a state, the exit actions defined for the state
	and the exit condition are executed exactly once, in the order
	that they appear.  (Note that the procedures
	defined in <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a> are
	executed on entry to a state, which is one major difference
	from this document.)  Each exit action is deemed to be atomic;
	i.e., execution of an exit action completes before the next
	sequential exit action starts to execute.  No exit action execute
	outside of a state block.  The exit actions in only one state
	block execute at a time even if the conditions for execution
	of state blocks in different state machines are satisfied.
	All exit actions in an executing state block complete execution
	before the transition to and execution of any other state
	blocks. The execution of any state block appears to be atomic
        with respect to the execution of any other state block and
        the transition condition to that state from the previous state
        is TRUE when execution commences.  The order of execution of
        state blocks in different state machines is undefined except
        as constrained by their transition conditions. A variable that
        is set to a particular value in a state block retains this
        value until a subsequent state block executes an exit action
        that modifies the value.
      
</p>
<p>
	On completion of the transition from the previous state to the
	current state, all exit conditions occurring during the current
        state (including exit conditions defined for the wildcard state)
	are evaluated until an exit condition for that state is met.
      
</p>
<p>
	Any event variable is set to TRUE when the corresponding event
	occurs and set to FALSE immediately after completion of the
	action associated with the current state and the event.
      
</p>
<p>
	The interpretation of the special symbols and operators used
	is defined in <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a>.
      
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Common Rules</h3>

<p>
	There are following procedures, variables, message
	initializing rules and state transitions that are common to
	both the PaC and PAA state machines.
      
</p>
<p>
	Throughout this document, the character string
	"PANA_MESSAGE_NAME" matches any one of the abbreviated PANA
	message names, i.e., "PCI", "PAR", "PAN", "PTR", "PTA", "PNR",
        "PNA".
      
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.1"></a><h3>6.1.&nbsp;
Common Procedures</h3>

<p>
	</p>
<blockquote class="text"><dl>
<dt>void None()</dt>
<dd>
            <br />

            A null procedure, i.e., nothing is done.
	  
</dd>
<dt>void Disconnect()</dt>
<dd>
            <br />

            A procedure to delete the PANA session as well as the
	    corresponding EAP session and authorization state.
	  
</dd>
<dt>boolean Authorize()</dt>
<dd>
            <br />

	    A procedure to create or modify authorization state.  It
	    returns TRUE if authorization is successful.  Otherwise,
	    it returns FALSE.  It is assumed that Authorize()
	    procedure of PaC state machine always returns TRUE. In
        the case that a non-key-generating EAP method is used
        but a PANA SA is required after successful authentication
        (generate_pana_sa() returns TRUE), Authorize() procedure
        must return FALSE.
	  
</dd>
<dt>void Tx:PANA_MESSAGE_NAME[flag](AVPs)</dt>
<dd>
            <br />

        A procedure to send a PANA message to its peering PANA entity.
        The "flag" argument contains one or more flag (e.g., Tx:PAR[C]) to be set
        to the message, except for 'R' (Request) flag.  The "AVPs"
        contains a list of names of optional AVPs to be inserted in the
        message, except for AUTH AVP.
        <br />
<br />

        This procedure includes the following action before actual
        transmission:
        <br />
<br />

        <div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
          if (flag==S)
            PANA_MESSAGE_NAME.S_flag=Set;
          if (flag==C)
            PANA_MESSAGE_NAME.C_flag=Set;
          if (flag==A)
            PANA_MESSAGE_NAME.A_flag=Set;
          if (flag==P)
            PANA_MESSAGE_NAME.P_flag=Set;
          PANA_MESSAGE_NAME.insert_avp(AVPs);
          if (key_available())
            PANA_MESSAGE_NANE.insert_avp("AUTH");
</pre></div>
      
</dd>
<dt>void TxEAP()</dt>
<dd>
            <br />

	    A procedure to send an EAP message to the EAP state
	    machine it interfaces to.
	  
</dd>
<dt>void RtxTimerStart()</dt>
<dd>
            <br />

	    A procedure to start the retransmission timer, reset
	    RTX_COUNTER variable to zero and set an appropriate
	    value to RTX_MAX_NUM variable. Note that RTX_MAX_NUM
            is assumed to be set to the same default value for all 
            messages. However, implementations may also reset
            RTX_MAX_NUM in this procedure and its value may vary
            depending on the message that was sent.
	  
</dd>
<dt>void RtxTimerStop()</dt>
<dd>
            <br />

	    A procedure to stop the retransmission timer.
	  
</dd>
<dt>void SessionTimerReStart(TIMEOUT)</dt>
<dd>
            <br />

        A procedure to (re)start PANA session timer. TIMEOUT specifies
        the expiration time associated of the session timer.
        Expiration of TIMEOUT will trigger a SESS_TIMEOUT event.
	  
</dd>
<dt>void SessionTimerStop()</dt>
<dd>
            <br />

	    A procedure to stop the current PANA session timer.
	  
</dd>
<dt>void Retransmit()</dt>
<dd>
            <br />

	    A procedure to retransmit a PANA message and increment
            RTX_COUNTER by one(1).
	  
</dd>
<dt>void EAP_Restart()</dt>
<dd>
            <br />

	    A procedure to (re)start an EAP conversation resulting
            in the re-initialization of an existing EAP session.
	  
</dd>
<dt>void PANA_MESSAGE_NAME.insert_avp("AVP_NAME1", "AVP_NAME2",...)</dt>
<dd>
            <br />

        A procedure to insert AVPs for each specified AVP name in the
        list of AVP names in the PANA message.  When an AVP name ends
        with "*", zero, one or more AVPs are inserted, otherwise one
        AVP is inserted.
	  
</dd>
<dt>boolean PANA_MESSAGE_NAME.exist_avp("AVP_NAME")</dt>
<dd>
            <br />

	    A procedure that checks whether an AVP of the specified
	    AVP name exists in the specified PANA message and
	    returns TRUE if the specified AVP is found, otherwise
	    returns FALSE.
	  
</dd>
<dt>boolean generate_pana_sa()</dt>
<dd>
            <br />

        A procedure to check whether the EAP method being used
        generates keys and that a PANA SA will be established on
        successful authentication. For the PaC, the procedure
        is also used to check and match the PRF and Integrity
        algorithm AVPs advertised by the PAA in PAR[S] message.
        For the PAA, it is used to indicate whether a PRF and Integrity
        algorithm AVPs will be sent in the PAR[S]. This procedure will
        return true if a PANA SA will be generated. Otherwise, it
        returns FALSE.
      
</dd>
<dt>boolean key_available()</dt>
<dd>
            <br />

	    A procedure to check whether the PANA session has a
	    PANA_AUTH_KEY.  If the state machine already has a
	    PANA_AUTH_KEY, it returns TRUE.  If the state machine
	    does not have a PANA_AUTH_KEY, it tries to retrieve an
	    MSK from the EAP entity.  If an MSK is retrieved,
	    it computes a PANA_AUTH_KEY from the MSK and returns
	    TRUE.  Otherwise, it returns FALSE.
	  
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.2"></a><h3>6.2.&nbsp;
Common Variables</h3>

<p>
    </p>
<blockquote class="text"><dl>
<dt>PAR.RESULT_CODE</dt>
<dd>
            <br />

	    This variable contains the Result-Code AVP value in the
	    PANA-Auth-Request message in process. When this variable
            carries PANA_SUCCESS it is assumed that the PAR message
            always contains an EAP-Payload AVP which carries an EAP-Success
            message.
	  
</dd>
<dt>NONCE_SENT</dt>
<dd>
            <br />

	    This variable is set to TRUE to indicate that a Nonce-AVP has already
        been sent. Otherwise it is set to FALSE.
	  
</dd>
<dt>RTX_COUNTER</dt>
<dd>
            <br />

	    This variable contains the current number of
	    retransmissions of the outstanding PANA message.
	  
</dd>
<dt>Rx:PANA_MESSAGE_NAME[flag]</dt>
<dd>
            <br />

        This event variable is set to TRUE when the specified PANA
        message is received from its peering PANA entity.  The "flag"
        contains a flag (e.g., Rx:PAR[C]), except for 'R' (Request)
        flag.
	  
</dd>
<dt>RTX_TIMEOUT</dt>
<dd>
            <br />

	    This event variable is set to TRUE when the
	    retransmission timer is expired.
	  
</dd>
<dt>REAUTH</dt>
<dd>
            <br />

	    This event variable is set to TRUE when an initiation of
	    re-authentication phase is triggered. This event variable can
            only be set while in the OPEN state.
	  
</dd>
<dt>TERMINATE</dt>
<dd>
            <br />

	    This event variable is set to TRUE when initiation of
	    PANA session termination is triggered. This event variable can
            only be set while in the OPEN state.
	  
</dd>
<dt>PANA_PING</dt>
<dd>
            <br />

	    This event variable is set to TRUE when initiation of
	    liveness test based on PANA-Notification exchange is
            triggered. This event variable can only be set while in the
            OPEN state.
	  
</dd>
<dt>SESS_TIMEOUT</dt>
<dd>
            <br />

	    This event is variable is set to TRUE when the session
	    timer has expired.
	  
</dd>
<dt>LIFETIME_SESS_TIMEOUT</dt>
<dd>
            <br />

            Configurable value used by the PaC and PAA to close or
            disconnect an established session in the access
            phase. This variable indicates the expiration of
            the session and is set to the value of
            Session-Lifetime AVP if present in the last
            PANA-Auth-Request message in the case of the PaC.
            Otherwise, it is assumed that the value is infinite
            and therefore has no expiration. Expiration of
            LIFETIME_SESS_TIMEOUT will cause the event variable
            SESS_TIMEOUT to be set.
      
</dd>
<dt>ANY</dt>
<dd>
            <br />

	    This event variable is set to TRUE when any event occurs.
	  
</dd>
</dl></blockquote><p>
      
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.3"></a><h3>6.3.&nbsp;
Configurable Values</h3>

<p>
	</p>
<blockquote class="text"><dl>
<dt>RTX_MAX_NUM</dt>
<dd>
            <br />

	    Configurable maximum for how many retransmissions should
	    be attempted before aborting.
	  
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.4"></a><h3>6.4.&nbsp;
Common Message Initialization Rules</h3>

<p>
	  When a message is prepared for sending, it is initialized as follows:	
	</p>
<ul class="text">
<li>
	    For a request message, R-flag of the header is set.
	    Otherwise, R-flag is not set.
	  
</li>
<li>
            Other message header flags are not set. They are set
            explicitly by specific state machine actions.
          
</li>
<li>
	    AVPs that are mandatory included in a message are inserted
	    with appropriate values set.
	  
</li>
</ul><p>
        
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.5"></a><h3>6.5.&nbsp;
Common Retransmition Rules</h3>

<p>
          The state machines defined in this document assumes
          that the PaC and the PAA caches the last transmitted answer
          message. This scheme is described in Sec 5.2 of
          <a class='info' href='#RFC5191'>[RFC5191]<span> (</span><span class='info'>Forsberg, D., Ohba, Y., Patil, B., Tschofenig, H., and A. Yegin, &ldquo;Protocol for Carrying Authentication for Network Access (PANA),&rdquo; May&nbsp;2008.</span><span>)</span></a>. When the PaC or PAA receives
          a re-transmitted or duplicate request, it would be able to re-send
          the corresponding answer without any aid from the EAP layer.
          However, to simplify the state machine description, this caching
          scheme is omitted in the state machines below. In the case that
          there is not corresponding answer to a re-transmitted request,
          the request will be handled by the corresponding statemachine.
        
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6.6"></a><h3>6.6.&nbsp;
Common State Transitions</h3>

<p>
	  The following transitions can occur at any state with exemptions
      explicitly noted.
	</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
----------
State: ANY
----------

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+------------
- - - - - - - - - - - - - (Re-transmissions)- - - - - - - - - -
RTX_TIMEOUT &amp;&amp;           Retransmit();              (no change)
RTX_COUNTER&lt;
RTX_MAX_NUM
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - (Reach maximum number of transmissions)- - - - - -
(RTX_TIMEOUT &amp;&amp;          Disconnect();              CLOSED
 RTX_COUNTER&gt;=
 RTX_MAX_NUM) ||
SESS_TIMEOUT
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

-------------------------
State: ANY except INITIAL
-------------------------

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+------------
- - - - - - - - - - (liveness test initiated by peer)- - - - - -
Rx:PNR[P]                Tx:PNA[P]();               (no change)


-------------------------------
State: ANY except WAIT_PNA_PING
-------------------------------

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+------------
- - - - - - - - - - - - (liveness test response) - - - - - - - -
Rx:PNA[P]                None();                    (no change)
</pre></div><p>

        
</p>
<p>
	  The following transitions can occur on any exit condition
          within the specified state.
	</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
-------------
State: CLOSED
-------------

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+------------
- - - - - - - -(Catch all event on closed state) - - - - - - - -
ANY                      None();                    CLOSED
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
</pre></div><p>

	
</p>
<a name="section-pac-statemachine"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
PaC State Machine</h3>

<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Interface between PaC and EAP Peer</h3>

<p>
	  This interface defines the interactions between a PaC and an
	  EAP peer.  The interface serves as a mechanism to deliver
	  EAP messages for the EAP peer.  It allows the EAP peer to
	  receive EAP requests and send EAP responses via the PaC.  It
	  also provides a mechanism to notify the EAP peer of PaC
	  events and a mechanism to receive notification of EAP peer
	  events.  The EAP message delivery mechanism as well as the
	  event notification mechanism in this interface have direct
	  correlation with the PaC state transition table entries.
	  These message delivery and event notifications mechanisms
	  occur only within the context of their associated states or
	  exit actions.
	
</p>
<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.1"></a><h3>7.1.1.&nbsp;
Delivering EAP Messages from PaC to EAP Peer</h3>

<p>
      TxEAP() procedure in the PaC state machine serves as the mechanism
      to deliver EAP messages contained in PANA-Auth-Request messages to
      the EAP peer. This procedure is enabled only after an
      EAP restart event is notified to the EAP peer and before
      any event resulting in a termination of the EAP peer session.
      In the case where the EAP peer follows the EAP peer state
      machine defined in <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a>,
      TxEAP() procedure sets eapReq variable of the EAP peer
      state machine and puts the EAP request in eapReqData
      variable of the EAP peer state machine.
	  
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.2"></a><h3>7.1.2.&nbsp;
Delivering EAP Messages from EAP Peer to PaC</h3>

<p>
      An EAP message is delivered from the EAP peer to the PaC
      via EAP_RESPONSE event variable.  The event variable is
      set when the EAP peer passes the EAP message to its
      lower-layer.  In the case where the EAP peer follows the
      EAP peer state machine defined in <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a>, EAP_RESPONSE event
      variable refers to eapResp variable of the EAP peer state
      machine and the EAP message is contained in eapRespData
      variable of the EAP peer state machine.
	  
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.3"></a><h3>7.1.3.&nbsp;
EAP Restart Notification from PaC to EAP Peer</h3>

<p>
      The EAP peer state machine defined in <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a> has an initialization
      procedure before receiving an EAP message.  To initialize
      the EAP state machine, the PaC state machine defines an
      event notification mechanism to send an EAP (re)start
      event to the EAP peer.  The event notification is done via
      EAP_Restart() procedure in the initialization action of
      the PaC state machine.
	  
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.4"></a><h3>7.1.4.&nbsp;
EAP Authentication Result Notification from EAP Peer to PaC</h3>

<p>
	    In order for the EAP peer to notify the PaC of an EAP
	    authentication result, EAP_SUCCESS and EAP_FAILURE event
	    variables are defined.  In the case where the EAP peer
	    follows the EAP peer state machine defined in <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a>, EAP_SUCCESS and
	    EAP_FAILURE event variables refer to eapSuccess and
	    eapFail variables of the EAP peer state machine,
	    respectively.  In this case, if EAP_SUCCESS event variable
	    is set to TRUE and an MSK is generated by the EAP
	    authentication method in use, eapKeyAvailable variable is
	    set to TRUE and eapKeyData variable contains the MSK.
	    Note that EAP_SUCCESS and EAP_FAILURE event variables may
	    be set to TRUE even before the PaC receives a PAR with a
            'Complete' flag set from the PAA.
	  
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.5"></a><h3>7.1.5.&nbsp;
Alternate Failure Notification from PaC to EAP Peer</h3>

<p>
	    alt_reject() procedure in the PaC state machine serves as
	    the mechanism to deliver an authentication failure event
	    to the EAP peer without accompanying an EAP message.  In
	    the case where the EAP peer follows the EAP peer state
	    machine defined in <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a>, alt_reject()
	    procedure sets altReject variable of the EAP peer state
	    machine.  Note that the EAP peer state machine in <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a> also defines
	    altAccept variable, however, it is never used in PANA in
	    which EAP-Success messages are reliably delivered by
	    the last PANA-Auth exchange.
	  
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.2"></a><h3>7.2.&nbsp;
Configurable Values</h3>

<p>
	</p>
<blockquote class="text"><dl>
<dt>FAILED_SESS_TIMEOUT</dt>
<dd>
            <br />

	    Configurable value that allows the PaC to determine
            whether a PaC authentication and authorization phase
            has stalled without an explicit EAP success or
            failure notification.
	  
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.3"></a><h3>7.3.&nbsp;
Variables</h3>

<p>
	</p>
<blockquote class="text"><dl>
<dt>AUTH_USER</dt>
<dd>
            <br />

	    This event variable is set to TRUE when initiation of
	    EAP-based (re-)authentication is triggered by the
	    application.
	  
</dd>
<dt>EAP_SUCCESS</dt>
<dd>
            <br />

	    This event variable is set to TRUE when the EAP peer
	    determines that EAP conversation completes with success.
	  
</dd>
<dt>EAP_FAILURE</dt>
<dd>
            <br />

	    This event variable is set to TRUE when the EAP peer
	    determines that EAP conversation completes with failure.
	  
</dd>
<dt>EAP_RESPONSE</dt>
<dd>
            <br />

        This event variable is set to TRUE when the EAP peer delivers an
        EAP message to the PaC.  This event accompanies an EAP message
        received from the EAP peer.
      
</dd>
<dt>EAP_RESP_TIMEOUT</dt>
<dd>
            <br />

        This event variable is set to TRUE when the PaC that has passed
        an EAP message to the EAP-layer does not receive a subsequent
        EAP message from the the EAP-layer in a given period.  This
        provides a time limit for certain EAP methods where user
        interaction maybe required.
      
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.4"></a><h3>7.4.&nbsp;
Procedures</h3>

<p>
	</p>
<blockquote class="text"><dl>
<dt>boolean eap_piggyback()</dt>
<dd>
            <br />

            This procedures returns TRUE to indicate whether the
            next EAP response will be carried in the pending
            PAN message for optimization.
	  
</dd>
<dt>void alt_reject()</dt>
<dd>
            <br />

            This procedure informs the EAP peer of an authentication
	    failure event without accompanying an EAP message.
	  
</dd>
<dt>void EAP_RespTimerStart()</dt>
<dd>
            <br />

	    A procedure to start a timer to receive an EAP-Response
	    from the EAP peer.
	  
</dd>
<dt>void EAP_RespTimerStop()</dt>
<dd>
            <br />

	    A procedure to stop a timer to receive an EAP-Response
	    from the EAP peer.
	  
</dd>
</dl></blockquote><p>
        
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.5"></a><h3>7.5.&nbsp;
PaC State Transition Table</h3>

<p>
	</p>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
------------------------------
State: INITIAL (Initial State)
------------------------------

Initialization Action:

  NONCE_SENT=Unset;
  RTX_COUNTER=0;
  RtxTimerStop();

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+-----------
- - - - - - - - - - (PaC-initiated Handshake) - - - - - - - - -
AUTH_USER                Tx:PCI[]();                INITIAL
                         RtxTimerStart();
                         SessionTimerReStart
                           (FAILED_SESS_TIMEOUT);
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

- - - - - - -(PAA-initiated Handshake, not optimized) - - - - -
Rx:PAR[S] &amp;&amp;             EAP_Restart();             WAIT_PAA
!PAR.exist_avp           SessionTimerReStart
("EAP-Payload")              (FAILED_SESS_TIMEOUT);
                         if (generate_pana_sa())
                             Tx:PAN[S]("PRF-Algorithm",
                                "Integrity-Algorithm");
                         else
                             Tx:PAN[S]();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

- - - - - - - -(PAA-initiated Handshake, optimized) - - - - - -
Rx:PAR[S] &amp;&amp;             EAP_Restart();             INITIAL
PAR.exist_avp            TxEAP();
("EAP-Payload") &amp;&amp;       SessionTimerReStart
eap_piggyback()            (FAILED_SESS_TIMEOUT);

Rx:PAR[S] &amp;&amp;             EAP_Restart();             WAIT_EAP_MSG
PAR.exist_avp            TxEAP();
("EAP-Payload") &amp;&amp;       SessionTimerReStart
!eap_piggyback()           (FAILED_SESS_TIMEOUT);
                         if (generate_pana_sa())
                             Tx:PAN[S]("PRF-Algorithm",
                               "Integrity-Algorithm");
                         else
                             Tx:PAN[S]();

EAP_RESPONSE             if (generate_pana_sa())    WAIT_PAA
                             Tx:PAN[S]("EAP-Payload",
                               "PRF-Algorithm",
                               "Integrity-Algorithm");
                         else
                             Tx:PAN[S]("EAP-Payload");
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

---------------
State: WAIT_PAA
---------------

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+------------
- - - - - - - - - - - - - - -(PAR-PAN exchange) - - - - - - - -
Rx:PAR[] &amp;&amp;              RtxTimerStop();            WAIT_EAP_MSG
!eap_piggyback()         TxEAP();
                         EAP_RespTimerStart();
                         if (NONCE_SENT==Unset) {
                           NONCE_SENT=Set;
                           Tx:PAN[]("Nonce");
                         }
                         else
                           Tx:PAN[]();

Rx:PAR[] &amp;&amp;              RtxTimerStop();            WAIT_EAP_MSG
eap_piggyback()          TxEAP();
                         EAP_RespTimerStart();

Rx:PAN[]                 RtxTimerStop();            WAIT_PAA

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - - - - - - - - -(PANA result) - - - - - - - - - -
Rx:PAR[C] &amp;&amp;             TxEAP();                   WAIT_EAP_RESULT
PAR.RESULT_CODE==
  PANA_SUCCESS

Rx:PAR[C] &amp;&amp;             if (PAR.exist_avp          WAIT_EAP_RESULT_
PAR.RESULT_CODE!=          ("EAP-Payload"))         CLOSE
  PANA_SUCCESS             TxEAP();
                         else
                            alt_reject();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

-------------------
State: WAIT_EAP_MSG
-------------------

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+------------
- - - - - - - - - - (Return PAN/PAR from EAP) - - - - - - - - -
EAP_RESPONSE &amp;&amp;          EAP_RespTimerStop()        WAIT_PAA
eap_piggyback()          if (NONCE_SENT==Unset) {
                           Tx:PAN[]("EAP-Payload",
                                    "Nonce");
                           NONCE_SENT=Set;
                         }
                         else
                           Tx:PAN[]("EAP-Payload");

EAP_RESPONSE &amp;&amp;          EAP_RespTimerStop()        WAIT_PAA
!eap_piggyback()         Tx:PAR[]("EAP-Payload");
                         RtxTimerStart();

EAP_RESP_TIMEOUT &amp;&amp;      Tx:PAN[]();                WAIT_PAA
eap_piggyback()

EAP_FAILURE              SessionTimerStop();        CLOSED
                         Disconnect();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

----------------------
State: WAIT_EAP_RESULT
----------------------

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+------------
- - - - - - - - - - - - - (EAP Result) - - - - - - - - - - - - -
EAP_SUCCESS             if (PAR.exist_avp           OPEN
                           ("Key-Id"))
                          Tx:PAN[C]("Key-Id");
                        else
                          Tx:PAN[C]();
                        Authorize();
                        SessionTimerReStart
                          (LIFETIME_SESS_TIMEOUT);

EAP_FAILURE             Tx:PAN[C]();                CLOSED
                        SessionTimerStop();
                        Disconnect();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

----------------------------
State: WAIT_EAP_RESULT_CLOSE
----------------------------

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+------------
- - - - - - - - - - - - - (EAP Result) - - - - - - - - - - - - -
EAP_SUCCESS ||          if (EAP_SUCCESS &amp;&amp;         CLOSED
EAP_FAILURE               PAR.exist_avp("Key-Id"))
                          Tx:PAN[C]("Key-Id");
                        else
                          Tx:PAN[C]();
                        SessionTimerStop();
                        Disconnect();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

-----------
State: OPEN
-----------

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+------------
- - - - - - - - - - (liveness test initiated by PaC)- - - - - -
PANA_PING                Tx:PNR[P]();               WAIT_PNA_PING
                         RtxTimerStart();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - - - (re-authentication initiated by PaC)- - - - - -
REAUTH                   NONCE_SENT=Unset;          WAIT_PNA_REAUTH
                         Tx:PNR[A]();
                         RtxTimerStart();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - - - (re-authentication initiated by PAA)- - - - - -
Rx:PAR[]                 EAP_RespTimerStart();      WAIT_EAP_MSG
                         TxEAP();
                         if (!eap_piggyback())
                           Tx:PAN[]("Nonce");
                         else
                           NONCE_SENT=Unset;
                         SessionTimerReStart
                           (FAILED_SESS_TIMEOUT);
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - -(Session termination initiated by PAA) - - - - - -
Rx:PTR[]                 Tx:PTA[]();                CLOSED
                         SessionTimerStop();
                         Disconnect();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - -(Session termination initiated by PaC) - - - - - -
TERMINATE                Tx:PTR[]();                SESS_TERM
                         RtxTimerStart();
                         SessionTimerStop();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

----------------------
State: WAIT_PNA_REAUTH
----------------------

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+------------
- - - - - - - - -(re-authentication initiated by PaC) - - - - -
Rx:PNA[A]                RtxTimerStop();            WAIT_PAA
                         SessionTimerReStart
                           (FAILED_SESS_TIMEOUT);
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - -(Session termination initiated by PAA) - - - - - -
Rx:PTR[]                 RtxTimerStop();            CLOSED
                         Tx:PTA[]();
                         SessionTimerStop();
                         Disconnect();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

--------------------
State: WAIT_PNA_PING
--------------------

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+------------
- - - - - - - - -(liveness test initiated by PaC) - - - - - - -
Rx:PNA[P]                RtxTimerStop();            OPEN
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - - - (re-authentication initiated by PAA)- - - - -
Rx:PAR[]                 RtxTimerStop();            WAIT_EAP_MSG
                         EAP_RespTimerStart();
                         TxEAP();
                         if (!eap_piggyback())
                           Tx:PAN[]("Nonce");
                         else
                           NONCE_SENT=Unset;
                         SessionTimerReStart
                           (FAILED_SESS_TIMEOUT);
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - -(Session termination initiated by PAA) - - - - - -
Rx:PTR[]                 RtxTimerStop();            CLOSED
                         Tx:PTA[]();
                         SessionTimerStop();
                         Disconnect();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

----------------
State: SESS_TERM
----------------

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+------------
- - - - - - - -(Session termination initiated by PaC) - - - - -
Rx:PTA[]                 Disconnect();              CLOSED
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
</pre></div><p>

        
</p>
<a name="section-paa-statemachine"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
PAA State Machine</h3>

<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
Interface between PAA and EAP Authenticator</h3>

<p>
	  The interface between a PAA and an EAP authenticator
	  provides a mechanism to deliver EAP messages for the EAP
	  authenticator as well as a mechanism to notify the EAP
	  authenticator of PAA events and to receive notification of
	  EAP authenticator events.  These message delivery and event
	  notification mechanisms occur only within context of their
	  associated states or exit actions.
	
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1.1"></a><h3>8.1.1.&nbsp;
EAP Restart Notification from PAA to EAP Authenticator</h3>

<p>
	    An EAP authenticator state machine defined in <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a> has an initialization
	    procedure before sending the first EAP request.  To
	    initialize the EAP state machine, the PAA state machine
	    defines an event notification mechanism to send an EAP
	    (re)start event to the EAP authenticator.  The event notification
	    is done via EAP_Restart() procedure in the initialization
	    action of the PAA state machine.
	  
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1.2"></a><h3>8.1.2.&nbsp;
Delivering EAP Responses from PAA to EAP Authenticator</h3>

<p>
	    TxEAP() procedure in the PAA state machine serves as the
	    mechanism to deliver EAP-Responses contained in
	    PANA-Auth-Answer messages to the EAP authenticator.  This
	    procedure is enabled only after an EAP restart event is
	    notified to the EAP authenticator and before any event
            resulting in a termination of the EAP authenticator session.
            In the case where the EAP authenticator follows the EAP
            authenticator state machines defined in <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a>, TxEAP() procedure
	    sets eapResp variable of the EAP authenticator state
	    machine and puts the EAP response in eapRespData variable
	    of the EAP authenticator state machine.
	  
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1.3"></a><h3>8.1.3.&nbsp;
Delivering EAP Messages from EAP Authenticator to PAA</h3>

<p>
	    An EAP request is delivered from the EAP authenticator to
	    the PAA via EAP_REQUEST event variable.  The event
	    variable is set when the EAP authenticator passes the EAP
	    request to its lower-layer.  In the case where the EAP
	    authenticator follows the EAP authenticator state machines
	    defined in <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a>,
	    EAP_REQUEST event variable refers to eapReq variable of
	    the EAP authenticator state machine and the EAP request is
	    contained in eapReqData variable of the EAP authenticator
	    state machine.
	  
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1.4"></a><h3>8.1.4.&nbsp;
EAP Authentication Result Notification from EAP Authenticator to PAA</h3>

<p>
	    In order for the EAP authenticator to notify the PAA of
	    the EAP authentication result, EAP_SUCCESS, EAP_FAILURE
	    and EAP_TIMEOUT event variables are defined.  In the case
	    where the EAP authenticator follows the EAP authenticator
	    state machines defined in <a class='info' href='#RFC4137'>[RFC4137]<span> (</span><span class='info'>Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator,&rdquo; August&nbsp;2005.</span><span>)</span></a>, EAP_SUCCESS,
	    EAP_FAILURE and EAP_TIMEOUT event variables refer to
	    eapSuccess, eapFail and eapTimeout variables of the EAP
	    authenticator state machine, respectively.  In this case,
	    if EAP_SUCCESS event variable is set to TRUE, an
	    EAP-Success message is contained in eapReqData variable of
	    the EAP authenticator state machine, and additionally,
	    eapKeyAvailable variable is set to TRUE and eapKeyData
	    variable contains an MSK if the MSK is generated as
	    a result of successful authentication by the EAP
	    authentication method in use.  Similarly, if EAP_FAILURE
	    event variable is set to TRUE, an EAP-Failure message is
	    contained in eapReqData variable of the EAP authenticator
	    state machine.  The PAA uses EAP_SUCCESS, EAP_FAILURE and
	    EAP_TIMEOUT event variables as a trigger to send a PAR
	    message to the PaC.
	  
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.2"></a><h3>8.2.&nbsp;
Variables</h3>

<blockquote class="text"><dl>
<dt>OPTIMIZED_INIT</dt>
<dd>
            <br />

	    This variable indicates whether the PAA is able to
	    piggyback an EAP-Request in the initial PANA-Auth-Request.
            Otherwise it is set to FALSE.
	  
</dd>
<dt>PAC_FOUND</dt>
<dd>
            <br />

            This variable is set to TRUE as a result of a PAA
            initiated handshake.
	  
</dd>
<dt>REAUTH_TIMEOUT</dt>
<dd>
            <br />

            This event variable is set to TRUE to indicate that
            the PAA initiates a re-authentication with the
            PaC. The re-authentication timeout should be set to
            a value less than the session timeout carried in
            the Session-Lifetime AVP if present.
	  
</dd>
<dt>EAP_SUCCESS</dt>
<dd>
            <br />

	    This event variable is set to TRUE when EAP conversation
	    completes with success.  This event accompanies an EAP-
	    Success message passed from the EAP authenticator.
	  
</dd>
<dt>EAP_FAILURE</dt>
<dd>
            <br />

	    This event variable is set to TRUE when EAP conversation
	    completes with failure.  This event accompanies an EAP-
	    Failure message passed from the EAP authenticator.
	  
</dd>
<dt>EAP_REQUEST</dt>
<dd>
            <br />

	    This event variable is set to TRUE when the EAP
	    authenticator delivers an EAP Request to the PAA.  This
	    event accompanies an EAP-Request message received from
	    the EAP authenticator.
	  
</dd>
<dt>EAP_TIMEOUT</dt>
<dd>
            <br />

	    This event variable is set to TRUE when EAP conversation
	    times out without generating an EAP-Success or an
	    EAP-Failure message.  This event does not accompany any
	    EAP message.
	  
</dd>
</dl></blockquote>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.3"></a><h3>8.3.&nbsp;
Procedures</h3>

<blockquote class="text"><dl>
<dt>boolean new_key_available()</dt>
<dd>
            <br />

	    A procedure to check whether the PANA session has a new
	    PANA_AUTH_KEY.  If the state machine already have a
	    PANA_AUTH_KEY, it returns FALSE.  If the state machine
	    does not have a PANA_AUTH_KEY, it tries to retrieve an
	    MSK from the EAP entity.  If an MSK has been
	    retrieved, it computes a PANA_AUTH_KEY from the MSK
	    and returns TRUE.  Otherwise, it returns FALSE.
	  
</dd>
</dl></blockquote>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.4"></a><h3>8.4.&nbsp;
PAA State Transition Table</h3>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
------------------------------
State: INITIAL (Initial State)
------------------------------

Initialization Action:

  OPTIMIZED_INIT=Set|Unset;
  NONCE_SENT=Unset;
  RTX_COUNTER=0;
  RtxTimerStop();

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+------------
 - - - - - - - - (PCI and PAA initiated PANA) - - - - - - - - -
(Rx:PCI[] ||             if (OPTIMIZED_INIT ==      INITIAL
 PAC_FOUND)                  Set) {
                           EAP_Restart();
                           SessionTimerReStart
                            (FAILED_SESS_TIMEOUT);
                         }
                         else {
                           if (generate_pana_sa())
                                Tx:PAR[S]("PRF-Algorithm",
                                   "Integrity-Algorithm");
                           else
                                Tx:PAR[S]();
                         }

EAP_REQUEST              if (generate_pana_sa())    INITIAL
                             Tx:PAR[S]("EAP-Payload",
                                "PRF-Algorithm",
                                "Integrity-Algorithm");
                         else
                             Tx:PAR[S]("EAP-Payload");
                         RtxTimerStart();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

- - - - - - - - - - - - - - (PAN Handling)  - - - - - - - - - -
Rx:PAN[S] &amp;&amp;             if (PAN.exist_avp          WAIT_EAP_MSG
((OPTIMIZED_INIT ==         ("EAP-Payload"))
  Unset) ||                TxEAP();
PAN.exist_avp            else {
  ("EAP-Payload"))         EAP_Restart();
                           SessionTimerReStart
                            (FAILED_SESS_TIMEOUT);
                         }

Rx:PAN[S] &amp;&amp;             None();                    WAIT_PAN_OR_PAR
(OPTIMIZED_INIT ==
  Set) &amp;&amp;
! PAN.exist_avp
 ("EAP-Payload")

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

-------------------
State: WAIT_EAP_MSG
-------------------

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+------------
- - - - - - - - - - - -(Receiving EAP-Request)- - - - - - - - -
EAP_REQUEST              if (NONCE_SENT==Unset) {   WAIT_PAN_OR_PAR
                           Tx:PAR[]("Nonce",
                                    "EAP-Payload");
                           NONCE_SENT=Set;
                         }
                         else
                           Tx:PAR[]("EAP-Payload");
                         RtxTimerStart();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - - - - -(Receiving EAP-Success/Failure) - - - - -
EAP_FAILURE              PAR.RESULT_CODE =          WAIT_FAIL_PAN
                           PANA_AUTHENTICATION_
                               REJECTED;
                         Tx:PAR[C]("EAP-Payload");
                         RtxTimerStart();
                         SessionTimerStop();

EAP_SUCCESS &amp;&amp;           PAR.RESULT_CODE =          WAIT_SUCC_PAN
Authorize()                PANA_SUCCESS;
                         if (new_key_available())
                           Tx:PAR[C]("EAP-Payload",
                                "Key-Id");
                         else
                           Tx:PAR[C]("EAP-Payload");
                         RtxTimerStart();

EAP_SUCCESS &amp;&amp;           PAR.RESULT_CODE =          WAIT_FAIL_PAN
!Authorize()               PANA_AUTHORIZATION_
                             REJECTED;
                         if (new_key_available())
                           Tx:PAR[C]("EAP-Payload",
                                "Key-Id");
                         else
                           Tx:PAR[C]("EAP-Payload");
                         RtxTimerStart();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 - - - - - (Receiving EAP-Timeout or invalid message) - - - - -
EAP_TIMEOUT              SessionTimerStop();        CLOSED
                         Disconnect();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

--------------------
State: WAIT_SUCC_PAN
--------------------

Event/Condition          Action                     Exit State
------------------------+--------------------------+------------
- - - - - - - - - - - - - (PAN Processing)- - - - - - - - - - -
Rx:PAN[C]                RtxTimerStop();            OPEN
                         SessionTimerReStart
                           (LIFETIME_SESS_TIMEOUT);
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

--------------------
State: WAIT_FAIL_PAN
--------------------

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+------------
- - - - - - - - - - - - - - (PAN Processing)- - - - - - - - - -
Rx:PAN[C]                RtxTimerStop();            CLOSED
                         Disconnect();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

-----------
State: OPEN
-----------

Event/Condition          Action                     Exit State
------------------------+--------------------------+------------
- - - - - - - - (re-authentication initiated by PaC) - - - - - -
Rx:PNR[A]                NONCE_SENT=Unset;          WAIT_EAP_MSG
                         EAP_Restart();
                         Tx:PNA[A]();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - - (re-authentication initiated by PAA)- - - - - -
REAUTH ||                NONCE_SENT=Unset;          WAIT_EAP_MSG
REAUTH_TIMEOUT           EAP_Restart();

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - (liveness test based on PNR-PNA exchange initiated by PAA)-
PANA_PING                Tx:PNR[P]();               WAIT_PNA_PING
                         RtxTimerStart();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - - (Session termination initated from PAA) - - - -
TERMINATE                Tx:PTR[]();                SESS_TERM
                         SessionTimerStop();
                         RtxTimerStart();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - - (Session termination initated from PaC) - - - -
Rx:PTR[]                 Tx:PTA[]();                CLOSED
                         SessionTimerStop();
                         Disconnect();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

--------------------
State: WAIT_PNA_PING
--------------------

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+------------
- - - - - - - - - - - - - -(PNA processing) - - - - - - - - - -
Rx:PNA[P]                RtxTimerStop();            OPEN
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - - (re-authentication initiated by PaC) - - - - - -
Rx:PNR[A]                RtxTimerStop();            WAIT_EAP_MSG
                         NONCE_SENT=Unset;
                         EAP_Restart();
                         Tx:PNA[A]();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - - (Session termination initated from PaC) - - - -
Rx:PTR[]                 RtxTimerStop();            CLOSED
                         Tx:PTA[]();
                         SessionTimerStop();
                         Disconnect();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

----------------------
State: WAIT_PAN_OR_PAR
----------------------

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+------------
- - - - - - - - - - - - - (PAR Processing)- - - - - - - - - - -
Rx:PAR[]                 TxEAP();                   WAIT_EAP_MSG
                         RtxTimerStop();
                         Tx:PAN[]();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - (Pass EAP Response to the EAP authenticator)- - - -
Rx:PAN[] &amp;&amp;              TxEAP();                   WAIT_EAP_MSG
PAN.exist_avp            RtxTimerStop();
("EAP-Payload")
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - - - - (PAN without an EAP response) - - - - - - -
Rx:PAN[] &amp;&amp;              RtxTimerStop();            WAIT_PAN_OR_PAR
!PAN.exist_avp
("EAP-Payload")
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - - - - - -(EAP retransmission) - - - - - - - - - -
EAP_REQUEST              RtxTimerStop();            WAIT_PAN_OR_PAR
                         Tx:PAR[]("EAP-Payload");
                         RtxTimerStart();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
- - - - - - - (EAP authentication timeout or failure)- - - - -
EAP_FAILURE ||           RtxTimerStop();            CLOSED
EAP_TIMEOUT              SessionTimerStop();
                         Disconnect();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

----------------
State: SESS_TERM
----------------

Exit Condition           Exit Action                Exit State
------------------------+--------------------------+------------
- - - - - - - - - - - - - -(PTA processing) - - - - - - - - - -
Rx:PTA[]                 RtxTimerStop();            CLOSED
                         Disconnect();
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
</pre></div>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Implementation Considerations</h3>

<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9.1"></a><h3>9.1.&nbsp;
PAA and PaC Interface to Service Management Entity</h3>

<p>
          In general, it is assumed each device or network equipment 
          has a PANA protocol stack available for use by other modules
          within the device or network equipment. One such module is the
          Service Management Entity (SME). The SME is a generic term for
          modules that manages different services (including network protocols) 
          that installed on a device or equipment. To integrate PANA protocol
          with the SME, it is recommended that a generic interface (i.e., 
          the SME-PANA interface) between the SME and the PANA protocol stack
          be provided by the implementation. This interface should include
          common procedures such as startup, shutdown and re-authenticate
          signals. It should also provision for extracting keying material.
          For the PAA, the SME-PANA interface should also provide a method
          for communicating filtering parameters to the EP(s) when
          cryptographic filtering is used. The filtering parameters include 
          keying material used for bootstrapping secured transport such
          as IPsec.  When a PAA device interacts with the backend authentication
          server using a AAA protocol, its SME may also provide an interface to the
          AAA protocol to obtain authorization parameters such as the authorization
          lifetime and additional filtering parameters.
	
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Security Considerations</h3>

<p>
      This document's intent is to describe the PANA state machines
      fully.  To this end, any security concerns with this document
      are likely a reflection of security concerns with PANA itself.
    
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
IANA Considerations</h3>

<p>
      This document has no actions for IANA.
    
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
Acknowledgments</h3>

<p>
	This work was started from state machines originally made by
	Dan Forsberg.
      
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.13"></a><h3>13.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>13.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC5191">[RFC5191]</a></td>
<td class="author-text">Forsberg, D., Ohba, Y., Patil, B., Tschofenig, H., and A. Yegin, &ldquo;<a href="http://tools.ietf.org/html/rfc5191">Protocol for Carrying Authentication for Network Access (PANA)</a>,&rdquo; RFC&nbsp;5191, May&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5191.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>13.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC4137">[RFC4137]</a></td>
<td class="author-text">Vollbrecht, J., Eronen, P., Petroni, N., and Y. Ohba, &ldquo;<a href="http://tools.ietf.org/html/rfc4137">State Machines for Extensible Authentication Protocol (EAP) Peer and Authenticator</a>,&rdquo; RFC&nbsp;4137, August&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4137.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc4137.pdf">PDF</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Victor Fajardo (editor)</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Toshiba America Research, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">1 Telcordia Drive</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Piscataway, NJ  08854</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 732 699 5368</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:vfajardo@tari.toshiba.com">vfajardo@tari.toshiba.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Yoshihiro Ohba</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Toshiba America Research, Inc.</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">1 Telcordia Drive</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Piscataway, NJ  08854</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+1 732 699 5305</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:yohba@tari.toshiba.com">yohba@tari.toshiba.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Rafa Marin Lopez</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">University of Murcia</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">30071 Murcia</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Spain</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:rafa@dif.um.es">rafa@dif.um.es</a></td></tr>
</table>
</body></html>
