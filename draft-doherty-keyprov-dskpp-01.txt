


KEYPROV Working Group                                         A. Doherty
Internet-Draft                         RSA, The Security Division of EMC
Intended status: Standards Track                                  M. Pei
Expires: January 9, 2008                                  VeriSign, Inc.
                                                             M. Nystroem
                                       RSA, The Security Division of EMC
                                                              S. Machani
                                                        Diversinet Corp.
                                                            July 8, 2007


          Dynamic Symmetric Key Provisioning Protocol (DSKPP)
                   draft-doherty-keyprov-dskpp-01.txt

Status of this Memo

   By submitting this Internet-Draft, each author represents that any
   applicable patent or other IPR claims of which he or she is aware
   have been or will be disclosed, and any of which he or she becomes
   aware will be disclosed, in accordance with Section 6 of BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on January 9, 2008.

Copyright Notice

   Copyright (C) The IETF Trust (2007).

Abstract

   DSKPP is a client-server protocol for initialization (and
   configuration) of symmetric keys to locally and remotely accessible
   cryptographic modules.  The protocol can be run with or without



Doherty, et al.          Expires January 9, 2008                [Page 1]


Internet-Draft                    DSKPP                        July 2007


   private-key capabilities in the cryptographic modules, and with or
   without an established public-key infrastructure.

   Three variations of the protocol support multiple usage scenarios.
   The four-pass (i.e., two round-trip) variant enables key generation
   in near real-time.  With the four-pass variant, keys are mutually
   generated by the provisioning server and cryptographic module;
   provisioned keys are not transferred over-the-wire or over-the-air.
   Two- and one-pass variants enable secure and efficient download and
   installation of symmetric keys to a cryptographic module in
   environments where near real-time communication may not be possible.

   This document builds on information contained in [RFC4758], adding
   specific enhancements in response to implementation experience and
   liaison requests.  It is intended, therefore, that this document or a
   successor version thereto will become the basis for subsequent
   progression of a symmetric key provisioning protocol specification on
   the standards track.

































Doherty, et al.          Expires January 9, 2008                [Page 2]


Internet-Draft                    DSKPP                        July 2007


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   7
     1.1.  Scope . . . . . . . . . . . . . . . . . . . . . . . . . .   7
     1.2.  Background  . . . . . . . . . . . . . . . . . . . . . . .   7
   2.  Notation and Terminology  . . . . . . . . . . . . . . . . . .   8
   3.  Use Cases . . . . . . . . . . . . . . . . . . . . . . . . . .   9
     3.1.  A cryptographic module obtains a symmetric key  . . . . .   9
     3.2.  A cryptographic module acquires multiple symmetric
           keys of different types . . . . . . . . . . . . . . . . .   9
     3.3.  A provisioning server imposes a validity period policy
           for provisioning sessions . . . . . . . . . . . . . . . .  10
     3.4.  A symmetric key issuer uses a third party provisioning
           service provider  . . . . . . . . . . . . . . . . . . . .  10
     3.5.  A cryptographic module renews its symmetric key with
           the same key ID . . . . . . . . . . . . . . . . . . . . .  10
     3.6.  An administrator initiates a symmetric key replacement
           before it can be used . . . . . . . . . . . . . . . . . .  10
     3.7.  A cryptographic module hosted by a smart card uses a
           pre-shared transport key to communicate with the
           provisioning server . . . . . . . . . . . . . . . . . . .  11
     3.8.  A cryptographic module hosted by a mobile device
           downloads a symmetric key through SMS . . . . . . . . . .  11
     3.9.  A cryptographic module acquires a symmetric key over a
           transport protocol that does not ensure data
           confidentiality . . . . . . . . . . . . . . . . . . . . .  12
     3.10. A cryptographic module acquires a symmetric key over a
           transport protocol that does not provide authentication .  12
   4.  DSKPP . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12
     4.1.  Entities  . . . . . . . . . . . . . . . . . . . . . . . .  12
     4.2.  Principles of Operation . . . . . . . . . . . . . . . . .  14
       4.2.1.  Four-pass DSKPP . . . . . . . . . . . . . . . . . . .  15
       4.2.2.  Two-pass DSKPP  . . . . . . . . . . . . . . . . . . .  19
       4.2.3.  One-pass DSKPP  . . . . . . . . . . . . . . . . . . .  21
     4.3.  Authentication  . . . . . . . . . . . . . . . . . . . . .  22
       4.3.1.  Client Authentication (Applicable to Four- and
               Two-Pass DSKPP) . . . . . . . . . . . . . . . . . . .  22
       4.3.2.  Server Authentication . . . . . . . . . . . . . . . .  25
     4.4.  Symmetric Key Container Format  . . . . . . . . . . . . .  25
     4.5.  The DSKPP One-Way Pseudorandom Function, DSKPP-PRF  . . .  25
       4.5.1.  Introduction  . . . . . . . . . . . . . . . . . . . .  25
       4.5.2.  Declaration . . . . . . . . . . . . . . . . . . . . .  26
     4.6.  Generation of Symmetric Keys for Cryptographic Modules  .  26
     4.7.  Encryption of Pseudorandom Nonces Sent from the DSKPP
           Client  . . . . . . . . . . . . . . . . . . . . . . . . .  27
     4.8.  MAC calculations  . . . . . . . . . . . . . . . . . . . .  27
       4.8.1.  Four-pass DSKPP . . . . . . . . . . . . . . . . . . .  27
       4.8.2.  Two-pass DSKPP  . . . . . . . . . . . . . . . . . . .  28



Doherty, et al.          Expires January 9, 2008                [Page 3]


Internet-Draft                    DSKPP                        July 2007


       4.8.3.  One-pass DSKPP  . . . . . . . . . . . . . . . . . . .  29
     4.9.  DSKPP Schema Basics . . . . . . . . . . . . . . . . . . .  30
       4.9.1.  The AbstractRequestType Type  . . . . . . . . . . . .  31
       4.9.2.  The AbstractResponseType Type . . . . . . . . . . . .  31
       4.9.3.  The VersionType Type  . . . . . . . . . . . . . . . .  32
       4.9.4.  The IdentifierType Type . . . . . . . . . . . . . . .  32
       4.9.5.  The StatusCode Type . . . . . . . . . . . . . . . . .  32
       4.9.6.  The DeviceIdentifierDataType Type . . . . . . . . . .  34
       4.9.7.  The TokenPlatformInfoType and PlatformType Types  . .  35
       4.9.8.  The NonceType Type  . . . . . . . . . . . . . . . . .  35
       4.9.9.  The AlgorithmsType Type . . . . . . . . . . . . . . .  36
       4.9.10. The ProtocolVariantsType and the
               TwoPassSupportType Types  . . . . . . . . . . . . . .  36
       4.9.11. The KeyContainersFormatTypeType . . . . . . . . . . .  37
       4.9.12. The AuthenticationDataType Type . . . . . . . . . . .  38
       4.9.13. The PayloadType Type  . . . . . . . . . . . . . . . .  40
       4.9.14. The MacType Type  . . . . . . . . . . . . . . . . . .  40
       4.9.15. The KeyContainerType Type . . . . . . . . . . . . . .  40
       4.9.16. The ExtensionsType and the AbstractExtensionType
               Types . . . . . . . . . . . . . . . . . . . . . . . .  41
     4.10. DSKPP Messages  . . . . . . . . . . . . . . . . . . . . .  41
       4.10.1. Introduction  . . . . . . . . . . . . . . . . . . . .  41
       4.10.2. DSKPP Initialization (OPTIONAL) . . . . . . . . . . .  41
       4.10.3. The DSKPP Client's Initial PDU (2- and 4-Pass)  . . .  43
       4.10.4. The DSKPP Server's Initial PDU (4-Pass Only)  . . . .  46
       4.10.5. The DSKPP Client's Second PDU (4-Pass Only) . . . . .  47
       4.10.6. The DSKPP Server's Final PDU (1-, 2-, and 4-Pass) . .  48
     4.11. Protocol Extensions . . . . . . . . . . . . . . . . . . .  50
       4.11.1. The ClientInfoType Type . . . . . . . . . . . . . . .  50
       4.11.2. The ServerInfoType Type . . . . . . . . . . . . . . .  50
       4.11.3. The KeyInitializationDataType Type  . . . . . . . . .  51
   5.  Protocol Bindings . . . . . . . . . . . . . . . . . . . . . .  52
     5.1.  General Requirements  . . . . . . . . . . . . . . . . . .  52
     5.2.  HTTP/1.1 Binding for DSKPP  . . . . . . . . . . . . . . .  52
       5.2.1.  Introduction  . . . . . . . . . . . . . . . . . . . .  52
       5.2.2.  Identification of DSKPP Messages  . . . . . . . . . .  53
       5.2.3.  HTTP Headers  . . . . . . . . . . . . . . . . . . . .  53
       5.2.4.  HTTP Operations . . . . . . . . . . . . . . . . . . .  53
       5.2.5.  HTTP Status Codes . . . . . . . . . . . . . . . . . .  53
       5.2.6.  HTTP Authentication . . . . . . . . . . . . . . . . .  54
       5.2.7.  Initialization of DSKPP . . . . . . . . . . . . . . .  54
       5.2.8.  Example Messages  . . . . . . . . . . . . . . . . . .  54
   6.  DSKPP Schema  . . . . . . . . . . . . . . . . . . . . . . . .  55
   7.  Security Considerations . . . . . . . . . . . . . . . . . . .  63
     7.1.  General . . . . . . . . . . . . . . . . . . . . . . . . .  63
     7.2.  Active Attacks  . . . . . . . . . . . . . . . . . . . . .  63
       7.2.1.  Introduction  . . . . . . . . . . . . . . . . . . . .  63
       7.2.2.  Message Modifications . . . . . . . . . . . . . . . .  64



Doherty, et al.          Expires January 9, 2008                [Page 4]


Internet-Draft                    DSKPP                        July 2007


       7.2.3.  Message Deletion  . . . . . . . . . . . . . . . . . .  65
       7.2.4.  Message Insertion . . . . . . . . . . . . . . . . . .  65
       7.2.5.  Message Replay  . . . . . . . . . . . . . . . . . . .  66
       7.2.6.  Message Reordering  . . . . . . . . . . . . . . . . .  66
       7.2.7.  Man-in-the-Middle . . . . . . . . . . . . . . . . . .  66
     7.3.  Passive Attacks . . . . . . . . . . . . . . . . . . . . .  66
     7.4.  Cryptographic Attacks . . . . . . . . . . . . . . . . . .  67
     7.5.  Attacks on the Interaction between DSKPP and User
           Authentication  . . . . . . . . . . . . . . . . . . . . .  67
     7.6.  Additional Considerations Specific to 2- and 1-pass
           DSKPP . . . . . . . . . . . . . . . . . . . . . . . . . .  68
       7.6.1.  Client Contributions to K_TOKEN Entropy . . . . . . .  68
       7.6.2.  Key Confirmation  . . . . . . . . . . . . . . . . . .  68
       7.6.3.  Server Authentication . . . . . . . . . . . . . . . .  68
       7.6.4.  Client Authentication . . . . . . . . . . . . . . . .  68
       7.6.5.  Key Protection in the Passphrase Profile  . . . . . .  69
   8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  70
   9.  Intellectual Property Considerations  . . . . . . . . . . . .  70
   10. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  70
   11. References  . . . . . . . . . . . . . . . . . . . . . . . . .  70
     11.1. Normative references  . . . . . . . . . . . . . . . . . .  70
     11.2. Informative references  . . . . . . . . . . . . . . . . .  71
   Appendix A.  Key Initialization Profiles of DSKPP . . . . . . . .  72
     A.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . .  73
     A.2.  Key Transport Profile . . . . . . . . . . . . . . . . . .  73
       A.2.1.  Introduction  . . . . . . . . . . . . . . . . . . . .  73
       A.2.2.  Identification  . . . . . . . . . . . . . . . . . . .  73
       A.2.3.  Payloads  . . . . . . . . . . . . . . . . . . . . . .  73
     A.3.  Key wrap profile  . . . . . . . . . . . . . . . . . . . .  74
       A.3.1.  Introduction  . . . . . . . . . . . . . . . . . . . .  74
       A.3.2.  Identification  . . . . . . . . . . . . . . . . . . .  74
       A.3.3.  Payloads  . . . . . . . . . . . . . . . . . . . . . .  74
     A.4.  Passphrase-based key wrap profile . . . . . . . . . . . .  76
       A.4.1.  Introduction  . . . . . . . . . . . . . . . . . . . .  76
       A.4.2.  Identification  . . . . . . . . . . . . . . . . . . .  76
       A.4.3.  Payloads  . . . . . . . . . . . . . . . . . . . . . .  76
   Appendix B.  Example Messages . . . . . . . . . . . . . . . . . .  77
     B.1.  Example Messages in a Four-pass Exchange  . . . . . . . .  77
       B.1.1.  Example of a DSKPP Initialization (Trigger) Message .  78
       B.1.2.  Example of a <ClientHello> Message  . . . . . . . . .  79
       B.1.3.  Example of a <ServerHello> Message  . . . . . . . . .  80
       B.1.4.  Example of a <ClientNonce> Message  . . . . . . . . .  80
       B.1.5.  Example of a <ServerFinished> Message . . . . . . . .  80
     B.2.  Example Messages in a Two- or One-pass Exchange . . . . .  81
       B.2.1.  Example of a <ClientHello> Message Indicating
               Support for Two-pass DSKPP  . . . . . . . . . . . . .  81
       B.2.2.  Example of a <ServerFinished> Message Using the
               Key Transport Profile . . . . . . . . . . . . . . . .  83



Doherty, et al.          Expires January 9, 2008                [Page 5]


Internet-Draft                    DSKPP                        July 2007


       B.2.3.  Example of a <ServerFinished> Message Using the
               Key Wrap Profile  . . . . . . . . . . . . . . . . . .  85
       B.2.4.  Example of a <ServerFinished> Message using the
               Passphrase-based Key Wrap Profile . . . . . . . . . .  86
   Appendix C.  Requirements . . . . . . . . . . . . . . . . . . . .  88
   Appendix D.  Integration with PKCS #11  . . . . . . . . . . . . .  90
     D.1.  The 4-pass Variant  . . . . . . . . . . . . . . . . . . .  91
     D.2.  The 2-pass Variant  . . . . . . . . . . . . . . . . . . .  91
     D.3.  The 1-pass Variant  . . . . . . . . . . . . . . . . . . .  93
   Appendix E.  Example of DSKPP-PRF Realizations  . . . . . . . . .  95
     E.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . .  96
     E.2.  DSKPP-PRF-AES . . . . . . . . . . . . . . . . . . . . . .  96
       E.2.1.  Identification  . . . . . . . . . . . . . . . . . . .  96
       E.2.2.  Definition  . . . . . . . . . . . . . . . . . . . . .  96
       E.2.3.  Example . . . . . . . . . . . . . . . . . . . . . . .  97
     E.3.  DSKPP-PRF-SHA256  . . . . . . . . . . . . . . . . . . . .  97
       E.3.1.  Identification  . . . . . . . . . . . . . . . . . . .  97
       E.3.2.  Definition  . . . . . . . . . . . . . . . . . . . . .  98
       E.3.3.  Example . . . . . . . . . . . . . . . . . . . . . . .  99
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  99
   Intellectual Property and Copyright Statements  . . . . . . . . . 100






























Doherty, et al.          Expires January 9, 2008                [Page 6]


Internet-Draft                    DSKPP                        July 2007


1.  Introduction

1.1.  Scope

   This document describes a client-server protocol for initialization
   (and configuration) of symmetric keys to locally and remotely
   accessible cryptographic modules.  The protocol can be run with or
   without private-key capabilities in the cryptographic modules, and
   with or without an established public-key infrastructure.  The
   objectives of this protocol are to:

   o     Provide a secure method of initializing cryptographic modules
         with symmetric keys without exposing generated, secret material
         to any other entities than the server and the cryptographic
         module itself.
   o     Provide a secure method of generating and transporting
         symmetric keys to a cryptographic module in environments where
         near real-time communication is not possible.
   o     Provide a secure method of transporting pre-generated (i.e.,
         legacy) keys to a cryptographic module.
   o     Provide a solution that is easy to administer and scales well.

   The mechanism is intended for general use within computer and
   communications systems employing symmetric cryptographic modules that
   are locally (i.e., over-the-wire) or remotely (i.e., over-the-air)
   accessible.

1.2.  Background

   A symmetric cryptographic module may be hosted by a hand-held
   hardware device (e.g., a mobile phone), a hardware device connected
   to a personal computer through an electronic interface, such as USB,
   or a software application resident on a personal computer.  The
   cryptographic module offers symmetric cryptographic functionality
   that may be used to authenticate a user towards some service, perform
   data encryption, etc.  Increasingly, these modules enable their
   programmatic initialization as well as programmatic retrieval of
   their output values.  This document intends to meet the need for an
   open and inter-operable mechanism to programmatically initialize and
   configure symmetric keys to locally and remotely accessible
   cryptographic modules.

   The target mechanism addressed herein is a symmetric key provisioning
   server.  In an ideal deployment scenario, near real-time
   communication is possible between the provisioning server and the
   cryptographic module.  In such an environment, it is possible for the
   cryptographic module and provisioning server to mutually generate a
   symmetric key, and to ensure that keys are not transported between



Doherty, et al.          Expires January 9, 2008                [Page 7]


Internet-Draft                    DSKPP                        July 2007


   them.

   There are, however, several deployment scenarios that make mutual key
   generation less suitable.  Specifically, scenarios where near real-
   time communication between the symmetric key provisioning server and
   the cryptographic module is not possible, and scenarios with
   significant design constraints.  Examples include work-flow
   constraints (e.g., policies that require incremental administrative
   approval), network design constraints that create network latency,
   and budget constraints that sustain reliance upon legacy systems that
   already have supplies of pre-generated keys.  In these situations,
   the cryptographic module is required to download and install a
   symmetric key from the provisioning server in a secure and efficient
   manner.

   This document tries to meet the needs of these scenarios by
   describing three variations to DSKPP for the provisioning of
   symmetric keys in two round trips or less.  The four-pass (i.e., two
   round-trip) variant enables key generation in near real-time.  With
   this variant, keys are mutually generated by the provisioning server
   and cryptographic module; provisioned keys are not transferred over-
   the-wire or over-the-air.  In contrast, two- and one-pass variants
   enable secure and efficient download and installation of symmetric
   keys to a cryptographic module in environments where near real-time
   communication is not possible.


2.  Notation and Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

   The following notations are used in this document:

   ||              String concatenation
   [x]             Optional element x
   A ^ B           Exclusive-OR operation on strings A and B (where A
                   and B are of equal length)
   DSKPP client    Manages communication between the symmetric
                   cryptographic module and the DSKPP server
   DSKPP server    The symmetric key provisioning server that
                   participates in the DSKPP protocol run
   ID_C            Identifier for DSKPP client







Doherty, et al.          Expires January 9, 2008                [Page 8]


Internet-Draft                    DSKPP                        July 2007


   ID_S            Identifier for DSKPP server
   K               Key used to encrypt R_C (either K_SERVER or K_SHARED)
   K_AUTH          Secret key used for server authentication purposes in
                   4-pass DSKPP
   K_CLIENT        Public key of the DSKPP client
   K_DERIVED       Secret key derived from a passphrase that is known to
                   both the DSKPP client or user and the DSKPP server
   K_MAC           Secret key used for key confirmation and server
                   authentication purposes, and generated in DSKPP
   K_MAC'          A second secret key used for server authentication
                   purposes in 2- and 1-pass DSKPP
   K_SERVER        Public key of the DSKPP server
   K_SHARED        Secret key shared between the DSKPP client and the
                   DSKPP server
   K_TOKEN         Secret key used for cryptographic module
                   computations, and generated in DSKPP
   R               Pseudorandom value chosen by the DSKPP client and
                   used for MAC computations, which is mandatory for
                   2-pass DSKPP and optional for 4-pass
   R_C             Pseudorandom value chosen by the DSKPP client and
                   used as input to the generation of K_TOKEN
   R_S             Pseudorandom value chosen by the DSKPP server and
                   used as input to the generation of K_TOKEN

   The following typographical convention is used in the body of the
   text: <XMLElement>.


3.  Use Cases

   This section describes typical use cases.

3.1.  A cryptographic module obtains a symmetric key

   A cryptographic module hosted by a device, such as a mobile phone,
   makes a request for a symmetric key from a provisioning server.
   Depending upon how the system is deployed, the provisioning server
   may generate a new key on-the-fly or use a pre-generated key, e.g.,
   one provided by a legacy back-end issuance server.  The provisioning
   server assigns a unique key ID to the symmetric key and provisions it
   to the cryptographic module.

3.2.  A cryptographic module acquires multiple symmetric keys of
      different types

   A cryptographic module makes multiple requests for symmetric keys
   from the same provisioning server.  The symmetric keys may or may not
   be of the same type, i.e., the keys may be used with different



Doherty, et al.          Expires January 9, 2008                [Page 9]


Internet-Draft                    DSKPP                        July 2007


   symmetric cryptographic algorithms, including the HMAC-Based One-Time
   Password (HOTP), RSA SecurID, challenge-response, etc.

3.3.  A provisioning server imposes a validity period policy for
      provisioning sessions

   Once a cryptographic module initiates a symmetric key request, the
   provisioning server may require that any subsequent actions to
   complete the provisioning cycle occur within a certain time window.
   For example, an issuer may provide a time-limited authentication code
   to a user during registration, which the user will input into the
   cryptographic module to authenticate themselves with the provisioning
   server.  As long as the user inputs a valid authentication code
   within the fixed time period established by the issuer, the server
   will provision a key to the cryptographic module hosted by the user's
   device.

3.4.  A symmetric key issuer uses a third party provisioning service
      provider

   A symmetric key issuer outsources its key provisioning to a third
   party key provisioning server provider.  The issuer is responsible
   for authenticating and granting rights to users to acquire keys while
   acting as a proxy to the cryptographic module to acquire symmetric
   keys from the provisioning server; the cryptographic module
   communicates with the issuer proxy server, which forwards
   provisioning requests to the provisioning server.

3.5.  A cryptographic module renews its symmetric key with the same key
      ID

   A cryptographic module requests renewal of a symmetric key using the
   same key ID already associated with the key.  Such a need may occur
   in the case when a user wants to upgrade her device that houses the
   cryptographic module or when a key has expired.  When a user uses the
   same cryptographic module to, for example, perform strong
   authentication at multiple Web login sites, keeping the same key ID
   removes the need for the user to register a new key ID at each site.

3.6.  An administrator initiates a symmetric key replacement before it
      can be used

   This use case represents a special case of symmetric key renewal in
   which a local administrator can authenticate the user procedurally
   before initiating the provisioning process.  It also allows for an
   issuer to pre-load a key onto a cryptographic module with a
   restriction that the key is replaced with a new key prior to use of
   the cryptographic module.



Doherty, et al.          Expires January 9, 2008               [Page 10]


Internet-Draft                    DSKPP                        July 2007


   Bulk initialization under controlled conditions, e.g., during
   manufacture, is likely to meet the security needs of most
   applications.  However, reliance on a pre-disclosed secret is
   unacceptable in some circumstances.  One such circumstance is when
   cryptographic modules are issued for classified government use or
   high security applications.  In such cases, the issuer requires the
   ability to remove all secret information already installed on the
   cryptographic module and replace it with symmetric keys established
   under conditions controlled by the issuer.

   Another variation of this use case is the issuer who recycles
   devices.  In this case, an issuer would provision a new symmetric key
   to a cryptographic module hosted on a device that was previously
   owned by another user.

   Note that this use case is essentially the same as the last use case
   wherein the same key ID is used for renewal.

3.7.  A cryptographic module hosted by a smart card uses a pre-shared
      transport key to communicate with the provisioning server

   A cryptographic module is loaded onto a smart card after the card is
   issued to a user.  The symmetric key for the cryptographic module
   will then be provisioned using a secure channel mechanism present in
   many smart card platforms.  This allows a direct secure channel to be
   established between the smart card chip and the provisioning server.
   For example, the card commands (i.e., Application Protocol Data
   Units, or APDUs) are encrypted with a pre-shared transport key and
   sent directly to the smart card chip, allowing secure post-issuance
   in-the-field provisioning.  This secure flow can pass Transport Layer
   Security (TLS) and other transport security boundaries.

   Note that two pre-conditions for this use case are for the protocol
   to be tunneled and the provisioning server to know the correct pre-
   established transport key.

3.8.  A cryptographic module hosted by a mobile device downloads a
      symmetric key through SMS

   A mobile device supports Short Message Service (SMS) but is not able
   to support a data service allowing for HTTP or HTTPS transports.  In
   addition, the cryptographic module can ensure that SMS will provide
   an acceptable level of protection for download of the symmetric key.
   In such a case, the cryptographic module hosted by the mobile device
   may initiate a symmetric key request from a desktop computer and ask
   the server to send the key to the mobile device through SMS.  User
   authentication is carried out via the online communication
   established between the desktop computer and the provisioning server.



Doherty, et al.          Expires January 9, 2008               [Page 11]


Internet-Draft                    DSKPP                        July 2007


3.9.  A cryptographic module acquires a symmetric key over a transport
      protocol that does not ensure data confidentiality

   Some devices are not able to support a secure transport channel such
   as SSL or TLS to provide data confidentiality.  A cryptographic
   module hosted by such a device requests a symmetric key from the
   provisioning server.  It is up to DSKPP to ensure data
   confidentiality over non-secure networks.

3.10.  A cryptographic module acquires a symmetric key over a transport
       protocol that does not provide authentication

   Some devices are not able to use a transport protocol that provides
   server authentication such as SSL or TLS.  A cryptographic module
   hosted by such a device wants to be sure that it sends a request for
   a symmetric key to a legitimate provisioning server.  It is up to
   DSKPP to provide proper client and server authentication.


4.  DSKPP

4.1.  Entities

   In principle, the protocol involves a DSKPP client and a DSKPP
   server.  The DSKPP client manages communication between the
   cryptographic module and the provisioning server.  The DSKPP server
   herein represents the provisioning server.

   A high-level object model that describes the client-side entities and
   how they relate to each other is shown in Figure 1.  Conceptually,
   each entity represents the following:

   User                    The person or client to whom devices are
                           issued
   UserID                  A unique identifier for the user or client
   Device                  A physical piece of hardware that hosts
                           symmetric cryptographic modules
   DeviceID                A unique identifier for the device
   Cryptographic Module    A low-level component of an application,
                           which enables symmetric cryptographic
                           functionality
   CryptoModuleID          A unique identifier for an instance of the
                           cryptographic module
   Encryption Algorithms   Encryption algorithms supported by the
                           cryptographic module






Doherty, et al.          Expires January 9, 2008               [Page 12]


Internet-Draft                    DSKPP                        July 2007


   MAC Algorithms          MAC algorithms supported by the cryptographic
                           module
   Key Container           An object that encapsulates a symmetric key
                           and its configuration data
   KeyID                   A unique identifier for the symmetric key
   Key Type                The type of symmetric cryptographic methods
                           for which the key will be used (e.g., OATH
                           HOTP or RSA SecurID authentication, AES
                           encryption, etc.)

   -----------          -------------
   | User    |          | Device    |
   |---------|*  owns  *|-----------|
   | UserID  |--------->| DeviceID  |
   | ...     |          | ...       |
   -----------          -------------
                            | 1
                            |
                            | contains
                            |
                            | *
                            V
                      -----------------------
                      |Cryptographic Module |
                      |---------------------|
                      |CryptoModuleID
                      |Encryption Algorithms|
                      |MAC Algorithms       |
                      |...                  |
                      -----------------------
                            | 1
                            |
                            | contains
                            |
                            | *
                            V
                      -----------------------
                      |Key Container        |
                      |---------------------|
                      |KeyID                |
                      |Key Type             |
                      |...                  |
                      -----------------------

                          Figure 1: Object Model

   It is assumed that a device will host an application layered above
   the cryptographic module, and this application will manage



Doherty, et al.          Expires January 9, 2008               [Page 13]


Internet-Draft                    DSKPP                        July 2007


   communication between the DSKPP client and cryptographic module.  The
   manner in which the communicating application will transfer DSKPP
   protocol elements to and from the cryptographic module is transparent
   to the DSKPP server.  One method for this transfer is described in
   [CT-KIP-P11].

4.2.  Principles of Operation

   To initiate a DSKPP session, a user may use a browser to connect to a
   web server.  The user may then identify and optionally authenticate
   herself and possibly indicate how the DSKPP client has to contact the
   DSKPP server.  There are also other alternatives for DSKPP session
   initiation, such as the DSKPP client being pre-configured to contact
   a certain DSKPP server, or the user being informed out-of-band about
   the address of the DSKPP server.

   Once the location of the DSKPP server is known, the DSKPP client and
   the DSKPP server engage in a 4-pass, 2-pass, or 1-pass protocol.
   With the four-pass variant, keys are mutually generated by the
   provisioning server and cryptographic module; provisioned keys are
   not transferred over-the-wire or over-the-air.  Two- and one-pass
   variants enable secure and efficient download and installation of
   symmetric keys to a cryptographic module in environments where near
   real-time communication may not be possible.

   DSKPP protocol variants may be applied to the use cases described in
   Section 3, as shown below:
























Doherty, et al.          Expires January 9, 2008               [Page 14]


Internet-Draft                    DSKPP                        July 2007


   ==========================================================
   Protocol   Applicable                Applicable
   Variant    Use Cases                 Deployment Scenarios
   ==========================================================
   4-pass     All but 3.6 and           Near real-time
              3.8 if mutual key         communication is
              generation is desired;    possible
              none if transport of
              a pre-generated key
              is required
   -----------------------------------------------------------
   2-pass     All                       Either near real-time
                                        or non real-time
                                        communication may be
                                        possible
   -----------------------------------------------------------
   1-pass     All but 3.8               Either near real-time
                                        or non real-time
                                        communication may be
                                        possible
    ==========================================================

            Figure 2: Mapping of use cases to protocol variants

4.2.1.  Four-pass DSKPP

   The 4-pass protocol flow is suitable for environments wherein there
   is near real-time communication possible between the DSKPP client and
   DSKPP server.  It is not suitable for environments wherein
   administrative approval is a required step in the flow, nor for
   provisioning of pre-generated keys.  The 4-pass protocol flow, shown
   in Figure 3 and expanded in Figure 4, consists of two round trips
   between the DSKPP client and server.


















Doherty, et al.          Expires January 9, 2008               [Page 15]


Internet-Draft                    DSKPP                        July 2007


   +---------------+                            +---------------+
   |               |                            |               |
   |  DSKPP client |                            |  DSKPP server |
   |               |                            |               |
   +---------------+                            +---------------+
           |                                            |
           |        [ <---- DSKPP trigger ----- ]       |
           |                                            |
           |        ------- Client Hello ------->       |
           |                                            |
           |        <------ Server Hello --------       |
           |                                            |
           |        ------- Client Nonce ------->       |
           |                                            |
           |        <----- Server Finished ------       |
           |                                            |

       Figure 3: The 4-pass DSKPP protocol (with OPTIONAL preceeding
                                 trigger)

   a.    The DSKPP client sends a <ClientHello> message to the DSKPP
         server.  The message provides information to the DSKPP server
         about the DSKPP versions, protocol variants, key types,
         encryption and MAC algorithms supported by the cryptographic
         module for the purposes of this protocol.  The message may also
         include client authentication data, such as a certificate or
         authentication code.
   b.    The DSKPP server responds to the DSKPP client with a
         <ServerHello> message, whose content includes a random nonce,
         R_S, along with information about the type of key to generate,
         and the encryption algorithm chosen to protect sensitive data
         sent in the protocol.  The length of the nonce R_S may depend
         on the selected key type.  The <ServerHello> message also
         provides information about either a shared secret key to use
         for encrypting the cryptographic module's random nonce (see
         description of <ClientNonce> below), or its own public key.
         Optionally, <ServerHello> may include a MAC that the DSKPP
         client may use for server authentication.
   c.    Based on information contained in the <ServerHello> message,
         the cryptographic module generates a random nonce, R_C. The
         length of the nonce R_C may depend on the selected key type.
         The cryptographic module encrypts R_C using the selected
         encryption algorithm and with a key, K, that is either the
         DSKPP server's public key, K_SERVER, or a shared secret key,
         K_SHARED, as indicated by the DSKPP server.  If K is equivalent
         to K_SERVER, then the cryptographic module SHOULD verify the
         server's certificate before using it to encrypt R_C. The DSKPP
         client then sends the encrypted random nonce to the DSKPP



Doherty, et al.          Expires January 9, 2008               [Page 16]


Internet-Draft                    DSKPP                        July 2007


         server in a <ClientNonce> message, and may include client
         authentication data, such as a certificate or authentication
         code.  Finally, the cryptographic module calculates a symmetric
         key, K_TOKEN, of the selected type from the combination of the
         two random nonces R_S and R_C, the encryption key K, and
         possibly some other data, using the DSKPP-PRF function defined
         in Section 4.5.
   d.    The DSKPP server decrypts R_C, calculates K_TOKEN from the
         combination of the two random nonces R_S and R_C, the
         encryption key K, and possibly some other data, using the
         DSKPP-PRF function defined in Section 4.5.  The server then
         associates K_TOKEN with the cryptographic module in a server-
         side data store.  The intent is that the data store later on
         will be used by some service that needs to verify or decrypt
         data produced by the cryptographic module and the key.
   e.    Once the association has been made, the DSKPP server sends a
         confirmation message to the DSKPP client called
         <ServerFinished>.  The confirmation message includes a key
         container that holds an identifier for the generated key (but
         not the key itself) and additional configuration information,
         e.g., the identity of the DSKPP server.  Optionally,
         <ServerFinished> may include a MAC that the DSKPP client may
         use for server authentication.
   f.    Upon receipt of the DSKPP server's confirmation message, the
         cryptographic module associates the provided key container with
         the generated key K_TOKEN, and stores any provided
         configuration data.
   Note: Conceptually, although R_C is one pseudorandom string, it may
   be viewed as consisting of two components, R_C1 and R_C2, where R_C1
   is generated during the protocol run, and R_C2 can be pre-generated
   and loaded on the cryptographic module before the device is issued to
   the user.  In that case, the latter string, R_C2, SHOULD be unique
   for each cryptographic module.

   The inclusion of the two random nonces R_S and R_C in the key
   generation provides assurance to both sides (the cryptographic module
   and the DSKPP server) that they have contributed to the key's
   randomness and that the key is unique.  The inclusion of the
   encryption key K ensures that no man-in-the-middle MAY be present, or
   else the cryptographic module will end up with a key different from
   the one stored by the legitimate DSKPP server.

   Note: A man-in-the-middle (in the form of corrupt client software or
   a mistakenly contacted server) MAY present his own public key to the
   cryptographic module.  This will enable the attacker to learn the
   client's version of K_TOKEN.  However, the attacker is not able to
   persuade the legitimate server to derive the same value for K_TOKEN,
   since K_TOKEN is a function of the public key involved, and the



Doherty, et al.          Expires January 9, 2008               [Page 17]


Internet-Draft                    DSKPP                        July 2007


   attacker's public key must be different than the correct server's (or
   else the attacker would not be able to decrypt the information
   received from the client).  Therefore, once the attacker is no longer
   "in the middle," the client and server will detect that they are "out
   of synch" when they try to use their keys.  In the case of encrypting
   R_C with K_SERVER, it is therefore important to verify that K_SERVER
   really is the legitimate server's key.  One way to do this is to
   independently validate a newly generated K_TOKEN against some
   validation service at the server (e.g. by using a connection
   independent from the one used for the key generation).

   +----------------------+    +-------+     +----------------------+
   |    +------------+    |    |       |     |                      |
   |    | Server key |    |    |       |     |                      |
   | +<-|  Public    |------>------------->-------------+---------+ |
   | |  |  Private   |    |    |       |     |          |         | |
   | |  +------------+    |    |       |     |          |         | |
   | |        |           |    |       |     |          |         | |
   | V        V           |    |       |     |          V         V |
   | |   +---------+      |    |       |     |        +---------+ | |
   | |   | Decrypt |<-------<-------------<-----------| Encrypt | | |
   | |   +---------+      |    |       |     |        +---------+ | |
   | |      |  +--------+ |    |       |     |            ^       | |
   | |      |  | Server | |    |       |     |            |       | |
   | |      |  | Random |--->------------->------+  +----------+  | |
   | |      |  +--------+ |    |       |     |   |  | Client   |  | |
   | |      |      |      |    |       |     |   |  | Random   |  | |
   | |      |      |      |    |       |     |   |  +----------+  | |
   | |      |      |      |    |       |     |   |        |       | |
   | |      V      V      |    |       |     |   V        V       | |
   | |   +------------+   |    |       |     | +------------+     | |
   | +-->|  DSKPP PRF |   |    |       |     | |  DSKPP PRF |<----+ |
   |     +------------+   |    |       |     | +------------+       |
   |           |          |    |       |     |       |              |
   |           V          |    |       |     |       V              |
   |       +-------+      |    |       |     |   +-------+          |
   |       |  Key  |      |    |       |     |   |  Key  |          |
   |       +-------+      |    |       |     |   +-------+          |
   |       +-------+      |    |       |     |   +-------+          |
   |       |Key Id |-------->------------->------|Key Id |          |
   |       +-------+      |    |       |     |   +-------+          |
   +----------------------+    +-------+     +----------------------+
         DSKPP Server         DSKPP Client         DSKPP Client
                               (PC Host)      (cryptographic module)

   Figure 4: Principal data flow for DSKPP key generation             -
                          using public server key




Doherty, et al.          Expires January 9, 2008               [Page 18]


Internet-Draft                    DSKPP                        July 2007


4.2.2.  Two-pass DSKPP

   The 2-pass protocol flow is suitable for environments wherein near
   real-time communication between the DSKPP client and server may not
   be possible.  It is also suitable for environments wherein
   administrative approval is a required step in the flow, and for
   provisioning of pre-generated keys.  In the 2-pass protocol flow,
   shown in Figure 5, the client's initial <ClientHello> message is
   directly followed by a <ServerFinished> message.  There is no
   exchange of the <ServerHello> message or the <ClientNonce> message.
   However, as the two-pass variant of DSKPP consists of one round trip
   to the server, the client is still able to include its random nonce,
   R_C, algorithm preferences and supported key types in the
   <ClientHello> message.  Note than by including R_C in <ClientHello>,
   the DSKPP client is able to ensure the server is alive before
   "commiting" the key.  Also note that the DSKPP "trigger" message MAY
   be used to trigger the client's sending of the <ClientHello> message.

   Essentially, two-pass DSKPP is a transport of key material from the
   DSKPP server to the DSKPP client.  Two-pass DSKPP supports multiple
   key initialization methods that ensure K_TOKEN is not exposed to any
   other entity than the DSKPP server and the cryptographic module
   itself.  Currently, three such key initialization methods are defined
   (refer to Appendix A), each supporting a different usage of 2-pass
   DSKPP:

   Key Transport               This profile is intended for PKI-capable
                               devices.  Key transport is carried out
                               using a public key, K_CLIENT, whose
                               private key part resides in the
                               cryptographic module as the transport
                               key.
   Key Wrap                    This profile is ideal for pre-keyed
                               devices, e.g., SIM cards.  Key wrap is
                               carried out using a symmetric key-
                               wrapping key, K_SHARED, which is known in
                               advance by both the cryptographic module
                               and the DSKPP server.
   Passphrase-based Key Wrap   This profile is a variation of the Key
                               Wrap Profile.  It is applicable to
                               constrained devices with keypads, e.g.,
                               mobile phones.  Key wrap is carried out
                               using a passphrase-derived key-wrapping
                               key, K_DERIVED, which is known in advance
                               by both the cryptographic module and
                               DSKPP server.





Doherty, et al.          Expires January 9, 2008               [Page 19]


Internet-Draft                    DSKPP                        July 2007


   +---------------+                            +---------------+
   |               |                            |               |
   |  DSKPP client |                            |  DSKPP server |
   |               |                            |               |
   +---------------+                            +---------------+
           |                                            |
           |        [ <---- DSKPP trigger ----- ]       |
           |                                            |
           |        ------- Client Hello ------->       |
           |                                            |
           |        <----- Server Finished ------       |
           |                                            |

   Figure 5: The 2-pass DSKPP protocol (with OPTIONAL preceding trigger)

   a.    The DSKPP client sends a <ClientHello> message to the DSKPP
         server.  The message provides the client nonce, R_C, and
         information about the DSKPP versions, protocol variants, key
         types, encryption and MAC algorithms supported by the
         cryptographic module for the purposes of this protocol.  The
         message may also include client authentication data, such as a
         certificate or authentication code.  Unlike 4-pass DSKPP,
         2-pass DSKPP client uses the <ClientHello> message to declare
         which key initialization method it supports, providing required
         payload information, e.g., K_CLIENT for the Key Transport
         Profile.
   b.    The DSKPP server generates a key K from which two keys, K_TOKEN
         and K_MAC are derived.  K is either transported or wrapped in
         accordance with the key initialization method specified by the
         DSKPP client in the <ClientHello> message.  The server then
         associates K_TOKEN with the cryptographic module in a server-
         side data store.  The intent is that the data store later on
         will be used by some service that needs to verify or decrypt
         data produced by the cryptographic module and the key.
   c.    Once the association has been made, the DSKPP server sends a
         confirmation message to the DSKPP client called
         <ServerFinished>.  The confirmation message includes a key
         container that holds an identifier for the key, the key K from
         which K_TOKEN and K_MAC are derived, and additional
         configuration information (note that the latter MUST include
         the identity of the DSKPP server for authentication purposes).
         In addition, <ServerFinished> MUST include two MACs whose
         values are calculated with contribution from the client nonce,
         R_C, provided in the <ClientHello> message.  The MAC values
         will allow the cryptographic module to perform key confirmation
         and server authentication before "commiting" the key.





Doherty, et al.          Expires January 9, 2008               [Page 20]


Internet-Draft                    DSKPP                        July 2007


   d.    Upon receipt of the DSKPP server's confirmation message, the
         cryptographic module extracts the key data from the provided
         key container, uses the two MAC values to perform key
         confirmation and server authentication, and stores the key
         material locally.

4.2.3.  One-pass DSKPP

   The one-pass protocol flow is suitable for environments wherein near
   real-time communication between the DSKPP client and server may not
   be possible.  It is also suitable for environments wherein
   administrative approval is a required step in the flow, and for
   provisioning of pre-generated keys.  In one-pass DSKPP, shown in
   Figure 6, the server simply sends a <ServerFinished> message to the
   DSKPP client.  In this case, there is no exchange of the
   <ClientHello>, <ServerHello>, and <ClientNonce> DSKPP messages, and
   hence there is no way for the client to express supported algorithms
   or key types.  Before attempting one-pass DSKPP, the server MUST
   therefore have prior knowledge not only that the client is able and
   willing to accept this variant of DSKPP, but also of algorithms and
   key types supported by the client.

   Essentially, one-pass DSKPP is a transport of key material from the
   DSKPP server to the DSKPP client.  As with two-pass DSKPP, the one-
   pass variant relies on key initialization methods that ensure K_TOKEN
   is not exposed to any other entity than the DSKPP server and the
   cryptographic module itself.  The same key initialization profiles
   are defined as described in Section 4.2.2 and Appendix A.

   Outside the specific cases where one-pass DSKPP is desired, clients
   SHOULD be constructed and configured to only accept DSKPP server
   messages in response to client-initiated transactions.


   +---------------+                            +---------------+
   |               |                            |               |
   |  DSKPP client |                            |  DSKPP server |
   |               |                            |               |
   +---------------+                            +---------------+
           |                                            |
           |        <----- Server Finished ------       |
           |                                            |

                    Figure 6: The 1-pass DSKPP protocol







Doherty, et al.          Expires January 9, 2008               [Page 21]


Internet-Draft                    DSKPP                        July 2007


   a.    The DSKPP server generates a key K from which two keys, K_TOKEN
         and K_MAC are derived.  K is either transported or wrapped in
         accordance with the key initialization method known in advance
         by the DSKPP server.  The server then associates K_TOKEN with
         the cryptographic module in a server-side data store.  The
         intent is that the data store later on will be used by some
         service that needs to verify or decrypt data produced by the
         cryptographic module and the key.
   b.    Once the association has been made, the DSKPP server sends a
         confirmation message to the DSKPP client called
         <ServerFinished>.  The confirmation message includes a key
         container that holds an identifier for the key, the key K from
         which K_TOKEN and K_MAC are derived, and additional
         configuration information (note that the latter MUST include
         the identity of the DSKPP server for authentication purposes).
         In addition, <ServerFinished> MUST include two MACs, which will
         allow the cryptographic module to perform key confirmation and
         server authentication before "commiting" the key.  Note that
         unlike two-pass DSKPP, in the one-pass variant, the server does
         not have the client nonce, R_C, and therefore the MACs values
         are calculated with contribution from an unsigned integer, I,
         generated by the server during the protocol run.
   c.    Upon receipt of the DSKPP server's confirmation message, the
         cryptographic module extracts the key data from the provided
         key container, uses the two MAC values to perform key
         confirmation and server authentication, and stores the key
         material locally.

4.3.  Authentication

4.3.1.  Client Authentication (Applicable to Four- and Two-Pass DSKPP)

   To ensure that a generated K_TOKEN ends up associated with the
   correct cryptographic module and user, the DSKPP server MAY couple an
   initial user authentication to the DSKPP execution in several ways,
   as discussed in the following sub-sections.  Whatever the method, the
   DSKPP server MUST ensure that a generated key is associated with the
   correct cryptographic module, and if applicable, the correct user.
   For a further discussion of this, and threats related to man-in-the-
   middle attacks in this context, see Section 7.

4.3.1.1.  Device Certificate

   Instead of requiring an Authentication Code for in-band
   authentication, a device certificate could be used, which was
   supplied with the cryptographic module by its issuer.





Doherty, et al.          Expires January 9, 2008               [Page 22]


Internet-Draft                    DSKPP                        July 2007


4.3.1.2.  Device Identifier

   The provisioning server could be pre-configured with a device
   identifier.  The DSKPP server MAY then include this identifier in the
   DSKPP initialization trigger, and the DSKPP client would include it
   in its message(s) to the DSKPP server for authentication.  Note that
   it is also legitimate for a DSKPP client to initiate the DSKPP
   protocol run without having received an initialization message from a
   server, but in this case any provided device identifier MUST NOT be
   accepted by the DSKPP server unless the server has access to a unique
   key for the identified device and that key will be used in the
   protocol.

4.3.1.3.  One-time Use Authentication Code

   A key issuer may provide a one-time value, called an Authentication
   Code, to the user or device out-of-band and require this value to be
   used by the DSKPP client when contacting the DSKPP server.  The DSKPP
   client MAY include the authentication data in its <ClientHello> (and
   <ClientNonce> for four-pass) message, and the DSKPP server MUST
   verify the data before continuing with the protocol run.  Note: An
   alternate method for getting the Authentication Code to the client,
   is for the DSKPP server to place the value in the <TriggerNonce>
   element of the DSKPP initialization trigger (if triggers are used;
   see Section 5.2.7) .


   +------------+  Get Authentication Code  +------------+
   |    User    |<------------------------->|   Issuer   |
   +------------+                           +------------+
          |                                        |
          |                                        |
          |                                        |
          V                                        V
   +--------------+                        +--------------+
   | Provisioning |   Authentication Data  | Provisioning |
   |    Client    |----------------------->|    Server    |
   +--------------+                        +--------------+

      Figure 7: User Authentication with One-Time               Code

   Considering an Authentication Code as a special form of shared secret
   between a user and a provisioning server, Authentication Data can
   have one of the following forms:

   o  AuthenticationData = Hash (Authentication Code)





Doherty, et al.          Expires January 9, 2008               [Page 23]


Internet-Draft                    DSKPP                        July 2007




      When an Authentication Code is used to initiate the protocol run,
      the Authentication Code MUST be sent to the DSKPP server in a
      secure manner.  If the underlying transport channel is secure, the
      authentication data MAY contain the plaintext format or the hashed
      format of the Authentication Code using a hash function.

   o  AuthenticationData = HMAC(Authentication Code, K_AUTH)

      If the underlying transport is not secure, the client MUST use a
      key K_AUTH and the Authentication Code to derive authentication
      data.  For example, if the Authentication Code has a fixed format,
      e.g.,

      AuthenticationCode = passwordLength || ID || password || checksum

      then AuthenticationData MAY be calculated as follows:

      AuthenticationData = AuthenticationCode->ID || B64(Digest)

      where for four-pass DSKPP, the cryptographic module uses the
      server nonce R_S in combination with the server URL to calculate
      the Digest:

      Digest = DSKPP-PRF-AES(K_AUTH, AuthCode->ID || serverURL || R_S,
      16)

      Refer to Section 4.5 for a description of DSKPP-PRF in general and
      Appendix E for a description of DSKPP-PRF-AES.

      For two-pass DSKPP, the cryptographic module does not have access
      to the server nonce R_S in combination and so:

      Digest = DSKPP-PRF-AES(K_AUTH, AuthenticationCode->ID ||
      serverURL, 16)

      In either case, K_AUTH MAY be derived AES key from
      AuthenticationCode->password as in:

      K_AUTH = truncate( Hash( Hash(...n times...( AuthCode->password )
      ) ) )

      where truncate() returns the first 16 bytes from the result of the
      last hash iteration, and n is the number of hash iterations (set
      to fixed values, e.g., between 10 and 100).





Doherty, et al.          Expires January 9, 2008               [Page 24]


Internet-Draft                    DSKPP                        July 2007


   o  AuthenticationData = <Signed data with a client certificate>

      When a certificate is used for authentication, the authentication
      data MAY be client-signed.  Authentication data MAY be omitted if
      client certificate authentication has been provided by the
      transport channel such as TLS.

   When an issuer delegates symmetric key provisioning to a third party
   provisioning service provider, both client authentication and issuer
   authentication are required by the provisioning server.  Client
   authentication to the Issuer MAY be in-band or out-of-band as
   described above.  The issuer acts as a proxy for the provisioning
   server.  The issuer authenticates to the provisioning service
   provider either using a certificate or a pre-established secret key.

4.3.2.  Server Authentication

   A DSKPP server MUST authenticate itself to avoid a false "Commit" of
   a symmetric key that which could cause the cryptographic module to
   end up in an initialized state for which the server does not know the
   stored key.  To do this, the DSKPP server authenticates itself by
   including a MAC in each of its responses to the client.  In 2-pass
   and 1-pass DSKPP, servers authenticate themselves by including a
   second MAC value in the response message.  In addition, a DSKPP
   server can leverage transport layer authentication if it is
   available.

4.4.  Symmetric Key Container Format

   The default symmetric key container format that is used in the
   <ServerFinished> message is based on the Portable Symmetric Key
   Container (PSKC) defined in [PSKC].  Alternative formats MAY include
   PKCS#12 [PKCS-12] or PKCS#5 XML [PKCS-5-XML] format.

4.5.  The DSKPP One-Way Pseudorandom Function, DSKPP-PRF

4.5.1.  Introduction

   The general requirements on DSKPP-PRF are the same as on keyed hash
   functions: It MUST take an arbitrary length input, and be one-way and
   collision-free (for a definition of these terms, see, e.g., [FAQ]).
   Further, the DSKPP-PRF function MUST be capable of generating a
   variable-length output, and its output MUST be unpredictable even if
   other outputs for the same key are known.

   It is assumed that any realization of DSKPP-PRF takes three input
   parameters: A secret key k, some combination of variable data, and
   the desired length of the output.  The combination of variable data



Doherty, et al.          Expires January 9, 2008               [Page 25]


Internet-Draft                    DSKPP                        July 2007


   can, without loss of generalization, be considered as a salt value
   (see PKCS#5 Version 2.0 [PKCS-5], Section 4), and this
   characterization of DSKPP-PRF SHOULD fit all actual PRF algorithms
   implemented by cryptographic modules.  From the point of view of this
   specification, DSKPP-PRF is a "black-box" function that, given the
   inputs, generates a pseudorandom value.

   Separate specifications MAY define the implementation of DSKPP-PRF
   for various types of cryptographic modules.  Appendix E contains two
   example realizations of DSKPP-PRF.

4.5.2.  Declaration

   DSKPP-PRF (k, s, dsLen)

   Input:

   k     secret key in octet string format
   s     octet string of varying length consisting of variable data
         distinguishing the particular string being derived
   dsLen desired length of the output

   Output:

   DS    pseudorandom string, dsLen-octets long
   For the purposes of this document, the secret key k MUST be 16 octets
   long.

4.6.  Generation of Symmetric Keys for Cryptographic Modules

   In DSKPP, keys are generated using the DSKPP-PRF function, a secret
   random value R_C chosen by the DSKPP client, a random value R_S
   chosen by the DSKPP server, and the key k used to encrypt R_C. The
   input parameter s of DSKPP-PRF is set to the concatenation of the
   (ASCII) string "Key generation", k, and R_S, and the input parameter
   dsLen is set to the desired length of the key, K_TOKEN (the length of
   K_TOKEN is given by the key's type):

   dsLen = (desired length of K_TOKEN)

   K_TOKEN = DSKPP-PRF (R_C, "Key generation" || k || R_S, dsLen)

   When computing K_TOKEN above, the output of DSKPP-PRF MAY be subject
   to an algorithm-dependent transform before being adopted as a key of
   the selected type.  One example of this is the need for parity in DES
   keys.





Doherty, et al.          Expires January 9, 2008               [Page 26]


Internet-Draft                    DSKPP                        July 2007


4.7.  Encryption of Pseudorandom Nonces Sent from the DSKPP Client

   DSKPP client random nonce(s) are either encrypted with the public key
   provided by the DSKPP server or by a shared secret key.  For example,
   in the case of a public RSA key, an RSA encryption scheme from PKCS
   #1 [PKCS-1] MAY be used.

   In the case of a shared secret key, to avoid dependence on other
   algorithms, the DSKPP client MAY use the DSKPP-PRF function described
   herein with the shared secret key K_SHARED as input parameter k (in
   this case, K_SHARED SHOULD be used solely for this purpose), the
   concatenation of the (ASCII) string "Encryption" and the server's
   nonce R_S as input parameter s, and dsLen set to the length of R_C:

   dsLen = len(R_C)

   DS = DSKPP-PRF(K_SHARED, "Encryption" || R_S, dsLen)

   This will produce a pseudorandom string DS of length equal to R_C.
   Encryption of R_C MAY then be achieved by XOR-ing DS with R_C:

   Enc-R_C = DS ^ R_C

   The DSKPP server will then perform the reverse operation to extract
   R_C from Enc-R_C.

   Note: It may appear that an attacker, who learns a previous value of
   R_C, may be able to replay the corresponding R_S and, hence, learn a
   new R_C as well.  However, this attack is mitigated by the
   requirement for a server to show knowledge of K_AUTH (see below) in
   order to successfully complete a key re-generation.

4.8.  MAC calculations

4.8.1.  Four-pass DSKPP

4.8.1.1.  Server Authentication: <ServerHello>

   The MAC value MUST be computed on the (ASCII) string "MAC 1
   computation", the client's nonce R (if sent), and the server's nonce
   R_S using an authentication key K_AUTH that SHOULD be a special
   authentication key used only for this purpose but MAY be the current
   K_TOKEN.

   The MAC value MAY be computed by using the DSKPP-PRF function of
   Section 4.5, in which case the input parameter s MUST be set to the
   concatenation of the (ASCII) string "MAC 1 computation", R (if sent
   by the client), and R_S, and k MUST be set to K_AUTH.  The input



Doherty, et al.          Expires January 9, 2008               [Page 27]


Internet-Draft                    DSKPP                        July 2007


   parameter dsLen MUST be set to the length of R_S:

   dsLen = len(R_S)

   MAC = DSKPP-PRF (K_AUTH, "MAC 1 computation" || [R ||] R_S, dsLen)

4.8.1.2.  Server Authentication: <ServerFinished>

   The MAC value MUST be computed on the (ASCII) string "MAC 2
   computation" and R_C using an authentication key K_AUTH.  Again, this
   SHOULD be a special authentication key used only for this purpose,
   but MAY also be an existing K_TOKEN.  (In this case, implementations
   MUST protect against attacks where K_TOKEN is used to pre-compute MAC
   values.)  If no authentication key is present in the cryptographic
   module, and no K_TOKEN existed before the DSKPP run, K_AUTH MUST be
   the newly generated K_TOKEN.

   If DSKPP-PRF is used as the MAC algorithm, then the input parameter s
   MUST consist of the concatenation of the (ASCII) string "MAC 2
   computation", R_C, the parameter dsLen MUST be set to the length of
   R_C:

   dsLen = len(R_C)

   MAC = DSKPP-PRF (K_AUTH, "MAC 2 computation" || R_C, dsLen)

4.8.2.  Two-pass DSKPP

4.8.2.1.  Key Confirmation

   In two-pass DSKPP, the client is REQUIRED to include a nonce R in the
   <ClientHello> message.  Further, the server is REQUIRED to include an
   identifier, ID_S, for itself (via the key container) in the
   <ServerFinished> message.  The MAC value in the <ServerFinished>
   message MUST be computed on the (ASCII) string "MAC 1 computation",
   the server identifier ID_S, and R using a MAC key K_MAC.  Again, in
   contrast with the MAC calculation in the four-pass DSKPP, this key
   MUST be provided together with K_TOKEN to the cryptographic module,
   and hence there is no need for a K_AUTH for key confirmation
   purposes.

   If DSKPP-PRF is used as the MAC algorithm, then the input parameter s
   MUST consist of the concatenation of the (ASCII) string "MAC 1
   computation" and R, and the parameter dsLen MUST be set to the length
   of R:

   dsLen = len(R)




Doherty, et al.          Expires January 9, 2008               [Page 28]


Internet-Draft                    DSKPP                        July 2007


   MAC = DSKPP-PRF (K_MAC, "MAC 1 computation" || ID_S || R, dsLen)

4.8.2.2.  Server Authentication

   As discussed in Section 4.3.2, servers need to authenticate
   themselves when attempting to replace an existing K_TOKEN.  In 2-pass
   DSKPP, servers authenticate themselves by including a second MAC
   value in the AuthenticationDataType element.  The MAC value in the
   AuthenticationDataType element MUST be computed on the (ASCII) string
   "MAC 1 computation", the server identifier ID_S, and R, using the
   existing MAC key K_MAC' (the MAC key that existed before this
   protocol run).  The MAC algorithm MUST be the same as the algorithm
   used for key confirmation purposes.

   If DSKPP-PRF is used as the MAC algorithm, then the input parameter s
   MUST consist of the concatenation of the (ASCII) string "MAC 1
   computation" ID_S, and R. The parameter dsLen MUST be set to at least
   16 (i.e. the length of the MAC MUST be at least 16 octets):

   dsLen >= 16

   MAC = DSKPP-PRF (K_MAC', "MAC 1 computation" || ID_S || R, dsLen)

4.8.3.  One-pass DSKPP

4.8.3.1.  Key Confirmation

   In one-pass DSKPP, the server MUST include an identifier, ID_S, for
   itself (via the key container) in the <ServerFinished> message.  The
   MAC value in the <ServerFinished> message MUST be computed on the
   (ASCII) string "MAC 1 computation", the server identifier ID_S, and
   an unsigned integer value I, using a MAC key K_MAC.  The value I MUST
   be monotonically increasing and guaranteed not to be used again by
   this server towards this cryptographic module.  It could for example
   be the number of seconds since some point in time with sufficient
   granularity, a counter value, or a combination of the two where the
   counter value is reset for each new time value.  In contrast to the
   MAC calculation in four-pass DSKPP, the MAC key K_MAC MUST be
   provided together with K_TOKEN to the cryptographic module, and hence
   there is no need for a K_AUTH for key confirmation purposes.

   Note: The integer I does not necessarily need to be maintained per
   cryptographic module by the DSKPP server (it is enough if the server
   can guarantee that the same value is never being sent twice to the
   same cryptographic module).

   If DSKPP-PRF is used as the MAC algorithm, then the input parameter s
   MUST consist of the concatenation of the (ASCII) string "MAC 1



Doherty, et al.          Expires January 9, 2008               [Page 29]


Internet-Draft                    DSKPP                        July 2007


   computation", ID_S, and I. The parameter dsLen MUST be set to at
   least 16 (i.e. the length of the MAC MUST be at least 16 octets):

   dsLen >= 16

   MAC = DSKPP-PRF (K_MAC, "MAC 1 computation" || ID_S || I, dsLen)

   The server MUST provide I to the client in the Nonce attribute of the
   <Mac> element of the <ServerFinished> message using the
   AuthenticationCodeMacType defined in Section 4.9.12.

4.8.3.2.  Server Authentication

   As discussed in Section 4.3.2, servers need to authenticate
   themselves when attempting to replace an existing K_TOKEN.  In 1-pass
   DSKPP, servers authenticate themselves by including a second MAC
   value in the AuthenticationDataType element.  The MAC value in the
   AuthenticationDataType element MUST be computed on the (ASCII) string
   "MAC 1 computation", the server identifier ID_S, and a new value I',
   I' > I, using the existing MAC key K_MAC' (the MAC key that existed
   before this protocol run).  The MAC algorithm MUST be the same as the
   algorithm used for key confirmation purposes.

   If DSKPP-PRF is used as the MAC algorithm, then the input parameter s
   MUST consist of the concatenation of the (ASCII) string "MAC 1
   computation" ID_S, and I'.  The parameter dsLen MUST be set to at
   least 16 (i.e. the length of the MAC MUST be at least 16 octets):

   dsLen >= 16

   MAC = DSKPP-PRF (K_MAC', "MAC 1 computation" || ID_S || I', dsLen)

   The server MUST provide I' to the client in the Nonce attribute of
   the <Mac> element of the AuthenticationDataType extension.  If the
   protocol run is successful, the client stores I' as the new value of
   I for this server.

4.9.  DSKPP Schema Basics

   This section describes the schema used by DSKPP.  The DSKPP XML
   schema itself can be found in Section 6.  Specific protocol message
   elements are defined in Section 4.10.  Examples can be found in
   Appendix B.

   Some DSKPP elements rely on the parties being able to compare
   received values with stored values.  Unless otherwise noted, all
   elements in this document that have the XML Schema "xs:string" type,
   or a type derived from it, MUST be compared using an exact binary



Doherty, et al.          Expires January 9, 2008               [Page 30]


Internet-Draft                    DSKPP                        July 2007


   comparison.  In particular, DSKPP implementations MUST NOT depend on
   case-insensitive string comparisons, normalization or trimming of
   white space, or conversion of locale-specific formats such as
   numbers.

   Implementations that compare values that are represented using
   different character encodings MUST use a comparison method that
   returns the same result as converting both values to the Unicode
   character encoding, Normalization Form C [UNICODE], and then
   performing an exact binary comparison.

   No collation or sorting order for attributes or element values is
   defined.  Therefore, DSKPP implementations MUST NOT depend on
   specific sorting orders for values.

4.9.1.  The AbstractRequestType Type

   All DSKPP requests are defined as extensions to the abstract
   AbstractRequestType type.  The elements of the AbstractRequestType,
   therefore, apply to all DSKPP requests.  All DSKPP requests MUST
   contain a Version attribute.  For this version of this specification,
   Version MUST be set to "1.0".

   <xs:complexType name="AbstractRequestType" abstract="true">
     <xs:attribute name="Version" type="VersionType" use="required"/>
   </xs:complexType>

4.9.2.  The AbstractResponseType Type

   All DSKPP responses are defined as extensions to the abstract
   AbstractResponseType type.  The elements of the AbstractResponseType,
   therefore, apply to all DSKPP responses.  All DSKPP responses contain
   a Version attribute indicating the version that was used.  A Status
   attribute, which indicates whether the preceding request was
   successful or not MUST also be present.  Finally, all responses MAY
   contain a SessionID attribute identifying the particular DSKPP
   session.  The SessionID attribute needs only be present if more than
   one roundtrip is REQUIRED for a successful protocol run (this is the
   case with the protocol version described herein).












Doherty, et al.          Expires January 9, 2008               [Page 31]


Internet-Draft                    DSKPP                        July 2007


   <xs:complexType name="AbstractResponseType" abstract="true">
     <xs:attribute name="Version" type="VersionType" use="required"/>
     <xs:attribute name="SessionID" type="IdentifierType"/>
     <xs:attribute name="Status" type="StatusCode" use="required"/>
   </xs:complexType>

4.9.3.  The VersionType Type

   The VersionType type is used within DSKPP messages to identify the
   highest version of this protocol supported by the DSKPP client and
   server.

   <xs:simpleType name="VersionType">
     <xs:restriction base="xs:string">
       <xs:pattern value="\d{1,2}\.\d{1,3}"/>
     </xs:restriction>
   </xs:simpleType>

4.9.4.  The IdentifierType Type

   The IdentifierType type is used to identify various DSKPP elements,
   such as sessions, users, and services.  Identifiers MUST NOT be
   longer than 128 octets.

   <xs:simpleType name="IdentifierType">
     <xs:restriction base="xs:string">
       <xs:maxLength value="128"/>
     </xs:restriction>
   </xs:simpleType>

4.9.5.  The StatusCode Type

   The StatusCode type enumerates all possible return codes:


















Doherty, et al.          Expires January 9, 2008               [Page 32]


Internet-Draft                    DSKPP                        July 2007


   <xs:simpleType name="StatusCode">
     <xs:restriction base="xs:string">
       <xs:enumeration value="Continue"/>
       <xs:enumeration value="Success"/>
       <xs:enumeration value="Abort"/>
       <xs:enumeration value="AccessDenied"/>
       <xs:enumeration value="MalformedRequest"/>
       <xs:enumeration value="UnknownRequest"/>
       <xs:enumeration value="UnknownCriticalExtension"/>
       <xs:enumeration value="UnsupportedVersion"/>
       <xs:enumeration value="NoSupportedKeyTypes"/>
       <xs:enumeration value="NoSupportedEncryptionAlgorithms"/>
       <xs:enumeration value="NoSupportedMACAlgorithms"/>
       <xs:enumeration value="NoProtocolVariants"/>
       <xs:enumeration value="NoSupportedKeyContainers"/>
       <xs:enumeration value="AuthenticationDataInvalid"/>
       <xs:enumeration value="InitializationFailed"/>
     </xs:restriction>
   </xs:simpleType>

   Upon transmission or receipt of a message for which the Status
   attribute's value is not "Success" or "Continue", the default
   behavior, unless explicitly stated otherwise below, is that both the
   DSKPP server and the DSKPP client MUST immediately terminate the
   DSKPP session.  DSKPP servers and DSKPP clients MUST delete any
   secret values generated as a result of failed runs of the DSKPP
   protocol.  Session identifiers MAY be retained from successful or
   failed protocol runs for replay detection purposes, but such retained
   identifiers MUST not be reused for subsequent runs of the protocol.

   When possible, the DSKPP client SHOULD present an appropriate error
   message to the user.

   These status codes are valid in all DSKPP Response messages unless
   explicitly stated otherwise:
   o  "Continue" indicates that the DSKPP server is ready for a
      subsequent request from the DSKPP client.  It cannot be sent in
      the server's final message.
   o  "Success" indicates successful completion of the DSKPP session.
      It can only be sent in the server's final message.
   o  "Abort" indicates that the DSKPP server rejected the DSKPP
      client's request for unspecified reasons.
   o  "AccessDenied" indicates that the DSKPP client is not authorized
      to contact this DSKPP server.
   o  "MalformedRequest" indicates that the DSKPP server failed to parse
      the DSKPP client's request.





Doherty, et al.          Expires January 9, 2008               [Page 33]


Internet-Draft                    DSKPP                        July 2007


   o  "UnknownRequest" indicates that the DSKPP client made a request
      that is unknown to the DSKPP server.
   o  "UnknownCriticalExtension" indicates that a critical DSKPP
      extension (see below) used by the DSKPP client was not supported
      or recognized by the DSKPP server.
   o  "UnsupportedVersion" indicates that the DSKPP client used a DSKPP
      protocol version not supported by the DSKPP server.  This error is
      only valid in the DSKPP server's first response message.
   o  "NoSupportedKeyTypes" indicates that the DSKPP client only
      suggested key types that are not supported by the DSKPP server.
      This error is only valid in the DSKPP server's first response
      message.
   o  "NoSupportedEncryptionAlgorithms" indicates that the DSKPP client
      only suggested encryption algorithms that are not supported by the
      DSKPP server.  This error is only valid in the DSKPP server's
      first response message.  Note that the error will only occur if
      the DSKPP server does not support any of the DSKPP client's
      suggested encryption algorithms.
   o  "NoSupportedMACAlgorithms" indicates that the DSKPP client only
      suggested MAC algorithms that are not supported by the DSKPP
      server.  This error is only valid in the DSKPP server's first
      response message.  Note that the error will only occur if the
      DSKPP server does not support any of the DSKPP client's suggested
      MAC algorithms.
   o  "NoProtocolVariants" indicates that the DSKPP client only
      suggested a protocol variant (either 2-pass or 4-pass) that is not
      supported by the DSKPP server.  This error is only valid in the
      DSKPP server's first response message.  Note that the error will
      only occur if the DSKPP server does not support any of the DSKPP
      client's suggested protocol variants.
   o  "NoSupportedKeyContainers" indicates that the DSKPP client only
      suggested key container formats that are not supported by the
      DSKPP server.  This error is only valid in the DSKPP server's
      first response message.  Note that the error will only occur if
      the DSKPP server does not support any of the DSKPP client's
      suggested key container formats.
   o  "AuthenticationDataInvalid" indicates that the DSKPP client
      supplied user or device authentication data that the DSKPP server
      failed to validate.
   o  "InitializationFailed" indicates that the DSKPP server could not
      generate a valid key given the provided data.  When this status
      code is received, the DSKPP client SHOULD try to restart DSKPP, as
      it is possible that a new run will succeed.

4.9.6.  The DeviceIdentifierDataType Type

   The DeviceIdentifierDataType type is used to uniquely identify the
   device that houses the cryptographic module, e.g., a mobile phone.



Doherty, et al.          Expires January 9, 2008               [Page 34]


Internet-Draft                    DSKPP                        July 2007


   The device identifier allows the DSKPP server to find, e.g., a pre-
   shared transport key for 2-pass DSKPP and/or the correct shared
   secret for MAC'ing purposes.  The default DeviceIdentifierDataType is
   defined in [PSKC].

   <xs:complexType name="DeviceIdentifierDataType">
     <xs:choice>
       <xs:element name="DeviceID" type="pskc:DeviceIdType"/>
       <xs:any namespace="##other" processContents="strict"/>
     </xs:choice>
   </xs:complexType>

4.9.7.  The TokenPlatformInfoType and PlatformType Types

   The TokenPlatformInfoType type is used to carry characteristics of
   the intended cryptographic module platform, and applies in the
   public-key variant of DSKPP in situations when the client potentially
   needs to select a cryptographic module to initialize.

   <xs:simpleType name="PlatformType">
     <xs:restriction base="xs:string">
       <xs:enumeration value="Hardware"/>
       <xs:enumeration value="Software"/>
       <xs:enumeration value="Unspecified"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:complexType name="TokenPlatformInfoType">
     <xs:attribute name="KeyLocation" type="dskpp:PlatformType"/>
     <xs:attribute name="AlgorithmLocation" type="dskpp:PlatformType"/>
   </xs:complexType>

4.9.8.  The NonceType Type

   The NonceType type is used to carry pseudorandom values in DSKPP
   messages.  A nonce, as the name implies, MUST be used only once.  For
   each DSKPP message that requires a nonce element to be sent, a fresh
   nonce MUST be generated each time.  Nonce values MUST be at least 16
   octets long.












Doherty, et al.          Expires January 9, 2008               [Page 35]


Internet-Draft                    DSKPP                        July 2007


   <xs:simpleType name="NonceType">
     <xs:restriction base="xs:base64Binary">
       <xs:minLength value="16"/>
     </xs:restriction>
   </xs:simpleType>

4.9.9.  The AlgorithmsType Type

   The AlgorithmsType type is a list of type-value pairs that define
   algorithms supported by a DSKPP client or server.  Algorithms are
   identified through URIs.

   <xs:complexType name="AlgorithmsType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="Algorithm" type="AlgorithmType"/>
     </xs:sequence>
   </xs:complexType>

   <xs:simpleType name="AlgorithmType">
     <xs:restriction base="xs:anyURI"/>
   </xs:simpleType>

4.9.10.  The ProtocolVariantsType and the TwoPassSupportType Types

   The ProtocolVariantsType type is OPTIONALLY used by the DSKPP client
   to indicate the number of passes of the DSKPP protocol that it
   supports (see Section 4.2).  The ProtocolVariantsType MAY be used to
   indicate support for 4-pass or 2-pass DSKPP.  Because 1-pass DSKPP
   does not include a client request to the server, the
   ProtocolVariantsType type MAY NOT be used to indicate support for
   1-pass DSKPP.  If the ProtocolVariantsType is not used, then the
   DSKPP server will proceed with ordinary 4-pass DSKPP.  However, it
   does not support 4-pass DSKPP, then the server MUST find a suitable
   two-pass variant or else the protocol run will fail.

















Doherty, et al.          Expires January 9, 2008               [Page 36]


Internet-Draft                    DSKPP                        July 2007


   <xs:complexType name="ProtocolVariantsType">
     <xs:sequence>
       <xs:element name="FourPass" minOccurs="0"/>
       <xs:element name="TwoPass" type="dskpp:TwoPassSupportType"
         minOccurs="0"/>
       <xs:element name="OnePass" minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="TwoPassSupportType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="SupportedKeyInitializationMethod"
         type="xs:anyURI"/>
       <xs:element name="Payload" minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   The TwoPassSupportType type signals client support for the 2-pass
   version of DSKPP, informs the server of supported two-pass variants,
   and provides OPTIONAL payload data to the DSKPP server.  The payload
   is sent in an opportunistic fashion, and MAY be discarded by the
   DSKPP server if the server does not support the two-pass variant the
   payload is associated with.  The elements of this type have the
   following meaning:
   o  <SupportedKeyInitializationMethod>: A two-pass key initialization
      method supported by the DSKPP client.  Multiple supported methods
      MAY be present, in which case they MUST be listed in order of
      precedence.
   o  <Payload>: An OPTIONAL payload associated with each supported key
      initialization method.
   A DSKPP client that indicates support for two-pass DSKPP MUST also
   include the nonce R in its <ClientHello> message (this will enable
   the client to verify that the DSKPP server it is communicating with
   is alive).

4.9.11.  The KeyContainersFormatTypeType

   The KeyContainersFormatType type is a list of type-value pairs that
   are OPTIONALLY used to define key container formats supported by a
   DSKPP client or server.  Key container formats are identified through
   URIs, e.g., the PSKC URI
   "http://www.openauthentication.org/OATH/2006/10/PSKC#KeyContainer"
   (see [PSKC].








Doherty, et al.          Expires January 9, 2008               [Page 37]


Internet-Draft                    DSKPP                        July 2007


   <xs:complexType name="KeyContainersFormatType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="KeyContainerFormat"
         type="dskpp:KeyContainerFormatType"/>
     </xs:sequence>
   </xs:complexType>

   <xs:simpleType name="KeyContainerFormatType">
     <xs:restriction base="xs:anyURI"/>
   </xs:simpleType>

4.9.12.  The AuthenticationDataType Type

   The AuthenticationDataType type is OPTIONALLY used to carry client or
   server authentication values in DSKPP messages (see Section 4.3).
   The element MAY be used as follows:
   a.  A DSKPP client MAY include a one-time use AuthenticationCode that
       was given by the issuer to the user for acquiring a symmetric
       key.  An AuthenticationCode MAY or MAY NOT contain alphanumeric
       characters in addition to numeric digits depending on the device
       type and policy of the issuer.  For example, if the device is a
       mobile phone, a code that the user enters on the keypad would
       typically be restricted to numeric digits for ease of use.  An
       activation code can be sent to the DSKPP server in plaintext
       form, hashed data form, or keyed hash data form depending on the
       underlying transport protocol.
   b.  A DSKPP client MAY include an AuthenticationCertificate that
       contains a certificate issued with the device by the issuer.
   c.  A DSKPP server MAY use the AuthenticationDataType element
       AuthenticationCodeMac to carry a MAC for authenticating itself to
       the client.  For example, when a successful 1- or 2-pass DSKPP
       protocol run will result in an existing key being replaced, then
       the DSKPP server MUST include a MAC proving to the DSKPP client
       that the server knows the value of the key it is about to
       replace.
















Doherty, et al.          Expires January 9, 2008               [Page 38]


Internet-Draft                    DSKPP                        July 2007


   <xs:complextype name="AuthenticationDataType">
     <xs:sequence>
       <xs:element name="ClientID" type="dskpp:IdentifierType"
         minOccurs="0"/>
       <xs:choice minOccurs="0">
         <xs:element name="AuthenticationCode"
           type="dskpp:AuthenticationCodeType"/>
         <xs:element name="AuthenticationCodeDigest"
           type="dskpp:AuthenticationCodeDigestType"/>
         <xs:element name="AuthenticationCodeMac"
           type="dskpp:AuthenticationCodeMacType"/>
         <xs:element name="AuthenticationCertificate"
           type="ds:KeyInfoType"/>
       </xs:choice>
     </xs:sequence>
   </xs:complexType>

   <xs:simpleType name="AuthenticationCodeType">
     <xs:restriction base="xs:string">
       <xs:maxLength value="20"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:complexType name="AuthenticationCodeDigestType">
     <xs:simpleContent>
       <xs:extension base="xs:base64Binary">
         <xs:attribute name="HashAlgorithm" type="xs:anyURI"
           use="required"/>
       </xs:extension>
     </xs:simpleContent>
   </xs:complexType>

   <xs:complexType name="AuthenticationCodeMacType">
     <xs:sequence>
       <xs:element name="Data" type="xs:base64Binary">
       <xs:element name="Nonce" type="dskpp:NonceType"/>
     </xs:sequence>
     <attribute name="HMACAlgorithm" type="xs:anyURI"
       use="required"/>
     <attribute name="NonceId" type="dskpp:IdentifierType"/>
   </xs:complexType>

   The element of the AuthenticationDataType type have the following
   meaning:
   o  <ClientID>: A requestor's identifier.  The value MAY be a user ID,
      a device ID, or a keyID associated with the requestor's
      authentication value.  When the authentication data is based on a
      certificate, <ClientID> can be omitted, as the certificate itself



Doherty, et al.          Expires January 9, 2008               [Page 39]


Internet-Draft                    DSKPP                        July 2007


      is typically sufficient to identify the requestor.  Also, if a
      <DSKPPTrigger> message was provided by the server to initiate the
      DSKPP protocol run, <ClientID> can be omitted, as the DeviceID,
      KeyID, and/or nonce provided in the <InitializationTriggerType>
      element ought to be sufficient to identify the requestor.
   o  <AuthenticationCode>: A one-time use value sent in the clear to
      the DSKPP server.
   o  <AuthenticationCodeDigest>: A one-time use value sent in digest
      form to the DSKPP server.
   o  <AuthenticationCodeMac>: An authentication MAC and OPTIONAL
      additional information (e.g., MAC algorithm).  The value could be
      a one-time use value sent as a MAC value to the DSKPP server; or,
      it could be a MAC value sent to the DSKPP client, where the MAC is
      calculated as described in Section 4.8.
   o  <AuthenticationCertificate>: A device certificate sent to the
      DSKPP server.

4.9.13.  The PayloadType Type

   The PayloadType type is used to carry data in a DSKPP client or
   server message.  For this version of the protocol, only one payload
   is defined, the pseudorandom string R_S, for one message, the DSKPP
   <ServerHello>.

   <xs:complexType name="PayloadType">
     <xs:choice>
       <xs:element name="Nonce" type="dskpp:NonceType"/>
       <xs:any namespace="##other" processContents="strict"/>
     </xs:choice>
   </xs:complexType>

4.9.14.  The MacType Type

   The MacType type is used by the DSKPP server to carry a MAC value
   that the DSKPP server uses to authenticate itself to the client.

   <xs:complexType name="MacType">
     <xs:simpleContent>
       <xs:extension base="xs:base64Binary">
         <xs:attribute name="MacAlgorithm" type="xs:anyURI"/>
       </xs:extension>
     </xs:simpleContent>
   </xs:complexType>

4.9.15.  The KeyContainerType Type

   The KeyContainerType type is used by the DSKPP server in its final
   message to carry symmetric key(s) (in the 2- and 1-pass exchanges)



Doherty, et al.          Expires January 9, 2008               [Page 40]


Internet-Draft                    DSKPP                        July 2007


   and configuration data.  The default element defined for the
   KeyContainerType is contained in the namespace defined in the PSKC
   namespace as KeyContainerType (see [PSKC].

   <xs:complexType name="KeyContainerType">
     <xs:choice>
       <xs:element name="KeyContainer"
         type="pskc:KeyContainerType"/>
       <xs:element name="##other" processContents="strict"/>
     </xs:choice>
   </xs:complexType>

4.9.16.  The ExtensionsType and the AbstractExtensionType Types

   The ExtensionsType type is a list of type-value pairs that define
   OPTIONAL DSKPP features supported by a DSKPP client or server.
   Extensions MAY be sent with any DSKPP message.  Please see the
   description of individual DSKPP messages in Section 4.11 of this
   document for applicable extensions.  All DSKPP extensions are defined
   as extensions to the AbstractExtensionType type.  The elements of the
   AbstractExtensionType, therefore, apply to all DSKPP extensions.
   Unless an extension is marked as Critical, a receiving party need not
   be able to interpret it.  A receiving party is always free to
   disregard any (non-critical) extensions.

   <xs:complexType name="ExtensionsType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="Extension" type="AbstractExtensionType"/>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="AbstractExtensionType" abstract="true">
     <xs:attribute name="Critical" type="xs:boolean"/>
   </xs:complexType>

4.10.  DSKPP Messages

4.10.1.  Introduction

   In this section, DSKPP messages, including their parameters, encoding
   and semantics are defined.

4.10.2.  DSKPP Initialization (OPTIONAL)

   The DSKPP server MAY initialize the DSKPP protocol by sending a
   <DSKPPTrigger> message.  This message MAY, e.g., be sent in response
   to a user requesting key initialization in a browsing session.




Doherty, et al.          Expires January 9, 2008               [Page 41]


Internet-Draft                    DSKPP                        July 2007


   <xs:complexType name="InitializationTriggerType">
     <xs:sequence>
       <xs:element name="DeviceIdentifierData"
         type="dskpp:DeviceIdentifierDataType" minOccurs="0"/>
       <xs:element name="KeyID" type="xs:base64Binary" minOccurs="0"/>
       <xs:element name="TokenPlatformInfo"
         type="dskpp:TokenPlatformInfoType" minOccurs="0"/>
       <xs:element name="TriggerNonce" type="dskpp:NonceType"/>
       <xs:element name="DSKPP_URL" type="xs:anyURI" minOccurs="0"/>
       <xs:any namespace="##other" processContents="strict"
         minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   <xs:element name="DSKPPTrigger" type="DSKPPTriggerType"/>

   <xs:complexType name="DSKPPTriggerType">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Message used to trigger the device to initiate a
         DSKPP protocol run.
       </xs:documentation>
     </xs:annotation>
     <xs:sequence>
       <xs:choice>
         <xs:element name="InitializationTrigger"
           type="dskpp:InitializationTriggerType"/>
         <xs:any namespace="##other" processContents="strict"/>
       </xs:choice>
     </xs:sequence>
     <xs:attribute name="Version" type="dskpp:VersionType"/>
   </xs:complexType>

   The <DSKPPTrigger> element is intended for the DSKPP client and MAY
   inform the DSKPP client about the identifier for the device that
   houses the cryptographic module to be initialized, and, OPTIONALLY,
   of the identifier for the key on that module.  The latter would apply
   to key renewal.  The trigger always contains a nonce to allow the
   DSKPP server to couple the trigger with a later DSKPP <ClientHello>
   request.  Finally, the trigger MAY contain a URL to use when
   contacting the DSKPP server.  The <xs:any> elements are for future
   extensibility.  Any provided <DeviceIdentifierData> or <KeyID> values
   MUST be used by the DSKPP client in the subsequent <ClientHello>
   request.  The OPTIONAL <TokenPlatformInfo> element informs the DSKPP
   client about the characteristics of the intended cryptographic module
   platform, and applies in the public-key variant of DSKPP in
   situations when the client potentially needs to decide which one of
   several modules to initialize.



Doherty, et al.          Expires January 9, 2008               [Page 42]


Internet-Draft                    DSKPP                        July 2007


   The Version attribute MUST be set to "1.0" for this version of DSKPP.

4.10.3.  The DSKPP Client's Initial PDU (2- and 4-Pass)

   This message is the initial message sent from the DSKPP client to the
   DSKPP server.













































Doherty, et al.          Expires January 9, 2008               [Page 43]


Internet-Draft                    DSKPP                        July 2007


   <xs:element name="ClientHello" type="ClientHelloPDU"/>

   <xs:complexType name="ClientHelloPDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Message sent from DSKPP client to DSKPP server to initiate a
         DSKPP session.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="AbstractRequestType">
         <xs:sequence>
           <xs:element name="DeviceIdentifierData"
             type="dskpp:DeviceIdentifierDataType" minOccurs="0"/>
           <xs:element name="KeyID" type="xs:base64Binary"
             minOccurs="0"/>
           <xs:element name="ClientNonce" type="dskpp:NonceType"
             minOccurs="0"/>
           <xs:element name="TriggerNonce" type="dskpp:NonceType"
             minOccurs="0"/>
           <xs:element name="SupportedKeyTypes"
             type="dskpp:AlgorithmsType"/>
           <xs:element name="SupportedEncryptionAlgorithms"
             type="dskpp:AlgorithmsType"/>
           <xs:element name="SupportedMACAlgorithms"
             type="dskpp:AlgorithmsType"/>
           <xs:element name="SupportedProtocolVariants"
             type="dskpp:ProtocolVariantsType" minOccurs="0"/>
           <xs:element name="SupportedKeyContainers"
             type="dskpp:KeyContainersFormatType" minOccurs="0"/>
           <xs:element name="AuthenticationData"
             type="dskpp:AuthenticationDataType" minOccurs="0"/>
           <xs:element name="Extensions" type="dskpp:ExtensionsType"
             minOccurs="0"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   The components of this message have the following meaning:
   o  Version: (attribute inherited from the AbstractRequestType type)
      The highest version of this protocol the client supports.  Only
      version one ("1.0") is currently specified.
   o  <DeviceIdentifierData>: An identifier for the cryptographic module
      as defined in Section 4.3.1 above.  The identifier MUST only be
      present if such shared secrets exist or if the identifier was
      provided by the server in a <DSKPPTrigger> element (see
      Section 5.2.7 below).  In the latter case, it MUST have the same



Doherty, et al.          Expires January 9, 2008               [Page 44]


Internet-Draft                    DSKPP                        July 2007


      value as the identifier provided in that element.
   o  <KeyID>: An identifier for the key that will be overwritten if the
      protocol run is successful.  The identifier MUST only be present
      if the key exists or was provided by the server in a
      <DSKPPTrigger> element (see Section 5.2.7 below).  In the latter
      case, it MUST have the same value as the identifier provided in
      that element.
   o  <ClientNonce>: This is the nonce R, which, when present, MUST be
      used by the server when calculating MAC values (see below).  It is
      RECOMMENDED that clients include this element whenever the <KeyID>
      element is present.
   o  <TriggerNonce>: This OPTIONAL element MUST be present if and only
      if the DSKPP run was initialized with a <DSKPPTrigger> message
      (see Section 5.2.7 below), and MUST, in that case, have the same
      value as the <TriggerNonce> child of that message.  A server using
      nonces in this way MUST verify that the nonce is valid and that
      any device or key identifier values provided in the <DSKPPTrigger>
      message match the corresponding identifier values in the
      <ClientHello> message.
   o  <SupportedKeyTypes>: A sequence of URIs indicating the key types
      for which the cryptographic module is willing to generate keys
      through DSKPP.
   o  <SupportedEncryptionAlgorithms>: A sequence of URIs indicating the
      encryption algorithms supported by the cryptographic module for
      the purposes of DSKPP.  The DSKPP client MAY indicate the same
      algorithm both as a supported key type and as an encryption
      algorithm.
   o  <SupportedMACAlgorithms>: A sequence of URIs indicating the MAC
      algorithms supported by the cryptographic module for the purposes
      of DSKPP.  The DSKPP client MAY indicate the same algorithm both
      as an encryption algorithm and as a MAC algorithm (e.g.,
      urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes defined
      in Appendix E).
   o  <SupportedProtocolVariants>: This OPTIONAL element is used by the
      DSKPP client to indicate support for four-pass or two-pass DSKPP.
      If two-pass support is specified, then <ClientNonce> MUST be set
      to nonce R in the <ClientHello> message unless <TriggerNonce> is
      already present.
   o  <SupportedKeyContainers>: This OPTIONAL element is a sequence of
      URIs indicating the key container formats supported by the DSKPP
      client.  If this element is not provided, then the DSKPP server
      MUST proceed with
      "http://www.openauthentication.org/OATH/2006/10/PSKC#KeyContainer"
      (see [PSKC].
   o  <AuthenticationData>: This OPTIONAL element contains data that the
      DSKPP client uses to authenticate the user or device to the DSKPP
      server.  The element is set as specified in Section 4.3.1.




Doherty, et al.          Expires January 9, 2008               [Page 45]


Internet-Draft                    DSKPP                        July 2007


   o  <Extensions>: A sequence of extensions.  One extension is defined
      for this message in this version of DSKPP: the ClientInfoType (see
      Section 4.11).

4.10.4.  The DSKPP Server's Initial PDU (4-Pass Only)

   This message is the first message sent from the DSKPP server to the
   DSKPP client (assuming a trigger message has not been sent to
   initiate the protocol, in which case, this message is the second
   message sent from the DSKPP server to the DSKPP client).  It is sent
   upon reception of a <ClientHello> message.

   <xs:element name="ServerHello" type="ServerHelloPDU"/>

   <xs:complexType name="ServerHelloPDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Message sent from DSKPP server to DSKPP client
         in response to a received ClientHello PDU.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="AbstractResponseType">
         <xs:sequence minOccurs="0">
           <xs:element name="KeyType"
             type="dskpp:AlgorithmType"/>
           <xs:element name="EncryptionAlgorithm"
             type="dskpp:AlgorithmType"/>
           <xs:element name="MacAlgorithm"
             type="dskpp:AlgorithmType"/>
           <xs:element name="EncryptionKey"
             type="ds:KeyInfoType"/>
           <xs:element name="KeyContainerFormat"
             type="dskpp:KeyContainerFormatType"/>
           <xs:element name="Payload"
             type="dskpp:PayloadType"/>
           <xs:element name="Extensions"
             type="dskpp:ExtensionsType" minOccurs="0"/>
           <xs:element name="Mac" type="dskpp:MacType"
             minOccurs="0"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   The components of this message have the following meaning:





Doherty, et al.          Expires January 9, 2008               [Page 46]


Internet-Draft                    DSKPP                        July 2007


   o  Version: (attribute inherited from the AbstractResponseType type)
      The version selected by the DSKPP server.  MAY be lower than the
      version indicated by the DSKPP client, in which case, local policy
      at the client MUST determine whether or not to continue the
      session.
   o  SessionID: (attribute inherited from the AbstractResponseType
      type) An identifier for this session.
   o  Status: (attribute inherited from the AbstractResponseType type)
      Return code for the <ClientHello>.  If Status is not "Continue",
      only the Status and Version attributes will be present; otherwise,
      all the other element MUST be present as well.
   o  <KeyType>: The type of the key to be generated.
   o  <EncryptionAlgorithm>: The encryption algorithm to use when
      protecting R_C.
   o  <MacAlgorithm>: The MAC algorithm to be used by the DSKPP server.
   o  <EncryptionKey>: Information about the key to use when encrypting
      R_C. It will either be the server's public key (the <ds:KeyValue>
      alternative of ds:KeyInfoType) or an identifier for a shared
      secret key (the <ds:KeyName> alternative of ds:KeyInfoType).
   o  <KeyContainerFormat>: The key container format type to be used by
      the DSKPP server.  The default setting relies on the
      KeyContainerType element defined in
      "urn:ietf:params:xml:schema:keyprov:container" [PSKC].
   o  <Payload>: The actual payload.  For this version of the protocol,
      only one payload is defined: the pseudorandom string R_S.
   o  <Extensions>: A list of server extensions.  Two extensions are
      defined for this message in this version of DSKPP: the
      ClientInfoType and the ServerInfoType (see Section 4.11).
   o  <Mac>: The MAC MUST be present if the DSKPP run will result in the
      replacement of an existing symmetric key with a new one (i.e., if
      the <KeyID> element was present in the <ClientHello message).  In
      this case, the DSKPP server MUST prove to the cryptographic module
      that it is authorized to replace it.  The MAC value MUST be
      computed as defined in Section 4.8.1.1.
      The DSKPP client MUST verify the MAC if the successful execution
      of the protocol will result in the replacement of an existing
      symmetric key with a newly generated one.  The DSKPP client MUST
      terminate the DSKPP session if the MAC does not verify, and MUST
      delete any nonces, keys, and/or secrets associated with the failed
      run of the DSKPP protocol.
      The MacType's MacAlgorithm attribute MUST, when present, identify
      the negotiated MAC algorithm.

4.10.5.  The DSKPP Client's Second PDU (4-Pass Only)

   This message contains the nonce chosen by the cryptographic module,
   R_C, encrypted by the specified encryption key and encryption
   algorithm.



Doherty, et al.          Expires January 9, 2008               [Page 47]


Internet-Draft                    DSKPP                        July 2007


   <xs:element name="ClientNonce" type="ClientNoncePDU"/>

   <xs:complexType name="ClientNoncePDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Second message sent from DSKPP client to
         DSKPP server in a DSKPP session.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="AbstractRequestType">
         <xs:sequence>
           <xs:element name="EncryptedNonce"
             type="xs:base64Binary"/>
           <xs:element name="AuthenticationData"
             type="dskpp:AuthenticationDataType" minOccurs="0"/>
           <xs:element name="Extensions"
             type="dskpp:ExtensionsType" minOccurs="0"/>
         </xs:sequence>
         <xs:attribute name="SessionID" type="dskpp:IdentifierType"
           use="required"/>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   The components of this message have the following meaning:

   o  Version: (inherited from the AbstractRequestType type) MUST be the
      same version as in the <ServerHello> message.
   o  <SessionID>: MUST have the same value as the SessionID attribute
      in the received <ServerHello> message.
   o  <EncryptedNonce>: The nonce generated and encrypted by the
      cryptographic module.  The encryption MUST be made using the
      selected encryption algorithm and identified key, and as specified
      in Section 4.5.
   o  <AuthenticationData>: The authentication data value, which MAY
      OPTIONALLY be the same as provided in the <ClientHello>, MUST be
      set as specified in Section 4.3.1.
   o  <Extensions>: A list of extensions.  Two extensions are defined
      for this message in this version of DSKPP: the ClientInfoType and
      the ServerInfoType (see Section 4.11).

4.10.6.  The DSKPP Server's Final PDU (1-, 2-, and 4-Pass)

   This message is the last message of the DSKPP protocol run.  In a
   4-pass exchange, the DSKPP server sends this message in response to a
   <ClientNonce> message, whereas in a 2-pass exchange, the DSKPP server
   sends this message in response to a <ClientHello> message.  In a



Doherty, et al.          Expires January 9, 2008               [Page 48]


Internet-Draft                    DSKPP                        July 2007


   1-pass exchange, the DSKPP server sends only this message to the
   client.

   <xs:element name="ServerFinished" type="ServerFinishedPDU"/>

   <xs:complexType name="ServerFinishedPDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Final message sent from DSKPP server to
         DSKPP client in a DSKPP session.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="AbstractResponseType">
         <xs:sequence minOccurs="0">
           <xs:element name="KeyContainer"
             type="dskpp:KeyContainerType"/>
           <xs:element name="Extensions"
             type="dskpp:ExtensionsType" minOccurs="0"/>
           <xs:element name="Mac"
             type="dskpp:MacType"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   The components of this message have the following meaning:

   o  Version: (inherited from the AbstractResponseType type) The DSKPP
      version used in this session.
   o  SessionID: (inherited from the AbstractResponseType type) The
      previously established identifier for this session.
   o  Status: (inherited from the AbstractResponseType type) Return code
      for the <ServerFinished> message.  If Status is not "Success",
      only the Status, SessionID, and Version attributes will be present
      (the presence of the SessionID attribute is dependent on the type
      of reported error); otherwise, all the other elements MUST be
      present as well.  In this latter case, the <ServerFinished>
      message can be seen as a "Commit" message, instructing the
      cryptographic module to store the generated key and associate the
      given key identifier with this key.
   o  <KeyContainer>: The key container containing symmetric key values
      (in the case of a 2- or 1-pass exchange) and configuration data.
      The default container format is based on the KeyContainerType type
      from PSKC, as defined in [PSKC].
   o  <Extensions>: A list of extensions chosen by the DSKPP server.
      For this message, this version of DSKPP defines one extension, the
      ClientInfoType (see Section 4.11).



Doherty, et al.          Expires January 9, 2008               [Page 49]


Internet-Draft                    DSKPP                        July 2007


   o  <Mac>: To avoid a false "Commit" message causing the cryptographic
      module to end up in an initialized state for which the server does
      not know the stored key, <ServerFinished> messages MUST always be
      authenticated with a MAC.  The MAC MUST be made using the already
      established MAC algorithm.  The MAC value MUST be computed as
      specified in Section 4.8.1.2.
      When receiving a <ServerFinished> message with Status="Success"
      for which the MAC verifies, the DSKPP client MUST associate the
      generated key K_TOKEN with the provided key identifier and store
      this data permanently.  After this operation, it MUST not be
      possible to overwrite the key unless knowledge of an authorizing
      key is proven through a MAC on a later <ServerHello> (and
      <ServerFinished>) message.
      The DSKPP client MUST verify the MAC.  The DSKPP client MUST
      terminate the DSKPP session if the MAC does not verify, and MUST,
      in this case, also delete any nonces, keys, and/or secrets
      associated with the failed run of the DSKPP protocol.
      The MacType's MacAlgorithm attribute MUST, when present, identify
      the negotiated MAC algorithm.

4.11.  Protocol Extensions

4.11.1.  The ClientInfoType Type

   When present in a <ClientHello> or a <ClientNonce> message, the
   OPTIONAL ClientInfoType extension contains DSKPP client-specific
   information.  DSKPP servers MUST support this extension.  DSKPP
   servers MUST NOT attempt to interpret the data it carries and, if
   received, MUST include it unmodified in the current protocol run's
   next server response.  Servers need not retain the ClientInfoType's
   data after that response has been generated.

   <xs:complexType name="ClientInfoType">
     <xs:complexContent>
       <xs:extension base="AbstractExtensionType">
         <xs:sequence>
           <xs:element name="Data"
             type="xs:base64Binary"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

4.11.2.  The ServerInfoType Type

   When present, the OPTIONAL ServerInfoType extension contains DSKPP
   server-specific information.  This extension is only valid in
   <ServerHello> messages for which Status = "Continue".  DSKPP clients



Doherty, et al.          Expires January 9, 2008               [Page 50]


Internet-Draft                    DSKPP                        July 2007


   MUST support this extension.  DSKPP clients MUST NOT attempt to
   interpret the data it carries and, if received, MUST include it
   unmodified in the current protocol run's next client request (i.e.,
   the <ClientNonce> message).  DSKPP clients need not retain the
   ServerInfoType's data after that request has been generated.  This
   extension MAY be used, e.g., for state management in the DSKPP
   server.

   <xs:complexType name="ServerInfoType">
     <xs:complexContent>
       <xs:extension base="AbstractExtensionType">
         <xs:sequence>
           <xs:element name="Data"
             type="xs:base64Binary"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

4.11.3.  The KeyInitializationDataType Type

   This extension is used for 2- and 1-pass DSKPP exchange; it carries
   an identifier for the selected key initialization method as well as
   key initialization method-dependent payload data.

   Servers MAY include this extension in a <ServerFinished> message that
   is being sent in response to a received <ClientHello> message if and
   only if that <ClientHello> message selected TwoPassSupport as the
   ProtocolVariantType and the client indicated support for the selected
   key initialization method.  Servers MUST include this extension in a
   <ServerFinished> message that is sent as part of a 1-pass DSKPP.




















Doherty, et al.          Expires January 9, 2008               [Page 51]


Internet-Draft                    DSKPP                        July 2007


   <xs:complexType name="KeyInitializationDataType">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         This extension is only valid in ServerFinished PDUs. It
         contains key initialization data and its presence results in a
         two-pass (or one-pass, if no ClientHello was sent) DSKPP
         exchange.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="dskpp:AbstractExtensionType">
         <xs:sequence>
           <xs:element name="KeyInitializationMethod" type="xs:anyURI"/>
           <xs:element name="Payload"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   The elements of this type have the following meaning:

   o  <KeyInitializationMethod>: A two-pass key initialization method
      supported by the DSKPP client.
   o  <Payload>: A payload associated with the key initialization
      method.  Since the syntax is a shorthand for <xs:element
      name="Payload" type="xs:anyType"/>, any well-formed payloads can
      be carried in this element.


5.  Protocol Bindings

5.1.  General Requirements

   DSKPP assumes a reliable transport.

5.2.  HTTP/1.1 Binding for DSKPP

5.2.1.  Introduction

   This section presents a binding of the previous messages to HTTP/1.1
   [RFC2616].  Note that the HTTP client normally will be different from
   the DSKPP client, i.e., the HTTP client will only exist to "proxy"
   DSKPP messages from the DSKPP client to the DSKPP server.  Likewise,
   on the HTTP server side, the DSKPP server MAY receive DSKPP PDUs from
   a "front-end" HTTP server.






Doherty, et al.          Expires January 9, 2008               [Page 52]


Internet-Draft                    DSKPP                        July 2007


5.2.2.  Identification of DSKPP Messages

   The MIME-type for all DSKPP messages MUST be

   application/vnd.ietf.keyprov.dskpp+xml

5.2.3.  HTTP Headers

   HTTP proxies MUST NOT cache responses carrying DSKPP messages.  For
   this reason, the following holds:
   o  When using HTTP/1.1, requesters SHOULD:
      *  Include a Cache-Control header field set to "no-cache, no-
         store".
      *  Include a Pragma header field set to "no-cache".
   o  When using HTTP/1.1, responders SHOULD:
      *  Include a Cache-Control header field set to "no-cache, no-must-
         revalidate, private".
      *  Include a Pragma header field set to "no-cache".
      *  NOT include a Validator, such as a Last-Modified or ETag
         header.
   There are no other restrictions on HTTP headers, besides the
   requirement to set the Content-Type header value according to
   Section 5.2.2.

5.2.4.  HTTP Operations

   Persistent connections as defined in HTTP/1.1 are assumed but not
   required.  DSKPP requests are mapped to HTTP POST operations.  DSKPP
   responses are mapped to HTTP responses.

5.2.5.  HTTP Status Codes

   A DSKPP HTTP responder that refuses to perform a message exchange
   with a DSKPP HTTP requester SHOULD return a 403 (Forbidden) response.
   In this case, the content of the HTTP body is not significant.  In
   the case of an HTTP error while processing a DSKPP request, the HTTP
   server MUST return a 500 (Internal Server Error) response.  This type
   of error SHOULD be returned for HTTP-related errors detected before
   control is passed to the DSKPP processor, or when the DSKPP processor
   reports an internal error (for example, the DSKPP XML namespace is
   incorrect, or the DSKPP schema cannot be located).  If the type of a
   DSKPP request cannot be determined, the DSKPP responder MUST return a
   400 (Bad request) response.

   In these cases (i.e., when the HTTP response code is 4xx or 5xx), the
   content of the HTTP body is not significant.

   Redirection status codes (3xx) apply as usual.



Doherty, et al.          Expires January 9, 2008               [Page 53]


Internet-Draft                    DSKPP                        July 2007


   Whenever the HTTP POST is successfully invoked, the DSKPP HTTP
   responder MUST use the 200 status code and provide a suitable DSKPP
   message (possibly with DSKPP error information included) in the HTTP
   body.

5.2.6.  HTTP Authentication

   No support for HTTP/1.1 authentication is assumed.

5.2.7.  Initialization of DSKPP

   The DSKPP server MAY initialize the DSKPP protocol by sending an HTTP
   response with Content-Type set according to Section 5.2.2 and
   response code set to 200 (OK).  This message MAY, e.g., be sent in
   response to a user requesting key initialization in a browsing
   session.  The initialization message MAY carry data in its body.  If
   this is the case, the data MUST be a valid instance of a
   <DSKPPTrigger> element.

5.2.8.  Example Messages

   a.  Initialization from DSKPP server:
       HTTP/1.1 200 OK

       Cache-Control: no-store
       Content-Type: application/vnd.ietf.keyprov.dskpp+xml
       Content-Length: <some value>

       DSKPP initialization data in XML form...

   b.  Initial request from DSKPP client:
       POST http://example.com/cgi-bin/DSKPP-server HTTP/1.1
       Cache-Control: no-store
       Pragma: no-cache
       Host: example.com
       Content-Type: application/vnd.ietf.keyprov.dskpp+xml
       Content-Length: <some value>

       DSKPP data in XML form (supported version, supported
       algorithms...)

   c.  Initial response from DSKPP server:
       HTTP/1.1 200 OK

       Cache-Control: no-store
       Content-Type: application/vnd.ietf.keyprov.dskpp+xml
       Content-Length: <some value>




Doherty, et al.          Expires January 9, 2008               [Page 54]


Internet-Draft                    DSKPP                        July 2007


       DSKPP data in XML form (server random nonce, server public key,
       ...)


6.  DSKPP Schema


 <?xml version="1.0" encoding="UTF-8"?>

 <xs:schema
   targetNamespace="urn:ietf:params:xml:ns:keyprov:protocol"
   xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:protocol"
   xmlns:pskc="urn:ietf:params:xml:ns:keyprov:protocol"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns:ds="http://www.w3.org/2000/09/xmldsig#">

   <xs:import namespace="http://www.w3.org/2000/09/xmldsig#"
     schemaLocation="http://www.w3.org/TR/2002/
     REC-xmldsig-core-20020212/xmldsig-core-schema.xsd"/>

   <!-- Basic types -->
   <xs:complexType name="AbstractRequestType" abstract="true">
     <xs:attribute name="Version" type="VersionType" use="required"/>
   </xs:complexType>

   <xs:complexType name="AbstractResponseType" abstract="true">
     <xs:attribute name="Version" type="VersionType" use="required"/>
     <xs:attribute name="SessionID" type="IdentifierType"/>
     <xs:attribute name="Status" type="StatusCode" use="required"/>
   </xs:complexType>

   <xs:simpleType name="VersionType">
     <xs:restriction base="xs:string">
       <xs:pattern value="\d{1,2}\.\d{1,3}"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:simpleType name="IdentifierType">
     <xs:restriction base="xs:string">
       <xs:maxLength value="128"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:simpleType name="StatusCode">
     <xs:restriction base="xs:string">
       <xs:enumeration value="Continue"/>
       <xs:enumeration value="Success"/>
       <xs:enumeration value="Abort"/>



Doherty, et al.          Expires January 9, 2008               [Page 55]


Internet-Draft                    DSKPP                        July 2007


       <xs:enumeration value="AccessDenied"/>
       <xs:enumeration value="MalformedRequest"/>
       <xs:enumeration value="UnknownRequest"/>
       <xs:enumeration value="UnknownCriticalExtension"/>
       <xs:enumeration value="UnsupportedVersion"/>
       <xs:enumeration value="NoSupportedKeyTypes"/>
       <xs:enumeration value="NoSupportedEncryptionAlgorithms"/>
       <xs:enumeration value="NoSupportedMACAlgorithms"/>
       <xs:enumeration value="NoProtocolVariants"/>
       <xs:enumeration value="NoSupportedKeyContainers"/>
       <xs:enumeration value="AuthenticationDataInvalid"/>
       <xs:enumeration value="InitializationFailed"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:complexType name="DeviceIdentifierDataType">
     <xs:choice>
       <xs:element name="DeviceID" type="pskc:DeviceIdType"/>
       <xs:any namespace="##other" processContents="strict"/>
     </xs:choice>
   </xs:complexType>

   <xs:simpleType name="PlatformType">
     <xs:restriction base="xs:string">
       <xs:enumeration value="Hardware"/>
       <xs:enumeration value="Software"/>
       <xs:enumeration value="Unspecified"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:complexType name="TokenPlatformInfoType">
     <xs:attribute name="KeyLocation" type="dskpp:PlatformType"/>
     <xs:attribute name="AlgorithmLocation" type="dskpp:PlatformType"/>
   </xs:complexType>

   <xs:simpleType name="NonceType">
     <xs:restriction base="xs:base64Binary">
       <xs:minLength value="16"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:complexType name="AlgorithmsType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="Algorithm" type="AlgorithmType"/>
     </xs:sequence>
   </xs:complexType>

   <xs:simpleType name="AlgorithmType">



Doherty, et al.          Expires January 9, 2008               [Page 56]


Internet-Draft                    DSKPP                        July 2007


     <xs:restriction base="xs:anyURI"/>
   </xs:simpleType>

   <xs:complexType name="ProtocolVariantsType">
     <xs:sequence>
       <xs:element name="FourPass" minOccurs="0"/>
       <xs:element name="TwoPass" type="dskpp:TwoPassSupportType"
         minOccurs="0"/>
       <xs:element name="OnePass" minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="TwoPassSupportType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="SupportedKeyInitializationMethod"
         type="xs:anyURI"/>
       <xs:element name="Payload" minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="KeyContainersFormatType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="KeyContainerFormat"
         type="dskpp:KeyContainerFormatType"/>
     </xs:sequence>
   </xs:complexType>

   <xs:simpleType name="KeyContainerFormatType">
     <xs:restriction base="xs:anyURI"/>
   </xs:simpleType>

   <xs:complextype name="AuthenticationDataType">
     <xs:sequence>
       <xs:element name="ClientID" type="dskpp:IdentifierType"
         minOccurs="0"/>
       <xs:choice minOccurs="0">
         <xs:element name="AuthenticationCode"
           type="dskpp:AuthenticationCodeType"/>
         <xs:element name="AuthenticationCodeDigest"
           type="dskpp:AuthenticationCodeDigestType"/>
         <xs:element name="AuthenticationCodeMac"
           type="dskpp:AuthenticationCodeMacType"/>
         <xs:element name="AuthenticationCertificate"
           type="ds:KeyInfoType"/>
       </xs:choice>
     </xs:sequence>
   </xs:complexType>




Doherty, et al.          Expires January 9, 2008               [Page 57]


Internet-Draft                    DSKPP                        July 2007


   <xs:simpleType name="AuthenticationCodeType">
     <xs:restriction base="xs:string">
       <xs:maxLength value="20"/>
     </xs:restriction>
   </xs:simpleType>

   <xs:complexType name="AuthenticationCodeDigestType">
     <xs:simpleContent>
       <xs:extension base="xs:base64Binary">
         <xs:attribute name="HashAlgorithm" type="xs:anyURI"
           use="required"/>
       </xs:extension>
     </xs:simpleContent>
   </xs:complexType>

   <xs:complexType name="AuthenticationCodeMacType">
     <xs:sequence>
       <xs:element name="Data" type="xs:base64Binary">
       <xs:element name="Nonce" type="dskpp:NonceType"/>
     </xs:sequence>
     <attribute name="HMACAlgorithm" type="xs:anyURI"
       use="required"/>
     <attribute name="NonceId" type="dskpp:IdentifierType"/>
   </xs:complexType>

   <xs:complexType name="PayloadType">
     <xs:choice>
       <xs:element name="Nonce" type="dskpp:NonceType"/>
       <xs:any namespace="##other" processContents="strict"/>
     </xs:choice>
   </xs:complexType>

   <xs:complexType name="MacType">
     <xs:simpleContent>
       <xs:extension base="xs:base64Binary">
         <xs:attribute name="MacAlgorithm" type="xs:anyURI"/>
       </xs:extension>
     </xs:simpleContent>
   </xs:complexType>

   <xs:complexType name="KeyContainerType">
     <xs:choice>
       <xs:element name="KeyContainer"
         type="pskc:KeyContainerType"/>
       <xs:element name="##other" processContents="strict"/>
     </xs:choice>
   </xs:complexType>




Doherty, et al.          Expires January 9, 2008               [Page 58]


Internet-Draft                    DSKPP                        July 2007


   <xs:complexType name="InitializationTriggerType">
     <xs:sequence>
       <xs:element name="DeviceIdentifierData"
         type="dskpp:DeviceIdentifierDataType" minOccurs="0"/>
       <xs:element name="KeyID" type="xs:base64Binary" minOccurs="0"/>
       <xs:element name="TokenPlatformInfo"
         type="dskpp:TokenPlatformInfoType" minOccurs="0"/>
       <xs:element name="TriggerNonce" type="dskpp:NonceType"/>
       <xs:element name="DSKPP_URL" type="xs:anyURI" minOccurs="0"/>
       <xs:any namespace="##other" processContents="strict"
         minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   <!-- Extension types -->
   <xs:complexType name="ExtensionsType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="Extension" type="AbstractExtensionType"/>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="AbstractExtensionType" abstract="true">
     <xs:attribute name="Critical" type="xs:boolean"/>
   </xs:complexType>

   <xs:complexType name="ClientInfoType">
     <xs:complexContent>
       <xs:extension base="AbstractExtensionType">
         <xs:sequence>
           <xs:element name="Data"
             type="xs:base64Binary"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <xs:complexType name="ServerInfoType">
     <xs:complexContent>
       <xs:extension base="AbstractExtensionType">
         <xs:sequence>
           <xs:element name="Data"
             type="xs:base64Binary"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <xs:complexType name="KeyInitializationDataType">



Doherty, et al.          Expires January 9, 2008               [Page 59]


Internet-Draft                    DSKPP                        July 2007


     <xs:annotation>
       <xs:documentation xml:lang="en">
         This extension is only valid in ServerFinished PDUs. It
         contains key initialization data and its presence results in a
         two-pass (or one-pass, if no ClientHello was sent) DSKPP
         exchange.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="dskpp:AbstractExtensionType">
         <xs:sequence>
           <xs:element name="KeyInitializationMethod" type="xs:anyURI"/>
           <xs:element name="Payload"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <!-- DSKPP PDUs -->

   <!-- DSKPP trigger -->
   <xs:element name="DSKPPTrigger" type="DSKPPTriggerType"/>

   <xs:complexType name="DSKPPTriggerType">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Message used to trigger the device to initiate a
         DSKPP protocol run.
       </xs:documentation>
     </xs:annotation>
     <xs:sequence>
       <xs:choice>
         <xs:element name="InitializationTrigger"
           type="dskpp:InitializationTriggerType"/>
         <xs:any namespace="##other" processContents="strict"/>
       </xs:choice>
     </xs:sequence>
     <xs:attribute name="Version" type="dskpp:VersionType"/>
   </xs:complexType>

   <!-- ClientHello PDU -->
   <xs:element name="ClientHello" type="ClientHelloPDU"/>

   <xs:complexType name="ClientHelloPDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Message sent from DSKPP client to DSKPP server to initiate a
         DSKPP session.



Doherty, et al.          Expires January 9, 2008               [Page 60]


Internet-Draft                    DSKPP                        July 2007


       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="AbstractRequestType">
         <xs:sequence>
           <xs:element name="DeviceIdentifierData"
             type="dskpp:DeviceIdentifierDataType" minOccurs="0"/>
           <xs:element name="KeyID" type="xs:base64Binary"
             minOccurs="0"/>
           <xs:element name="ClientNonce" type="dskpp:NonceType"
             minOccurs="0"/>
           <xs:element name="TriggerNonce" type="dskpp:NonceType"
             minOccurs="0"/>
           <xs:element name="SupportedKeyTypes"
             type="dskpp:AlgorithmsType"/>
           <xs:element name="SupportedEncryptionAlgorithms"
             type="dskpp:AlgorithmsType"/>
           <xs:element name="SupportedMACAlgorithms"
             type="dskpp:AlgorithmsType"/>
           <xs:element name="SupportedProtocolVariants"
             type="dskpp:ProtocolVariantsType" minOccurs="0"/>
           <xs:element name="SupportedKeyContainers"
             type="dskpp:KeyContainersFormatType" minOccurs="0"/>
           <xs:element name="AuthenticationData"
             type="dskpp:AuthenticationDataType" minOccurs="0"/>
           <xs:element name="Extensions" type="dskpp:ExtensionsType"
             minOccurs="0"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <!-- ServerHello PDU -->
   <xs:element name="ServerHello" type="ServerHelloPDU"/>

   <xs:complexType name="ServerHelloPDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Message sent from DSKPP server to DSKPP client
         in response to a received ClientHello PDU.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="AbstractResponseType">
         <xs:sequence minOccurs="0">
           <xs:element name="KeyType"
             type="dskpp:AlgorithmType"/>
           <xs:element name="EncryptionAlgorithm"



Doherty, et al.          Expires January 9, 2008               [Page 61]


Internet-Draft                    DSKPP                        July 2007


             type="dskpp:AlgorithmType"/>
           <xs:element name="MacAlgorithm"
             type="dskpp:AlgorithmType"/>
           <xs:element name="EncryptionKey"
             type="ds:KeyInfoType"/>
           <xs:element name="KeyContainerFormat"
             type="dskpp:KeyContainerFormatType"/>
           <xs:element name="Payload"
             type="dskpp:PayloadType"/>
           <xs:element name="Extensions"
             type="dskpp:ExtensionsType" minOccurs="0"/>
           <xs:element name="Mac" type="dskpp:MacType"
             minOccurs="0"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <!-- ClientNonce PDU -->
   <xs:element name="ClientNonce" type="ClientNoncePDU"/>

   <xs:complexType name="ClientNoncePDU">
     <xs:annotation>
       <xs:documentation xml:lang="en">
         Second message sent from DSKPP client to
         DSKPP server in a DSKPP session.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="AbstractRequestType">
         <xs:sequence>
           <xs:element name="EncryptedNonce"
             type="xs:base64Binary"/>
           <xs:element name="AuthenticationData"
             type="dskpp:AuthenticationDataType" minOccurs="0"/>
           <xs:element name="Extensions"
             type="dskpp:ExtensionsType" minOccurs="0"/>
         </xs:sequence>
         <xs:attribute name="SessionID" type="dskpp:IdentifierType"
           use="required"/>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   <!-- ServerFinished PDU -->
   <xs:element name="ServerFinished" type="ServerFinishedPDU"/>

   <xs:complexType name="ServerFinishedPDU">



Doherty, et al.          Expires January 9, 2008               [Page 62]


Internet-Draft                    DSKPP                        July 2007


     <xs:annotation>
       <xs:documentation xml:lang="en">
         Final message sent from DSKPP server to
         DSKPP client in a DSKPP session.
       </xs:documentation>
     </xs:annotation>
     <xs:complexContent>
       <xs:extension base="AbstractResponseType">
         <xs:sequence minOccurs="0">
           <xs:element name="KeyContainer"
             type="dskpp:KeyContainerType"/>
           <xs:element name="Extensions"
             type="dskpp:ExtensionsType" minOccurs="0"/>
           <xs:element name="Mac"
             type="dskpp:MacType"/>
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

 </xs:schema>


7.  Security Considerations

7.1.  General

   DSKPP is designed to protect generated key material from exposure.
   No other entities than the DSKPP server and the cryptographic module
   will have access to a generated K_TOKEN if the cryptographic
   algorithms used are of sufficient strength and, on the DSKPP client
   side, generation and encryption of R_C and generation of K_TOKEN take
   place as specified and in the cryptographic module.  This applies
   even if malicious software is present in the DSKPP client.  However,
   as discussed in the following, DSKPP does not protect against certain
   other threats resulting from man-in-the-middle attacks and other
   forms of attacks.  DSKPP SHOULD, therefore, be run over a transport
   providing privacy and integrity, such as HTTP over Transport Layer
   Security (TLS) with a suitable ciphersuite, when such threats are a
   concern.  Note that TLS ciphersuites with anonymous key exchanges are
   not suitable in those situations.

7.2.  Active Attacks

7.2.1.  Introduction

   An active attacker MAY attempt to modify, delete, insert, replay, or
   reorder messages for a variety of purposes including service denial



Doherty, et al.          Expires January 9, 2008               [Page 63]


Internet-Draft                    DSKPP                        July 2007


   and compromise of generated key material.  Section 7.2.2 through
   Section 7.2.7.

7.2.2.  Message Modifications

   Modifications to a <DSKPPPTrigger> message will either cause denial-
   of-service (modifications of any of the identifiers or the nonce) or
   the DSKPP client to contact the wrong DSKPP server.  The latter is in
   effect a man-in-the-middle attack and is discussed further in
   Section 7.2.7.

   An attacker may modify a <ClientHello> message.  This means that the
   attacker could indicate a different key or device than the one
   intended by the DSKPP client, and could also suggest other
   cryptographic algorithms than the ones preferred by the DSKPP client,
   e.g., cryptographically weaker ones.  The attacker could also suggest
   earlier versions of the DSKPP protocol, in case these versions have
   been shown to have vulnerabilities.  These modifications could lead
   to an attacker succeeding in initializing or modifying another
   cryptographic module than the one intended (i.e., the server
   assigning the generated key to the wrong module), or gaining access
   to a generated key through the use of weak cryptographic algorithms
   or protocol versions.  DSKPP implementations MAY protect against the
   latter by having strict policies about what versions and algorithms
   they support and accept.  The former threat (assignment of a
   generated key to the wrong module) is not possible when the shared-
   key variant of DSKPP is employed (assuming existing shared keys are
   unique per cryptographic module), but is possible in the public-key
   variant.  Therefore, DSKPP servers MUST NOT accept unilaterally
   provided device identifiers in the public-key variant.  This is also
   indicated in the protocol description.  In the shared-key variant,
   however, an attacker may be able to provide the wrong identifier
   (possibly also leading to the incorrect user being associated with
   the generated key) if the attacker has real-time access to the
   cryptographic module with the identified key.  In other words, the
   generated key is associated with the correct cryptographic module but
   the module is associated with the incorrect user.  See further
   Section 7.5 for a discussion of this threat and possible
   countermeasures.

   An attacker may also modify a <ServerHello> message.  This means that
   the attacker could indicate different key types, algorithms, or
   protocol versions than the legitimate server would, e.g.,
   cryptographically weaker ones.  The attacker could also provide a
   different nonce than the one sent by the legitimate server.  Clients
   will protect against the former through strict adherence to policies
   regarding permissible algorithms and protocol versions.  The latter
   (wrong nonce) will not constitute a security problem, as a generated



Doherty, et al.          Expires January 9, 2008               [Page 64]


Internet-Draft                    DSKPP                        July 2007


   key will not match the key generated on the legitimate server.  Also,
   whenever the DSKPP run would result in the replacement of an existing
   key, the <Mac> element protects against modifications of R_S.

   Modifications of <ClientNonce> messages are also possible.  If an
   attacker modifies the SessionID attribute, then, in effect, a switch
   to another session will occur at the server, assuming the new
   SessionID is valid at that time on the server.  It still will not
   allow the attacker to learn a generated K_TOKEN since R_C has been
   wrapped for the legitimate server.  Modifications of the
   <EncryptedNonce> element, e.g., replacing it with a value for which
   the attacker knows an underlying R'C, will not result in the client
   changing its pre-DSKPP state, since the server will be unable to
   provide a valid MAC in its final message to the client.  The server
   MAY, however, end up storing K'TOKEN rather than K_TOKEN.  If the
   cryptographic module has been associated with a particular user, then
   this could constitute a security problem.  For a further discussion
   about this threat, and a possible countermeasure, see Section 7.5
   below.  Note that use of Secure Socket Layer (SSL) or TLS does not
   protect against this attack if the attacker has access to the DSKPP
   client (e.g., through malicious software, "trojans").

   Finally, attackers may also modify the <ServerFinished> message.
   Replacing the <Mac> element will only result in denial-of-service.
   Replacement of any other element may cause the DSKPP client to
   associate, e.g., the wrong service with the generated key.  DSKPP
   SHOULD be run over a transport providing privacy and integrity when
   this is a concern.

7.2.3.  Message Deletion

   Message deletion will not cause any other harm than denial-of-
   service, since a cryptographic module MUST NOT change its state
   (i.e., "commit" to a generated key) until it receives the final
   message from the DSKPP server and successfully has processed that
   message, including validation of its MAC.  A deleted <ServerFinished>
   message will not cause the server to end up in an inconsistent state
   vis-a-vis the cryptographic module if the server implements the
   suggestions in Section 7.5.

7.2.4.  Message Insertion

   An active attacker may initiate a DSKPP run at any time, and suggest
   any device identifier.  DSKPP server implementations MAY receive some
   protection against inadvertently initializing a key or inadvertently
   replacing an existing key or assigning a key to a cryptographic
   module by initializing the DSKPP run by use of the <DSKPPTrigger>.
   The <TriggerNonce> element allows the server to associate a DSKPP



Doherty, et al.          Expires January 9, 2008               [Page 65]


Internet-Draft                    DSKPP                        July 2007


   protocol run with, e.g., an earlier user-authenticated session.  The
   security of this method, therefore, depends on the ability to protect
   the <TriggerNonce> element in the DSKPP initialization message.  If
   an eavesdropper is able to capture this message, he may race the
   legitimate user for a key initialization.  DSKPP over a transport
   providing privacy and integrity, coupled with the recommendations in
   Section 7.5, is RECOMMENDED when this is a concern.

   Insertion of other messages into an existing protocol run is seen as
   equivalent to modification of legitimately sent messages.

7.2.5.  Message Replay

   During 4-pass DSKPP, attempts to replay a previously recorded DSKPP
   message will be detected, as the use of nonces ensures that both
   parties are live.  For example, a DSKPP client knows that a server it
   is communicating with is "live" since the server MUST create a MAC on
   information sent by the client.

   The same is true for 2-pass DSKPP thanks to the requirement that the
   client sends R in the <ClientHello> message and that the server
   includes R in the MAC computation.

   In 1-pass DSKPP clients that record the latest I used by a particular
   server (as identified by ID_S) will be able to detect replays.

7.2.6.  Message Reordering

   An attacker may attempt to re-order 4-pass DSKPP messages but this
   will be detected, as each message is of a unique type.  Note: Message
   re-ordering attacks cannot occur in 2- and 1-pass DSKPP since each
   party sends at most one message each.

7.2.7.  Man-in-the-Middle

   In addition to other active attacks, an attacker posing as a man in
   the middle may be able to provide his own public key to the DSKPP
   client.  This threat and countermeasures to it are discussed in
   Section 4.2.  An attacker posing as a man-in-the-middle may also be
   acting as a proxy and, hence, may not interfere with DSKPP runs but
   still learn valuable information; see Section 7.3.

7.3.  Passive Attacks

   Passive attackers may eavesdrop on DSKPP runs to learn information
   that later on may be used to impersonate users, mount active attacks,
   etc.




Doherty, et al.          Expires January 9, 2008               [Page 66]


Internet-Draft                    DSKPP                        July 2007


   If DSKPP is not run over a transport providing privacy, a passive
   attacker may learn:
   o  What cryptographic modules a particular user is in possession of;
   o  The identifiers of keys on those crypotgraphic modules and other
      attributes pertaining to those keys, e.g., the lifetime of the
      keys; and
   o  DSKPP versions and cryptographic algorithms supported by a
      particular DSKPP client or server.
   Whenever the above is a concer, DSKPP SHOULD be run over a transport
   providing privacy.  If man-in-the-middle attacks for the purposes
   described above are a concern, the transport SHOULD also offer
   server-side authentication.

7.4.  Cryptographic Attacks

   An attacker with unlimited access to an initialized cryptographic
   module may use the module as an "oracle" to pre-compute values that
   later on may be used to impersonate the DSKPP server.  Section 4.7
   and Section 4.10 contain discussions of this threat and steps
   RECOMMENDED to protect against it.

7.5.  Attacks on the Interaction between DSKPP and User Authentication

   If keys generated in DSKPP will be associated with a particular user
   at the DSKPP server (or a server trusted by, and communicating with
   the DSKPP server), then in order to protect against threats where an
   attacker replaces a client-provided encrypted R_C with his own R'C
   (regardless of whether the public-key variant or the shared-secret
   variant of DSKPP is employed to encrypt the client nonce), the server
   SHOULD not commit to associate a generated K_TOKEN with the given
   cryptographic module until the user simultaneously has proven both
   possession of the device that hosts the cryptographic module
   containing K_TOKEN and some out-of-band provided authenticating
   information (e.g., a temporary password).  For example, if the
   cryptographic module is a one-time password token, the user could be
   required to authenticate with both a one-time password generated by
   the cryptographic module and an out-of-band provided temporary PIN in
   order to have the server "commit" to the generated OTP value for the
   given user.  Preferably, the user SHOULD perform this operation from
   another host than the one used to initialize keys on the
   cryptographic module, in order to minimize the risk of malicious
   software on the client interfering with the process.

   Note: This scenario, wherein the attacker replaces a client-provided
   R_C with his own R'C, does not apply to 2- and 1-pass DSKPP as the
   client does not provide any entropy to K_TOKEN.  The attack as such
   (and its countermeasures) still applies to 2- and 1-pass DSKPP,
   however, as it essentially is a man-in-the-middle attack.



Doherty, et al.          Expires January 9, 2008               [Page 67]


Internet-Draft                    DSKPP                        July 2007


   Another threat arises when an attacker is able to trick a user to
   authenticate to the attacker rather than to the legitimate service
   before the DSKPP protocol run.  If successful, the attacker will then
   be able to impersonate the user towards the legitimate service, and
   subsequently receive a valid DSKPP trigger.  If the public-key
   variant of DSKPP is used, this may result in the attacker being able
   to (after a successful DSKPP protocol run) impersonate the user.
   Ordinary precautions MUST, therefore, be in place to ensure that
   users authenticate only to legitimate services.

7.6.  Additional Considerations Specific to 2- and 1-pass DSKPP

7.6.1.  Client Contributions to K_TOKEN Entropy

   In 4-pass DSKPP, both the client and the server provide randomizing
   material to K_TOKEN , in a manner that allows both parties to verify
   that they did contribute to the resulting key.  In the 1- and 2-pass
   DSKPP versions defined herein, only the server contributes to the
   entropy of K_TOKEN.  This means that a broken or compromised
   (pseudo-)random number generator in the server may cause more damage
   than it would in the 4-pass variant.  Server implementations SHOULD
   therefore take extreme care to ensure that this situation does not
   occur.

7.6.2.  Key Confirmation

   4-pass DSKPP servers provide key confirmation through the MAC on R_C
   in the <ServerFinished> message.  In the 1- and 2-pass DSKPP variants
   described herein, key confirmation is provided by the MAC including I
   (in the 1-pass case) or R (2-pass case), using K_MAC.

7.6.3.  Server Authentication

   DSKPP servers MUST authenticate themselves whenever a successful
   DSKPP 1- or 2-pass protocol run would result in an existing K_TOKEN
   being replaced by a K_TOKEN', or else a denial-of-service attack
   where an unauthorized DSKPP server replaces a K_TOKEN with another
   key would be possible.  In 1- and 2-pass DSKPP, servers authenticate
   by including the AuthenticationDataType extension containing a MAC as
   described in Section 4.8 above.

7.6.4.  Client Authentication

   A DSKPP server MUST authenticate a client to ensure that K_TOKEN is
   delivered to the intended device.  The following measures SHOULD be
   considered:





Doherty, et al.          Expires January 9, 2008               [Page 68]


Internet-Draft                    DSKPP                        July 2007


   o  When a device certificate is used for client authentication, the
      DSKPP server SHOULD follow standard certificate verification
      processes to ensure that it is a trusted device.
   o  When an Authentication Code is used for client authentication, a
      password dictionary attack on the authentication data is possible.
      When a secure channel, e.g., SSL or TLS, is established between a
      DSKPP client and server, an attacker could successfully brute-
      force guess an Authentication Code, allowing him to illegitimately
      receive K_TOKEN.
   o  The length the of the Authentication Code when used over a non-
      secure channel SHOULD be longer than what is used over a secure
      channel.  When a device, e.g., some mobile phones with small
      screens, cannot handle a long Authentication Code in a user-
      friendly manner, DSKPP SHOULD rely on a secure channel for
      communication.
   o  In the case that a non-secure channel has to be used, the
      Authentication Code SHOULD be sent to the server MAC's with a
      DSKPP server's nonce value.  The Authentication Code and nonce
      value MUST be strong enough to prevent offline brute-force
      recovery of the Authentication Code from the HMAC data.  Because
      the nonce value is almost public across a non-secure channel, the
      key strength is dependent on the Authentication Code.

7.6.5.  Key Protection in the Passphrase Profile

   The passphrase-based key wrap profile uses the PBKDF2 function from
   [PKCS-5] to generate an encryption key from a passphrase and salt
   string.  The derived key, K_DERIVED is used by the server to encrypt
   K_TOKEN and by the cryptographic module to decrypt the newly
   delivered K_TOKEN.  It is important to note that passphrase-based
   encryption is generally limited in the security that it provides
   despite the use of salt and iteration count in PBKDF2 to increase the
   complexity of attack.  Implementations SHOULD therefore take
   additional measures to strengthen the security of the passphrase-
   based key wrap profile.  The following measures SHOULD be considered
   where applicable:

   o  The passphrase SHOULD be selected well, and usage guidelines such
      as the ones in [NIST-PWD] SHOULD be taken into account.
   o  A different passphrase SHOULD be used for every key initialization
      wherever possible (the use of a global passphrase for a batch of
      cryptographic modules SHOULD be avoided, for example).  One way to
      achieve this is to use randomly-generated passphrases.
   o  The passphrase SHOULD be protected well if stored on the server
      and/or on the cryptographic module and SHOULD be delivered to the
      device's user using secure methods.





Doherty, et al.          Expires January 9, 2008               [Page 69]


Internet-Draft                    DSKPP                        July 2007


   o  User pre-authentication SHOULD be implemented to ensure that
      K_TOKEN is not delivered to a rogue recipient.
   o  The iteration count in PBKDF2 SHOULD be high to impose more work
      for an attacker using brute-force methods (see [PKCS-5] for
      recommendations).  However, it MUST be noted that the higher the
      count, the more work is required on the legitimate cryptographic
      module to decrypt the newly delivered K_TOKEN.  Servers MAY use
      relatively low iteration counts to accommodate devices with
      limited processing power such as some PDA and cell phones when
      other security measures are implemented and the security of the
      passphrase-based key wrap method is not weakened.
   o  Transport level security (e.g.  TLS) SHOULD be used where possible
      to protect a 2-pass or 1-pass protocol run.  Transport level
      security provides a second layer of protection for the newly
      generated K_TOKEN.


8.  IANA Considerations

   This document calls for registration of new URNs within the IETF sub-
   namespace per RFC3553 [RFC3553].  The following URNs are RECOMMENDED:
   o  DSKPP XML schema: "urn:ietf:params:xml:schema:keyprov:protocol"
   o  DSKPP XML namespace: "urn:ietf:params:xml:ns:keyprov:protocol"


9.  Intellectual Property Considerations

   RSA and RSA Security are registered trademarks or trademarks of RSA
   Security Inc. in the United States and/or other countries.  The names
   of other products and services mentioned may be the trademarks of
   their respective owners.


10.  Acknowledgements

   The authors would like to thank all the members of OATH [OATH] and
   participants of OTPS workshops for their review and comments related
   to this document.


11.  References

11.1.  Normative references

   [UNICODE]  Davis, M. and M. Duerst, "Unicode Normalization Forms",
              March 2001,
              <http://www.unicode.org/unicode/reports/tr15/
              tr15-21.html>.



Doherty, et al.          Expires January 9, 2008               [Page 70]


Internet-Draft                    DSKPP                        July 2007


   [XMLDSIG]  W3C, "XML Signature Syntax and Processing",
              W3C Recommendation, February 2002,
              <http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/>.

   [XMLENC]   W3C, "XML Encryption Syntax and Processing",
              W3C Recommendation, December 2002,
              <http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/>.

11.2.  Informative references

   [CT-KIP-P11]
              RSA Laboratories, "PKCS #11 Mechanisms for the
              Cryptographic Token Key Initialization Protocol", PKCS #11
              Version 2.20 Amd.2, December 2005,
              <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [FAQ]      RSA Laboratories, "Frequently Asked Questions About
              Today's Cryptography",  Version 4.1, 2000.

   [FIPS180-SHA]
              National Institute of Standards and Technology, "Secure
              Hash Standard", FIPS 180-2, February 2004, <http://
              csrc.nist.gov/publications/fips/fips180-2/
              fips180-2withchangenotice.pdf>.

   [FIPS197-AES]
              National Institute of Standards and Technology,
              "Specification for the Advanced Encryption Standard
              (AES)", FIPS 197, November 2001, <http://csrc.nist.gov/
              publications/fips/fips197/fips-197.pdf>.

   [FSE2003]  Iwata, T. and K. Kurosawa, "OMAC: One-Key CBC MAC. In Fast
              Software Encryption", FSE 2003, Springer-Verlag , 2003,
              <http://crypt.cis.ibaraki.ac.jp/omac/docs/omac.pdf>.

   [NIST-PWD]
              National Institute of Standards and Technology, "Password
              Usage", FIPS 112, May 1985,
              <http://www.itl.nist.gov/fipspubs/fip112.htm>.

   [OATH]     "Initiative for Open AuTHentication", 2005,
              <http://www.openauthentication.org>.

   [PKCS-1]   RSA Laboratories, "RSA Cryptography Standard", PKCS #1
              Version 2.1, June 2002,
              <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [PKCS-11]  RSA Laboratories, "Cryptographic Token Interface



Doherty, et al.          Expires January 9, 2008               [Page 71]


Internet-Draft                    DSKPP                        July 2007


              Standard", PKCS #11 Version 2.20, June 2004,
              <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [PKCS-12]  "Personal Information Exchange Syntax Standard", PKCS #12
              Version 1.0, 2005,
              <ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/
              pkcs-12v1.pdf>.

   [PKCS-5]   RSA Laboratories, "Password-Based Cryptography Standard",
              PKCS #5 Version 2.0, March 1999,
              <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [PKCS-5-XML]
              RSA Laboratories, "XML Schema for PKCS #5 Version 2.0",
              PKCS #5 Version 2.0 Amd.1 (FINAL DRAFT), October 2006,
              <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [PSKC]     "Portable Symmetric Key Container", 2005, <http://
              www.ietf.org/internet-drafts/
              draft-hoyer-keyprov-portable-symmetric-key-container-
              00.txt>.

   [RFC2104]  Krawzcyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104,
              February 1997.

   [RFC2119]  "Key words for use in RFCs to Indicate Requirement
              Levels", BCP 14, RFC 2119, March 1997,
              <http://www.ietf.org/rfc/rfc2119.txt>.

   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", RFC 2616, June 1999,
              <http://www.ietf.org/rfc/rfc2616.txt>.

   [RFC3553]  Mealling, M., Masinter, L., Hardie, T., and G. Klyne, "An
              IETF URN Sub-namespace for Registered Protocol
              Parameters", RFC 3553, BCP 73, June 2003.

   [RFC4758]  RSA, The Security Division of EMC, "Cryptographic Token
              Key Initialization Protocol (CT-KIP)", November 2006,
              <http://www.ietf.org/rfc/rfc4758.txt>.


Appendix A.  Key Initialization Profiles of DSKPP






Doherty, et al.          Expires January 9, 2008               [Page 72]


Internet-Draft                    DSKPP                        July 2007


A.1.  Introduction

   This appendix introduces three profiles of DSKPP for key
   initialization.  They MAY all be used for two- as well as one-pass
   initialization of cryptographic modules.  Further profiles MAY be
   defined by external entities or through the IETF process.

A.2.  Key Transport Profile

A.2.1.  Introduction

   This profile initializes the cryptographic module with a symmetric
   key, K_TOKEN, through key transport and key derivation.  The key
   transport is carried out using a public key, K_CLIENT, whose private
   key part resides in the cryptographic module as the transport key.  A
   key K from which two keys, K_TOKEN and K_MAC are derived MUST be
   transported.

A.2.2.  Identification

   This profile MUST be identified with the following URN:

   urn:ietf:params:xml:schema:keyprov:protocol#transport

A.2.3.  Payloads

   In the two-pass version of DSKPP, the client MUST send a payload
   associated with this key initialization method.  The payload MUST be
   of type ds:KeyInfoType ([XMLDSIG]), and only those choices of the ds:
   KeyInfoType that identify a public key are allowed.  The ds:
   X509Certificate option of the ds:X509Data alternative is RECOMMENDED
   when the public key corresponding to the private key on the
   cryptographic module has been certified.

   The server payload associated with this key initialization method
   MUST be of type xenc:EncryptedKeyType ([XMLENC]), and only those
   encryption methods utilizing a public key that are supported by the
   DSKPP client (as indicated in the <SupportedEncryptionAlgorithms>
   element of the <ClientHello> message in the case of 2-pass DSKPP, or
   as otherwise known in the case of 1-pass DSKPP) are allowed as values
   for the <xenc:EncryptionMethod> element.  Further, in the case of
   2-pass DSKPP, the <ds:KeyInfo> element MUST contain the same value
   (i.e. identify the same public key) as the <Payload> of the
   corresponding supported key initialization method in the
   <ClientHello> message that triggered the response.  The
   <CarriedKeyName> element MAY be present, but MUST, when present,
   contain the same value as the <KeyID> element of the <ServerFinished>
   message.  The Type attribute of the xenc:EncryptedKeyType MUST be



Doherty, et al.          Expires January 9, 2008               [Page 73]


Internet-Draft                    DSKPP                        July 2007


   present and MUST identify the type of the wrapped key.  The type MUST
   be one of the types supported by the DSKPP client (as reported in the
   <SupportedKeyTypes> of the preceding <ClientHello> message in the
   case of 2-pass DSKPP, or as otherwise known in the case of 1-pass
   DSKPP).  The transported key MUST consist of two parts of equal
   length.  The first half constitutes K_MAC and the second half
   constitutes K_TOKEN.  The length of K_TOKEN (and hence also the
   length of K_MAC) is determined by the type of K_TOKEN.

   DSKPP servers and cryptographic modules supporting this profile MUST
   support the http://www.w3.org/2001/04/xmlenc#rsa-1_5 key-wrapping
   mechanism defined in [XMLENC].

   When this profile is used, the MacAlgorithm attribute of the <Mac>
   element of the <ServerFinished> message MUST be present and MUST
   identify the selected MAC algorithm.  The selected MAC algorithm MUST
   be one of the MAC algorithms supported by the DSKPP client (as
   indicated in the <SupportedMACAlgorithms> element of the
   <ClientHello> message in the case of 2-pass DSKPP, or as otherwise
   known in the case of 1-pass DSKPP).  The MAC MUST be calculated as
   described in Section 4.8

   In addition, DSKPP servers MUST include the AuthenticationDataType
   element (see further Section 4.8) in their <ServerFinished> messages
   whenever a successful protocol run will result in an existing K_TOKEN
   being replaced.

A.3.  Key wrap profile

A.3.1.  Introduction

   This profile initializes the cryptographic module with a symmetric
   key, K_TOKEN, through key wrap and key derivation.  The key wrap MUST
   be carried out using a (symmetric) key-wrapping key, K_SHARED, known
   in advance by both the cryptographic module and the DSKPP server.  A
   key K from which two keys, K_TOKEN and K_MAC are derived MUST be
   wrapped.

A.3.2.  Identification

   This profile MUST be identified with the following URI:

   urn:ietf:params:xml:schema:keyprov:protocol#wrap

A.3.3.  Payloads

   In the 2-pass version of DSKPP, the client MUST send a payload
   associated with this key initialization method.  The payload MUST be



Doherty, et al.          Expires January 9, 2008               [Page 74]


Internet-Draft                    DSKPP                        July 2007


   of type ds:KeyInfoType ([XMLDSIG]), and only those choices of the ds:
   KeyInfoType that identify a symmetric key are allowed.  The ds:
   KeyName alternative is RECOMMENDED.

   The server payload associated with this key initialization method
   MUST be of type xenc:EncryptedKeyType ([XMLENC]), and only those
   encryption methods utilizing a symmetric key that are supported by
   the DSKPP client (as indicated in the <SupportedEncryptionAlgorithms>
   element of the <ClientHello> message in the case of 2-pass DSKPP, or
   as otherwise known in the case of 1-pass DSKPP) are allowed as values
   for the <xenc:EncryptionMethod> element.  Further, in the case of
   2-pass DSKPP, the <ds:KeyInfo> element MUST contain the same value
   (i.e. identify the same symmetric key) as the <Payload> of the
   corresponding supported key initialization method in the
   <ClientHello> message that triggered the response.  The
   <CarriedKeyName> element MAY be present, and MUST, when present,
   contain the same value as the <KeyID> element of the <ServerFinished>
   message.  The Type attribute of the xenc:EncryptedKeyType MUST be
   present and MUST identify the type of the wrapped key.  The type MUST
   be one of the types supported by the DSKPP client (as reported in the
   <SupportedKeyTypes> of the preceding <ClientHello> message in the
   case of 2-pass DSKPP, or as otherwise known in the case of 1-pass
   DSKPP).  The wrapped key MUST consist of two parts of equal length.
   The first half constitutes K_MAC and the second half constitutes
   K_TOKEN.  The length of K_TOKEN (and hence also the length of K_MAC)
   is determined by the type of K_TOKEN.

   DSKP servers and cryptographic modules supporting this profile MUST
   support the http://www.w3.org/2001/04/xmlenc#kw-aes128 key-wrapping
   mechanism defined in [XMLENC].

   When this profile is used, the MacAlgorithm attribute of the <Mac>
   element of the <ServerFinished> message MUST be present and MUST
   identify the selected MAC algorithm.  The selected MAC algorithm MUST
   be one of the MAC algorithms supported by the DSKPP client (as
   indicated in the <SupportedMACAlgorithms> element of the
   <ClientHello> message in the case of 2-pass DSKPP, or as otherwise
   known in the case of 1-pass DSKPP).  The MAC MUST be calculated as
   described in Section 4.8

   In addition, DSKPP servers MUST include the AuthenticationDataType
   element (see further Section 4.8) in their <ServerFinished> messages
   whenever a successful protocol run will result in an existing K_TOKEN
   being replaced.







Doherty, et al.          Expires January 9, 2008               [Page 75]


Internet-Draft                    DSKPP                        July 2007


A.4.  Passphrase-based key wrap profile

A.4.1.  Introduction

   This profile is a variation of the key wrap profile.  It initializes
   the cryptographic module with a symmetric key, K_TOKEN, through key
   wrap and key derivation, using a passphrase-derived key-wrapping key,
   K_DERIVED.  The passphrase is known in advance by both the device
   user and the DSKPP server.  To preserve the property of not exposing
   K_TOKEN to any other entity than the DSKPP server and the
   cryptographic module itself, the method SHOULD be employed only when
   the device contains facilities (e.g. a keypad) for direct entry of
   the passphrase.  A key K from which two keys, K_TOKEN and K_MAC are
   derived MUST be wrapped.

A.4.2.  Identification

   This profile MUST be identified with the following URI:

   urn:ietf:params:xml:schema:keyprov:protocol#passphrase-wrap

A.4.3.  Payloads

   In the 2-pass version of DSKPP, the client MUST send a payload
   associated with this key initialization method.  The payload MUST be
   of type ds:KeyInfoType ([XMLDSIG]).  The ds:KeyName option MUST be
   used and the key name MUST identify the passphrase that will be used
   by the server to generate the key-wrapping key.  As an example, the
   identifier could be a user identifier or a registration identifier
   issued by the server to the user during a session preceding the DSKPP
   protocol run.

   The server payload associated with this key initialization method
   MUST be of type xenc:EncryptedKeyType ([XMLENC]), and only those
   encryption methods utilizing a passphrase to derive the key-wrapping
   key that are supported by the DSKPP client (as indicated in the
   <SupportedEncryptionAlgorithms> element of the <ClientHello> message
   in the case of 2-pass DSKPP, or as otherwise known in the case of
   1-pass DSKPP) are allowed as values for the <xenc:EncryptionMethod>
   element.  Further, in the case of 2-pass DSKPP, the <ds:KeyInfo>
   element MUST contain the same value (i.e. identify the same
   passphrase) as the <Payload> of the corresponding supported key
   initialization method in the <ClientHello> message that triggered the
   response.  The <CarriedKeyName> element MAY be present, and MUST,
   when present, contain the same value as the <KeyID> element of the
   <ServerFinished> message.  The Type attribute of the xenc:
   EncryptedKeyType MUST be present and MUST identify the type of the
   wrapped key.  The type MUST be one of the types supported by the



Doherty, et al.          Expires January 9, 2008               [Page 76]


Internet-Draft                    DSKPP                        July 2007


   DSKPP client (as reported in the <SupportedKeyTypes> of the preceding
   <ClientHello> message in the case of 2-pass DSKPP, or as otherwise
   known in the case of 1-pass DSKPP).  The wrapped key MUST consist of
   two parts of equal length.  The first half constitutes K_MAC and the
   second half constitutes K_TOKEN.  The length of K_TOKEN (and hence
   also the length of K_MAC) is determined by the type of K_TOKEN.

   DSKPP servers and cryptographic modules supporting this profile MUST
   support the PBES2 password based encryption scheme defined in
   [PKCS-5] (and identified as
   http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2 in
   [PKCS-5-XML]), the PBKDF2 passphrase-based key derivation function
   also defined in [PKCS-5] (and identified as
   http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbkdf2 in
   [PKCS-5-XML]), and the http://www.w3.org/2001/04/xmlenc#kw-aes128
   key-wrapping mechanism defined in [XMLENC].

   When this profile is used, the MacAlgorithm attribute of the <Mac>
   element of the <ServerFinished> message MUST be present and MUST
   identify the selected MAC algorithm.  The selected MAC algorithm MUST
   be one of the MAC algorithms supported by the DSKPP client (as
   indicated in the <SupportedMACAlgorithms> element of the
   <ClientHello> message in the case of 2-pass DSKPP, or as otherwise
   known in the case of 1-pass DSKPP).  The MAC MUST be calculated as
   described in Section 4.8

   In addition, DSKPP servers MUST include the AuthenticationDataType
   element (see further Section 4.8) in their <ServerFinished> messages
   whenever a successful protocol run will result in an existing K_TOKEN
   being replaced.


Appendix B.  Example Messages

   All examples are syntactically correct.  MAC and cipher values are
   fictitious however.

B.1.  Example Messages in a Four-pass Exchange

   The examples below illustrate a complete four-pass DSKPP exchange.











Doherty, et al.          Expires January 9, 2008               [Page 77]


Internet-Draft                    DSKPP                        July 2007


B.1.1.  Example of a DSKPP Initialization (Trigger) Message

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:DSKPPTrigger Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="urn:ietf:params:xml:schema:keyprov:protocol">
     <InitializationTrigger>
       <DeviceIdentifierData>
         <pskc:DeviceID>
           <Manufacturer>ManufacturerABC</Manufacturer>
           <SerialNo>XL0000000001234</SerialNo>
           <Model>U2</Model>
         </DeviceID>
       </DeviceIdentifierData>
       <TriggerNonce>112dsdfwf312asder394jw==</TriggerNonce>
     </InitializationTrigger>
   </dskpp:DSKPPTrigger>
































Doherty, et al.          Expires January 9, 2008               [Page 78]


Internet-Draft                    DSKPP                        July 2007


B.1.2.  Example of a <ClientHello> Message

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:ClientHello Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
     <DeviceIdentifierData>
       <pskc:DeviceID>
         <Manufacturer>ManufacturerABC</Manufacturer>
         <SerialNo>XL0000000001234</SerialNo>
         <Model>U2</Model>
       </DeviceID>
     </DeviceIdentifierData>
     <TriggerNonce>112dsdfwf312asder394jw==</TriggerNonce>
     <SupportedKeyTypes>
       <Algorithm>http://www.rsa.com/rsalabs/otps/schemas/2005/09/
         otps-wst#SecurID-AES</Algorithm>
       <Algorithm>http://www.openauthentication.org/OATH/2006/10/PSKC#
         HOTP</Algorithm>
     </SupportedKeyTypes>
     <SupportedEncryptionAlgorithms>
       <Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5</Algorithm>
       <Algorithm>urn:ietf:params:xml:schema:keyprov:protocol#
         dskpp-prf-aes</Algorithm>
     </SupportedMACAlgorithms>
       <Algorithm>urn:ietf:params:xml:schema:keyprov:protocol#
         dskpp-prf-aes</Algorithm>
     </SupportedMACAlgorithms>
     <SupportedProtocolVariants>FourPass</SupportedProtocolVariants>
     <SupportedKeyContainers>
       <KeyContainerFormat>
         urn:ietf:params:xml:schema:keyprov:container
       </KeyContainerFormat>
     </SupportedKeyContainers>
     <AuthenticationData>
       <AuthenticationCode>1erd354657689102abcd</AuthenticationCode>
     </AuthenticationData>
   </dskpp:ClientHello>










Doherty, et al.          Expires January 9, 2008               [Page 79]


Internet-Draft                    DSKPP                        July 2007


B.1.3.  Example of a <ServerHello> Message

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:ServerHello Version="1.0" SessionID="4114" Status="Success"
     xmlns:dskpp="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
     <KeyType>
       http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#
         SecurID-AES
     </KeyType>
     <EncryptionAlgorithm>
       urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
     </EncryptionAlgorithm>
     <MacAlgorithm>
       urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
     </MacAlgorithm>
     <EncryptionKey>
       <ds:KeyName>KEY-1</ds:KeyName>
     </EncryptionKey>
     <KeyContainerFormat>
       urn:ietf:params:xml:schema:keyprov:container
     </KeyContainerFormat>
     <Payload>
       <Nonce>qw2ewasde312asder394jw==</Nonce>
     </Payload>
   </dskpp:ServerHello>

B.1.4.  Example of a <ClientNonce> Message

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:ClientNonce Version="1.0" SessionID="4114"
     xmlns:dskpp="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
     <EncryptedNonce>VXENc+Um/9/NvmYKiHDLaErK0gk=</EncryptedNonce>
     <AuthenticationData>
       <AuthenticationCode>1erd354657689102abcd</AuthenticationCode>
     </AuthenticationData>
   </dskpp:ClientNonce>

B.1.5.  Example of a <ServerFinished> Message






Doherty, et al.          Expires January 9, 2008               [Page 80]


Internet-Draft                    DSKPP                        July 2007


   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:ServerFinished Version="1.0" SessionID="4114" Status="Success"
     xmlns:dskpp="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="urn:ietf:params:xml:schema:keyprov:protocol">
     <pskc:KeyContainer version="1.0">
       <Device>
         <Secret SecretAlgorithm="other" SecretAlgorithm-ext="SecurID"
           SecretId="XL0000000001234">
           <Issuer>CredentialIssuer</Issuer>
           <Usage otp="true">
             <ResponseFormat format="DECIMAL" length="6"/>
           </Usage>
           <FriendlyName>MyFirstToken</FriendlyName>
           <Data Name="TIME">
             <Value>Time</Value>
           </Data>
           <Expiry>10/30/2009</Expiry>
         </Secret>
       </Device>
     </pskc:KeyContainer>
     <Mac>miidfasde312asder394jw==</Mac>
   </dskpp:ServerFinished>

B.2.  Example Messages in a Two- or One-pass Exchange

   The examples illustrate a complete two-pass DSKPP exchange.  The
   server messages MAY also constitute the only messages in a one-pass
   DSKPP exchange.

B.2.1.  Example of a <ClientHello> Message Indicating Support for Two-
        pass DSKPP

   The client indicates support both for the two-pass key transport
   variant as well as the two-pass key wrap variant.

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:ClientHello Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     xmlns:pkcs-5=
     "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#">
     <DeviceIdentifierData>
       <pskc:DeviceID>



Doherty, et al.          Expires January 9, 2008               [Page 81]


Internet-Draft                    DSKPP                        July 2007


         <Manufacturer>ManufacturerABC</Manufacturer>
         <SerialNo>XL0000000001234</SerialNo>
         <Model>U2</Model>
       </DeviceID>
     </DeviceIdentifierData>
     <ClientNonce>1523sdfxe798jowie913ol==</ClientNonce>
     <SupportedKeyTypes>
       <Algorithm>
         http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#
           SecurID-AES
       </Algorithm>
       <Algorithm>
         http://www.openauthentication.org/OATH/2006/10/PSKC#HOTP
       </Algorithm>
     </SupportedKeyTypes>
     <SupportedEncryptionAlgorithms>
       <Algorithm>
         http://www.w3.org/2001/05/xmlenc#rsa_1_5
       </Algorithm>
       <Algorithm>
         http://www.w3.org/2001/04/xmlenc#kw-aes128
       </Algorithm>
       <Algorithm>
         http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#
           pbes2
       </Algorithm>
       <Algorithm>
         urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes
       </Algorithm>
     </SupportedMACAlgorithms>
       <Algorithm>urn:ietf:params:xml:schema:keyprov:protocol#
         dskpp-prf-aes</Algorithm>
     </SupportedMACAlgorithms>
     <SupportedProtocolVariants>
       <Variant>
         <TwoPass>
           <SupportedKeyInitializationMethod>
             urn:ietf:params:xml:schema:keyprov:protocol#wrap
           </SupportedKeyInitializationMethod>
           <Payload xsi:type="ds:KeyInfoType">
             <ds:KeyName>Key_001</ds:KeyName>
           </Payload>
           <SupportedKeyInitializationMethod>
             urn:ietf:params:xml:schema:keyprov:protocol#transport
           </SupportedKeyInitializationMethod>
           <Payload xsi:type="ds:KeyInfoType">
             <ds:X509Data>
               <ds:X509Certificate>miib</ds:X509Certificate>



Doherty, et al.          Expires January 9, 2008               [Page 82]


Internet-Draft                    DSKPP                        July 2007


             </ds:X509Data>
           </Payload>
         </TwoPass>
       </Variant>
     </SupportedProtocolVariants
     <SupportedKeyContainers>
       <KeyContainerFormat>
         urn:ietf:params:xml:schema:keyprov:container
       </KeyContainerFormat>
     </SupportedKeyContainers>
     <AuthenticationData>
       <AuthenticationCode>1erd354657689102abcd</AuthenticationCode>
     </AuthenticationData>
   </dskpp:ClientHello>

B.2.2.  Example of a <ServerFinished> Message Using the Key Transport
        Profile

   In this example, the server responds to the previous request using
   the key transport profile.































Doherty, et al.          Expires January 9, 2008               [Page 83]


Internet-Draft                    DSKPP                        July 2007


   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:ServerFinished Version="1.0" SessionID="4114" Status="Success"
     xmlns:dskpp="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     xmlns:xenc="http://www.w3.org/2001/04/xmlenc#">
     <pskc:KeyContainer version="1.0">
       <EncryptionMethod
         algorithm="http://www.w3.org/2001/05/xmlenc#rsa_1_5">
         <EncKeyLabel>43212093<
         <ds:KeyInfo>
           <ds:X509Data>
             <ds:X509Certificate>miib</ds:X509Certificate>
           </ds:X509Data>
         </ds:KeyInfo>
       </EncryptionMethod>
       <Device>
         <Secret SecretAlgorithm="HOTP" SecretId="SDU312345678">
           <Issuer>CredentialIssuer</Issuer>
           <Usage otp="true">
             <ResponseFormat format="DECIMAL" length="6"/>
           </Usage>
           <FriendlyName>MyFirstToken</FriendlyName>
           <Data Name="SECRET">
             <Value>
               7JHUyp3azOkqJENSsh6b2vxXzwGBYypzJxEr+ikQAa229KV/BgZhGA==
             </Value>
             <ValueDigest>
               9AEDpd4td44mRSASab625oPqlvHHIplzADer+pPOlL118JW/AhIoHB==
             </ValueDigest>
           </Data>
           <Data Name="COUNTER">
             <Value>1</Value>
           </Data>
           <Expiry>10/30/2009</Expiry>
         </Secret>
       </Device>
     </pskc:KeyContainer>
     <Mac MacAlgorithm=
       "urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes">
       miidfasde312asder394jw==
     </Mac>
   </dskpp:ServerFinished>






Doherty, et al.          Expires January 9, 2008               [Page 84]


Internet-Draft                    DSKPP                        July 2007


B.2.3.  Example of a <ServerFinished> Message Using the Key Wrap Profile

   In this example, the server responds to the previous request using
   the key wrap profile.















































Doherty, et al.          Expires January 9, 2008               [Page 85]


Internet-Draft                    DSKPP                        July 2007


   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:ServerFinished Version="1.0" SessionID="4114" Status="Success"
     xmlns:dskpp="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="urn:ietf:params:xml:schema:keyprov:protocol"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     xmlns:xenc="http://www.w3.org/2001/04/xmlenc#">
     <pskc:KeyContainer version="1.0">
       <EncryptionMethod
         algorithm="http://www.w3.org/2001/05/xmlenc#kw-aes128">
         <EncKeyLabel>43212093</EncKeyLabel>
         <ds:KeyInfo>
           <ds:KeyName>Key-001</ds:KeyName>
         </ds:KeyInfo>
       </EncryptionMethod>
       <Device>
         <Secret SecretAlgorithm="HOTP" SecretId="SDU312345678">
           <Issuer>CredentialIssuer</Issuer>
           <Usage otp="true">
             <ResponseFormat format="DECIMAL" length="6"/>
           </Usage>
           <FriendlyName>MyFirstToken</FriendlyName>
           <Data Name="SECRET">
              <Value>
               7JHUyp3azOkqJENSsh6b2vxXzwGBYypzJxEr+ikQAa229KV/BgZhGA==
             </Value>
             <ValueDigest>
               9AEDpd4td44mRSASab625oPqlvHHIplzADer+pPOlL118JW/AhIoHB==
             </ValueDigest>
           </Data>
           <Data Name="COUNTER">
             <Value>1</Value>
           </Data>
           <Expiry>10/30/2009</Expiry>
         </Secret>
       </Device>
     </pskc:KeyContainer>
     <Mac MacAlgorithm=
       "urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes">
       miidfasde312asder394jw==
     </Mac>
   </dskpp:ServerFinished>

B.2.4.  Example of a <ServerFinished> Message using the Passphrase-based
        Key Wrap Profile

   In this example, the server responds to the previous request using



Doherty, et al.          Expires January 9, 2008               [Page 86]


Internet-Draft                    DSKPP                        July 2007


   the passphrase-based key wrap profile.

 <?xml version="1.0" encoding="UTF-8"?>
 <dskpp:ServerFinished Version="1.0" SessionID="4114" Status="Success"
   xmlns:dskpp="urn:ietf:params:xml:schema:keyprov:protocol"
   xmlns:pskc="urn:ietf:params:xml:ns:keyprov:container"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="urn:ietf:params:xml:schema:keyprov:protocol"
   xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
   xmlns:xenc=http://www.w3.org/2001/04/xmlenc#
   xmlns:pkcs-5=
   "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#">
   <pskc:KeyContainer version="1.0">
     <EncryptionMethod algorithm=
         "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2">
       <pkcs-5:PBES2-params>
         <KeyDerivationFunc Algorithm=
           "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#
           pbkdf2">
           <pkcs-5:PBKDF2-params>
             <Salt>
               <Specified>32113435</Specified>
             </Salt>
             <IterationCount>1024</IterationCount>
             <KeyLength>128</KeyLength>
             <PRF/>
           </pkcs-5:PBKDF2-params>
         </KeyDerivationFunc>
         <EncryptionScheme Algorithm=
           "http://www.w3.org/2001/04/xmlenc#kw-aes128-cbc">
         </EncryptionScheme
       </pkcs-5:PBES2-params>
       <EncKeyLabel>43212093</EncKeyLabel>
       <ds:KeyInfo>
         <ds:KeyName>Passphrase1</ds:KeyName>
       </ds:KeyInfo>
     </EncryptionMethod>
     <Device>
       <Secret SecretAlgorithm="HOTP" SecretId="SDU312345678">
         <Issuer>CredentialIssuer</Issuer>
         <Usage otp="true">
           <ResponseFormat format="DECIMAL" length="6"/>
         </Usage>
         <FriendlyName>MyFirstToken</FriendlyName>
         <Data Name="SECRET">
           <Value>
             7JHUyp3azOkqJENSsh6b2vxXzwGBYypzJxEr+ikQAa229KV/BgZhGA==
           </Value>



Doherty, et al.          Expires January 9, 2008               [Page 87]


Internet-Draft                    DSKPP                        July 2007


           <ValueDigest>
             9AEDpd4td44mRSASab625oPqlvHHIplzADer+pPOlL118JW/AhIoHB==
           </ValueDigest>
         </Data>
         <Data Name="COUNTER">
           <Value>1</Value>
         </Data>
         <Expiry>10/30/2009</Expiry>
       </Secret>
     </Device>
   </pskc:KeyContainer>
   <Mac MacAlgorithm=
     "urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes">
     miidfasde312asder394jw==
   </Mac>
 </dskpp:ServerFinished>


Appendix C.  Requirements

   This section specifies mandatory and desirable protocol requirements.

   Req-1:

      The protocol MUST support provisioning of keys for use with
      multiple types of symmetric cryptographic algorithms.

   Req-2:

      The protocol MUST support pre-generated symmetric keys (by
      separate key issuance service) or locally generated keys in real-
      time (by provisioning server).

   Req-3:

      The protocol MUST support mutually generated symmetric keys by
      both client and server (i.e., joint key control).

   Req-4:

      The protocol MUST allow cryptographic modules to acquire multiple
      symmetric keys; each key MAY be acquired in a separate
      provisioning session.








Doherty, et al.          Expires January 9, 2008               [Page 88]


Internet-Draft                    DSKPP                        July 2007


   Req-5:

      The protocol MUST support renewal of a symmetric key with the
      original key ID.

   Req-6:

      The protocol MUST allow clients to specify their cryptographic
      capabilities to the server and the server to indicate the
      cryptography and algorithm types that it will be using.

   Req-7:

      The protocol MUST support mutual authentication and
      confidentiality of sensitive data during provisioning.

   Req-8:

      The protocol MAY use a public-key infrastructure and the use of
      client certificates for device authentication or symmetric key
      data protection.  The protocol MUST allow for other mechanisms,
      such as symmetric key-based techniques, to be used.

   Req-9:

      The protocol SHOULD NOT only rely on transport layer security.  It
      SHOULD be compatible with transport layer security when available.

   Req-10:

      The protocol SHOULD allow the server to use pre-loaded symmetric
      transport keys if available on the device that hosts the
      cryptographic module (i.e., smart card update keys, such as used
      by Global Platform for establishing a secure channel).

   Req-11:

      The protocol MUST protect against replay attacks.

   Req-12:

      The protocol MUST protect against MITM attacks.

   Req-13:

      The protocol MAY support a cryptographic module request to acquire
      multiple symmetric keys in the same session.




Doherty, et al.          Expires January 9, 2008               [Page 89]


Internet-Draft                    DSKPP                        July 2007


   Req-14:

      The protocol MAY allow the provisioning server to verify that the
      key has been correctly provisioned to the cryptographic module
      (i.e., key confirmation).

   Req-15:

      The protocol MAY allow a cryptographic module to notify the
      provisioning server upon symmetric key deletion.

   Req-16:

      The protocol MAY limit a protocol run to complete within a certain
      time window.

   Req-17:

      The protocol MAY support download of a key to a cryptographic
      module via SMS depending upon whether the application can provide
      an acceptable level of protection for transport of the symmetric
      key.


   The following is a list of features that are not required by the
   protocol:

   Non-Req-1:

      Support for cryptographic module generated symmetric key upload to
      a provisioning server.

   Non-Req-2:

      Support for other key lifecycle management functions, such as key
      suspension, lock, and activation.  These functions are supported
      in a symmetric key-based application, such as an authentication
      system.

   Non-Req-3:

      Support for asymmetric key pair provisioning.


Appendix D.  Integration with PKCS #11

   A DSKPP client that needs to communicate with a conncected
   cryptographic module to perform a DSKPP exchange MAY use PKCS #11



Doherty, et al.          Expires January 9, 2008               [Page 90]


Internet-Draft                    DSKPP                        July 2007


   [PKCS-11]as a programming interface.

D.1.  The 4-pass Variant

   When performing 4-pass DSKPP with a cryptographic module using the
   PKCS #11 programming interface, the procedure described in
   [CT-KIP-P11], Appendix B, is RECOMMENDED.

D.2.  The 2-pass Variant

   A suggested procedure to perform 2-pass DSKPP with a cryptographic
   module through the PKCS #11 interface using the mechanisms defined in
   [CT-KIP-P11] is as follows:

   a.  On the client side,
       1.  The client selects a suitable slot and token (e.g. through
           use of the <DeviceIdentifier> or the <PlatformInfo> element
           of the DSKPP trigger message).
       2.  A nonce R is generated, e.g. by calling C_SeedRandom and
           C_GenerateRandom.
       3.  The client sends its first message to the server, including
           the nonce R.
   b.  On the server side,
       1.  A generic key K = K_TOKEN | K _MAC (where '|' denotes
           concatenation) is generated, e.g. by calling C_GenerateKey
           (using key type CKK_GENERIC_SECRET).  The template for K MUST
           allow it to be exported (but only in wrapped form, i.e.
           CKA_SENSITIVE MUST be set to CK_TRUE and CKA_EXTRACTABLE MUST
           also be set to CK_TRUE), and also to be used for further key
           derivation.  From K, a token key K_TOKEN of suitable type is
           derived by calling C_DeriveKey using the PKCS #11 mechanism
           CKM_EXTRACT_KEY_FROM_KEY and setting the CK_EXTRACT_PARAMS to
           the first bit of the generic secret key (i.e. set to 0).
           Likewise, a MAC key K_MAC is derived from K by calling
           C_DeriveKey using the CKM_EXTRACT_KEY_FROM_KEY mechanism,
           this time setting CK_EXTRACT_PARAMS to the length of K (in
           bits) divided by two.
       2.  The server wraps K with either the token's public key
           K_CLIENT, the shared secret key K_SHARED, or the derived
           shared secret key K_DERIVED by using C_WrapKey.  If use of
           the DSKPP key wrap algorithm has been negotiated then the
           CKM_KIP_WRAP mechanism MUST be used to wrap K. When calling
           C_WrapKey, the hKey handle in the CK_KIP_PARAMS structure
           MUST be set to NULL_PTR.  The pSeed parameter in the
           CK_KIP_PARAMS structure MUST point to the nonce R provided by
           the DSKPP client, and the ulSeedLen parameter MUST indicate
           the length of R. The hWrappingKey parameter in the call to
           C_WrapKey MUST be set to refer to the wrapping key.



Doherty, et al.          Expires January 9, 2008               [Page 91]


Internet-Draft                    DSKPP                        July 2007


       3.  Next, the server needs to calculate a MAC using K_MAC.  If
           use of the DSKPP MAC algorithm has been negotiated, then the
           MAC is calculated by calling C_SignInit with the CKM_KIP_MAC
           mechanism followed by a call to C_Sign.  In the call to
           C_SignInit, K_MAC MUST be the signature key, the hKey
           parameter in the CK_KIP_PARAMS structure MUST be set to
           NULL_PTR, the pSeed parameter of the CT_KIP_PARAMS structure
           MUST be set to NULL_PTR, and the ulSeedLen parameter MUST be
           set to zero.  In the call to C_Sign, the pData parameter MUST
           be set to the concatenation of the string ID_S and the nonce
           R, and the ulDataLen parameter MUST be set to the length of
           the concatenated string.  The desired length of the MAC MUST
           be specified through the pulSignatureLen parameter and MUST
           be set to the length of R.
       4.  If the server also needs to authenticate its message (due to
           an existing K_TOKEN being replaced), the server MUST
           calculate a second MAC.  Again, if use of the DSKPP MAC
           algorithm has been negotiated, then the MAC is calculated by
           calling C_SignInit with the CKM_KIP_MAC mechanism followed by
           a call to C_Sign.  In this call to C_SignInit, the K_MAC
           existing before this DSKPP protocol run MUST be the signature
           key, the hKey parameter in the CK_KIP_PARAMS structure MUST
           be set to NULL, the pSeed parameter of the CT_KIP_PARAMS
           structure MUST be set to NULL_PTR, and the ulSeeidLen
           parameter MUST be set to zero.  In the call to C_Sign, the
           pData parameter MUST be set to the concatenation of the
           string ID_S and the nonce R, and the ulDataLen parameter MUST
           be set to the length of concatenated string.  The desired
           length of the MAC MUST be specified through the
           pulSignatureLen parameter and MUST be set to the length of R.
       5.  The server sends its message to the client, including the
           wrapped key K, the MAC and possibly also the authenticating
           MAC.
   c.  On the client side,
       1.  The client calls C_UnwrapKey to receive a handle to K. After
           this, the client calls C_DeriveKey twice: Once to derive
           K_TOKEN and once to derive K_MAC.  The client MUST use the
           same mechanism (CKM_EXTRACT_KEY_FROM_KEY) and the same
           mechanism parameters as used by the server above.  When
           calling C_UnwrapKey and C_DeriveKey, the pTemplate parameter
           MUST be used to set additional key attributes in accordance
           with local policy and as negotiated and expressed in the
           protocol.  In particular, the value of the <KeyID> element in
           the server's response message MAY be used as CKA_ID for
           K_TOKEN.  The key K MUST be destroyed after deriving K_TOKEN
           and K_MAC.





Doherty, et al.          Expires January 9, 2008               [Page 92]


Internet-Draft                    DSKPP                        July 2007


       2.  The MAC is verified in a reciprocal fashion as it was
           generated by the server.  If use of the CKM_KIP_MAC mechanism
           has been negotiated, then in the call to C_VerifyInit, the
           hKey parameter in the CK_KIP_PARAMS structure MUST be set to
           NULL_PTR, the pSeed parameter MUST be set to NULL_PTR, and
           ulSeedLen MUST be set to 0.  The hKey parameter of
           C_VerifyInit MUST refer to K_MAC.  In the call to C_Verify,
           pData MUST be set to the concatenation of the string ID_S and
           the nonce R, and the ulDataLen parameter MUST be set to the
           length of the concatenated string, pSignature to the MAC
           value received from the server, and ulSignatureLen to the
           length of the MAC.  If the MAC does not verify the protocol
           session ends with a failure.  The token MUST be constructed
           to not "commit" to the new K_TOKEN or the new K_MAC unless
           the MAC verifies.
       3.  If an authenticating MAC was received (REQUIRED if the new
           K_TOKEN will replace an existing key on the token), then it
           is verified in a similar vein but using the K_MAC associated
           with this server and existing before the protocol run.
           Again, if the MAC does not verify the protocol session ends
           with a failure, and the token MUST be constructed no to
           "commit" to the new K_TOKEN or the new K_MAC unless the MAC
           verifies.

D.3.  The 1-pass Variant

   A suggested procedure to perform 1-pass DSKPP with a cryptographic
   module through the PKCS #11 interface using the mechanisms defined in
   [CT-KIP-P11] is as follows:

   a.  On the server side,
       1.  A generic key K = K_TOKEN | K _MAC (where '|' denotes
           concatenation) is generated, e.g. by calling C_GenerateKey
           (using key type CKK_GENERIC_SECRET).  The template for K MUST
           allow it to be exported (but only in wrapped form, i.e.
           CKA_SENSITIVE MUST be set to CK_TRUE and CKA_EXTRACTABLE MUST
           also be set to CK_TRUE), and also to be used for further key
           derivation.  From K, a token key K_TOKEN of suitable type is
           derived by calling C_DeriveKey using the PKCS #11 mechanism
           CKM_EXTRACT_KEY_FROM_KEY and setting the CK_EXTRACT_PARAMS to
           the first bit of the generic secret key (i.e. set to 0).
           Likewise, a MAC key K_MAC is derived from K by calling
           C_DeriveKey using the CKM_EXTRACT_KEY_FROM_KEY mechanism,
           this time setting CK_EXTRACT_PARAMS to the length of K (in
           bits) divided by two.






Doherty, et al.          Expires January 9, 2008               [Page 93]


Internet-Draft                    DSKPP                        July 2007


       2.  The server wraps K with either the token's public key,
           K_CLIENT, the shared secret key, K_SHARED, or the derived
           shared secret key, K_DERIVED by using C_WrapKey.  If use of
           the DSKPP key wrap algorithm has been negotiated, then the
           CKM_KIP_WRAP mechanism MUST be used to wrap K. When calling
           C_WrapKey, the hKey handle in the CK_KIP_PARAMS structure
           MUST be set to NULL_PTR.  The pSeed parameter in the
           CK_KIP_PARAMS structure MUST point to the octet-string
           representation of an integer I whose value MUST be
           incremented before each protocol run, and the ulSeedLen
           parameter MUST indicate the length of the octet-string
           representation of I. The hWrappingKey parameter in the call
           to C_WrapKey MUST be set to refer to the wrapping key.

           Note: The integer-to-octet string conversion MUST be made
           using the I2OSP primitive from [PKCS-1].  There MUST be no
           leading zeros.
       3.  For the server's message to the client, if use of the DSKPP
           MAC algorithm has been negotiated, then the MAC is calculated
           by calling C_SignInit with the CKM_KIP_MAC mechanism followed
           by a call to C_Sign.  In the call to C_SignInit, K_MAC MUST
           be the signature key, the hKey parameter in the CK_KIP_PARAMS
           structure MUST be set to NULL_PTR, the pSeed parameter of the
           CT_KIP_PARAMS structure MUST be set to NULL_PTR, and the
           ulSeedLen parameter MUST be set to zero.  In the call to
           C_Sign, the pData parameter MUST be set to the concatenation
           of the string ID_S and the octet-string representation of the
           integer I, and the ulDataLen parameter MUST be set to the
           length of concatenated string.  The desired length of the MAC
           MUST be specified through the pulSignatureLen parameter as
           usual, and MUST be equal to, or greater than, sixteen (16).
       4.  If the server also needs to authenticate its message (due to
           an existing K_TOKEN being replaced), the server calculates a
           second MAC.  If the DSKPP MAC mechanism is used, the server
           does this by calling C_SignInit with the CKM_KIP_MAC
           mechanism followed by a call to C_Sign.  In the call to
           C_SignInit, the K_MAC existing on the token before this
           protocol run MUST be the signature key, the hKey parameter in
           the CK_KIP_PARAMS structure MUST be set to NULL_PTR, the
           pSeed parameter of the CT_KIP_PARAMS structure MUST be set to
           NULL_PTR, and the ulSeedLen parameter MUST be set to zero.
           In the call to C_Sign, the pData parameter MUST be set to the
           concatenation of the string ID_S and the octet-string
           representation of the integer I+1 (i.e.  I MUST be
           incremented before each use), and the ulDataLen parameter
           MUST be set to the length of the concatenated string.  The
           desired length of the MAC MUST be specified through the
           pulSignatureLen parameter as usual, and MUST be equal to, or



Doherty, et al.          Expires January 9, 2008               [Page 94]


Internet-Draft                    DSKPP                        July 2007


           greater than, sixteen (16).
       5.  The server sends its message to the client, including the MAC
           and possibly also the authenticating MAC.
   b.  On the client side,
       1.  The client calls C_UnwrapKey to receive a handle to K. After
           this, the client calls C_DeriveKey twice: Once to derive
           K_TOKEN and once to derive K_MAC.  The client MUST use the
           same mechanism (CKM_EXTRACT_KEY_FROM_KEY) and the same
           mechanism parameters as used by the server above.  When
           calling C_UnwrapKey and C_DeriveKey, the pTemplate parameter
           MUST be used to set additional key attributes in accordance
           with local policy and as negotiated and expressed in the
           protocol.  In particular, the value of the <KeyID> element in
           the server's response message MAY be used as CKA_ID for
           K_TOKEN.  The key K MUST be destroyed after deriving K_TOKEN
           and K_MAC.
       2.  The MAC is verified in a reciprocal fashion as it was
           generated by the server.  If use of the CKM_KIP_MAC mechanism
           has been negotiated, then in the call to C_VerifyInit, the
           hKey parameter in the CK_KIP_PARAMS structure MUST be set to
           NULL_PTR, the pSeed parameter MUST be set to NULL_PTR, and
           ulSeedLen MUST be set to 0.  The hKey parameter of
           C_VerifyInit MUST refer to K_MAC.  In the call to C_Verify,
           pData MUST be set to the concatenation of the string ID_S and
           the octet-string representation of the provided value for I,
           and the ulDataLen parameter MUST be set to the length of the
           concatenated string, pSignature to the MAC value received
           from the server, and ulSignatureLen to the length of the MAC.
           If the MAC does not verify or if the provided value of I is
           not larger than any stored value I' for the identified server
           ID_S the protocol session ends with a failure.  The token
           MUST be constructed to not "commit" to the new K_TOKEN or the
           new K_MAC unless the MAC verifies.  If the verification
           succeeds, the token MUST store the provided value of I as a
           new I' for ID_S.
       3.  If an authenticating MAC was received (REQUIRED if K_TOKEN
           will replace an existing key on the token), it is verified in
           a similar vein but using the K_MAC existing before the
           protocol run.  Again, if the MAC does not verify the protocol
           session ends with a failure, and the token MUST be
           constructed no to "commit" to the new K_TOKEN or the new
           K_MAC unless the MAC verifies.


Appendix E.  Example of DSKPP-PRF Realizations






Doherty, et al.          Expires January 9, 2008               [Page 95]


Internet-Draft                    DSKPP                        July 2007


E.1.  Introduction

   This example appendix defines DSKPP-PRF in terms of AES [FIPS197-AES]
   and HMAC [RFC2104].

E.2.  DSKPP-PRF-AES

E.2.1.  Identification

   For cryptographic modules supporting this realization of DSKPP-PRF,
   the following URI MAY be used to identify this algorithm in DSKPP:

   urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-aes

   When this URI is used to identify the encryption algorithm to use,
   the method for encryption of R_C values described in Section 4.7 MUST
   be used.

E.2.2.  Definition

   DSKPP-PRF-AES (k, s, dsLen)

   Input:
   k         Encryption keyto use
   s         Octet string consisting of randomizing material.  The
             length of the string s is sLen.
   dsLen     Desired length of the output

   Output:

   DS        A pseudorandom string, dsLen-octets long

   Steps:

   1.  Let bLen be the output block size of AES in octets:

       bLen = (AES output block length in octets)
       (normally, bLen = 16)
   2.  If dsLen > (2**32 - 1) * bLen, output "derived data too long" and
       stop
   3.  Let n be the number of bLen-octet blocks in the output data,
       rounding up, and let j be the number of octets in the last block:

       n = ROUND( dsLen / bLen)
       j = dsLen - (n - 1) * bLen






Doherty, et al.          Expires January 9, 2008               [Page 96]


Internet-Draft                    DSKPP                        July 2007


   4.  For each block of the pseudorandom string DS, apply the function
       F defined below to the key k, the string s and the block index to
       compute the block:

       B1 = F (k, s, 1) ,
       B2 = F (k, s, 2) ,
       ...
       Bn = F (k, s, n)
   The function F is defined in terms of the OMAC1 construction from
   [FSE2003], using AES as the block cipher:

   F (k, s, i) = OMAC1-AES (k, INT (i) || s)

   where INT (i) is a four-octet encoding of the integer i, most
   significant octet first, and the output length of OMAC1 is set to
   bLen.

   Concatenate the blocks and extract the first dsLen octets to product
   the desired data string DS:

   DS = B1 || B2 || ... || Bn<0..j-1>

   Output the derived data DS.

E.2.3.  Example

   If we assume that dsLen = 16, then:

   n = 16 / 16 = 1

   j = 16 - (1 - 1) * 16 = 16

   DS = B1 = F (k, s, 1) = OMAC1-AES (k, INT (1) || s)

E.3.  DSKPP-PRF-SHA256

E.3.1.  Identification

   For cryptographic modules supporting this realization of DSKPP-PRF,
   the following URI MAY be used to identify this algorithm in DSKPP:

   urn:ietf:params:xml:schema:keyprov:protocol#dskpp-prf-sha256

   When this URI is used to identify the encryption algorithm to use,
   the method for encryption of R_C values described in Section 4.7 MUST
   be used.





Doherty, et al.          Expires January 9, 2008               [Page 97]


Internet-Draft                    DSKPP                        July 2007


E.3.2.  Definition

   DSKPP-PRF-SHA256 (k, s, dsLen)

   Input:
   k         Encryption key to use
   s         Octet string consisting of randomizing material.  The
             length of the string s is sLen.
   dsLen     Desired length of the output

   Output:

   DS        A pseudorandom string, dsLen-octets long

   Steps:

   1.  Let bLen be the output size of SHA-256 in octets of [FIPS180-SHA]
       (no truncation is done on the HMAC output):

       bLen = 32
       (normally, bLen = 16)
   2.  If dsLen > (2**32 - 1) * bLen, output "derived data too long" and
       stop
   3.  Let n be the number of bLen-octet blocks in the output data,
       rounding up, and let j be the number of octets in the last block:

       n = ROUND( dsLen / bLen)
       j = dsLen - (n - 1) * bLen
   4.  For each block of the pseudorandom string DS, apply the function
       F defined below to the key k, the string s and the block index to
       compute the block:

       B1 = F (k, s, 1) ,
       B2 = F (k, s, 2) ,
       ...
       Bn = F (k, s, n)
   The function F is defined in terms of the HMAC construction from
   [RFC2104], using SHA-256 as the digest algorithm:

   F (k, s, i) = HMAC-SHA256 (k, INT (i) || s)

   where INT (i) is a four-octet encoding of the integer i, most
   significant octet first, and the output length of HMAC is set to
   bLen.

   Concatenate the blocks and extract the first dsLen octets to product
   the desired data string DS:




Doherty, et al.          Expires January 9, 2008               [Page 98]


Internet-Draft                    DSKPP                        July 2007


   DS = B1 || B2 || ... || Bn<0..j-1>

   Output the derived data DS.

E.3.3.  Example

   If we assume that sLen = 256 (two 128-octet long values) and dsLen =
   16, then:

   n = ROUND ( 16 / 32 ) = 1

   j = 16 - (1 - 1) * 32 = 16

   B1 = F (k, s, 1) = HMAC-SHA256 (k, INT (1) || s)

   DS = B1<0 ... 15>

   That is, the result will be the first 16 octets of the HMAC output.


Authors' Addresses

   Andrea Doherty
   RSA, The Security Division of EMC

   Email: adoherty@rsa.com


   Mingliang Pei
   VeriSign, Inc.

   Email: mpei@verisign.com


   Magnus Nystroem
   RSA, The Security Division of EMC

   Email: magnus@rsa.com


   Salah Machani
   Diversinet Corp.

   Email: smachani@diversinet.com







Doherty, et al.          Expires January 9, 2008               [Page 99]


Internet-Draft                    DSKPP                        July 2007


Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Acknowledgment

   Funding for the RFC Editor function is provided by the IETF
   Administrative Support Activity (IASA).





Doherty, et al.          Expires January 9, 2008              [Page 100]




