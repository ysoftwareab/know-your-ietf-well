<?xml version="1.0" encoding="UTF-8"?>


<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" docName="draft-ietf-lwig-tcp-constrained-node-networks-13" number="9006" ipr="trust200902" obsoletes="" updates="" submissionType="IETF" category="info" consensus="true" xml:lang="en" tocInclude="true" tocDepth="4" symRefs="true" sortRefs="true" version="3">

  <!-- xml2rfc v2v3 conversion 3.5.0 -->

  <front>
   
    <title abbrev="TCP in IoT">
    TCP Usage Guidance in the Internet of Things (IoT)
    </title>
    <seriesInfo name="RFC" value="9006"/>
 
    <author fullname="Carles Gomez" initials="C." surname="Gomez">
      <organization>UPC</organization>
      <address>
        <postal>
          <street>C/Esteve Terradas, 7</street>
          <city>Castelldefels</city>
          <region/>
          <code>08860</code>
          <country>Spain</country>
        </postal>
        <phone/>
        <email>carlesgo@entel.upc.edu</email>
        <uri/>
      </address>
    </author>
    <author fullname="Jon Crowcroft" initials="J." surname="Crowcroft">
      <organization>University of Cambridge</organization>
      <address>
        <postal>
          <street>JJ Thomson Avenue</street>
          <city>Cambridge</city>
          <code>CB3 0FD</code>
          <country>United Kingdom</country>
        </postal>
        <phone/>
        <email>jon.crowcroft@cl.cam.ac.uk</email>
        <uri/>
      </address>
    </author>
    <author fullname="Michael Scharf" initials="M." surname="Scharf">
      <organization>Hochschule Esslingen</organization>
      <address>
        <postal>
	  <street> University of Applied Sciences</street>
          <street>Flandernstr. 101</street>
          <city>Esslingen am Neckar</city>
          <region/>
          <code>73732</code>
          <country>Germany</country>
        </postal>
        <phone/>
        <email>michael.scharf@hs-esslingen.de</email>
        <uri/>
      </address>
    </author>

    <date month="March" year="2021"/>

    <area>APP</area>
    <workgroup>LWIG Working Group</workgroup>

    <abstract>
      <t> This document provides guidance on how to implement and use the Transmission Control Protocol (TCP) in Constrained-Node Networks (CNNs), which are a characteristic of the Internet of Things (IoT). Such environments require a lightweight TCP implementation and may not make use of optional functionality. This document explains a number of known and deployed techniques to simplify a TCP stack as well as corresponding trade-offs. The objective is to help embedded developers with decisions on which TCP features to use.</t>
    </abstract>
  </front>
  <middle>
    <section numbered="true" toc="default">
      <name>Introduction</name>
      <t>The Internet Protocol suite is being used for connecting Constrained-Node Networks (CNNs) to the Internet, enabling the so-called Internet of Things (IoT) <xref target="RFC7228" format="default"/>. In order to meet the requirements that stem from CNNs, the IETF has produced a suite of new protocols specifically designed for such environments (see, e.g., <xref target="RFC8352" format="default"/>).
         New IETF protocol stack components include the IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs) adaptation layer 
         <xref target="RFC4944" format="default"/><xref target="RFC6282" format="default"/><xref target="RFC6775" format="default"/>, the IPv6 Routing Protocol for Low-Power and Lossy Networks (RPL)
         <xref target="RFC6550" format="default"/>, and the Constrained Application Protocol (CoAP) <xref target="RFC7252" format="default"/>.</t>
      <t>As of this writing, the main transport-layer protocols in IP-based IoT scenarios are UDP and TCP.  TCP has been
   criticized, often unfairly, as a protocol that is unsuitable for the IoT.  It is true that some TCP features, such as relatively long header size, 
   unsuitability for multicast, and always-confirmed data delivery, are not optimal for IoT scenarios. However, 
         many typical claims on TCP unsuitability for IoT (e.g., a high complexity, connection-oriented approach incompatibility with radio duty-cycling and spurious congestion control activation
         in wireless links) are not valid, can be solved, or are also found in well-accepted IoT end-to-end reliability mechanisms (see a detailed analysis in <xref target="IntComp" format="default"/>).
      </t>
      <t>At the application layer, CoAP was developed over UDP <xref target="RFC7252" format="default"/>.  However, the integration of some
   CoAP deployments with existing infrastructure is being challenged by
   middleboxes such as firewalls, which may limit and even block UDP-based
   communications.  This is the main reason why a CoAP over TCP
      specification has been developed  <xref target="RFC8323" format="default"/>.</t>
      
      <t>Other application-layer protocols not specifically
   designed for CNNs are also being considered for the IoT space.  Some
   examples include HTTP/2 and even HTTP/1.1, both of which run over TCP
   by default  <xref target="RFC7230" format="default"/> <xref target="RFC7540" format="default"/>, and the Extensible Messaging and Presence Protocol (XMPP) <xref target="RFC6120" format="default"/>.  TCP is also used by non-IETF
   application-layer protocols in the IoT space such as the Message Queuing Telemetry Transport (MQTT) <xref target="MQTT" format="default"/> and its
      lightweight variants.</t>
      
      <t>TCP is a sophisticated transport protocol that includes optional
   functionality (e.g., TCP options) that may improve performance in some environments. However, many
   optional TCP extensions require complex logic inside the TCP stack
   and increase the code size and the memory requirements.  Many
   TCP extensions are not required for interoperability with other
   standard-compliant TCP endpoints.  Given
   the limited resources on constrained devices, careful selection of optional TCP features can make an implementation more lightweight.
      </t>
      <t>This document provides guidance on how to implement and configure TCP
 and guidance on how applications should use TCP in CNNs. The overarching goal is to offer simple measures to allow for lightweight TCP implementation and suitable operation in such environments. A TCP implementation following the guidance in this document is intended to be compatible with a TCP endpoint that is compliant to the TCP standards, albeit possibly with a lower performance. This implies that such a TCP client would always be able to connect with a standard-compliant TCP server, and a corresponding TCP server would always be able to connect with a standard-compliant TCP client.</t>
      <t>This document assumes that the reader is familiar with TCP. A comprehensive survey of the TCP standards can be found in RFC 7414 <xref target="RFC7414" format="default"/>. Similar guidance regarding the use of TCP in special environments has been published before, e.g., for cellular wireless networks <xref target="RFC3481" format="default"/>.
      </t>
    </section>
    <section numbered="true" toc="default">
      <name>Characteristics of CNNs Relevant for TCP</name>
      <section numbered="true" toc="default">
        <name>Network and Link Properties</name>
        <t>CNNs are defined in <xref target="RFC7228" format="default"/> as networks whose characteristics are influenced by being composed of a significant portion of constrained nodes. 
         The latter are characterized by significant limitations on processing, memory, and energy resources, among others <xref target="RFC7228" format="default"/>. 
         The first two dimensions pose constraints on the complexity and memory footprint of the protocols that constrained nodes can support. The latter requires techniques to save energy, such as radio duty-cycling in wireless devices <xref target="RFC8352" format="default"/> and the minimization of the number of messages transmitted/received (and their size).</t>
        <t><xref target="RFC7228" format="default"/> lists typical network constraints in CNNs, including low achievable bitrate/throughput, high packet loss and high variability of packet loss, highly asymmetric link characteristics, severe penalties for using larger packets, limits on reachability over time, etc. CNNs may use wireless or wired technologies (e.g., Power Line Communication), and the transmission rates are typically low (e.g., below 1 Mbps).</t>
        <t>For use of TCP, one challenge is that not all technologies in a CNN may be aligned with typical Internet subnetwork design principles <xref target="RFC3819" format="default"/>. For instance, constrained nodes often use physical- / link-layer technologies that
   have been characterized as 'lossy', i.e., exhibit a relatively high bit error rate. Dealing with corruption loss is one of the open issues in the Internet <xref target="RFC6077" format="default"/>.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Usage Scenarios</name>
        <t>There are different deployment and usage scenarios for CNNs. Some CNNs follow the star topology, whereby one or several hosts are linked to a central
         device that acts as a router connecting the CNN to the Internet. Alternatively, CNNs may also follow the multihop topology <xref target="RFC6606" format="default"/>. 
        </t>
        <t>In constrained environments, there can be different types of devices <xref target="RFC7228" format="default"/>.
      For example, there can be devices with a single combined send/receive buffer, a separate send and receive buffer, or a pool 
      of multiple send/receive buffers. In the latter case, it is possible that buffers are also shared for other protocols.</t>

      <t>
      One key use case for TCP in CNNs is a model where
   constrained devices connect to unconstrained servers in the Internet.
   But it is also possible that both TCP endpoints run on constrained
   devices.
   In the first case, 
   communication will possibly traverse a middlebox (e.g., a firewall,
   NAT, etc.).  Figure 1 illustrates such a scenario.  Note that the
   scenario is asymmetric, as the unconstrained device will typically
   not suffer the severe constraints of the constrained device.  The
   unconstrained device is expected to be mains-powered, have a high
   amount of memory and processing power, and be connected to a
   resource-rich network.
        </t>
        <t>
   Assuming that a majority of constrained devices will correspond to 
   sensor nodes, the amount of data traffic sent by constrained devices 
   (e.g., sensor node measurements) is expected to be higher than the 
   amount of data traffic in the opposite direction. Nevertheless, 
   constrained devices may receive requests (to which they may 
   respond), commands (for configuration purposes and for constrained 
   devices including actuators), and relatively infrequent 
   firmware/software updates.

        </t>
        <figure anchor="fig_scenario">
          <name>TCP Communication between a Constrained Device and an Unconstrained Device, Traversing a Middlebox</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[    
                                                   +---------------+
        o     o <-------- TCP communication -----> |               |
       o     o                                     |               |
          o     o                                  | Unconstrained |
    o        o              +-----------+          |    device     |
        o     o   o  ------ | Middlebox |  ------- |               |
         o   o              +-----------+          | (e.g., cloud) |
       o    o  o                                   |               |
                                                   +---------------+ 
   Constrained devices
        ]]></artwork>
        </figure>
      </section>
      <section numbered="true" toc="default">
        <name>Communication and Traffic Patterns</name>
        <t>IoT applications are characterized by a number of different communication patterns. The following non-comprehensive list explains some typical examples:</t>
        <dl spacing="normal">
          <dt>Unidirectional transfers:</dt><dd>An IoT device (e.g., a sensor) can (repeatedly) send updates to the other endpoint. There is not always a need for an application response back to the IoT device. </dd>
          <dt>Request-response patterns:</dt><dd>An IoT device receiving a request from the other endpoint, which triggers a response from the IoT device.</dd>
          <dt>Bulk data transfers:</dt><dd>A typical example for a long file transfer would be an IoT device firmware update.</dd>
        </dl>
        <t>A typical communication pattern is that a constrained device communicates with an unconstrained device (cf.&nbsp;<xref target="fig_scenario" format="default"/>). But it is also possible that constrained devices communicate amongst themselves.</t>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>TCP Implementation and Configuration in CNNs</name>
      <t>This section explains how a TCP stack can deal with typical constraints in CNN. The guidance in this section relates to the TCP implementation and its configuration.
      </t>
      <section numbered="true" toc="default">
        <name>Addressing Path Properties</name>
        <section numbered="true" toc="default">
          <name>Maximum Segment Size (MSS)</name>
          <t>Assuming that IPv6 is used, and for the sake of lightweight implementation and operation, unless applications
          require handling large data units (i.e., leading to an IPv6 datagram
          size greater than 1280 bytes), it may be desirable to limit the IP datagram size to 
          1280 bytes in order to avoid the need to support Path MTU Discovery <xref target="RFC8201" format="default"/>.
          In addition, an IP datagram size of 1280 bytes avoids incurring IPv6-layer fragmentation <xref target="RFC8900" format="default"/>. 
          </t>

          <t>An IPv6 datagram size exceeding 1280 bytes can be avoided by setting the TCP MSS to 1220 bytes or less.  Note that
   it is already a requirement for TCP implementations to consume payload space instead of increasing datagram size when including IP or TCP options
   in an IP packet to be sent <xref target="RFC6691" format="default"/>.  Therefore, it is not required to advertise an MSS smaller than 1220 bytes in order to accommodate TCP options.
          </t>
          <t>Note that setting the MTU to 1280 bytes is possible for link-layer technologies in the CNN space, even if some of them are characterized by a short data unit payload size, e.g., up to a few tens or hundreds of bytes. 
          For example, the maximum frame size in IEEE 802.15.4 is 127 bytes.
          6LoWPAN defined an adaptation layer to support IPv6 over IEEE 802.15.4 networks. The adaptation layer includes a fragmentation mechanism, 
          since IPv6 requires the layer below to support an MTU of 1280 bytes <xref target="RFC8200" format="default"/>, while IEEE 802.15.4 lacks fragmentation mechanisms. 
          6LoWPAN defines an IEEE 802.15.4 link MTU of 1280 bytes <xref target="RFC4944" format="default"/>. Other technologies, such as Bluetooth low energy <xref target="RFC7668" format="default"/>, 
          ITU-T G.9959 <xref target="RFC7428" format="default"/>, or Digital Enhanced Cordless
            Telecommunications (DECT) Ultra Low Energy (ULE) <xref target="RFC8105" format="default"/>, also use 6LoWPAN-based adaptation layers in order to enable 
          IPv6 support. These technologies do support link-layer fragmentation.  By exploiting this 
          functionality, the adaptation layers that enable IPv6 over such technologies also define an MTU of 1280 bytes.
          </t>
          <t>On the other hand, there exist technologies also used in the CNN space, such as Master Slave (MS) / Token Passing (TP) <xref target="RFC8163" format="default"/>, 
             Narrowband IoT (NB-IoT) <xref target="RFC8376" format="default"/>, or IEEE 802.11ah <xref target="I-D.delcarpio-6lo-wlanah" format="default"/>, 
             that do not suffer the same degree of frame size limitations as the technologies mentioned above.
	     It is recommended that the MTU for MS/TP be 1500 bytes <xref target="RFC8163" format="default"/>;
             the MTU in NB-IoT is 1600 bytes, and the maximum frame payload size for IEEE 802.11ah is 7991 bytes.
          </t>
          <t> Using a larger MSS (to a suitable extent) may be beneficial in some scenarios, 
              especially when transferring large payloads, as it reduces the number of packets (and packet headers)
              required for a given payload.  However, the characteristics of the constrained network need to be considered. 
              In particular, in a lossy network where unreliable fragment delivery is used, the amount of data that TCP unnecessarily
              retransmits due to fragment loss increases (and throughput decreases) quickly with the MSS. This happens because the loss of a fragment leads to the
              loss of the whole fragmented packet being transmitted. Unnecessary data retransmission is particularly
              harmful in CNNs due to the resource constraints of such environments.

	      Note that, while the original 6LoWPAN fragmentation 
              mechanism <xref target="RFC4944" format="default"/> does not offer reliable fragment delivery, fragment recovery functionality for 6LoWPAN or 6Lo environments
              has been standardized <xref target="RFC8931" format="default"/>.
          </t>
        </section>
        <section numbered="true" toc="default">
          <name>Explicit Congestion Notification (ECN)</name>
          <t>ECN <xref target="RFC3168" format="default"/> allows a router to signal
             in the IP header of a packet that congestion is rising, for example,
             when a queue size reaches a certain threshold.  An ECN-enabled TCP
             receiver will echo back the congestion signal to the TCP sender by
             setting a flag in its next TCP Acknowledgment (ACK).  The sender triggers congestion
             control measures as if a packet loss had happened.
          </t>
          <t>RFC 8087 <xref target="RFC8087" format="default"/> outlines the principal gains in terms of increased throughput,
             reduced delay, and other benefits when ECN is used over a network path that includes equipment that supports Congestion Experienced
             (CE) marking.  In the context of CNNs, a remarkable feature of ECN is that congestion can be signaled without incurring packet drops (which will lead to retransmissions and consumption of limited resources such as energy and bandwidth).
          </t>
          <t>ECN can further reduce packet losses since congestion control
   measures can be applied earlier <xref target="RFC2884" format="default"/>.  Fewer lost packets implies
   that the number of retransmitted segments decreases, which is
   particularly beneficial in CNNs, where energy and bandwidth resources
   are typically limited.  Also, it makes sense to try to avoid packet
   drops for transactional workloads with small data sizes, which are
   typical for CNNs.  In such traffic patterns, it is more difficult and often impossible to
   detect packet loss without retransmission timeouts (e.g., as there
   may not be three duplicate ACKs).  Any retransmission timeout slows
   down the data transfer significantly.  In addition, if the
   constrained device uses power-saving techniques, a retransmission
   timeout will incur a wake-up action, in contrast to ACK
   clock-triggered sending.  When the congestion window of a TCP sender has a
  size of one segment and a TCP ACK with an ECN signal (ECN-Echo (ECE) flag) arrives
  at the TCP sender, the TCP sender resets the retransmit timer, and
  the sender will only be able to send a new packet when the retransmit
  timer expires. Effectively, at that moment, the TCP sender reduces its
  sending rate from 1 segment per Round-Trip Time (RTT) to 1
  segment per Retransmission Timeout (RTO) and reduces the sending rate further on each ECN signal
  received in subsequent TCP ACKs. Otherwise, if an ECN signal is not
  present in a subsequent TCP ACK, the TCP sender resumes the normal
  ACK-clocked transmission of segments <xref target="RFC3168" format="default"/>.
          </t>
          <t>ECN can be
   incrementally deployed in the Internet.  Guidance on configuration and usage of ECN is provided in RFC 7567 <xref target="RFC7567" format="default"/>.
   Given the benefits, more and more TCP stacks in the Internet support ECN, and it makes sense to specifically leverage ECN in controlled
   environments such as CNNs. As of this writing, there is ongoing work to extend the types of TCP packets that are ECN capable, including pure ACKs <xref target="I-D.ietf-tcpm-generalized-ecn" format="default"/>. 
   Such a feature may further increase the benefits of ECN in CNN environments. Note, however, that supporting ECN increases implementation complexity.
          </t>
        </section>
        <section numbered="true" toc="default">
          <name>Explicit Loss Notifications</name>
          <t>There has been a significant body of research on solutions capable of explicitly indicating whether a TCP segment loss is due to corruption, in order to avoid activation of congestion control mechanisms <xref target="ETEN" format="default"/> <xref target="RFC2757" format="default"/>. While such solutions may provide significant improvement, they have not been widely deployed and remain as experimental work. In fact, as of today, the IETF has not standardized any such solution.
          </t>
        </section>
      </section>
      <section numbered="true" toc="default">
        <name>TCP Guidance for Single-MSS Stacks</name>
        <t>This section discusses TCP stacks that allow transferring a single MSS. More general guidance is provided in <xref target="Beyond1MSS" format="default"/>.
        </t>
        <section numbered="true" toc="default" anchor="single_MSS_stacks_benefits">
          <name>Single-MSS Stacks -- Benefits and Issues</name>
          <t>   A TCP stack can reduce the memory requirements by advertising a TCP window size of 1 MSS and also transmit, at most, 1 MSS of
                unacknowledged data.  In that case, both congestion and flow control implementation are quite simple.  Such a small receive and send window
                may be sufficient for simple message exchanges in the CNN space. However, only using a window of 1 MSS can significantly affect
                performance.  A stop-and-wait operation results in low throughput for transfers that exceed the length of 1 MSS, e.g., a firmware
                download.  Furthermore, a single-MSS solution relies solely on timer-based loss recovery, therefore missing the performance gain of Fast
                Retransmit and Fast Recovery (which requires a larger window size; see <xref target="loss_recovery_flow" format="default"/>).
          </t>
          <t>If CoAP is used over TCP with the default setting for NSTART in RFC 7252 <xref target="RFC7252" format="default"/>, a CoAP endpoint is not allowed to send 
             a new message to a destination until a response for the previous message sent to that destination has been received. This is equivalent to an
             application-layer window size of 1 data unit.  For this use of CoAP, a maximum TCP window of 1 MSS may be sufficient, as long as the 
             CoAP message size does not exceed 1 MSS. An exception in CoAP over TCP, though, is the Capabilities and Settings Message (CSM) that must be sent at the
             start of the TCP connection. The first application message carrying user data is allowed to be sent immediately after the CSM message.
             If the sum of the CSM size plus the application message size exceeds the MSS, a sender using a single-MSS stack will need to wait for the ACK confirming 
             the CSM before sending the application message. 
          </t>
        </section>
        <section numbered="true" toc="default">
          <name>TCP Options for Single-MSS Stacks</name>
          <t>A TCP implementation needs to support, at a minimum, TCP options 2, 1, and 0. These are, respectively, the MSS option,
             the No-Operation option, and the End Of Option List marker <xref target="RFC0793" format="default"/>. None of these are a substantial burden to support. 
             These options are sufficient for interoperability with a standard-compliant TCP endpoint, albeit many TCP stacks support additional options
             and can negotiate their use. A TCP implementation is permitted to silently ignore all other TCP options.
          </t>
          <t>A TCP implementation for a constrained device that uses a single-MSS TCP receive or transmit window size may not benefit from supporting the following TCP options: Window Scale <xref target="RFC7323" format="default"/>, TCP Timestamps <xref target="RFC7323" format="default"/>, Selective Acknowledgment (SACK) <xref target="RFC2018" format="default"/>, and SACK-Permitted <xref target="RFC2018" format="default"/>. Also, other TCP options may not be required on a constrained device with a very lightweight implementation. With regard to 
             the Window Scale option, note that it is only useful if a window size greater than 64 kB is needed.
          </t>
          <t>
	     Note that a TCP sender can benefit from the TCP Timestamps option <xref target="RFC7323" format="default"/> in detecting spurious RTOs. The latter are quite likely to occur
             in CNN scenarios due to a number of reasons (e.g., route changes in a multihop scenario, link-layer retries, etc.). The header overhead incurred 
             by the Timestamps option (of up to 12 bytes) needs to be taken into account.
          </t>
        </section>
        <section anchor="DelAck" numbered="true" toc="default">
          <name>Delayed Acknowledgments for Single-MSS Stacks</name>
          <t>TCP Delayed Acknowledgments are meant to reduce the number of ACKs sent within a TCP connection, thus reducing network overhead, but
             they may increase the time until a sender may receive an ACK.  In general, usefulness of Delayed ACKs depends heavily on the usage
             scenario (see <xref target="delayed_ACKs" format="default"/>).  There can be interactions with single-MSS stacks.
          </t>
          <t>When traffic is unidirectional, if the sender can send at most 1 MSS of data or the receiver advertises a receive window not greater than the MSS, Delayed ACKs may unnecessarily contribute delay (up to 500 ms) to the RTT <xref target="RFC5681" format="default"/>, which limits the throughput and can increase data delivery time. Note that, in some cases, it may not be possible to disable Delayed ACKs.    One known workaround is to split the
             data to be sent into two segments of smaller size.  A standard-compliant TCP receiver may immediately acknowledge the second MSS of data, which
             can improve throughput. However, this "split hack" may not always work since a TCP receiver is required to acknowledge every second full-sized segment, but not two consecutive small segments. The overhead of sending two IP
             packets instead of one is another downside of the "split hack".
          </t>
          <t>Similar issues may happen when the sender uses the Nagle algorithm, since the sender may need to wait for an unnecessarily Delayed ACK
             to send a new segment. Disabling the algorithm will not have impact if the sender can only handle stop-and-wait operation
             at the TCP level. 
          </t>
          <t>For request-response traffic, when the receiver uses Delayed ACKs, a response to a data message can piggyback an ACK, as long as the latter is sent before the Delayed ACK timer expires, thus avoiding unnecessary ACKs without payload. 
             Disabling Delayed ACKs at the request sender allows an immediate ACK for the data segment carrying the response.
          </t>

        </section>
        <section numbered="true" toc="default">
          <name>RTO Calculation for Single-MSS Stacks</name>
          <t>The RTO calculation is one of the fundamental TCP algorithms <xref target="RFC6298" format="default"/>. There is a fundamental trade-off: 
             a short, aggressive RTO behavior reduces wait time before retransmissions, but it also increases the probability of spurious timeouts. 
             The latter leads to unnecessary waste of potentially scarce resources in CNNs such as energy and bandwidth. In contrast, 
             a conservative timeout can result in long error recovery times and, thus, needlessly delay data delivery.
          </t>
          <t>If a TCP sender uses a very small window size, and it cannot benefit from Fast Retransmit and Fast Recovery or SACK, the RTO algorithm has a
            large impact on performance. In that case, RTO algorithm tuning may be considered, although careful
            assessment of possible drawbacks is recommended <xref target="RFC8961" format="default"/>. 
          </t>
          <t>As an example, adaptive RTO algorithms defined for CoAP over UDP have been found to perform well in CNN scenarios <xref target="Commag" format="default"/>
            <xref target="I-D.ietf-core-fasor" format="default"/>.
          </t>
        </section>
      </section>
      <section anchor="Beyond1MSS" numbered="true" toc="default">
        <name>General Recommendations for TCP in CNNs</name>
        <t>This section summarizes some widely used techniques to improve TCP, with a focus on their use in CNNs. The TCP extensions discussed here are useful in a wide range of network scenarios, including CNNs. This section is not comprehensive. A comprehensive survey of TCP extensions is published in RFC 7414 <xref target="RFC7414" format="default"/>.</t>
        <section numbered="true" toc="default" anchor="loss_recovery_flow">
          <name>Loss Recovery and Congestion/Flow Control</name>
          <t>Devices that have enough memory to allow a larger (i.e., more than 3 MSS of data) TCP window size can leverage a more efficient loss recovery 
             than the timer-based approach used for a smaller TCP window size (see <xref target="single_MSS_stacks_benefits" format="default"/>) by 
             using Fast Retransmit and Fast Recovery <xref target="RFC5681" format="default"/>, at the expense of slightly greater complexity and Transmission Control Block (TCB) size. 
             Assuming that Delayed ACKs are used by the receiver, a window size of up to 5 MSS is required for Fast Retransmit and Fast Recovery 
             to work efficiently: in a given TCP transmission of full-sized segments 1, 2, 3, 4, and 5, if segment 2 gets lost, and the ACK for segment 1 
             is held by the Delayed ACK timer, then the sender should get an ACK for segment 1 when 3 arrives and duplicate ACKs when segments 4, 5, and 6
             arrive.  It will retransmit segment 2 when the third duplicate ACK arrives.  In order to have segments 2, 3, 4, 5, and 6 sent, the window
             has to be of at least 5 MSS.  With an MSS of 1220 bytes, a buffer of a size of 5 MSS would require 6100 bytes.
          </t>
          <t>The example in the previous paragraph did not use a further TCP improvement such as Limited Transmit <xref target="RFC3042" format="default"/>. The latter
             may also be useful for any transfer that has more than one segment in flight. Small transfers tend
             to benefit more from Limited Transmit, because they are more likely to not receive enough duplicate ACKs. Assuming the example 
             in the previous paragraph, Limited Transmit allows sending 5 MSS with a congestion window (cwnd) of three segments, plus two additional 
             segments for the first two duplicate ACKs. With Limited Transmit, even a cwnd of two segments allows sending 5 MSS, at the expense of 
             additional delay contributed by the Delayed ACK timer for the ACK that confirms segment 1.              
          </t>
          <t>When a multiple-segment window is used, the receiver will need to manage the reception of possible out-of-order received segments, 
             requiring sufficient buffer space. Note that even when a window of 1 MSS is used, out-of-order arrival should also be managed, as the sender may send multiple sub-MSS packets that fit in the window. (On the other hand, the receiver is free to simply drop out-of-order segments, thus forcing retransmissions.)
          </t>
          <section numbered="true" toc="default">
            <name>Selective Acknowledgments (SACKs)</name>
            <t>
   If a device with less severe memory and processing constraints can
   afford advertising a TCP window size of several MSSs, it makes sense
   to support the SACK option to improve performance.  SACK allows a
   data receiver to inform the data sender of non-contiguous data blocks
   received, thus a sender (having previously sent the SACK-Permitted
   option) can avoid performing unnecessary retransmissions, saving
   energy and bandwidth, as well as reducing latency. In addition, SACK often allows for faster loss recovery when there is more than one lost segment in a window of data, since SACK recovery may complete with less RTTs. SACK is
   particularly useful for bulk data transfers.  A receiver supporting SACK will need to keep track of the data blocks that need to be received. The sender will also need to keep track of which data segments need to be resent after learning which data blocks are missing at the receiver. SACK adds
   8*n+2 bytes to the TCP header, where n denotes the number of data
   blocks received, up to four blocks.  For a low number of out-of-order
   segments, the header overhead penalty of SACK is compensated by
   avoiding unnecessary retransmissions. When the sender discovers the data blocks that have already been received, it needs to also 
   store the necessary state to avoid unnecessary retransmission of data segments that have already been received.
            </t>
          </section>
        </section>
        <section numbered="true" toc="default" anchor="delayed_ACKs">
          <name>Delayed Acknowledgments</name>
          <t>For certain traffic patterns, Delayed ACKs may have a detrimental effect, as already noted in <xref target="DelAck" format="default"/>. Advanced TCP stacks may use heuristics to determine the maximum delay for an ACK. For CNNs, the recommendation depends on the expected communication patterns.
          </t>
          <t>When traffic over a CNN is expected mostly to be unidirectional messages with a size typically up to 1 MSS, and the time between two 
             consecutive message transmissions is greater than the Delayed ACK timeout, it may make sense to use a smaller timeout or disable Delayed ACKs
             at the receiver. This avoids incurring additional delay, as well as the energy consumption of the sender (which might, e.g., keep its radio 
             interface in receive mode) during that time. Note that disabling Delayed ACKs may only be possible if the peer device is administered 
             by the same entity managing the constrained device. For request-response traffic, enabling Delayed ACKs is recommended at
             the server end, in order to allow combining a response with the ACK into a single segment, thus increasing efficiency.  In addition, if
             a client issues requests infrequently, disabling Delayed ACKs at the client allows an immediate ACK for the data segment
             carrying the response.
          </t>
          <t>In contrast, Delayed ACKs allow for a reduced number of ACKs in bulk transfer types of traffic, e.g., for firmware/software updates or for transferring larger data units containing a batch of sensor readings.  
          </t>
          <t>Note that, in many scenarios, the peer that a constrained device communicates with will be a general purpose system that communicates with both constrained and unconstrained devices. Since Delayed ACKs are often configured through system-wide parameters, the behavior of Delayed ACKs at the peer will be the same regardless of the nature of the endpoints it talks to. Such a peer will typically have Delayed ACKs enabled.
          </t>
        </section>
        <section numbered="true" toc="default">
          <name>Initial Window</name>
          <t><xref target="RFC5681" format="default"/> specifies a TCP Initial Window (IW) of roughly 4 kB. Subsequently, RFC 6928 <xref target="RFC6928" format="default"/> defines an experimental new value for the IW,
             which in practice will result in an IW of 10 MSS. Nowadays, the latter is used in many TCP implementations. 
          </t>
          <t>Note that a 10-MSS IW was recommended for resource-rich environments (e.g., broadband environments), which are significantly different from CNNs.
             In CNNs, many application-layer data units are relatively small (e.g., below 1 MSS). However, larger objects (e.g., large files containing 
             sensor readings, firmware updates, etc.) may also need to be transferred in CNNs. If such a large object is transferred in CNNs, with an IW 
             setting of 10 MSS, there is significant buffer overflow risk, since many CNN devices support network or radio buffers of a size smaller than 10 MSS.
             In order to avoid such a problem, the IW needs to be carefully set in CNNs, based
             on device and network resource constraints. In many cases, a safe IW setting will be smaller than 10 MSS.
          </t>
        </section>
      </section>
    </section>
    <section numbered="true" toc="default">
      <name>TCP Usage Recommendations in CNNs</name>
      <t>This section discusses how TCP can be used by applications that are developed for CNN scenarios. These remarks are by and large independent of how TCP is exactly implemented.
      </t>
      <section numbered="true" toc="default">
        <name>TCP Connection Initiation</name>
        <t>In the scenario of a constrained device to an unconstrained device illustrated 
        above, a TCP connection is typically initiated by the constrained 
        device, in order for the device to support possible sleep periods to 
        save energy.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Number of Concurrent Connections</name>
        <t>TCP endpoints with a small amount of memory may only support a small
   number of connections.  Each TCP connection requires storing a number
   of variables in the TCB.  Depending on
   the internal TCP implementation, each connection may result in
   further memory overhead, and connections may compete for scarce resources (e.g., further memory overhead for send and receive buffers, etc.).
        </t>
        <t>A careful application design may try to keep the number of concurrent connections as small as possible. A client can, for instance, limit the number of simultaneous open connections that it maintains to a given server. Multiple connections could, for instance, be used to avoid the "head-of-line blocking" problem in an application transfer. However, in addition to consuming resources, using multiple connections can also cause undesirable side effects in congested networks. 
           For example, the HTTP/1.1 specification encourages clients to be conservative when opening multiple connections <xref target="RFC7230" format="default"/>.
           Furthermore, each new connection will start with a three-way handshake, therefore increasing message overhead.
        </t>
        <t>Being conservative when opening multiple TCP connections is of particular importance in Constrained-Node Networks.</t>
      </section>
      <section anchor="short_connections" numbered="true" toc="default">
        <name>TCP Connection Lifetime</name>
        <t>In order to minimize message overhead, it makes sense to keep a TCP connection
        open as long as the two TCP endpoints have more data to send. If applications
        exchange data rather infrequently, i.e., if TCP connections would stay idle for a long time,
        the idle time can result in problems. For instance, certain middleboxes
        such as firewalls or NAT devices are known to delete state records after an inactivity interval.

         RFC 5382 <xref target="RFC5382" format="default"/> specifies a minimum value for such an interval of 124 minutes. Measurement studies have reported that TCP NAT binding timeouts are highly 
        variable across devices, 
        with the median being around 60 minutes, the shortest timeout being around 2 minutes, and more than 50% of the devices with a timeout shorter than the 
        aforementioned minimum timeout of 124 minutes <xref target="HomeGateway" format="default"/>. The timeout duration used by a
        middlebox implementation may not be known to the TCP endpoints.</t>
	
        <t>In CNNs, such middleboxes may, e.g., be present at the boundary between the CNN and other networks.
        If the middlebox can be optimized for CNN use cases, it makes sense to increase the initial value
        for filter state inactivity timers to avoid problems with idle connections. Apart from that,
        this problem can be dealt with by different connection-handling strategies, each having pros and cons.</t>
	
        <t>One approach for infrequent data transfer is to use short-lived TCP connections.
        Instead of trying to maintain a TCP connection for a long time, it is possible that short-lived 
        connections can be opened between two endpoints, which are closed if no more data needs
        to be exchanged. For use cases that can cope with the additional messages and the latency
        resulting from starting new connections, it is recommended to use a sequence of short-lived connections instead of maintaining a single long-lived connection.</t>
        <t>
        The message and latency overhead that stems from using a sequence of short-lived connections could be reduced by TCP Fast Open (TFO) <xref target="RFC7413" format="default"/>,
        which is an experimental TCP extension, at the expense of increased implementation complexity and increased TCB size.  TFO allows data to be
        carried in SYN (and SYN-ACK) segments and to be consumed immediately
        by the receiving endpoint.  This reduces the message and latency overhead compared to
        the traditional three-way handshake to establish a TCP connection.
        For security reasons, the connection initiator has to request a TFO
        cookie from the other endpoint.  The cookie, with a size of 4 or 16
        bytes, is then included in SYN packets of subsequent connections.
        The cookie needs to be refreshed (and obtained by the client) after a
        certain amount of time.  While a given cookie is used for multiple connections between the same two endpoints,
        the latter may become vulnerable to privacy threats. In addition, a valid cookie may be stolen from a compromised host
        and may be used to perform SYN flood attacks, as well as amplified reflection attacks to victim hosts (see <xref target="RFC7413" sectionFormat="of" section="5"/>). 
        Nevertheless, TFO is more efficient than
        frequently opening new TCP connections with the traditional three-way
        handshake, as long as the cookie can be reused in subsequent
        connections. However, as stated in <xref target="RFC7413" format="default"/>, TFO deviates from the standard TCP semantics, since the data in the SYN could be replayed
        to an application in some rare circumstances. Applications should not use TFO unless they can tolerate this issue, e.g., by using 
        TLS <xref target="RFC7413" format="default"/>. A comprehensive discussion on TFO can be found in RFC 7413 <xref target="RFC7413" format="default"/>.
        </t>
        <t>Another approach is to use long-lived TCP connections with
          application-layer heartbeat messages.  Various application protocols
          support such heartbeat messages (e.g., CoAP over TCP <xref target="RFC8323" format="default"/>).   
          Periodic application-layer heartbeats can prevent early filter state record deletion in middleboxes. 
          If the TCP binding timeout for a middlebox to be traversed by a given connection is known, middlebox filter
          state deletion will be avoided if the heartbeat period is lower than the middlebox TCP binding timeout. 
          Otherwise, the implementer needs to take into account that middlebox TCP binding timeouts fall in a wide range 
          of possible values <xref target="HomeGateway" format="default"/>, and it may be hard to find a proper heartbeat period for application-layer heartbeat messages.
        </t>
        <t>
          One specific advantage of heartbeat messages is that they also allow liveness checks at the
          application level.  In general, it makes sense to realize
          liveness checks at the highest protocol layer possible that is
          meaningful to the application, in order to maximize the depth of the
          liveness check.  In addition, timely detection of a dead peer may
          allow savings in terms of TCB memory use. However, the transmission of 
          heartbeat messages consumes resources. This aspect needs to be assessed carefully, considering the characteristics of each specific CNN.
        </t>
        <t>A TCP implementation may also be able to send "keep-alive" segments to test a TCP connection.
        According to <xref target="RFC1122" format="default"/>, keep-alives are an optional TCP mechanism that is
        turned off by default, i.e., an application must explicitly enable it for a TCP connection.
        The interval between keep-alive messages must be configurable, and it must default to no less
        than two hours. With this large timeout, TCP keep-alive messages might not always be useful to avoid deletion of 
        filter state records in some middleboxes.  However, sending TCP keep-alive probes more frequently risks draining power on energy-
        constrained devices.
        </t>

      </section>
    </section>
    <section anchor="Security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>Best current practices for securing TCP and TCP-based communication also applies to CNN. As an example, use of TLS <xref target="RFC8446" format="default"/> is strongly recommended if it is applicable.
         However, note that TLS protects only the contents of the data segments.
      </t>
      <t>There are TCP options that can actually protect the transport layer.  One example is the TCP Authentication Option (TCP-AO) <xref target="RFC5925" format="default"/>. 
         However, this option adds overhead and complexity. TCP-AO typically has a size of 16-20 bytes.
         An implementer needs to asses the trade-off between security and performance when using TCP-AO, considering the characteristics (in terms of energy, bandwidth, and computational power)
         of the environment where TCP will be used.
      </t>
      <t>For the mechanisms discussed in this document, the corresponding considerations apply. For instance, if TFO is used, the security considerations of  RFC 7413 <xref target="RFC7413" format="default"/> apply.</t>
      <t>Constrained devices are expected to support smaller TCP window sizes than less-limited devices. In such conditions, segment retransmission
         triggered by RTO expiration is expected to be relatively frequent, due to lack of (enough) duplicate ACKs, especially when a constrained device
         uses a single-MSS implementation. For this reason, constrained devices running TCP may appear as particularly appealing victims of the so-called
         "shrew" Denial-of-Service (DoS) attack <xref target="SHREW" format="default"/>, whereby one or more sources generate a packet spike targeted to coincide with consecutive 
         RTO-expiration-triggered retry attempts of a victim node. Note that the attack may be performed by Internet-connected devices,
         including constrained devices in the same CNN as the victim, as well as remote ones. Mitigation techniques include RTO randomization and attack blocking by routers able to detect
         shrew attacks based on their traffic pattern. </t>
    </section>

 <section anchor="IANA" numbered="true" toc="default">
   <name>IANA Considerations</name>
   <t>This document has no IANA actions.</t>
 </section>
    

  </middle>


  <back>

<displayreference target="I-D.ietf-core-fasor" to="CORE-FASOR"/>
<displayreference target="I-D.delcarpio-6lo-wlanah" to="6LO-WLANAH"/>
<displayreference target="I-D.ietf-tcpm-generalized-ecn" to="TCPM-ECN"/>


    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.0793.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.1122.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7323.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2018.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8200.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3168.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3042.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5681.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6298.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6691.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6928.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7228.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7413.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7567.xml"/>
      </references>
      <references>
        <name>Informative References</name>
  

        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8201.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2757.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2884.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3481.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3819.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4944.xml"/>
	<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5382.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5925.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6077.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6120.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6282.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6550.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6606.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6775.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7252.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7414.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7428.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7540.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7668.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8087.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8105.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8163.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8323.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8352.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8376.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8900.xml"/>

<!-- draft-delcarpio-6lo-wlanah-01; Expired -->
<reference anchor='I-D.delcarpio-6lo-wlanah'>
<front>
<title>IPv6 over 802.11ah</title>
<author initials='L' surname='Del Carpio Vega' fullname='Luis Felipe Del Carpio Vega'>
    <organization />
</author>
<author initials='M' surname='Robles' fullname='Maria Ines Robles'>
    <organization />
</author>
<author initials='R' surname='Morabito' fullname='Roberto Morabito'>
    <organization />
</author>
<date month='October' day='19' year='2015' />
</front>
<seriesInfo name='Internet-Draft' value='draft-delcarpio-6lo-wlanah-01' />
</reference>


<!--  [I-D.ietf-core-fasor] IESG state I-D Exists -->
        <xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.ietf-core-fasor.xml"/>

<!--  [I-D.ietf-tcpm-rto-consider] Published as RFC 8961 -->
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8961.xml"/>

<!--  [I-D.ietf-6lo-fragment-recovery] Published as RFC 8931 -->
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8931.xml"/>

<!-- [I-D.ietf-tcpm-generalized-ecn] IESG state I-D Exists -->
        <xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.ietf-tcpm-generalized-ecn.xml"/>
    

<reference anchor="Commag">
  <front>
    <title>CoAP Congestion Control for the Internet of Things</title>
    <author initials='A.' surname='Betzler' fullname='August Betzler'>
     <organization />
    </author>
  <author initials='C.' surname='Gomez' fullname='Carles Gomez'>
  <organization /></author>
  <author initials='I.' surname='Demirkol' fullname='Ilker Demirkol'>
  <organization />
  </author>
  <author initials='J.' surname='Paradells' fullname='Josep Paradelis'>
   <organization /></author>
        <date year="2016" month="July"/>
  </front>
   <seriesInfo name="DOI" value="10.1109/MCOM.2016.7509394"/>
  <refcontent>IEEE Communications Magazine, Vol. 54, Issue 7, pp. 154-160</refcontent>
</reference>


	
	
        <reference anchor="IntComp">
          <front>
            <title>TCP in the Internet of Things: from Ostracism to Prominence</title>
            <author initials='C.' surname='Gomez' fullname='Carles Gomez'>
            <organization /></author>
	      <author initials='A.' surname='Arcia-Moret' fullname='Andres Arcia-Moret'>
              <organization /></author>
	       <author initials='J.' surname='Crowcroft' fullname='Jon Crowcroft'>
            <organization /></author>
            <date year="2018" month="January"/>
          </front>
	   <seriesInfo name="DOI" value="10.1109/MIC.2018.112102200"/>
	 <refcontent>IEEE Internet Computing, Vol. 22, Issue 1, pp. 29-41</refcontent>
        </reference>


        <reference anchor="MQTT">
          <front>
            <title>Information technology -- Message Queuing Telemetry Transport (MQTT) v3.1.1</title>
            <author>
              <organization>ISO/IEC</organization>
            </author>
            <date year="2016" month="June"/>
          </front>
	  <refcontent>ISO/IEC 20922:2016</refcontent>
        </reference>


        <reference anchor="HomeGateway">
          <front>
            <title>An Experimental Study of Home Gateway Characteristics</title>
	      <author initials='S.' surname='Haetoenen' fullname='Seppo Haetoenen'>
              <organization /></author>
              <author initials='A.' surname='Nyrhinen' fullname='Aki Nyrhinen'>
              <organization /></author>
	      <author initials='L.' surname='Eggert' fullname='Lars Eggert'>
              <organization /></author>
	         <author initials='S.' surname='Strowes' fullname='S. Strowes'>
		 <organization /></author>
		 <author initials='P.' surname='Sarolahti' fullname='Pasi Sarolahti'>
		 <organization /></author>
		<author initials='M.' surname='Kojo' fullname='Markku Kojo'>
              <organization /></author>
             <date year="2010" month="November"/>
	  </front>
	  <seriesInfo name="DOI" value="10.1145/1879141.1879174"/>
         <refcontent>Proceedings of the 10th ACM SIGCOMM conference on Internet measurement, pp. 260-266</refcontent>
        </reference>


        <reference anchor="SHREW">
          <front>
            <title>Low-Rate TCP-Targeted Denial of Service Attacks (The Shrew vs. the Mice and Elephants)</title>
	     <author initials='A.' surname='Nyrhinen' fullname='Aleksandar Kuzmanovic'>
              <organization /></author>
              <author initials='E.' surname='Knightly' fullname='Edward Knightly'>
              <organization /></author>
            <date year="2003" month="August"/>
          </front>
	  <seriesInfo name="DOI" value="10.1145/863955.863966"/>
	  <refcontent>SIGCOMM'03</refcontent>
        </reference>

	
        <reference anchor="ETEN">
          <front>
            <title>Explicit transport error notification (ETEN) for error-prone wireless and satellite networks</title>
	      <author initials='R.' surname='Krishnan' fullname='Rajesh Krishnan'>
              <organization /></author>
	       <author initials='J.' surname='Sterbenz' fullname='James Sterbenz'>
               <organization /></author>
	         <author initials='W.' surname='Eddy' fullname='Wesley Eddy'>
              <organization /></author>
            <author initials='C.' surname='Partridge' fullname='C. Partridge'>
              <organization /></author>
            <date year="2004" month="June"/>
          </front>
	  <seriesInfo name="DOI" value="10.1016/j.comnet.2004.06.012"/>
	 <refcontent>Computer Networks</refcontent>
        </reference>


     <reference anchor="Dunk">
          <front>
            <title>Full TCP/IP for 8-Bit Architectures</title>
	    <author initials='A.' surname='Dunkels' fullname='Adam Dunkels'>
              <organization /></author>
            <date year="2003" month="May"/>
          </front>
	   <seriesInfo name="DOI" value="10.1145/1066116.106611"/>
	  <refcontent>MobiSys '03, pp. 85-98</refcontent>
        </reference>


        <reference anchor="RIOT">
          <front>
            <title>RIOT: An Open Source Operating System for Low-End Embedded Devices in the IoT</title>
 <author initials='E.' surname='Baccelli' fullname='Emmanuel Baccelli'>
 <organization /></author>
  <author initials='C.' surname='Gndoa' fullname='Cenk Gndoa'>
  <organization /></author>
  <author initials='O.' surname='Hahm' fullname='Oliver Hahm'>
  <organization /></author>
    <author initials='P.' surname='Kietzmann' fullname='Kietzmann'>
    <organization /></author>
      <author initials='M.' surname='Lenders' fullname='Martine Lenders'>
      <organization /></author>
        <author initials='H.' surname='Petersen' fullname='Hauke Petersen'>
	<organization /></author>
	  <author initials='K.' surname='Schleiser' fullname='Schleiser'>
	  <organization /></author>
	    <author initials='T.' surname='Schmidt' fullname='Thomas Schmidt'>
	    <organization /></author>
	      <author initials='M.' surname='Whlisch' fullname='Matthias Whlisch'>
               <organization /></author>
            <date year="2018" month="March"/>
          </front>
	   <seriesInfo name="DOI" value="10.1109/JIOT.2018.2815038"/>
	   <refcontent>IEEE Internet of Things Journal, Vol. 5, Issue 6</refcontent>
        </reference>


        <reference anchor="GNRC">
          <front>
            <title>Connecting the World of Embedded Mobiles: The RIOT Approach to Ubiquitous Networking for the IoT</title>
	   <author initials='M.' surname='Lenders' fullname='Martine Lenders'>
	   <organization /></author>
           <author initials='P.' surname='Kietzmann' fullname='Kietzmann'>
	   <organization /></author>
	   <author initials='O.' surname='Hahm' fullname='Oliver Hahm'>
	   <organization /></author>
	    <author initials='H.' surname='Petersen' fullname='Hauke Petersen'>
	    <organization /></author>
	    <author initials='C.' surname='Gndoa' fullname='Cenk Gndoa'>
	    <organization /></author>
	    <author initials='E.' surname='Baccelli' fullname='Emmanuel Baccelli'>
	    <organization /></author>
	    <author initials='K.' surname='Schleiser' fullname='Schleiser'>
	    <organization /></author>
	    <author initials='T.' surname='Schmidt' fullname='Thomas Schmidt'>
	    <organization /></author>
	    <author initials='M.' surname='Whlisch' fullname='Matthias Whlisch'>
	    <organization /></author>
            <date year="2018" month="January"/>
          </front>
	   <refcontent>arXiv:1801.02833v1 [cs.NI]</refcontent>
        </reference>
      </references>
    </references>

        <section numbered="true" toc="default">
      <name>TCP Implementations for Constrained Devices</name>
      <t>This section overviews the main features of TCP implementations for constrained devices. The survey is limited to open-source stacks with a small footprint. It is not meant to be all-encompassing. For more powerful embedded systems (e.g., with 32-bit processors), there are further stacks that comprehensively implement TCP. On the other hand, please be aware that this Annex is based on information available as of the writing.</t>
      <section numbered="true" toc="default">
        <name>uIP</name>
        <t>uIP is a TCP/IP stack, targeted for 8- and 16-bit microcontrollers, which pioneered TCP/IP implementations for constrained devices.
           uIP has been deployed with Contiki and the Arduino Ethernet shield. A code size of ~5 kB (which comprises checksumming, IPv4, ICMP, and TCP) 
           has been reported for uIP <xref target="Dunk" format="default"/>. Later versions of uIP implement IPv6 as well.</t>
        <t>uIP uses the same global buffer for both incoming and outgoing traffic, which has a
           size of a single packet.  In case of a retransmission, an application must be able to reproduce the same user data that had been
           transmitted. Multiple connections are supported but need to share the global buffer.
        </t>
        <t>The MSS is announced via the MSS option on connection establishment, and the receive window size (of 1 MSS) is not modified during a connection. Stop-and-wait operation is used for sending data. Among other optimizations, this allows for the avoidance of sliding window operations, which use 32-bit arithmetic extensively and are expensive on 8-bit CPUs.</t>
        <t>Contiki uses the "split hack" technique (see <xref target="DelAck" format="default"/>) to avoid Delayed ACKs for senders using a single segment.</t>

	
        <t>The code size of the TCP implementation in Contiki-NG has been measured to be 3.2 kB on CC2538DK, cross-compiling on Linux.</t>
      </section>
      <section numbered="true" toc="default">
        <name>lwIP</name>
        <t>lwIP is a TCP/IP stack, targeted for 8- and 16-bit microcontrollers. lwIP has a total code size of ~14 kB to ~22 kB 
          (which comprises memory management, checksumming, network interfaces, IPv4, ICMP, and TCP) and a TCP code size of ~9 kB to ~14 kB <xref target="Dunk" format="default"/>.
        Both IPv4 and IPv6 are supported in lwIP since v2.0.0.</t>
	
        <t>In contrast with uIP, lwIP decouples applications from the network stack. lwIP supports a TCP transmission window greater than a single segment, as well as the buffering of incoming and outgoing data. Other implemented mechanisms comprise slow start, congestion avoidance, fast retransmit, and fast recovery. 
           SACK and Window Scale support has been recently added to lwIP.</t>
      </section>
      <section numbered="true" toc="default">
        <name>RIOT</name>
        <t> The RIOT TCP implementation (called "GNRC TCP") has been designed for Class 1 devices <xref target="RFC7228" format="default"/>. The main target platforms are 8- and 16-bit microcontrollers, with 32-bit platforms also supported. GNRC TCP 
            offers a similar function set as uIP, but it provides and maintains an independent receive buffer for each connection. In contrast to uIP, retransmission is also handled by GNRC TCP. For simplicity, GNRC TCP uses a single-MSS implementation. The application programmer does not need to know anything about the TCP internals; therefore, GNRC TCP can be seen as a user-friendly uIP TCP implementation.
        </t>
        <t> The MSS is set on connections establishment and cannot be changed during connection lifetime. GNRC TCP allows multiple connections in parallel, but each TCB must 
            be allocated somewhere in the system. By default, there is only enough memory allocated for a single TCP connection, but it can be increased at compile time if the user needs multiple parallel connections.
        </t>

	
        <t> The RIOT TCP implementation offers an optional Portable Operating System Interface (POSIX) socket wrapper that enables POSIX compliance, if needed.
        </t>
        <t> Further details on RIOT and GNRC can be found in <xref target="RIOT" format="default"/> and <xref target="GNRC" format="default"/>. 
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>TinyOS</name>
        <t>TinyOS was important as a platform for early constrained devices. TinyOS has an experimental TCP stack that uses a simple non-blocking library-based implementation of TCP, which provides a subset of the socket interface primitives. The application is responsible for buffering. The TCP library does not do any receive-side buffering. Instead, it will immediately dispatch new, in-order data to the application or otherwise drop the segment. A send buffer is provided by the application. Multiple TCP connections are possible. Recently, there has been little work on the stack.</t>
      </section>
      <section numbered="true" toc="default">
        <name>FreeRTOS</name>
        <t>FreeRTOS is a real-time operating system kernel for embedded devices that 
              is supported by 16- and 32-bit microprocessors. Its TCP implementation is based on multiple-segment window size, although a "Tiny-TCP" option, which is a single-MSS variant, can be enabled. Delayed ACKs are supported, with a 20 ms Delayed ACK timer as a technique intended "to gain performance".
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>uC/OS</name>
        <t>uC/OS is a real-time operating system kernel for embedded devices, which is maintained by Micrium.&nbsp; uC/OS is intended for 8-, 16-, and 32-bit microprocessors. The uC/OS TCP implementation supports a multiple-segment window size.
        </t>
      </section>
      <section numbered="true" toc="default">
        <name>Summary</name>

	<t>None of the implementations considered in this Annex support ECN or TFO.</t>
	
<table anchor="table_1"> 
  <name>Summary of TCP Features for Different Lightweight TCP Implementations</name>   
  <thead>  
    <tr>
      <th colspan="2"></th>   
      <th>uIP</th>
      <th>lwIP orig</th>
      <th>lwIP 2.1</th>
      <th>RIOT</th>
      <th>TinyOS</th>
      <th>FreeRTOS</th>
      <th>uC/OS</th>
    </tr>
    </thead>
    <tbody>

<tr>
      <td colspan="2">Code Size (kB)</td>
      <td align="center">&lt;5</td>
      <td align="center">~9 to ~14</td>
      <td align="center">38</td>
      <td align="center">&lt;7</td>
      <td align="center">N/A</td>
      <td align="center">&lt;9.2</td>
      <td align="center">N/A</td>
</tr>
<tr>
      <td colspan="2">Memory</td>
      <td align="center">(a)</td>
      <td align="center">(T1)</td>
      <td align="center">(T4)</td>
      <td align="center">(T3)</td>
      <td align="center">N/A</td>
      <td align="center">(T2)</td>
      <td align="center">N/A</td>
</tr>
<tr>
 <th rowspan="1" colspan="9" align="left">TCP Features</th>
</tr>
    <tr>
      <td rowspan="1" colspan="2" align="right">Single-Segm.</td>
      <td align="center">Yes</td>
      <td align="center">No</td>
      <td align="center">No</td>
      <td align="center">Yes</td>
      <td align="center">No</td>
      <td align="center">No</td>
      <td align="center">No</td>
    </tr>
    <tr>
      <td rowspan="1" colspan="2" align="right">Slow start</td>
      <td align="center">No</td>
      <td align="center">Yes</td>
      <td align="center">Yes</td>
      <td align="center">No</td>
      <td align="center">Yes</td>
      <td align="center">No</td>
      <td align="center">Yes</td>
    </tr>
     <tr>
      <td rowspan="1" colspan="2" align="right">Fast rec/retx</td>
      <td align="center">No</td>
      <td align="center">Yes</td>
      <td align="center">Yes</td>
      <td align="center">No</td>
      <td align="center">Yes</td>
      <td align="center">No</td>
      <td align="center">Yes</td>
     </tr>
       <tr>
      <td rowspan="1" colspan="2" align="right">Keep-alive</td>
      <td align="center">No</td>
      <td align="center">No</td>
      <td align="center">Yes</td>
      <td align="center">No</td>
      <td align="center">No</td>
      <td align="center">Yes</td>
      <td align="center">Yes</td>
       </tr>
         <tr>
      <td rowspan="1" colspan="2" align="right">Win. Scale</td>
      <td align="center">No</td>
      <td align="center">No</td>
      <td align="center">Yes</td>
      <td align="center">No</td>
      <td align="center">No</td>
      <td align="center">Yes</td>
      <td align="center">No</td>
	 </tr>
	 <tr>
      <td rowspan="1" colspan="2" align="right">TCP timest.</td>
      <td align="center">No</td>
      <td align="center">No</td>
      <td align="center">Yes</td>
      <td align="center">No</td>
      <td align="center">No</td>
      <td align="center">Yes</td>
      <td align="center">No</td>
	 </tr>
	  <tr>
      <td rowspan="1" colspan="2" align="right">SACK</td>
      <td align="center">No</td>
      <td align="center">No</td>
      <td align="center">Yes</td>
      <td align="center">No</td>
      <td align="center">No</td>
      <td align="center">Yes</td>
      <td align="center">No</td>
	  </tr>
	 <tr>
      <td rowspan="1" colspan="2" align="right">Del. ACKs</td>
      <td align="center">No</td>
      <td align="center">Yes</td>
      <td align="center">Yes</td>
      <td align="center">No</td>
      <td align="center">No</td>
      <td align="center">Yes</td>
      <td align="center">Yes</td>
	 </tr>
	  <tr>
      <td rowspan="1" colspan="2" align="right">Socket</td>
      <td align="center">No</td>
      <td align="center">No</td>
      <td>Optional</td>
      <td align="center">(I)</td>
      <td>Subset</td>
      <td align="center">Yes</td>
      <td align="center">Yes</td>
	  </tr>
	   <tr>
      <td rowspan="1" colspan="2" align="right">Concur. Conn.</td>
      <td align="center">Yes</td>
      <td align="center">Yes</td>
      <td align="center">Yes</td>
      <td align="center">Yes</td>
      <td align="center">Yes</td>
      <td align="center">Yes</td>
      <td align="center">Yes</td>
	   </tr>
	   <tr>
      <th rowspan="1" colspan="2" align="left">TLS supported</th>
      <th align="center">No</th>
      <th align="center">No</th>
      <th align="center">Yes</th>
      <th align="center">Yes</th>
      <th align="center">Yes</th>
      <th align="center">Yes</th>
      <th align="center">Yes</th> 
    </tr>
    
  </tbody>
</table>

<t>Legend:</t>

<dl spacing="normal" indent="8">
  <dt>(T1):</dt><dd>TCP-only, on x86 and AVR platforms</dd>
     <dt>(T2):</dt><dd>TCP-only, on ARM Cortex-M platform</dd>
     <dt>(T3):</dt><dd>TCP-only, on ARM Cortex-M0+ platform (NOTE: RAM usage for the same platform 
             is ~2.5 kB for one TCP connection plus ~1.2 kB for each additional connection)</dd>
    <dt>(T4):</dt><dd>TCP-only, on CC2538DK, cross-compiling on Linux</dd>
    <dt>(a):</dt><dd>Includes IP, ICMP, and TCP on x86 and AVR platforms. The Contiki-NG TCP implementation has a code size of 3.2 kB on CC2538DK, cross-compiling on Linux</dd>
    <dt>(I):</dt><dd>Optional POSIX socket wrapper that enables POSIX compliance if needed</dd>
    <dt>Mult.:</dt><dd>Multiple</dd>
    <dt>N/A:</dt><dd>Not Available</dd>
</dl>
	
      </section>
    </section>

 <section anchor="ACKs" numbered="false" toc="default">
      <name>Acknowledgments</name>
      <t>The work of <contact fullname="Carles Gomez"/> has been funded in part by the Spanish Government (Ministerio de Educacion, Cultura y Deporte) through Jose Castillejo grants CAS15/00336
         and CAS18/00170; the European Regional Development Fund (ERDF); the Spanish Government through projects TEC2016-79988-P, PID2019-106808RA-I00, AEI/FEDER, and UE; and
         the Generalitat de Catalunya Grant 2017 SGR 376. 
      Part of his contribution to this work has been carried out during his stays as a visiting scholar at the Computer Laboratory of the University of Cambridge.</t>
      
      <t> The authors appreciate the feedback received for this document. The    
   following folks provided comments that helped improve the document: 
   <contact fullname="Carsten Bormann"/>, <contact fullname="Zhen Cao"/>, <contact fullname="Wei Genyu"/>, <contact fullname="Ari Kernen"/>, <contact fullname="Abhijan Bhattacharyya"/>, <contact fullname="Andres Arcia-Moret"/>, <contact fullname="Yoshifumi Nishida"/>, <contact fullname="Joe Touch"/>, <contact fullname="Fred Baker"/>, <contact fullname="Nik Sultana"/>, <contact fullname="Kerry Lynn"/>, <contact fullname="Erik Nordmark"/>, <contact fullname="Markku Kojo"/>, <contact fullname="Hannes Tschofenig"/>, <contact fullname="David Black"/>, <contact fullname="Ilpo Jarvinen"/>, 
   <contact fullname="Emmanuel Baccelli"/>, <contact fullname="Stuart Cheshire"/>, <contact fullname="Gorry Fairhurst"/>, <contact fullname="Ingemar Johansson"/>, <contact fullname="Ted Lemon"/>, and <contact fullname="Michael Txen"/>. 
   <contact fullname="Simon Brummer"/> provided details and kindly performed Random Access Memory (RAM) and Read-Only Memory (ROM) usage measurements on the RIOT TCP implementation. <contact fullname="Xavi Vilajosana"/> provided details on the OpenWSN TCP implementation.
   <contact fullname="Rahul Jadhav"/> kindly performed code size measurements on the Contiki-NG and lwIP 2.1.2 TCP implementations. He also provided details on the uIP TCP implementation.
      </t>
 </section>
    
  </back>
</rfc>
