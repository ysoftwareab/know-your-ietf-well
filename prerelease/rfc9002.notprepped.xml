<?xml version="1.0" encoding="UTF-8"?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" ipr="trust200902" docName="draft-ietf-quic-recovery-34" category="std" consensus="true" number="9002" obsoletes="" updates="" submissionType="IETF" xml:lang="en" tocInclude="true" sortRefs="true" symRefs="true" version="3">
  <link href="https://datatracker.ietf.org/doc/draft-ietf-quic-recovery-34" rel="prev"/>
  <front>
    <title abbrev="QUIC Loss Detection">QUIC Loss Detection and Congestion Control</title>
    <seriesInfo name="RFC" value="9002"/>
    <author initials="J." surname="Iyengar" fullname="Jana Iyengar" role="editor">
      <organization>Fastly</organization>
      <address>
        <email>jri.ietf@gmail.com</email>
      </address>
    </author>
    <author initials="I." surname="Swett" fullname="Ian Swett" role="editor">
      <organization>Google</organization>
      <address>
        <email>ianswett@google.com</email>
      </address>
    </author>
    <date year="2021" month="May"/>
    <area>Transport</area>
    <workgroup>QUIC</workgroup>
    <keyword>bbr</keyword>
    <keyword>delay-sensitive congestion control</keyword>
    <keyword>fec</keyword>
    <keyword>loss-tolerant congestion control</keyword>
    <keyword>next generation</keyword>
    <abstract>
      <t>This document describes loss detection and congestion control mechanisms for
QUIC.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>QUIC is a secure, general-purpose transport protocol, described in
<xref target="QUIC-TRANSPORT" format="default"/>. This document describes loss detection and congestion
control mechanisms for QUIC.</t>
    </section>
    <section anchor="conventions-and-definitions" numbered="true" toc="default">
      <name>Conventions and Definitions</name>
      <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>",
"<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>", "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this
document are to be interpreted as described in BCP 14 <xref target="RFC2119" format="default"/> <xref target="RFC8174" format="default"/>
when, and only when, they appear in all capitals, as shown here.</t>
      <t>Definitions of terms that are used in this document:</t>
      <dl>
        <dt>Ack-eliciting frames:</dt>
        <dd>
          <t>All frames other than ACK, PADDING, and CONNECTION_CLOSE are considered
ack-eliciting.</t>
        </dd>
        <dt>Ack-eliciting packets:</dt>
        <dd>
          <t>Packets that contain ack-eliciting frames elicit an ACK from the receiver
within the maximum acknowledgment delay and are called ack-eliciting packets.</t>
        </dd>
        <dt>In-flight packets:</dt>
        <dd>
          <t>Packets are considered in flight when they are ack-eliciting or contain a
PADDING frame, and they have been sent but are not acknowledged, declared
lost, or discarded along with old keys.</t>
        </dd>
      </dl>
    </section>
    <section anchor="design-of-the-quic-transmission-machinery" numbered="true" toc="default">
      <name>Design of the QUIC Transmission Machinery</name>
      <t>All transmissions in QUIC are sent with a packet-level header, which indicates
the encryption level and includes a packet sequence number (referred to below as
a packet number).  The encryption level indicates the packet number space, as
described in <xref section="12.3" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>.  Packet numbers never repeat
within a packet number space for the lifetime of a connection.  Packet numbers
are sent in monotonically increasing order within a space, preventing ambiguity.
It is permitted for some packet numbers to never be used, leaving intentional
gaps.</t>
      <t>This design obviates the need for disambiguating between transmissions and
retransmissions; this eliminates significant complexity from QUIC's
interpretation of TCP loss detection mechanisms.</t>
      <t>QUIC packets can contain multiple frames of different types. The recovery
mechanisms ensure that data and frames that need reliable delivery are
acknowledged or declared lost and sent in new packets as necessary. The types
of frames contained in a packet affect recovery and congestion control logic:</t>
      <ul spacing="normal">
        <li>All packets are acknowledged, though packets that contain no
ack-eliciting frames are only acknowledged along with ack-eliciting
packets.</li>
        <li>Long header packets that contain CRYPTO frames are critical to the
performance of the QUIC handshake and use shorter timers for
acknowledgment.</li>
        <li>Packets containing frames besides ACK or CONNECTION_CLOSE frames count toward
congestion control limits and are considered to be in flight.</li>
        <li>PADDING frames cause packets to contribute toward bytes in flight without
directly causing an acknowledgment to be sent.</li>
      </ul>
    </section>
    <section anchor="relevant-differences-between-quic-and-tcp" numbered="true" toc="default">
      <name>Relevant Differences between QUIC and TCP</name>
      <t>Readers familiar with TCP's loss detection and congestion control will find
algorithms here that parallel well-known TCP ones. However, protocol differences
between QUIC and TCP contribute to algorithmic differences. These protocol
differences are briefly described below.</t>
      <section anchor="separate-packet-number-spaces" numbered="true" toc="default">
        <name>Separate Packet Number Spaces</name>
        <t>QUIC uses separate packet number spaces for each encryption level,
except 0-RTT and all generations of 1-RTT keys use the same packet
number space.  Separate packet number spaces ensures that the
acknowledgment of packets sent with one level of encryption will not
cause spurious retransmission of packets sent with a different
encryption level.  Congestion control and round-trip time (RTT)
measurement are unified across packet number spaces.</t>
      </section>
      <section anchor="monotonically-increasing-packet-numbers" numbered="true" toc="default">
        <name>Monotonically Increasing Packet Numbers</name>
        <t>TCP conflates transmission order at the sender with delivery order at the
receiver, resulting in the retransmission ambiguity problem
<xref target="RETRANSMISSION" format="default"/>.  QUIC separates transmission order from delivery order:
packet numbers indicate transmission order, and delivery order is determined by
the stream offsets in STREAM frames.</t>
        <t>QUIC's packet number is strictly increasing within a packet number space
and directly encodes transmission order.  A higher packet number signifies
that the packet was sent later, and a lower packet number signifies that
the packet was sent earlier.  When a packet containing ack-eliciting
frames is detected lost, QUIC includes necessary frames in a new packet
with a new packet number, removing ambiguity about which packet is
acknowledged when an ACK is received.  Consequently, more accurate RTT
measurements can be made, spurious retransmissions are trivially detected, and
mechanisms such as Fast Retransmit can be applied universally, based only on
packet number.</t>
        <t>This design point significantly simplifies loss detection mechanisms for QUIC.
Most TCP mechanisms implicitly attempt to infer transmission ordering based on
TCP sequence numbers -- a nontrivial task, especially when TCP timestamps are
not available.</t>
      </section>
      <section anchor="clearer-loss-epoch" numbered="true" toc="default">
        <name>Clearer Loss Epoch</name>
        <t>QUIC starts a loss epoch when a packet is lost. The loss epoch ends when any
packet sent after the start of the epoch is acknowledged.  TCP waits for the gap
in the sequence number space to be filled, and so if a segment is lost multiple
times in a row, the loss epoch may not end for several round trips. Because both
should reduce their congestion windows only once per epoch, QUIC will do it once
for every round trip that experiences loss, while TCP may only do it once across
multiple round trips.</t>
      </section>
      <section anchor="no-reneging" numbered="true" toc="default">
        <name>No Reneging</name>
        <t>QUIC ACK frames contain information similar to that in TCP Selective
Acknowledgments (SACKs) <xref target="RFC2018" format="default"/>. However, QUIC does not allow a packet
acknowledgment to be reneged, greatly simplifying implementations on both sides
and reducing memory pressure on the sender.</t>
      </section>
      <section anchor="more-ack-ranges" numbered="true" toc="default">
        <name>More ACK Ranges</name>
        <t>QUIC supports many ACK ranges, as opposed to TCP's three SACK ranges.  In
high-loss environments, this speeds recovery, reduces spurious retransmits, and
ensures forward progress without relying on timeouts.</t>
      </section>
      <section anchor="explicit-correction-for-delayed-acknowledgments" numbered="true" toc="default">
        <name>Explicit Correction for Delayed Acknowledgments</name>
        <t>QUIC endpoints measure the delay incurred between when a packet is received and
when the corresponding acknowledgment is sent, allowing a peer to maintain a
more accurate RTT estimate; see <xref section="13.2" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>.</t>
      </section>
      <section anchor="probe-timeout-replaces-rto-and-tlp" numbered="true" toc="default">
        <name>Probe Timeout Replaces RTO and TLP</name>
        <t>QUIC uses a probe timeout (PTO; see <xref target="pto" format="default"/>), with a timer based on TCP's
retransmission timeout (RTO) computation; see <xref target="RFC6298" format="default"/>.  QUIC's PTO includes
the peer's maximum expected acknowledgment delay instead of using a fixed
minimum timeout.</t>
        <t>Similar to the RACK-TLP loss detection algorithm for TCP <xref target="RFC8985" format="default"/>, QUIC does
not collapse the congestion window when the PTO expires, since a single packet
loss at the tail does not indicate persistent congestion.  Instead, QUIC
collapses the congestion window when persistent congestion is declared; see
<xref target="persistent-congestion" format="default"/>. In doing this, QUIC avoids unnecessary congestion
window reductions, obviating the need for correcting mechanisms such as Forward
RTO-Recovery (F-RTO) <xref target="RFC5682" format="default"/>. Since QUIC does not collapse the congestion
window on a PTO expiration, a QUIC sender is not limited from sending more
in-flight packets after a PTO expiration if it still has available congestion
window. This occurs when a sender is application limited and the PTO timer
expires. This is more aggressive than TCP's RTO mechanism when application
limited, but identical when not application limited.</t>
        <t>QUIC allows probe packets to temporarily exceed the congestion window whenever
the timer expires.</t>
      </section>
      <section anchor="the-minimum-congestion-window-is-two-packets" numbered="true" toc="default">
        <name>The Minimum Congestion Window Is Two Packets</name>
        <t>TCP uses a minimum congestion window of one packet. However, loss of that single
packet means that the sender needs to wait for a PTO to recover (<xref target="pto" format="default"/>), which
can be much longer than an RTT.  Sending a single ack-eliciting packet also
increases the chances of incurring additional latency when a receiver delays its
acknowledgment.</t>
        <t>QUIC therefore recommends that the minimum congestion window be two
packets. While this increases network load, it is considered safe since the
sender will still reduce its sending rate exponentially under persistent
congestion (<xref target="pto" format="default"/>).</t>
      </section>
      <section anchor="handshake-packets-are-not-special" numbered="true" toc="default">
        <name>Handshake Packets Are Not Special</name>
        <t>TCP treats the loss of SYN or SYN-ACK packet as persistent congestion and
reduces the congestion window to one packet; see <xref target="RFC5681" format="default"/>. QUIC treats loss
of a packet containing handshake data the same as other losses.</t>
      </section>
    </section>
    <section anchor="compute-rtt" numbered="true" toc="default">
      <name>Estimating the Round-Trip Time</name>
      <t>At a high level, an endpoint measures the time from when a packet was sent to
when it is acknowledged as an RTT sample. The endpoint uses RTT samples and
peer-reported host delays (see <xref section="13.2" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>) to generate a
statistical description of the network path's RTT. An endpoint computes the
following three values for each path: the minimum value over a period of time
(min_rtt), an exponentially weighted moving average (smoothed_rtt), and the mean
deviation (referred to as "variation" in the rest of this document) in the
observed RTT samples (rttvar).</t>
      <section anchor="latest-rtt" numbered="true" toc="default">
        <name>Generating RTT Samples</name>
        <t>An endpoint generates an RTT sample on receiving an ACK frame that meets the
following two conditions:</t>
        <ul spacing="normal">
          <li>the largest acknowledged packet number is newly acknowledged, and</li>
          <li>at least one of the newly acknowledged packets was ack-eliciting.</li>
        </ul>
        <t>The RTT sample, latest_rtt, is generated as the time elapsed since the largest
acknowledged packet was sent:</t>
        <sourcecode type="pseudocode"><![CDATA[
latest_rtt = ack_time - send_time_of_largest_acked
]]></sourcecode>
        <t>An RTT sample is generated using only the largest acknowledged packet in the
received ACK frame.  This is because a peer reports acknowledgment delays for
only the largest acknowledged packet in an ACK frame.  While the reported
acknowledgment delay is not used by the RTT sample measurement, it is used to
adjust the RTT sample in subsequent computations of smoothed_rtt and rttvar
(<xref target="smoothed-rtt" format="default"/>).</t>
        <t>To avoid generating multiple RTT samples for a single packet, an ACK frame
<bcp14>SHOULD NOT</bcp14> be used to update RTT estimates if it does not newly acknowledge the
largest acknowledged packet.</t>
        <t>An RTT sample <bcp14>MUST NOT</bcp14> be generated on receiving an ACK frame that does not
newly acknowledge at least one ack-eliciting packet. A peer usually does not
send an ACK frame when only non-ack-eliciting packets are received. Therefore,
an ACK frame that contains acknowledgments for only non-ack-eliciting packets
could include an arbitrarily large ACK Delay value.  Ignoring
such ACK frames avoids complications in subsequent smoothed_rtt and rttvar
computations.</t>
        <t>A sender might generate multiple RTT samples per RTT when multiple ACK frames
are received within an RTT.  As suggested in <xref target="RFC6298" format="default"/>, doing so might result
in inadequate history in smoothed_rtt and rttvar.  Ensuring that RTT estimates
retain sufficient history is an open research question.</t>
      </section>
      <section anchor="min-rtt" numbered="true" toc="default">
        <name>Estimating min_rtt</name>
        <t>min_rtt is the sender's estimate of the minimum RTT observed for a given network
path over a period of time. In this document, min_rtt is used by loss detection
to reject implausibly small RTT samples.</t>
        <t>min_rtt <bcp14>MUST</bcp14> be set to the latest_rtt on the first RTT sample. min_rtt <bcp14>MUST</bcp14> be
set to the lesser of min_rtt and latest_rtt (<xref target="latest-rtt" format="default"/>) on all other
samples.</t>
        <t>An endpoint uses only locally observed times in computing the min_rtt and does
not adjust for acknowledgment delays reported by the peer. Doing so allows the
endpoint to set a lower bound for the smoothed_rtt based entirely on what it
observes (see <xref target="smoothed-rtt" format="default"/>) and limits potential underestimation due to
erroneously reported delays by the peer.</t>
        <t>The RTT for a network path may change over time. If a path's actual RTT
decreases, the min_rtt will adapt immediately on the first low sample.  If the
path's actual RTT increases, however, the min_rtt will not adapt to it, allowing
future RTT samples that are smaller than the new RTT to be included in
smoothed_rtt.</t>
        <t>Endpoints <bcp14>SHOULD</bcp14> set the min_rtt to the newest RTT sample after persistent
congestion is established. This avoids repeatedly declaring persistent
congestion when the RTT increases. This also allows a connection to reset
its estimate of min_rtt and smoothed_rtt after a disruptive network event;
see <xref target="smoothed-rtt" format="default"/>.</t>
        <t>Endpoints <bcp14>MAY</bcp14> reestablish the min_rtt at other times in the connection, such as
when traffic volume is low and an acknowledgment is received with a low
acknowledgment delay. Implementations <bcp14>SHOULD NOT</bcp14> refresh the min_rtt
value too often since the actual minimum RTT of the path is not
frequently observable.</t>
      </section>
      <section anchor="smoothed-rtt" numbered="true" toc="default">
        <name>Estimating smoothed_rtt and rttvar</name>
        <t>smoothed_rtt is an exponentially weighted moving average of an endpoint's RTT
samples, and rttvar estimates the variation in the RTT samples using a mean
variation.</t>
        <t>The calculation of smoothed_rtt uses RTT samples after adjusting them for
acknowledgment delays. These delays are decoded from the ACK Delay field of
ACK frames as described in <xref section="19.3" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>.</t>
        <t>The peer might report acknowledgment delays that are larger than the peer's
max_ack_delay during the handshake (<xref section="13.2.1" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>). To
account for this, the endpoint <bcp14>SHOULD</bcp14> ignore max_ack_delay until the handshake
is confirmed, as defined in <xref section="4.1.2" sectionFormat="of" target="QUIC-TLS" format="default"/>. When they occur,
these large acknowledgment delays are likely to be non-repeating and limited to
the handshake. The endpoint can therefore use them without limiting them to the
max_ack_delay, avoiding unnecessary inflation of the RTT estimate.</t>
        <t>Note that a large acknowledgment delay can result in a substantially inflated
smoothed_rtt if there is an error either in the peer's reporting of the
acknowledgment delay or in the endpoint's min_rtt estimate.  Therefore, prior
to handshake confirmation, an endpoint <bcp14>MAY</bcp14> ignore RTT samples if adjusting
the RTT sample for acknowledgment delay causes the sample to be less than the
min_rtt.</t>
        <t>After the handshake is confirmed, any acknowledgment delays reported by the
peer that are greater than the peer's max_ack_delay are attributed to
unintentional but potentially repeating delays, such as scheduler latency at the
peer or loss of previous acknowledgments.  Excess delays could also be due to
a noncompliant receiver.  Therefore, these extra delays are considered
effectively part of path delay and incorporated into the RTT estimate.</t>
        <t>Therefore, when adjusting an RTT sample using peer-reported acknowledgment
delays, an endpoint:</t>
        <ul spacing="normal">
          <li><bcp14>MAY</bcp14> ignore the acknowledgment delay for Initial packets, since these
acknowledgments are not delayed by the peer (<xref section="13.2.1" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>);</li>
          <li><bcp14>SHOULD</bcp14> ignore the peer's max_ack_delay until the handshake is confirmed;</li>
          <li><bcp14>MUST</bcp14> use the lesser of the acknowledgment delay and the peer's max_ack_delay
after the handshake is confirmed; and</li>
          <li><bcp14>MUST NOT</bcp14> subtract the acknowledgment delay from the RTT sample if the
resulting value is smaller than the min_rtt.  This limits the underestimation
of the smoothed_rtt due to a misreporting peer.</li>
        </ul>
        <t>Additionally, an endpoint might postpone the processing of acknowledgments when
the corresponding decryption keys are not immediately available. For example, a
client might receive an acknowledgment for a 0-RTT packet that it cannot
decrypt because 1-RTT packet protection keys are not yet available to it. In
such cases, an endpoint <bcp14>SHOULD</bcp14> subtract such local delays from its RTT sample
until the handshake is confirmed.</t>
        <t>Similar to <xref target="RFC6298" format="default"/>, smoothed_rtt and rttvar are computed as follows.</t>
        <t>An endpoint initializes the RTT estimator during connection establishment and
when the estimator is reset during connection migration; see <xref section="9.4" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>. Before any RTT samples are available for a new path or when
the estimator is reset, the estimator is initialized using the initial RTT; see
<xref target="pto-handshake" format="default"/>.</t>
        <t>smoothed_rtt and rttvar are initialized as follows, where kInitialRtt contains
the initial RTT value:</t>
        <sourcecode type="pseudocode"><![CDATA[
smoothed_rtt = kInitialRtt
rttvar = kInitialRtt / 2
]]></sourcecode>
        <t>RTT samples for the network path are recorded in latest_rtt; see
<xref target="latest-rtt" format="default"/>. On the first RTT sample after initialization, the estimator is
reset using that sample. This ensures that the estimator retains no history of
past samples.  Packets sent on other paths do not contribute RTT samples to the
current path, as described in <xref section="9.4" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>.</t>
        <t>On the first RTT sample after initialization, smoothed_rtt and rttvar are set as
follows:</t>
        <sourcecode type="pseudocode"><![CDATA[
smoothed_rtt = latest_rtt
rttvar = latest_rtt / 2
]]></sourcecode>
        <t>On subsequent RTT samples, smoothed_rtt and rttvar evolve as follows:</t>
        <sourcecode type="pseudocode"><![CDATA[
ack_delay = decoded acknowledgment delay from ACK frame
if (handshake confirmed):
  ack_delay = min(ack_delay, max_ack_delay)
adjusted_rtt = latest_rtt
if (latest_rtt >= min_rtt + ack_delay):
  adjusted_rtt = latest_rtt - ack_delay
smoothed_rtt = 7/8 * smoothed_rtt + 1/8 * adjusted_rtt
rttvar_sample = abs(smoothed_rtt - adjusted_rtt)
rttvar = 3/4 * rttvar + 1/4 * rttvar_sample
]]></sourcecode>
      </section>
    </section>
    <section anchor="loss-detection" numbered="true" toc="default">
      <name>Loss Detection</name>
      <t>QUIC senders use acknowledgments to detect lost packets and a PTO to ensure
acknowledgments are received; see <xref target="pto" format="default"/>. This section provides a description
of these algorithms.</t>
      <t>If a packet is lost, the QUIC transport needs to recover from that loss, such
as by retransmitting the data, sending an updated frame, or discarding the
frame.  For more information, see <xref section="13.3" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>.</t>
      <t>Loss detection is separate per packet number space, unlike RTT measurement and
congestion control, because RTT and congestion control are properties of the
path, whereas loss detection also relies upon key availability.</t>
      <section anchor="ack-loss-detection" numbered="true" toc="default">
        <name>Acknowledgment-Based Detection</name>
        <t>Acknowledgment-based loss detection implements the spirit of TCP's Fast
Retransmit <xref target="RFC5681" format="default"/>, Early Retransmit <xref target="RFC5827" format="default"/>, Forward Acknowledgment
<xref target="FACK" format="default"/>, SACK loss recovery <xref target="RFC6675" format="default"/>, and RACK-TLP <xref target="RFC8985" format="default"/>. This
section provides an overview of how these algorithms are implemented in QUIC.</t>
        <t>A packet is declared lost if it meets all of the following conditions:</t>
        <ul spacing="normal">
          <li>The packet is unacknowledged, in flight, and was sent prior to an
acknowledged packet.</li>
          <li>The packet was sent kPacketThreshold packets before an acknowledged packet
(<xref target="packet-threshold" format="default"/>), or it was sent long enough in the past
(<xref target="time-threshold" format="default"/>).</li>
        </ul>
        <t>The acknowledgment indicates that a packet sent later was delivered, and the
packet and time thresholds provide some tolerance for packet reordering.</t>
        <t>Spuriously declaring packets as lost leads to unnecessary retransmissions and
may result in degraded performance due to the actions of the congestion
controller upon detecting loss.  Implementations can detect spurious
retransmissions and increase the packet or time reordering threshold to
reduce future spurious retransmissions and loss events. Implementations with
adaptive time thresholds <bcp14>MAY</bcp14> choose to start with smaller initial reordering
thresholds to minimize recovery latency.</t>
        <section anchor="packet-threshold" numbered="true" toc="default">
          <name>Packet Threshold</name>
          <t>The <bcp14>RECOMMENDED</bcp14> initial value for the packet reordering threshold
(kPacketThreshold) is 3, based on best practices for TCP loss detection
<xref target="RFC5681" format="default"/> <xref target="RFC6675" format="default"/>.  In order to remain similar to TCP,
implementations <bcp14>SHOULD NOT</bcp14> use a packet threshold less than 3; see <xref target="RFC5681" format="default"/>.</t>
          <t>Some networks may exhibit higher degrees of packet reordering, causing a sender
to detect spurious losses. Additionally, packet reordering could be more common
with QUIC than TCP because network elements that could observe and reorder TCP
packets cannot do that for QUIC and also because QUIC packet numbers are
encrypted.  Algorithms that increase the reordering threshold after spuriously
detecting losses, such as RACK <xref target="RFC8985" format="default"/>, have proven to be useful in TCP and
are expected to be at least as useful in QUIC.</t>
        </section>
        <section anchor="time-threshold" numbered="true" toc="default">
          <name>Time Threshold</name>
          <t>Once a later packet within the same packet number space has been acknowledged,
an endpoint <bcp14>SHOULD</bcp14> declare an earlier packet lost if it was sent a threshold
amount of time in the past. To avoid declaring packets as lost too early, this
time threshold <bcp14>MUST</bcp14> be set to at least the local timer granularity, as
indicated by the kGranularity constant.  The time threshold is:</t>
          <sourcecode type="pseudocode"><![CDATA[
max(kTimeThreshold * max(smoothed_rtt, latest_rtt), kGranularity)
]]></sourcecode>
          <t>If packets sent prior to the largest acknowledged packet cannot yet be declared
lost, then a timer <bcp14>SHOULD</bcp14> be set for the remaining time.</t>
          <t>Using max(smoothed_rtt, latest_rtt) protects from the two following cases:</t>
          <ul spacing="normal">
            <li>the latest RTT sample is lower than the smoothed RTT, perhaps due to
reordering where the acknowledgment encountered a shorter path;</li>
            <li>the latest RTT sample is higher than the smoothed RTT, perhaps due to a
sustained increase in the actual RTT, but the smoothed RTT has not yet caught
up.</li>
          </ul>
          <t>The <bcp14>RECOMMENDED</bcp14> time threshold (kTimeThreshold), expressed as an RTT multiplier,
is 9/8. The <bcp14>RECOMMENDED</bcp14> value of the timer granularity (kGranularity) is 1
millisecond.</t>
          <aside>
            <t>Note: TCP's RACK <xref target="RFC8985" format="default"/> specifies a slightly larger threshold, equivalent
to 5/4, for a similar purpose. Experience with QUIC shows that 9/8 works well.</t>
          </aside>
          <t>Implementations <bcp14>MAY</bcp14> experiment with absolute thresholds, thresholds from
previous connections, adaptive thresholds, or the including of RTT variation.
Smaller thresholds reduce reordering resilience and increase spurious
retransmissions, and larger thresholds increase loss detection delay.</t>
        </section>
      </section>
      <section anchor="pto" numbered="true" toc="default">
        <name>Probe Timeout</name>
        <t>A Probe Timeout (PTO) triggers the sending of one or two probe datagrams when
ack-eliciting packets are not acknowledged within the expected period of
time or the server may not have validated the client's address.  A PTO enables
a connection to recover from loss of tail packets or acknowledgments.</t>
        <t>As with loss detection, the PTO is per packet number space. That is, a
PTO value is computed per packet number space.</t>
        <t>A PTO timer expiration event does not indicate packet loss and <bcp14>MUST NOT</bcp14> cause
prior unacknowledged packets to be marked as lost. When an acknowledgment is
received that newly acknowledges packets, loss detection proceeds as dictated
by the packet and time threshold mechanisms; see <xref target="ack-loss-detection" format="default"/>.</t>
        <t>The PTO algorithm used in QUIC implements the reliability functions of Tail Loss
Probe <xref target="RFC8985" format="default"/>, RTO <xref target="RFC5681" format="default"/>, and F-RTO algorithms for TCP
<xref target="RFC5682" format="default"/>. The timeout computation is based on TCP's RTO period <xref target="RFC6298" format="default"/>.</t>
        <section anchor="computing-pto" numbered="true" toc="default">
          <name>Computing PTO</name>
          <t>When an ack-eliciting packet is transmitted, the sender schedules a timer for
the PTO period as follows:</t>
          <sourcecode type="pseudocode"><![CDATA[
PTO = smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay
]]></sourcecode>
          <t>The PTO period is the amount of time that a sender ought to wait for an
acknowledgment of a sent packet.  This time period includes the estimated
network RTT (smoothed_rtt), the variation in the estimate (4*rttvar),
and max_ack_delay, to account for the maximum time by which a receiver might
delay sending an acknowledgment.</t>
          <t>When the PTO is armed for Initial or Handshake packet number spaces, the
max_ack_delay in the PTO period computation is set to 0, since the peer is
expected to not delay these packets intentionally; see <xref section="13.2.1" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>.</t>
          <t>The PTO period <bcp14>MUST</bcp14> be at least kGranularity to avoid the timer expiring
immediately.</t>
          <t>When ack-eliciting packets in multiple packet number spaces are in flight, the
timer <bcp14>MUST</bcp14> be set to the earlier value of the Initial and Handshake packet
number spaces.</t>
          <t>An endpoint <bcp14>MUST NOT</bcp14> set its PTO timer for the Application Data packet number
space until the handshake is confirmed. Doing so prevents the endpoint from
retransmitting information in packets when either the peer does not yet have the
keys to process them or the endpoint does not yet have the keys to process their
acknowledgments. For example, this can happen when a client sends 0-RTT packets
to the server; it does so without knowing whether the server will be able to
decrypt them. Similarly, this can happen when a server sends 1-RTT packets
before confirming that the client has verified the server's certificate and can
therefore read these 1-RTT packets.</t>
          <t>A sender <bcp14>SHOULD</bcp14> restart its PTO timer every time an ack-eliciting packet is
sent or acknowledged, or when Initial or Handshake keys are discarded
(<xref section="4.9" sectionFormat="of" target="QUIC-TLS" format="default"/>). This ensures the PTO is always set based on the
latest estimate of the RTT and for the correct packet across packet
number spaces.</t>
          <t>When a PTO timer expires, the PTO backoff <bcp14>MUST</bcp14> be increased, resulting in the
PTO period being set to twice its current value. The PTO backoff factor is reset
when an acknowledgment is received, except in the following case. A server
might take longer to respond to packets during the handshake than otherwise.  To
protect such a server from repeated client probes, the PTO backoff is not reset
at a client that is not yet certain that the server has finished validating the
client's address. That is, a client does not reset the PTO backoff factor on
receiving acknowledgments in Initial packets.</t>
          <t>This exponential reduction in the sender's rate is important because consecutive
PTOs might be caused by loss of packets or acknowledgments due to severe
congestion.  Even when there are ack-eliciting packets in flight in multiple
packet number spaces, the exponential increase in PTO occurs across all spaces
to prevent excess load on the network.  For example, a timeout in the Initial
packet number space doubles the length of the timeout in the Handshake packet
number space.</t>
          <t>The total length of time over which consecutive PTOs expire is limited by the
idle timeout.</t>
          <t>The PTO timer <bcp14>MUST NOT</bcp14> be set if a timer is set for time threshold
loss detection; see <xref target="time-threshold" format="default"/>.  A timer that is set for time
threshold loss detection will expire earlier than the PTO timer
in most cases and is less likely to spuriously retransmit data.</t>
        </section>
        <section anchor="pto-handshake" numbered="true" toc="default">
          <name>Handshakes and New Paths</name>
          <t>Resumed connections over the same network <bcp14>MAY</bcp14> use the previous connection's
final smoothed RTT value as the resumed connection's initial RTT.  When no
previous RTT is available, the initial RTT <bcp14>SHOULD</bcp14> be set to 333 milliseconds.
This results in handshakes starting with a PTO of 1 second, as recommended for
TCP's initial RTO; see <xref section="2" sectionFormat="of" target="RFC6298" format="default"/>.</t>
          <t>A connection <bcp14>MAY</bcp14> use the delay between sending a PATH_CHALLENGE and receiving a
PATH_RESPONSE to set the initial RTT (see kInitialRtt in
<xref target="constants-of-interest" format="default"/>) for a new path, but the delay <bcp14>SHOULD NOT</bcp14> be
considered an RTT sample.</t>
          <t>When the Initial keys and Handshake keys are discarded (see
<xref target="discarding-packets" format="default"/>), any Initial packets and Handshake packets can
no longer be acknowledged, so they are removed from bytes in
flight. When Initial or Handshake keys are discarded, the PTO and loss
detection timers <bcp14>MUST</bcp14> be reset, because discarding keys indicates
forward progress and the loss detection timer might have been set for
a now-discarded packet number space.</t>
          <section anchor="before-address-validation" numbered="true" toc="default">
            <name>Before Address Validation</name>
            <t>Until the server has validated the client's address on the path, the amount of
data it can send is limited to three times the amount of data received,
as specified in <xref section="8.1" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>. If no additional data can be
sent, the server's PTO timer <bcp14>MUST NOT</bcp14> be armed until datagrams have been
received from the client because packets sent on PTO count against the
anti-amplification limit.</t>
            <t>When the server receives a datagram from the client, the amplification limit is
increased and the server resets the PTO timer.  If the PTO timer is then set to
a time in the past, it is executed immediately. Doing so avoids sending new
1-RTT packets prior to packets critical to the completion of the handshake.
In particular, this can happen when 0-RTT is accepted but the server fails to
validate the client's address.</t>
            <t>Since the server could be blocked until more datagrams are received from the
client, it is the client's responsibility to send packets to unblock the server
until it is certain that the server has finished its address validation (see
<xref section="8" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>). That is, the client <bcp14>MUST</bcp14> set the PTO timer
if the client has not received an acknowledgment for any of its Handshake
packets and the handshake is not confirmed (see <xref section="4.1.2" sectionFormat="of" target="QUIC-TLS" format="default"/>),
even if there are no packets in flight. When the PTO fires, the client <bcp14>MUST</bcp14>
send a Handshake packet if it has Handshake keys, otherwise it <bcp14>MUST</bcp14> send an
Initial packet in a UDP datagram with a payload of at least 1200 bytes.</t>
          </section>
        </section>
        <section anchor="speeding-up-handshake-completion" numbered="true" toc="default">
          <name>Speeding up Handshake Completion</name>
          <t>When a server receives an Initial packet containing duplicate CRYPTO data,
it can assume the client did not receive all of the server's CRYPTO data sent
in Initial packets, or the client's estimated RTT is too small. When a
client receives Handshake or 1-RTT packets prior to obtaining Handshake keys,
it may assume some or all of the server's Initial packets were lost.</t>
          <t>To speed up handshake completion under these conditions, an endpoint <bcp14>MAY</bcp14>, for a
limited number of times per connection, send a packet containing
unacknowledged CRYPTO data earlier than the PTO expiry, subject to the address
validation limits in <xref section="8.1" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>. Doing so at most once
for each connection is adequate to quickly recover from a single packet loss.
An endpoint that always retransmits packets in response to receiving packets
that it cannot process risks creating an infinite exchange of packets.</t>
          <t>Endpoints can also use coalesced packets (see <xref section="12.2" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>) to ensure that each datagram elicits at least one
acknowledgment. For example, a client can coalesce an Initial packet containing
PING and PADDING frames with a 0-RTT data packet, and a server can coalesce an
Initial packet containing a PING frame with one or more packets in its first
flight.</t>
        </section>
        <section anchor="sending-probe-packets" numbered="true" toc="default">
          <name>Sending Probe Packets</name>
          <t>When a PTO timer expires, a sender <bcp14>MUST</bcp14> send at least one ack-eliciting packet
in the packet number space as a probe.  An endpoint <bcp14>MAY</bcp14> send up to two
full-sized datagrams containing ack-eliciting packets to avoid an expensive
consecutive PTO expiration due to a single lost datagram or to transmit data
from multiple packet number spaces. All probe packets sent on a PTO <bcp14>MUST</bcp14> be
ack-eliciting.</t>
          <t>In addition to sending data in the packet number space for which the timer
expired, the sender <bcp14>SHOULD</bcp14> send ack-eliciting packets from other packet number
spaces with in-flight data, coalescing packets if possible.  This is
particularly valuable when the server has both Initial and Handshake data in
flight or when the client has both Handshake and Application Data in flight
because the peer might only have receive keys for one of the two packet number
spaces.</t>
          <t>If the sender wants to elicit a faster acknowledgment on PTO, it can skip a
packet number to eliminate the acknowledgment delay.</t>
          <t>An endpoint <bcp14>SHOULD</bcp14> include new data in packets that are sent on PTO expiration.
Previously sent data <bcp14>MAY</bcp14> be sent if no new data can be sent. Implementations
<bcp14>MAY</bcp14> use alternative strategies for determining the content of probe packets,
including sending new or retransmitted data based on the application's
priorities.</t>
          <t>It is possible the sender has no new or previously sent data to send.
As an example, consider the following sequence of events: new application data
is sent in a STREAM frame, deemed lost, then retransmitted in a new packet,
and then the original transmission is acknowledged.  When there is no data to
send, the sender <bcp14>SHOULD</bcp14> send a PING or other ack-eliciting frame in a single
packet, rearming the PTO timer.</t>
          <t>Alternatively, instead of sending an ack-eliciting packet, the sender <bcp14>MAY</bcp14> mark
any packets still in flight as lost.  Doing so avoids sending an additional
packet but increases the risk that loss is declared too aggressively, resulting
in an unnecessary rate reduction by the congestion controller.</t>
          <t>Consecutive PTO periods increase exponentially, and as a result, connection
recovery latency increases exponentially as packets continue to be dropped in
the network.  Sending two packets on PTO expiration increases resilience to
packet drops, thus reducing the probability of consecutive PTO events.</t>
          <t>When the PTO timer expires multiple times and new data cannot be sent,
implementations must choose between sending the same payload every time
or sending different payloads.  Sending the same payload may be simpler
and ensures the highest priority frames arrive first.  Sending different
payloads each time reduces the chances of spurious retransmission.</t>
        </section>
      </section>
      <section anchor="handling-retry-packets" numbered="true" toc="default">
        <name>Handling Retry Packets</name>
        <t>A Retry packet causes a client to send another Initial packet, effectively
restarting the connection process.  A Retry packet indicates that the Initial
packet was received but not processed.  A Retry packet cannot be treated as an
acknowledgment because it does not indicate that a packet was processed or
specify the packet number.</t>
        <t>Clients that receive a Retry packet reset congestion control and loss recovery
state, including resetting any pending timers.  Other connection state, in
particular cryptographic handshake messages, is retained; see
<xref section="17.2.5" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>.</t>
        <t>The client <bcp14>MAY</bcp14> compute an RTT estimate to the server as the time period from
when the first Initial packet was sent to when a Retry or a Version Negotiation
packet is received.  The client <bcp14>MAY</bcp14> use this value in place of its default for
the initial RTT estimate.</t>
      </section>
      <section anchor="discarding-packets" numbered="true" toc="default">
        <name>Discarding Keys and Packet State</name>
        <t>When Initial and Handshake packet protection keys are discarded
(see <xref section="4.9" sectionFormat="of" target="QUIC-TLS" format="default"/>), all packets that were sent with those keys
can no longer be acknowledged because their acknowledgments cannot be processed.
The sender <bcp14>MUST</bcp14> discard all recovery state associated with those packets
and <bcp14>MUST</bcp14> remove them from the count of bytes in flight.</t>
        <t>Endpoints stop sending and receiving Initial packets once they start exchanging
Handshake packets; see <xref section="17.2.2.1" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>. At this point,
recovery state for all in-flight Initial packets is discarded.</t>
        <t>When 0-RTT is rejected, recovery state for all in-flight 0-RTT packets is
discarded.</t>
        <t>If a server accepts 0-RTT, but does not buffer 0-RTT packets that arrive
before Initial packets, early 0-RTT packets will be declared lost, but that
is expected to be infrequent.</t>
        <t>It is expected that keys are discarded at some time after the packets
encrypted with them are either acknowledged or declared lost. However,
Initial and Handshake secrets are discarded as soon as Handshake and
1-RTT keys are proven to be available to both client and server; see
<xref section="4.9.1" sectionFormat="of" target="QUIC-TLS" format="default"/>.</t>
      </section>
    </section>
    <section anchor="congestion-control" numbered="true" toc="default">
      <name>Congestion Control</name>
      <t>This document specifies a sender-side congestion controller for QUIC similar to
TCP NewReno <xref target="RFC6582" format="default"/>.</t>
      <t>The signals QUIC provides for congestion control are generic and are designed to
support different sender-side algorithms. A sender can unilaterally choose a
different algorithm to use, such as CUBIC <xref target="RFC8312" format="default"/>.</t>
      <t>If a sender uses a different controller than that specified in this document,
the chosen controller <bcp14>MUST</bcp14> conform to the congestion control guidelines
specified in <xref section="3.1" sectionFormat="of" target="RFC8085" format="default"/>.</t>
      <t>Similar to TCP, packets containing only ACK frames do not count toward bytes
in flight and are not congestion controlled.  Unlike TCP, QUIC can detect the
loss of these packets and <bcp14>MAY</bcp14> use that information to adjust the congestion
controller or the rate of ACK-only packets being sent, but this document does
not describe a mechanism for doing so.</t>
      <t>The congestion controller is per path, so packets sent on other paths do not
alter the current path's congestion controller, as described in
<xref section="9.4" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>.</t>
      <t>The algorithm in this document specifies and uses the controller's congestion
window in bytes.</t>
      <t>An endpoint <bcp14>MUST NOT</bcp14> send a packet if it would cause bytes_in_flight (see
<xref target="vars-of-interest" format="default"/>) to be larger than the congestion window, unless the packet
is sent on a PTO timer expiration (see <xref target="pto" format="default"/>) or when entering recovery
(see <xref target="recovery-period" format="default"/>).</t>
      <section anchor="congestion-ecn" numbered="true" toc="default">
        <name>Explicit Congestion Notification</name>
        <t>If a path has been validated to support Explicit Congestion Notification (ECN)
<xref target="RFC3168" format="default"/> <xref target="RFC8311" format="default"/>, QUIC treats a Congestion Experienced (CE) codepoint
in the IP header as a signal of congestion. This document specifies an
endpoint's response when the peer-reported ECN-CE count increases; see <xref section="13.4.2" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>.</t>
      </section>
      <section anchor="initial-cwnd" numbered="true" toc="default">
        <name>Initial and Minimum Congestion Window</name>
        <t>QUIC begins every connection in slow start with the congestion window set to an
initial value.  Endpoints <bcp14>SHOULD</bcp14> use an initial congestion window of ten times
the maximum datagram size (max_datagram_size), while limiting the window to the
larger of 14,720 bytes or twice the maximum datagram size. This follows the
analysis and recommendations in <xref target="RFC6928" format="default"/>, increasing the byte limit to
account for the smaller 8-byte overhead of UDP compared to the 20-byte overhead
for TCP.</t>
        <t>If the maximum datagram size changes during the connection, the initial
congestion window <bcp14>SHOULD</bcp14> be recalculated with the new size.  If the maximum
datagram size is decreased in order to complete the handshake, the
congestion window <bcp14>SHOULD</bcp14> be set to the new initial congestion window.</t>
        <t>Prior to validating the client's address, the server can be further limited by
the anti-amplification limit as specified in <xref section="8.1" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>.
Though the anti-amplification limit can prevent the congestion window from
being fully utilized and therefore slow down the increase in congestion window,
it does not directly affect the congestion window.</t>
        <t>The minimum congestion window is the smallest value the congestion window can
attain in response to loss, an increase in the peer-reported ECN-CE count,
or persistent congestion.  The <bcp14>RECOMMENDED</bcp14> value is 2 * max_datagram_size.</t>
      </section>
      <section anchor="congestion-control-states" numbered="true" toc="default">
        <name>Congestion Control States</name>
        <t>The NewReno congestion controller described in this document has three
distinct states, as shown in <xref target="fig-cc-fsm" format="default"/>.</t>
        <figure anchor="fig-cc-fsm">
          <name>Congestion Control States and Transitions</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
                 New path or      +------------+
            persistent congestion |   Slow     |
        (O)---------------------->|   Start    |
                                  +------------+
                                        |
                                Loss or |
                        ECN-CE increase |
                                        v
 +------------+     Loss or       +------------+
 | Congestion |  ECN-CE increase  |  Recovery  |
 | Avoidance  |------------------>|   Period   |
 +------------+                   +------------+
           ^                            |
           |                            |
           +----------------------------+
              Acknowledgment of packet
                sent during recovery
]]></artwork>
        </figure>
        <t>These states and the transitions between them are described in subsequent
sections.</t>
        <section anchor="slow-start" numbered="true" toc="default">
          <name>Slow Start</name>
          <t>A NewReno sender is in slow start any time the congestion window is below the
slow start threshold. A sender begins in slow start because the slow start
threshold is initialized to an infinite value.</t>
          <t>While a sender is in slow start, the congestion window increases by the number
of bytes acknowledged when each acknowledgment is processed. This results in
exponential growth of the congestion window.</t>
          <t>The sender <bcp14>MUST</bcp14> exit slow start and enter a recovery period when a packet is
lost or when the ECN-CE count reported by its peer increases.</t>
          <t>A sender reenters slow start any time the congestion window is less than the
slow start threshold, which only occurs after persistent congestion is
declared.</t>
        </section>
        <section anchor="recovery-period" numbered="true" toc="default">
          <name>Recovery</name>
          <t>A NewReno sender enters a recovery period when it detects the loss of a packet
or when the ECN-CE count reported by its peer increases. A sender that is
already in a recovery period stays in it and does not reenter it.</t>
          <t>On entering a recovery period, a sender <bcp14>MUST</bcp14> set the slow start threshold to
half the value of the congestion window when loss is detected. The congestion
window <bcp14>MUST</bcp14> be set to the reduced value of the slow start threshold before
exiting the recovery period.</t>
          <t>Implementations <bcp14>MAY</bcp14> reduce the congestion window immediately upon entering a
recovery period or use other mechanisms, such as Proportional Rate Reduction
<xref target="PRR" format="default"/>, to reduce the congestion window more gradually. If the
congestion window is reduced immediately, a single packet can be sent prior to
reduction. This speeds up loss recovery if the data in the lost packet is
retransmitted and is similar to TCP as described in <xref section="5" sectionFormat="of" target="RFC6675" format="default"/>.</t>
          <t>The recovery period aims to limit congestion window reduction to once per round
trip. Therefore, during a recovery period, the congestion window does not change
in response to new losses or increases in the ECN-CE count.</t>
          <t>A recovery period ends and the sender enters congestion avoidance when a packet
sent during the recovery period is acknowledged. This is slightly different
from TCP's definition of recovery, which ends when the lost segment that
started recovery is acknowledged <xref target="RFC5681" format="default"/>.</t>
        </section>
        <section anchor="congestion-avoidance" numbered="true" toc="default">
          <name>Congestion Avoidance</name>
          <t>A NewReno sender is in congestion avoidance any time the congestion window is
at or above the slow start threshold and not in a recovery period.</t>
          <t>A sender in congestion avoidance uses an Additive Increase Multiplicative
Decrease (AIMD) approach that <bcp14>MUST</bcp14> limit the increase to the congestion window
to at most one maximum datagram size for each congestion window that is
acknowledged.</t>
          <t>The sender exits congestion avoidance and enters a recovery period when a
packet is lost or when the ECN-CE count reported by its peer increases.</t>
        </section>
      </section>
      <section anchor="ignoring-loss-of-undecryptable-packets" numbered="true" toc="default">
        <name>Ignoring Loss of Undecryptable Packets</name>
        <t>During the handshake, some packet protection keys might not be available when
a packet arrives, and the receiver can choose to drop the packet. In particular,
Handshake and 0-RTT packets cannot be processed until the Initial packets
arrive, and 1-RTT packets cannot be processed until the handshake completes.
Endpoints <bcp14>MAY</bcp14> ignore the loss of Handshake, 0-RTT, and 1-RTT packets that might
have arrived before the peer had packet protection keys to process those
packets. Endpoints <bcp14>MUST NOT</bcp14> ignore the loss of packets that were sent after
the earliest acknowledged packet in a given packet number space.</t>
      </section>
      <section anchor="probe-timeout" numbered="true" toc="default">
        <name>Probe Timeout</name>
        <t>Probe packets <bcp14>MUST NOT</bcp14> be blocked by the congestion controller.  A sender <bcp14>MUST</bcp14>
however count these packets as being additionally in flight, since these packets
add network load without establishing packet loss.  Note that sending probe
packets might cause the sender's bytes in flight to exceed the congestion window
until an acknowledgment is received that establishes loss or delivery of
packets.</t>
      </section>
      <section anchor="persistent-congestion" numbered="true" toc="default">
        <name>Persistent Congestion</name>
        <t>When a sender establishes loss of all packets sent over a long enough duration,
the network is considered to be experiencing persistent congestion.</t>
        <section anchor="pc-duration" numbered="true" toc="default">
          <name>Duration</name>
          <t>The persistent congestion duration is computed as follows:</t>
          <sourcecode type="pseudocode"><![CDATA[
(smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay) *
    kPersistentCongestionThreshold
]]></sourcecode>
          <t>Unlike the PTO computation in <xref target="pto" format="default"/>, this duration includes the max_ack_delay
irrespective of the packet number spaces in which losses are established.</t>
          <t>This duration allows a sender to send as many packets before establishing
persistent congestion, including some in response to PTO expiration, as TCP does
with Tail Loss Probes <xref target="RFC8985" format="default"/> and an RTO <xref target="RFC5681" format="default"/>.</t>
          <t>Larger values of kPersistentCongestionThreshold cause the sender to become less
responsive to persistent congestion in the network, which can result in
aggressive sending into a congested network. Too small a value can result in a
sender declaring persistent congestion unnecessarily, resulting in reduced
throughput for the sender.</t>
          <t>The <bcp14>RECOMMENDED</bcp14> value for kPersistentCongestionThreshold is 3, which results in
behavior that is approximately equivalent to a TCP sender declaring an RTO after
two TLPs.</t>
          <t>This design does not use consecutive PTO events to establish persistent
congestion, since application patterns impact PTO expiration. For example, a
sender that sends small amounts of data with silence periods between them
restarts the PTO timer every time it sends, potentially preventing the PTO timer
from expiring for a long period of time, even when no acknowledgments are being
received. The use of a duration enables a sender to establish persistent
congestion without depending on PTO expiration.</t>
        </section>
        <section anchor="establishing-persistent-congestion" numbered="true" toc="default">
          <name>Establishing Persistent Congestion</name>
          <t>A sender establishes persistent congestion after the receipt of an
acknowledgment if two packets that are ack-eliciting are declared lost, and:</t>
          <ul spacing="normal">
            <li>across all packet number spaces, none of the packets sent between the send
times of these two packets are acknowledged;</li>
            <li>the duration between the send times of these two packets exceeds the
persistent congestion duration (<xref target="pc-duration" format="default"/>); and</li>
            <li>a prior RTT sample existed when these two packets were sent.</li>
          </ul>
          <t>These two packets <bcp14>MUST</bcp14> be ack-eliciting, since a receiver is required to
acknowledge only ack-eliciting packets within its maximum acknowledgment delay;
see <xref section="13.2" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>.</t>
          <t>The persistent congestion period <bcp14>SHOULD NOT</bcp14> start until there is at least one
RTT sample. Before the first RTT sample, a sender arms its PTO timer based on
the initial RTT (<xref target="pto-handshake" format="default"/>), which could be substantially larger than
the actual RTT. Requiring a prior RTT sample prevents a sender from establishing
persistent congestion with potentially too few probes.</t>
          <t>Since network congestion is not affected by packet number spaces, persistent
congestion <bcp14>SHOULD</bcp14> consider packets sent across packet number spaces. A sender
that does not have state for all packet number spaces or an implementation that
cannot compare send times across packet number spaces <bcp14>MAY</bcp14> use state for just the
packet number space that was acknowledged. This might result in erroneously
declaring persistent congestion, but it will not lead to a failure to detect
persistent congestion.</t>
          <t>When persistent congestion is declared, the sender's congestion window <bcp14>MUST</bcp14> be
reduced to the minimum congestion window (kMinimumWindow), similar to a TCP
sender's response on an RTO <xref target="RFC5681" format="default"/>.</t>
        </section>
        <section anchor="example" numbered="true" toc="default">
          <name>Example</name>
          <t>The following example illustrates how a sender might establish persistent
congestion. Assume:</t>
          <sourcecode type="pseudocode"><![CDATA[
smoothed_rtt + max(4*rttvar, kGranularity) + max_ack_delay = 2
kPersistentCongestionThreshold = 3
]]></sourcecode>
          <t>Consider the following sequence of events:</t>
          <table align="center">
            <thead>
              <tr>
                <th align="left">Time</th>
                <th align="left">Action</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">t=0</td>
                <td align="left">Send packet #1 (application data)</td>
              </tr>
              <tr>
                <td align="left">t=1</td>
                <td align="left">Send packet #2 (application data)</td>
              </tr>
              <tr>
                <td align="left">t=1.2</td>
                <td align="left">Receive acknowledgment of #1</td>
              </tr>
              <tr>
                <td align="left">t=2</td>
                <td align="left">Send packet #3 (application data)</td>
              </tr>
              <tr>
                <td align="left">t=3</td>
                <td align="left">Send packet #4 (application data)</td>
              </tr>
              <tr>
                <td align="left">t=4</td>
                <td align="left">Send packet #5 (application data)</td>
              </tr>
              <tr>
                <td align="left">t=5</td>
                <td align="left">Send packet #6 (application data)</td>
              </tr>
              <tr>
                <td align="left">t=6</td>
                <td align="left">Send packet #7 (application data)</td>
              </tr>
              <tr>
                <td align="left">t=8</td>
                <td align="left">Send packet #8 (PTO 1)</td>
              </tr>
              <tr>
                <td align="left">t=12</td>
                <td align="left">Send packet #9 (PTO 2)</td>
              </tr>
              <tr>
                <td align="left">t=12.2</td>
                <td align="left">Receive acknowledgment of #9</td>
              </tr>
            </tbody>
          </table>
          <t>Packets 2 through 8 are declared lost when the acknowledgment for packet 9 is
received at <tt>t = 12.2</tt>.</t>
          <t>The congestion period is calculated as the time between the oldest and newest
lost packets: <tt>8 - 1 = 7</tt>.  The persistent congestion duration is <tt>2 * 3 = 6</tt>.
Because the threshold was reached and because none of the packets between the
oldest and the newest lost packets were acknowledged, the network is considered
to have experienced persistent congestion.</t>
          <t>While this example shows PTO expiration, they are not required for persistent
congestion to be established.</t>
        </section>
      </section>
      <section anchor="pacing" numbered="true" toc="default">
        <name>Pacing</name>
        <t>A sender <bcp14>SHOULD</bcp14> pace sending of all in-flight packets based on input from the
congestion controller.</t>
        <t>Sending multiple packets into the network without any delay between them creates
a packet burst that might cause short-term congestion and losses. Senders <bcp14>MUST</bcp14>
either use pacing or limit such bursts. Senders <bcp14>SHOULD</bcp14> limit bursts to the
initial congestion window; see <xref target="initial-cwnd" format="default"/>. A sender with knowledge that
the network path to the receiver can absorb larger bursts <bcp14>MAY</bcp14> use a higher
limit.</t>
        <t>An implementation should take care to architect its congestion controller to
work well with a pacer.  For instance, a pacer might wrap the congestion
controller and control the availability of the congestion window, or a pacer
might pace out packets handed to it by the congestion controller.</t>
        <t>Timely delivery of ACK frames is important for efficient loss recovery. To avoid
delaying their delivery to the peer, packets containing only ACK frames <bcp14>SHOULD</bcp14>
therefore not be paced.</t>
        <t>Endpoints can implement pacing as they choose. A perfectly paced sender spreads
packets exactly evenly over time. For a window-based congestion controller, such
as the one in this document, that rate can be computed by averaging the
congestion window over the RTT. Expressed as a rate in units of
bytes per time, where congestion_window is in bytes:</t>
        <sourcecode type="pseudocode"><![CDATA[
rate = N * congestion_window / smoothed_rtt
]]></sourcecode>
        <t>Or expressed as an inter-packet interval in units of time:</t>
        <sourcecode type="pseudocode"><![CDATA[
interval = ( smoothed_rtt * packet_size / congestion_window ) / N
]]></sourcecode>
        <t>Using a value for <tt>N</tt> that is small, but at least 1 (for example, 1.25) ensures
that variations in RTT do not result in underutilization of the
congestion window.</t>
        <t>Practical considerations, such as packetization, scheduling delays, and
computational efficiency, can cause a sender to deviate from this rate over time
periods that are much shorter than an RTT.</t>
        <t>One possible implementation strategy for pacing uses a leaky bucket algorithm,
where the capacity of the "bucket" is limited to the maximum burst size and the
rate the "bucket" fills is determined by the above function.</t>
      </section>
      <section anchor="underutilizing-the-congestion-window" numbered="true" toc="default">
        <name>Underutilizing the Congestion Window</name>
        <t>When bytes in flight is smaller than the congestion window and sending is not
pacing limited, the congestion window is underutilized. This can happen due to
insufficient application data or flow control limits. When this occurs,
the congestion window <bcp14>SHOULD NOT</bcp14> be increased in either slow start or
congestion avoidance.</t>
        <t>A sender that paces packets (see <xref target="pacing" format="default"/>) might delay sending packets
and not fully utilize the congestion window due to this delay. A sender
<bcp14>SHOULD NOT</bcp14> consider itself application limited if it would have fully
utilized the congestion window without pacing delay.</t>
        <t>A sender <bcp14>MAY</bcp14> implement alternative mechanisms to update its congestion window
after periods of underutilization, such as those proposed for TCP in
<xref target="RFC7661" format="default"/>.</t>
      </section>
    </section>
    <section anchor="security-considerations" numbered="true" toc="default">
      <name>Security Considerations</name>
      <section anchor="loss-and-congestion-signals" numbered="true" toc="default">
        <name>Loss and Congestion Signals</name>
        <t>Loss detection and congestion control fundamentally involve the consumption of
signals, such as delay, loss, and ECN markings, from unauthenticated
entities. An attacker can cause endpoints to reduce their sending rate by
manipulating these signals: by dropping packets, by altering path delay
strategically, or by changing ECN codepoints.</t>
      </section>
      <section anchor="traffic-analysis" numbered="true" toc="default">
        <name>Traffic Analysis</name>
        <t>Packets that carry only ACK frames can be heuristically identified by observing
packet size.  Acknowledgment patterns may expose information about link
characteristics or application behavior.  To reduce leaked information,
endpoints can bundle acknowledgments with other frames, or they can use PADDING
frames at a potential cost to performance.</t>
      </section>
      <section anchor="misreporting-ecn-markings" numbered="true" toc="default">
        <name>Misreporting ECN Markings</name>
        <t>A receiver can misreport ECN markings to alter the congestion response of a
sender.  Suppressing reports of ECN-CE markings could cause a sender to
increase their send rate.  This increase could result in congestion and loss.</t>
        <t>A sender can detect suppression of reports by marking occasional packets that it
sends with an ECN-CE marking. If a packet sent with an ECN-CE marking is not
reported as having been CE marked when the packet is acknowledged, then the
sender can disable ECN for that path by not setting ECN-Capable Transport (ECT)
codepoints in subsequent packets sent on that path <xref target="RFC3168" format="default"/>.</t>
        <t>Reporting additional ECN-CE markings will cause a sender to reduce their sending
rate, which is similar in effect to advertising reduced connection flow control
limits and so no advantage is gained by doing so.</t>
        <t>Endpoints choose the congestion controller that they use. Congestion controllers
respond to reports of ECN-CE by reducing their rate, but the response may vary.
Markings can be treated as equivalent to loss <xref target="RFC3168" format="default"/>, but other
responses can be specified, such as <xref target="RFC8511" format="default"/> or <xref target="RFC8311" format="default"/>.</t>
      </section>
    </section>
  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <reference anchor="QUIC-TRANSPORT" target="https://www.rfc-editor.org/info/rfc9000">
          <front>
            <title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
            <author initials="J." surname="Iyengar" fullname="Jana Iyengar" role="editor">
              <organization>Fastly</organization>
            </author>
            <author initials="M." surname="Thomson" fullname="Martin Thomson" role="editor">
              <organization>Mozilla</organization>
            </author>
            <date year="2021" month="May"/>
          </front>
          <seriesInfo name="RFC" value="9000"/>
          <seriesInfo name="DOI" value="10.17487/RFC9000"/>
        </reference>
        <reference anchor="QUIC-TLS" target="https://www.rfc-editor.org/info/rfc9001">
          <front>
            <title>Using TLS to Secure QUIC</title>
            <author initials="M." surname="Thomson" fullname="Martin Thomson" role="editor">
              <organization>Mozilla</organization>
            </author>
            <author initials="S." surname="Turner" fullname="Sean Turner" role="editor">
              <organization>sn3rd</organization>
            </author>
            <date year="2021" month="May"/>
          </front>
          <seriesInfo name="RFC" value="9001"/>
          <seriesInfo name="DOI" value="10.17487/RFC9001"/>
        </reference>
        <reference anchor="RFC8085" target="https://www.rfc-editor.org/info/rfc8085">
          <front>
            <title>UDP Usage Guidelines</title>
            <author fullname="L. Eggert" initials="L." surname="Eggert">
              <organization/>
            </author>
            <author fullname="G. Fairhurst" initials="G." surname="Fairhurst">
              <organization/>
            </author>
            <author fullname="G. Shepherd" initials="G." surname="Shepherd">
              <organization/>
            </author>
            <date month="March" year="2017"/>
            <abstract>
              <t>The User Datagram Protocol (UDP) provides a minimal message-passing transport that has no inherent congestion control mechanisms.  This document provides guidelines on the use of UDP for the designers of applications, tunnels, and other protocols that use UDP.  Congestion control guidelines are a primary focus, but the document also provides guidance on other topics, including message sizes, reliability, checksums, middlebox traversal, the use of Explicit Congestion Notification (ECN), Differentiated Services Code Points (DSCPs), and ports.</t>
              <t>Because congestion control is critical to the stable operation of the Internet, applications and other protocols that choose to use UDP as an Internet transport must employ mechanisms to prevent congestion collapse and to establish some degree of fairness with concurrent traffic.  They may also need to implement additional mechanisms, depending on how they use UDP.</t>
              <t>Some guidance is also applicable to the design of other protocols (e.g., protocols layered directly on IP or via IP-based tunnels), especially when these protocols do not themselves provide congestion control.</t>
              <t>This document obsoletes RFC 5405 and adds guidelines for multicast UDP usage.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="145"/>
          <seriesInfo name="RFC" value="8085"/>
          <seriesInfo name="DOI" value="10.17487/RFC8085"/>
        </reference>
        <reference anchor="RFC2119" target="https://www.rfc-editor.org/info/rfc2119">
          <front>
            <title>Key words for use in RFCs to Indicate Requirement Levels</title>
            <author fullname="S. Bradner" initials="S." surname="Bradner">
              <organization/>
            </author>
            <date month="March" year="1997"/>
            <abstract>
              <t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="2119"/>
          <seriesInfo name="DOI" value="10.17487/RFC2119"/>
        </reference>
        <reference anchor="RFC8174" target="https://www.rfc-editor.org/info/rfc8174">
          <front>
            <title>Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</title>
            <author fullname="B. Leiba" initials="B." surname="Leiba">
              <organization/>
            </author>
            <date month="May" year="2017"/>
            <abstract>
              <t>RFC 2119 specifies common key words that may be used in protocol  specifications.  This document aims to reduce the ambiguity by clarifying that only UPPERCASE usage of the key words have the  defined special meanings.</t>
            </abstract>
          </front>
          <seriesInfo name="BCP" value="14"/>
          <seriesInfo name="RFC" value="8174"/>
          <seriesInfo name="DOI" value="10.17487/RFC8174"/>
        </reference>
        <reference anchor="RFC3168" target="https://www.rfc-editor.org/info/rfc3168">
          <front>
            <title>The Addition of Explicit Congestion Notification (ECN) to IP</title>
            <author fullname="K. Ramakrishnan" initials="K." surname="Ramakrishnan">
              <organization/>
            </author>
            <author fullname="S. Floyd" initials="S." surname="Floyd">
              <organization/>
            </author>
            <author fullname="D. Black" initials="D." surname="Black">
              <organization/>
            </author>
            <date month="September" year="2001"/>
            <abstract>
              <t>This memo specifies the incorporation of ECN (Explicit Congestion Notification) to TCP and IP, including ECN's use of two bits in the IP header.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3168"/>
          <seriesInfo name="DOI" value="10.17487/RFC3168"/>
        </reference>
      </references>
      <references>
        <name>Informative References</name>
        <reference anchor="FACK">
          <front>
            <title>Forward acknowledgement: Refining TCP Congestion Control</title>
            <author initials="M." surname="Mathis">
              <organization/>
            </author>
            <author initials="J." surname="Mahdavi">
              <organization/>
            </author>
            <date year="1996" month="August"/>
          </front>
          <seriesInfo name="DOI" value="10.1145/248157.248181"/>
          <refcontent>ACM SIGCOMM Computer Communication Review</refcontent>
        </reference>
        <reference anchor="RETRANSMISSION">
          <front>
            <title>Improving Round-Trip Time Estimates in Reliable Transport Protocols</title>
            <author initials="P." surname="Karn">
              <organization/>
            </author>
            <author initials="C." surname="Partridge">
              <organization/>
            </author>
            <date year="1991" month="November"/>
          </front>
          <seriesInfo name="DOI" value="10.1145/118544.118549"/>
          <refcontent>ACM Transactions on Computer Systems</refcontent>
        </reference>
        <reference anchor="RFC3465" target="https://www.rfc-editor.org/info/rfc3465">
          <front>
            <title>TCP Congestion Control with Appropriate Byte Counting (ABC)</title>
            <author fullname="M. Allman" initials="M." surname="Allman">
              <organization/>
            </author>
            <date month="February" year="2003"/>
            <abstract>
              <t>This document proposes a small modification to the way TCP increases its congestion window.  Rather than the traditional method of increasing the congestion window by a constant amount for each arriving acknowledgment, the document suggests basing the increase on the number of previously unacknowledged bytes each ACK covers.  This change improves the performance of TCP, as well as closes a security hole TCP receivers can use to induce the sender into increasing the sending rate too rapidly. This memo defines an Experimental Protocol for the Internet community.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="3465"/>
          <seriesInfo name="DOI" value="10.17487/RFC3465"/>
        </reference>
        <reference anchor="RFC2018" target="https://www.rfc-editor.org/info/rfc2018">
          <front>
            <title>TCP Selective Acknowledgment Options</title>
            <author fullname="M. Mathis" initials="M." surname="Mathis">
              <organization/>
            </author>
            <author fullname="J. Mahdavi" initials="J." surname="Mahdavi">
              <organization/>
            </author>
            <author fullname="S. Floyd" initials="S." surname="Floyd">
              <organization/>
            </author>
            <author fullname="A. Romanow" initials="A." surname="Romanow">
              <organization/>
            </author>
            <date month="October" year="1996"/>
            <abstract>
              <t>This memo proposes an implementation of SACK and discusses its performance and related issues.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="2018"/>
          <seriesInfo name="DOI" value="10.17487/RFC2018"/>
        </reference>
        <reference anchor="RFC6298" target="https://www.rfc-editor.org/info/rfc6298">
          <front>
            <title>Computing TCP's Retransmission Timer</title>
            <author fullname="V. Paxson" initials="V." surname="Paxson">
              <organization/>
            </author>
            <author fullname="M. Allman" initials="M." surname="Allman">
              <organization/>
            </author>
            <author fullname="J. Chu" initials="J." surname="Chu">
              <organization/>
            </author>
            <author fullname="M. Sargent" initials="M." surname="Sargent">
              <organization/>
            </author>
            <date month="June" year="2011"/>
            <abstract>
              <t>This document defines the standard algorithm that Transmission Control Protocol (TCP) senders are required to use to compute and manage their retransmission timer.  It expands on the discussion in Section 4.2.3.1 of RFC 1122 and upgrades the requirement of supporting the algorithm from a <bcp14>SHOULD</bcp14> to a <bcp14>MUST</bcp14>.  This document obsoletes RFC 2988.   [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6298"/>
          <seriesInfo name="DOI" value="10.17487/RFC6298"/>
        </reference>
        <reference anchor="RFC8985" target="https://www.rfc-editor.org/info/rfc8985">
          <front>
            <title>The RACK-TLP Loss Detection Algorithm for TCP</title>
            <author fullname="Y. Cheng" initials="Y." surname="Cheng">
              <organization/>
            </author>
            <author fullname="N. Cardwell" initials="N." surname="Cardwell">
              <organization/>
            </author>
            <author fullname="N. Dukkipati" initials="N." surname="Dukkipati">
              <organization/>
            </author>
            <author fullname="P. Jha" initials="P." surname="Jha">
              <organization/>
            </author>
            <date month="February" year="2021"/>
            <abstract>
              <t>This document presents the RACK-TLP loss detection algorithm for TCP. RACK-TLP uses per-segment transmit timestamps and selective acknowledgments (SACKs) and has two parts. Recent Acknowledgment (RACK) starts fast recovery quickly using time-based inferences derived from acknowledgment (ACK) feedback, and Tail Loss Probe (TLP) leverages RACK and sends a probe packet to trigger ACK feedback to avoid retransmission timeout (RTO) events. Compared to the widely used duplicate acknowledgment (DupAck) threshold approach, RACK-TLP detects losses more efficiently when there are application-limited flights of data, lost retransmissions, or data packet reordering events. It is intended to be an alternative to the DupAck threshold approach.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8985"/>
          <seriesInfo name="DOI" value="10.17487/RFC8985"/>
        </reference>
        <reference anchor="RFC5682" target="https://www.rfc-editor.org/info/rfc5682">
          <front>
            <title>Forward RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious Retransmission Timeouts with TCP</title>
            <author fullname="P. Sarolahti" initials="P." surname="Sarolahti">
              <organization/>
            </author>
            <author fullname="M. Kojo" initials="M." surname="Kojo">
              <organization/>
            </author>
            <author fullname="K. Yamamoto" initials="K." surname="Yamamoto">
              <organization/>
            </author>
            <author fullname="M. Hata" initials="M." surname="Hata">
              <organization/>
            </author>
            <date month="September" year="2009"/>
            <abstract>
              <t>The purpose of this document is to move the F-RTO (Forward RTO-Recovery) functionality for TCP in RFC 4138 from Experimental to Standards Track status.  The F-RTO support for Stream Control Transmission Protocol (SCTP) in RFC 4138 remains with Experimental status.  See Appendix B for the differences between this document and RFC 4138.</t>
              <t>Spurious retransmission timeouts cause suboptimal TCP performance because they often result in unnecessary retransmission of the last window of data.  This document describes the F-RTO detection algorithm for detecting spurious TCP retransmission timeouts.  F-RTO is a TCP sender-only algorithm that does not require any TCP options to operate.  After retransmitting the first unacknowledged segment triggered by a timeout, the F-RTO algorithm of the TCP sender monitors the incoming acknowledgments to determine whether the timeout was spurious.  It then decides whether to send new segments or retransmit unacknowledged segments.  The algorithm effectively helps to avoid additional unnecessary retransmissions and thereby improves TCP performance in the case of a spurious timeout.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5682"/>
          <seriesInfo name="DOI" value="10.17487/RFC5682"/>
        </reference>
        <reference anchor="RFC5681" target="https://www.rfc-editor.org/info/rfc5681">
          <front>
            <title>TCP Congestion Control</title>
            <author fullname="M. Allman" initials="M." surname="Allman">
              <organization/>
            </author>
            <author fullname="V. Paxson" initials="V." surname="Paxson">
              <organization/>
            </author>
            <author fullname="E. Blanton" initials="E." surname="Blanton">
              <organization/>
            </author>
            <date month="September" year="2009"/>
            <abstract>
              <t>This document defines TCP's four intertwined congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery.  In addition, the document specifies how TCP should begin transmission after a relatively long idle period, as well as discussing various acknowledgment generation methods.  This document obsoletes RFC 2581.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5681"/>
          <seriesInfo name="DOI" value="10.17487/RFC5681"/>
        </reference>
        <reference anchor="RFC5827" target="https://www.rfc-editor.org/info/rfc5827">
          <front>
            <title>Early Retransmit for TCP and Stream Control Transmission Protocol (SCTP)</title>
            <author fullname="M. Allman" initials="M." surname="Allman">
              <organization/>
            </author>
            <author fullname="K. Avrachenkov" initials="K." surname="Avrachenkov">
              <organization/>
            </author>
            <author fullname="U. Ayesta" initials="U." surname="Ayesta">
              <organization/>
            </author>
            <author fullname="J. Blanton" initials="J." surname="Blanton">
              <organization/>
            </author>
            <author fullname="P. Hurtig" initials="P." surname="Hurtig">
              <organization/>
            </author>
            <date month="May" year="2010"/>
            <abstract>
              <t>This document proposes a new mechanism for TCP and Stream Control Transmission Protocol (SCTP) that can be used to recover lost segments when a connection's congestion window is small.  The "Early Retransmit" mechanism allows the transport to reduce, in certain special circumstances, the number of duplicate acknowledgments required to trigger a fast retransmission.  This allows the transport to use fast retransmit to recover segment losses that would otherwise require a lengthy retransmission timeout.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="5827"/>
          <seriesInfo name="DOI" value="10.17487/RFC5827"/>
        </reference>
        <reference anchor="RFC6675" target="https://www.rfc-editor.org/info/rfc6675">
          <front>
            <title>A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP</title>
            <author fullname="E. Blanton" initials="E." surname="Blanton">
              <organization/>
            </author>
            <author fullname="M. Allman" initials="M." surname="Allman">
              <organization/>
            </author>
            <author fullname="L. Wang" initials="L." surname="Wang">
              <organization/>
            </author>
            <author fullname="I. Jarvinen" initials="I." surname="Jarvinen">
              <organization/>
            </author>
            <author fullname="M. Kojo" initials="M." surname="Kojo">
              <organization/>
            </author>
            <author fullname="Y. Nishida" initials="Y." surname="Nishida">
              <organization/>
            </author>
            <date month="August" year="2012"/>
            <abstract>
              <t>This document presents a conservative loss recovery algorithm for TCP that is based on the use of the selective acknowledgment (SACK) TCP option.  The algorithm presented in this document conforms to the spirit of the current congestion control specification (RFC 5681), but allows TCP senders to recover more effectively when multiple segments are lost from a single flight of data. This document obsoletes RFC 3517 and describes changes from it.   [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6675"/>
          <seriesInfo name="DOI" value="10.17487/RFC6675"/>
        </reference>
        <reference anchor="RFC6582" target="https://www.rfc-editor.org/info/rfc6582">
          <front>
            <title>The NewReno Modification to TCP's Fast Recovery Algorithm</title>
            <author fullname="T. Henderson" initials="T." surname="Henderson">
              <organization/>
            </author>
            <author fullname="S. Floyd" initials="S." surname="Floyd">
              <organization/>
            </author>
            <author fullname="A. Gurtov" initials="A." surname="Gurtov">
              <organization/>
            </author>
            <author fullname="Y. Nishida" initials="Y." surname="Nishida">
              <organization/>
            </author>
            <date month="April" year="2012"/>
            <abstract>
              <t>RFC 5681 documents the following four intertwined TCP congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery.  RFC 5681 explicitly allows certain modifications of these algorithms, including modifications that use the TCP Selective Acknowledgment (SACK) option (RFC 2883), and modifications that respond to "partial acknowledgments" (ACKs that cover new data, but not all the data outstanding when loss was detected) in the absence of SACK.  This document describes a specific algorithm for responding to partial acknowledgments, referred to as "NewReno".  This response to partial acknowledgments was first proposed by Janey Hoe.  This document obsoletes RFC 3782.  [STANDARDS-TRACK]</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6582"/>
          <seriesInfo name="DOI" value="10.17487/RFC6582"/>
        </reference>
        <reference anchor="RFC8312" target="https://www.rfc-editor.org/info/rfc8312">
          <front>
            <title>CUBIC for Fast Long-Distance Networks</title>
            <author fullname="I. Rhee" initials="I." surname="Rhee">
              <organization/>
            </author>
            <author fullname="L. Xu" initials="L." surname="Xu">
              <organization/>
            </author>
            <author fullname="S. Ha" initials="S." surname="Ha">
              <organization/>
            </author>
            <author fullname="A. Zimmermann" initials="A." surname="Zimmermann">
              <organization/>
            </author>
            <author fullname="L. Eggert" initials="L." surname="Eggert">
              <organization/>
            </author>
            <author fullname="R. Scheffenegger" initials="R." surname="Scheffenegger">
              <organization/>
            </author>
            <date month="February" year="2018"/>
            <abstract>
              <t>CUBIC is an extension to the current TCP standards.  It differs from the current TCP standards only in the congestion control algorithm on the sender side.  In particular, it uses a cubic function instead of a linear window increase function of the current TCP standards to improve scalability and stability under fast and long-distance networks.  CUBIC and its predecessor algorithm have been adopted as defaults by Linux and have been used for many years.  This document provides a specification of CUBIC to enable third-party implementations and to solicit community feedback through experimentation on the performance of CUBIC.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8312"/>
          <seriesInfo name="DOI" value="10.17487/RFC8312"/>
        </reference>
        <reference anchor="RFC8311" target="https://www.rfc-editor.org/info/rfc8311">
          <front>
            <title>Relaxing Restrictions on Explicit Congestion Notification (ECN) Experimentation</title>
            <author fullname="D. Black" initials="D." surname="Black">
              <organization/>
            </author>
            <date month="January" year="2018"/>
            <abstract>
              <t>This memo updates RFC 3168, which specifies Explicit Congestion Notification (ECN) as an alternative to packet drops for indicating network congestion to endpoints.  It relaxes restrictions in RFC 3168 that hinder experimentation towards benefits beyond just removal of loss.  This memo summarizes the anticipated areas of experimentation and updates RFC 3168 to enable experimentation in these areas.  An Experimental RFC in the IETF document stream is required to take advantage of any of these enabling updates.  In addition, this memo makes related updates to the ECN specifications for RTP in RFC 6679 and for the Datagram Congestion Control Protocol (DCCP) in RFCs 4341, 4342, and 5622.  This memo also records the conclusion of the ECN nonce experiment in RFC 3540 and provides the rationale for reclassification of RFC 3540 from Experimental to Historic; this reclassification enables new experimental use of the ECT(1) codepoint.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8311"/>
          <seriesInfo name="DOI" value="10.17487/RFC8311"/>
        </reference>
        <reference anchor="RFC6928" target="https://www.rfc-editor.org/info/rfc6928">
          <front>
            <title>Increasing TCP's Initial Window</title>
            <author fullname="J. Chu" initials="J." surname="Chu">
              <organization/>
            </author>
            <author fullname="N. Dukkipati" initials="N." surname="Dukkipati">
              <organization/>
            </author>
            <author fullname="Y. Cheng" initials="Y." surname="Cheng">
              <organization/>
            </author>
            <author fullname="M. Mathis" initials="M." surname="Mathis">
              <organization/>
            </author>
            <date month="April" year="2013"/>
            <abstract>
              <t>This document proposes an experiment to increase the permitted TCP initial window (IW) from between 2 and 4 segments, as specified in RFC 3390, to 10 segments with a fallback to the existing recommendation when performance issues are detected.  It discusses the motivation behind the increase, the advantages and disadvantages of the higher initial window, and presents results from several large-scale experiments showing that the higher initial window improves the overall performance of many web services without resulting in a congestion collapse.  The document closes with a discussion of usage and deployment for further experimental purposes recommended by the IETF TCP Maintenance and Minor Extensions (TCPM) working group.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6928"/>
          <seriesInfo name="DOI" value="10.17487/RFC6928"/>
        </reference>
        <reference anchor="PRR" target="https://www.rfc-editor.org/info/rfc6937">
          <front>
            <title>Proportional Rate Reduction for TCP</title>
            <author fullname="M. Mathis" initials="M." surname="Mathis">
              <organization/>
            </author>
            <author fullname="N. Dukkipati" initials="N." surname="Dukkipati">
              <organization/>
            </author>
            <author fullname="Y. Cheng" initials="Y." surname="Cheng">
              <organization/>
            </author>
            <date month="May" year="2013"/>
            <abstract>
              <t>This document describes an experimental Proportional Rate Reduction (PRR) algorithm as an alternative to the widely deployed Fast Recovery and Rate-Halving algorithms.  These algorithms determine the amount of data sent by TCP during loss recovery.  PRR minimizes excess window adjustments, and the actual window size at the end of recovery will be as close as possible to the ssthresh, as determined by the congestion control algorithm.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="6937"/>
          <seriesInfo name="DOI" value="10.17487/RFC6937"/>
        </reference>
        <reference anchor="RFC7661" target="https://www.rfc-editor.org/info/rfc7661">
          <front>
            <title>Updating TCP to Support Rate-Limited Traffic</title>
            <author fullname="G. Fairhurst" initials="G." surname="Fairhurst">
              <organization/>
            </author>
            <author fullname="A. Sathiaseelan" initials="A." surname="Sathiaseelan">
              <organization/>
            </author>
            <author fullname="R. Secchi" initials="R." surname="Secchi">
              <organization/>
            </author>
            <date month="October" year="2015"/>
            <abstract>
              <t>This document provides a mechanism to address issues that arise when TCP is used for traffic that exhibits periods where the sending rate is limited by the application rather than the congestion window.  It provides an experimental update to TCP that allows a TCP sender to restart quickly following a rate-limited interval.  This method is expected to benefit applications that send rate-limited traffic using TCP while also providing an appropriate response if congestion is experienced.</t>
              <t>This document also evaluates the Experimental specification of TCP Congestion Window Validation (CWV) defined in RFC 2861 and concludes that RFC 2861 sought to address important issues but failed to deliver a widely used solution.  This document therefore reclassifies the status of RFC 2861 from Experimental to Historic.  This document obsoletes RFC 2861.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="7661"/>
          <seriesInfo name="DOI" value="10.17487/RFC7661"/>
        </reference>
        <reference anchor="RFC8511" target="https://www.rfc-editor.org/info/rfc8511">
          <front>
            <title>TCP Alternative Backoff with ECN (ABE)</title>
            <author fullname="N. Khademi" initials="N." surname="Khademi">
              <organization/>
            </author>
            <author fullname="M. Welzl" initials="M." surname="Welzl">
              <organization/>
            </author>
            <author fullname="G. Armitage" initials="G." surname="Armitage">
              <organization/>
            </author>
            <author fullname="G. Fairhurst" initials="G." surname="Fairhurst">
              <organization/>
            </author>
            <date month="December" year="2018"/>
            <abstract>
              <t>Active Queue Management (AQM) mechanisms allow for burst tolerance while enforcing short queues to minimise the time that packets spend enqueued at a bottleneck.  This can cause noticeable performance degradation for TCP connections traversing such a bottleneck, especially if there are only a few flows or their bandwidth-delay product (BDP) is large.  The reception of a Congestion Experienced (CE) Explicit Congestion Notification (ECN) mark indicates that an AQM mechanism is used at the bottleneck, and the bottleneck network queue is therefore likely to be short.  Feedback of this signal allows the TCP sender-side ECN reaction in congestion avoidance to reduce the Congestion Window (cwnd) by a smaller amount than the congestion control algorithm's reaction to inferred packet loss. Therefore, this specification defines an experimental change to the TCP reaction specified in RFC 3168, as permitted by RFC 8311.</t>
            </abstract>
          </front>
          <seriesInfo name="RFC" value="8511"/>
          <seriesInfo name="DOI" value="10.17487/RFC8511"/>
        </reference>
      </references>
    </references>
    <section anchor="loss-recovery-pseudocode" numbered="true" toc="default">
      <name>Loss Recovery Pseudocode</name>
      <t>We now describe an example implementation of the loss detection mechanisms
described in <xref target="loss-detection" format="default"/>.</t>
      <t>The pseudocode segments in this section are licensed as Code Components; see the
copyright notice.</t>
      <section anchor="tracking-sent-packets" numbered="true" toc="default">
        <name>Tracking Sent Packets</name>
        <t>To correctly implement congestion control, a QUIC sender tracks every
ack-eliciting packet until the packet is acknowledged or lost.
It is expected that implementations will be able to access this information by
packet number and crypto context and store the per-packet fields
(<xref target="sent-packets-fields" format="default"/>) for loss recovery and congestion control.</t>
        <t>After a packet is declared lost, the endpoint can still maintain state for it
for an amount of time to allow for packet reordering; see <xref section="13.3" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>. This enables a sender to detect spurious retransmissions.</t>
        <t>Sent packets are tracked for each packet number space, and ACK
processing only applies to a single space.</t>
        <section anchor="sent-packets-fields" numbered="true" toc="default">
          <name>Sent Packet Fields</name>
          <dl>
            <dt>packet_number:</dt>
            <dd>
              <t>The packet number of the sent packet.</t>
            </dd>
            <dt>ack_eliciting:</dt>
            <dd>
              <t>A Boolean that indicates whether a packet is ack-eliciting.
If true, it is expected that an acknowledgment will be received,
though the peer could delay sending the ACK frame containing it
by up to the max_ack_delay.</t>
            </dd>
            <dt>in_flight:</dt>
            <dd>
              <t>A Boolean that indicates whether the packet counts toward bytes in
flight.</t>
            </dd>
            <dt>sent_bytes:</dt>
            <dd>
              <t>The number of bytes sent in the packet, not including UDP or IP
overhead, but including QUIC framing overhead.</t>
            </dd>
            <dt>time_sent:</dt>
            <dd>
              <t>The time the packet was sent.</t>
            </dd>
          </dl>
        </section>
      </section>
      <section anchor="constants-of-interest" numbered="true" toc="default">
        <name>Constants of Interest</name>
        <t>Constants used in loss recovery are based on a combination of RFCs, papers, and
common practice.</t>
        <dl>
          <dt>kPacketThreshold:</dt>
          <dd>
            <t>Maximum reordering in packets before packet threshold loss detection
considers a packet lost. The value recommended in <xref target="packet-threshold" format="default"/> is 3.</t>
          </dd>
          <dt>kTimeThreshold:</dt>
          <dd>
            <t>Maximum reordering in time before time threshold loss detection
considers a packet lost. Specified as an RTT multiplier. The value
recommended in <xref target="time-threshold" format="default"/> is 9/8.</t>
          </dd>
          <dt>kGranularity:</dt>
          <dd>
            <t>Timer granularity. This is a system-dependent value, and <xref target="time-threshold" format="default"/>
recommends a value of 1 ms.</t>
          </dd>
          <dt>kInitialRtt:</dt>
          <dd>
            <t>The RTT used before an RTT sample is taken. The value recommended in
<xref target="pto-handshake" format="default"/> is 333 ms.</t>
          </dd>
          <dt>kPacketNumberSpace:</dt>
          <dd>
            <t>An enum to enumerate the three packet number spaces:</t>
          </dd>
        </dl>
        <artwork name="" type="" align="left" alt=""><![CDATA[
enum kPacketNumberSpace {
  Initial,
  Handshake,
  ApplicationData,
}
]]></artwork>
      </section>
      <section anchor="ld-vars-of-interest" numbered="true" toc="default">
        <name>Variables of Interest</name>
        <t>Variables required to implement the congestion control mechanisms
are described in this section.</t>
        <dl>
          <dt>latest_rtt:</dt>
          <dd>
            <t>The most recent RTT measurement made when receiving an acknowledgment for
a previously unacknowledged packet.</t>
          </dd>
          <dt>smoothed_rtt:</dt>
          <dd>
            <t>The smoothed RTT of the connection, computed as described in
<xref target="smoothed-rtt" format="default"/>.</t>
          </dd>
          <dt>rttvar:</dt>
          <dd>
            <t>The RTT variation, computed as described in <xref target="smoothed-rtt" format="default"/>.</t>
          </dd>
          <dt>min_rtt:</dt>
          <dd>
            <t>The minimum RTT seen over a period of time, ignoring acknowledgment delay, as
described in <xref target="min-rtt" format="default"/>.</t>
          </dd>
          <dt>first_rtt_sample:</dt>
          <dd>
            <t>The time that the first RTT sample was obtained.</t>
          </dd>
          <dt>max_ack_delay:</dt>
          <dd>
            <t>The maximum amount of time by which the receiver intends to delay
acknowledgments for packets in the Application Data packet number
space, as defined by the eponymous transport parameter (<xref section="18.2" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>). Note that the actual ack_delay in a received
ACK frame may be larger due to late timers, reordering, or loss.</t>
          </dd>
          <dt>loss_detection_timer:</dt>
          <dd>
            <t>Multi-modal timer used for loss detection.</t>
          </dd>
          <dt>pto_count:</dt>
          <dd>
            <t>The number of times a PTO has been sent without receiving an acknowledgment.</t>
          </dd>
          <dt>time_of_last_ack_eliciting_packet[kPacketNumberSpace]:</dt>
          <dd>
            <t>The time the most recent ack-eliciting packet was sent.</t>
          </dd>
          <dt>largest_acked_packet[kPacketNumberSpace]:</dt>
          <dd>
            <t>The largest packet number acknowledged in the packet number space so far.</t>
          </dd>
          <dt>loss_time[kPacketNumberSpace]:</dt>
          <dd>
            <t>The time at which the next packet in that packet number space can be
considered lost based on exceeding the reordering window in time.</t>
          </dd>
          <dt>sent_packets[kPacketNumberSpace]:</dt>
          <dd>
            <t>An association of packet numbers in a packet number space to information
about them.  Described in detail above in <xref target="tracking-sent-packets" format="default"/>.</t>
          </dd>
        </dl>
      </section>
      <section anchor="initialization" numbered="true" toc="default">
        <name>Initialization</name>
        <t>At the beginning of the connection, initialize the loss detection variables as
follows:</t>
        <sourcecode type="pseudocode"><![CDATA[
loss_detection_timer.reset()
pto_count = 0
latest_rtt = 0
smoothed_rtt = kInitialRtt
rttvar = kInitialRtt / 2
min_rtt = 0
first_rtt_sample = 0
for pn_space in [ Initial, Handshake, ApplicationData ]:
  largest_acked_packet[pn_space] = infinite
  time_of_last_ack_eliciting_packet[pn_space] = 0
  loss_time[pn_space] = 0
]]></sourcecode>
      </section>
      <section anchor="on-sending-a-packet" numbered="true" toc="default">
        <name>On Sending a Packet</name>
        <t>After a packet is sent, information about the packet is stored.  The parameters
to OnPacketSent are described in detail above in <xref target="sent-packets-fields" format="default"/>.</t>
        <t>Pseudocode for OnPacketSent follows:</t>
        <sourcecode type="pseudocode"><![CDATA[
OnPacketSent(packet_number, pn_space, ack_eliciting,
             in_flight, sent_bytes):
  sent_packets[pn_space][packet_number].packet_number =
                                           packet_number
  sent_packets[pn_space][packet_number].time_sent = now()
  sent_packets[pn_space][packet_number].ack_eliciting =
                                           ack_eliciting
  sent_packets[pn_space][packet_number].in_flight = in_flight
  sent_packets[pn_space][packet_number].sent_bytes = sent_bytes
  if (in_flight):
    if (ack_eliciting):
      time_of_last_ack_eliciting_packet[pn_space] = now()
    OnPacketSentCC(sent_bytes)
    SetLossDetectionTimer()
]]></sourcecode>
      </section>
      <section anchor="on-receiving-a-datagram" numbered="true" toc="default">
        <name>On Receiving a Datagram</name>
        <t>When a server is blocked by anti-amplification limits, receiving
a datagram unblocks it, even if none of the packets in the
datagram are successfully processed. In such a case, the PTO
timer will need to be rearmed.</t>
        <t>Pseudocode for OnDatagramReceived follows:</t>
        <sourcecode type="pseudocode"><![CDATA[
OnDatagramReceived(datagram):
  // If this datagram unblocks the server, arm the
  // PTO timer to avoid deadlock.
  if (server was at anti-amplification limit):
    SetLossDetectionTimer()
    if loss_detection_timer.timeout < now():
      // Execute PTO if it would have expired
      // while the amplification limit applied.
      OnLossDetectionTimeout()
]]></sourcecode>
      </section>
      <section anchor="on-receiving-an-acknowledgment" numbered="true" toc="default">
        <name>On Receiving an Acknowledgment</name>
        <t>When an ACK frame is received, it may newly acknowledge any number of packets.</t>
        <t>Pseudocode for OnAckReceived and UpdateRtt follow:</t>
        <sourcecode type="pseudocode"><![CDATA[
IncludesAckEliciting(packets):
  for packet in packets:
    if (packet.ack_eliciting):
      return true
  return false

OnAckReceived(ack, pn_space):
  if (largest_acked_packet[pn_space] == infinite):
    largest_acked_packet[pn_space] = ack.largest_acked
  else:
    largest_acked_packet[pn_space] =
        max(largest_acked_packet[pn_space], ack.largest_acked)

  // DetectAndRemoveAckedPackets finds packets that are newly
  // acknowledged and removes them from sent_packets.
  newly_acked_packets =
      DetectAndRemoveAckedPackets(ack, pn_space)
  // Nothing to do if there are no newly acked packets.
  if (newly_acked_packets.empty()):
    return

  // Update the RTT if the largest acknowledged is newly acked
  // and at least one ack-eliciting was newly acked.
  if (newly_acked_packets.largest().packet_number ==
          ack.largest_acked &&
      IncludesAckEliciting(newly_acked_packets)):
    latest_rtt =
      now() - newly_acked_packets.largest().time_sent
    UpdateRtt(ack.ack_delay)

  // Process ECN information if present.
  if (ACK frame contains ECN information):
      ProcessECN(ack, pn_space)

  lost_packets = DetectAndRemoveLostPackets(pn_space)
  if (!lost_packets.empty()):
    OnPacketsLost(lost_packets)
  OnPacketsAcked(newly_acked_packets)

  // Reset pto_count unless the client is unsure if
  // the server has validated the client's address.
  if (PeerCompletedAddressValidation()):
    pto_count = 0
  SetLossDetectionTimer()


UpdateRtt(ack_delay):
  if (first_rtt_sample == 0):
    min_rtt = latest_rtt
    smoothed_rtt = latest_rtt
    rttvar = latest_rtt / 2
    first_rtt_sample = now()
    return

  // min_rtt ignores acknowledgment delay.
  min_rtt = min(min_rtt, latest_rtt)
  // Limit ack_delay by max_ack_delay after handshake
  // confirmation.
  if (handshake confirmed):
    ack_delay = min(ack_delay, max_ack_delay)

  // Adjust for acknowledgment delay if plausible.
  adjusted_rtt = latest_rtt
  if (latest_rtt >= min_rtt + ack_delay):
    adjusted_rtt = latest_rtt - ack_delay

  rttvar = 3/4 * rttvar + 1/4 * abs(smoothed_rtt - adjusted_rtt)
  smoothed_rtt = 7/8 * smoothed_rtt + 1/8 * adjusted_rtt
]]></sourcecode>
      </section>
      <section anchor="setting-the-loss-detection-timer" numbered="true" toc="default">
        <name>Setting the Loss Detection Timer</name>
        <t>QUIC loss detection uses a single timer for all timeout loss detection.  The
duration of the timer is based on the timer's mode, which is set in the packet
and timer events further below.  The function SetLossDetectionTimer defined
below shows how the single timer is set.</t>
        <t>This algorithm may result in the timer being set in the past, particularly if
timers wake up late. Timers set in the past fire immediately.</t>
        <t>Pseudocode for SetLossDetectionTimer follows (where the "^" operator represents
exponentiation):</t>
        <sourcecode type="pseudocode"><![CDATA[
GetLossTimeAndSpace():
  time = loss_time[Initial]
  space = Initial
  for pn_space in [ Handshake, ApplicationData ]:
    if (time == 0 || loss_time[pn_space] < time):
      time = loss_time[pn_space];
      space = pn_space
  return time, space

GetPtoTimeAndSpace():
  duration = (smoothed_rtt + max(4 * rttvar, kGranularity))
      * (2 ^ pto_count)
  // Anti-deadlock PTO starts from the current time
  if (no ack-eliciting packets in flight):
    assert(!PeerCompletedAddressValidation())
    if (has handshake keys):
      return (now() + duration), Handshake
    else:
      return (now() + duration), Initial
  pto_timeout = infinite
  pto_space = Initial
  for space in [ Initial, Handshake, ApplicationData ]:
    if (no ack-eliciting packets in flight in space):
        continue;
    if (space == ApplicationData):
      // Skip Application Data until handshake confirmed.
      if (handshake is not confirmed):
        return pto_timeout, pto_space
      // Include max_ack_delay and backoff for Application Data.
      duration += max_ack_delay * (2 ^ pto_count)

    t = time_of_last_ack_eliciting_packet[space] + duration
    if (t < pto_timeout):
      pto_timeout = t
      pto_space = space
  return pto_timeout, pto_space

PeerCompletedAddressValidation():
  // Assume clients validate the server's address implicitly.
  if (endpoint is server):
    return true
  // Servers complete address validation when a
  // protected packet is received.
  return has received Handshake ACK ||
       handshake confirmed

SetLossDetectionTimer():
  earliest_loss_time, _ = GetLossTimeAndSpace()
  if (earliest_loss_time != 0):
    // Time threshold loss detection.
    loss_detection_timer.update(earliest_loss_time)
    return

  if (server is at anti-amplification limit):
    // The server's timer is not set if nothing can be sent.
    loss_detection_timer.cancel()
    return

  if (no ack-eliciting packets in flight &&
      PeerCompletedAddressValidation()):
    // There is nothing to detect lost, so no timer is set.
    // However, the client needs to arm the timer if the
    // server might be blocked by the anti-amplification limit.
    loss_detection_timer.cancel()
    return

  timeout, _ = GetPtoTimeAndSpace()
  loss_detection_timer.update(timeout)
]]></sourcecode>
      </section>
      <section anchor="on-timeout" numbered="true" toc="default">
        <name>On Timeout</name>
        <t>When the loss detection timer expires, the timer's mode determines the action
to be performed.</t>
        <t>Pseudocode for OnLossDetectionTimeout follows:</t>
        <sourcecode type="pseudocode"><![CDATA[
OnLossDetectionTimeout():
  earliest_loss_time, pn_space = GetLossTimeAndSpace()
  if (earliest_loss_time != 0):
    // Time threshold loss Detection
    lost_packets = DetectAndRemoveLostPackets(pn_space)
    assert(!lost_packets.empty())
    OnPacketsLost(lost_packets)
    SetLossDetectionTimer()
    return

  if (no ack-eliciting packets in flight):
    assert(!PeerCompletedAddressValidation())
    // Client sends an anti-deadlock packet: Initial is padded
    // to earn more anti-amplification credit,
    // a Handshake packet proves address ownership.
    if (has Handshake keys):
      SendOneAckElicitingHandshakePacket()
    else:
      SendOneAckElicitingPaddedInitialPacket()
  else:
    // PTO. Send new data if available, else retransmit old data.
    // If neither is available, send a single PING frame.
    _, pn_space = GetPtoTimeAndSpace()
    SendOneOrTwoAckElicitingPackets(pn_space)

  pto_count++
  SetLossDetectionTimer()
]]></sourcecode>
      </section>
      <section anchor="detecting-lost-packets" numbered="true" toc="default">
        <name>Detecting Lost Packets</name>
        <t>DetectAndRemoveLostPackets is called every time an ACK is received or the time
threshold loss detection timer expires. This function operates on the
sent_packets for that packet number space and returns a list of packets newly
detected as lost.</t>
        <t>Pseudocode for DetectAndRemoveLostPackets follows:</t>
        <sourcecode type="pseudocode"><![CDATA[
DetectAndRemoveLostPackets(pn_space):
  assert(largest_acked_packet[pn_space] != infinite)
  loss_time[pn_space] = 0
  lost_packets = []
  loss_delay = kTimeThreshold * max(latest_rtt, smoothed_rtt)

  // Minimum time of kGranularity before packets are deemed lost.
  loss_delay = max(loss_delay, kGranularity)

  // Packets sent before this time are deemed lost.
  lost_send_time = now() - loss_delay

  foreach unacked in sent_packets[pn_space]:
    if (unacked.packet_number > largest_acked_packet[pn_space]):
      continue

    // Mark packet as lost, or set time when it should be marked.
    // Note: The use of kPacketThreshold here assumes that there
    // were no sender-induced gaps in the packet number space.
    if (unacked.time_sent <= lost_send_time ||
        largest_acked_packet[pn_space] >=
          unacked.packet_number + kPacketThreshold):
      sent_packets[pn_space].remove(unacked.packet_number)
      lost_packets.insert(unacked)
    else:
      if (loss_time[pn_space] == 0):
        loss_time[pn_space] = unacked.time_sent + loss_delay
      else:
        loss_time[pn_space] = min(loss_time[pn_space],
                                  unacked.time_sent + loss_delay)
  return lost_packets
]]></sourcecode>
      </section>
      <section anchor="upon-dropping-initial-or-handshake-keys" numbered="true" toc="default">
        <name>Upon Dropping Initial or Handshake Keys</name>
        <t>When Initial or Handshake keys are discarded, packets from the space
are discarded and loss detection state is updated.</t>
        <t>Pseudocode for OnPacketNumberSpaceDiscarded follows:</t>
        <sourcecode type="pseudocode"><![CDATA[
OnPacketNumberSpaceDiscarded(pn_space):
  assert(pn_space != ApplicationData)
  RemoveFromBytesInFlight(sent_packets[pn_space])
  sent_packets[pn_space].clear()
  // Reset the loss detection and PTO timer
  time_of_last_ack_eliciting_packet[pn_space] = 0
  loss_time[pn_space] = 0
  pto_count = 0
  SetLossDetectionTimer()
]]></sourcecode>
      </section>
    </section>
    <section anchor="congestion-control-pseudocode" numbered="true" toc="default">
      <name>Congestion Control Pseudocode</name>
      <t>We now describe an example implementation of the congestion controller described
in <xref target="congestion-control" format="default"/>.</t>
      <t>The pseudocode segments in this section are licensed as Code Components; see the
copyright notice.</t>
      <section anchor="cc-consts-of-interest" numbered="true" toc="default">
        <name>Constants of Interest</name>
        <t>Constants used in congestion control are based on a combination of RFCs, papers,
and common practice.</t>
        <dl>
          <dt>kInitialWindow:</dt>
          <dd>
            <t>Default limit on the initial bytes in flight as described in <xref target="initial-cwnd" format="default"/>.</t>
          </dd>
          <dt>kMinimumWindow:</dt>
          <dd>
            <t>Minimum congestion window in bytes as described in <xref target="initial-cwnd" format="default"/>.</t>
          </dd>
          <dt>kLossReductionFactor:</dt>
          <dd>
            <t>Scaling factor applied to reduce the congestion window when a new loss event
is detected. <xref target="congestion-control" format="default"/> recommends a value of 0.5.</t>
          </dd>
          <dt>kPersistentCongestionThreshold:</dt>
          <dd>
            <t>Period of time for persistent congestion to be established, specified as a PTO
multiplier. <xref target="persistent-congestion" format="default"/> recommends a value of 3.</t>
          </dd>
        </dl>
      </section>
      <section anchor="vars-of-interest" numbered="true" toc="default">
        <name>Variables of Interest</name>
        <t>Variables required to implement the congestion control mechanisms
are described in this section.</t>
        <dl>
          <dt>max_datagram_size:</dt>
          <dd>
            <t>The sender's current maximum payload size. This does not include UDP or IP
overhead.  The max datagram size is used for congestion window
computations. An endpoint sets the value of this variable based on its Path
Maximum Transmission Unit (PMTU; see <xref section="14.2" sectionFormat="of" target="QUIC-TRANSPORT" format="default"/>), with
a minimum value of 1200 bytes.</t>
          </dd>
          <dt>ecn_ce_counters[kPacketNumberSpace]:</dt>
          <dd>
            <t>The highest value reported for the ECN-CE counter in the packet number space
by the peer in an ACK frame. This value is used to detect increases in the
reported ECN-CE counter.</t>
          </dd>
          <dt>bytes_in_flight:</dt>
          <dd>
            <t>The sum of the size in bytes of all sent packets that contain at least one
ack-eliciting or PADDING frame and have not been acknowledged or declared
lost. The size does not include IP or UDP overhead, but does include the QUIC
header and Authenticated Encryption with Associated Data (AEAD) overhead.
Packets only containing ACK frames do not count toward bytes_in_flight to
ensure congestion control does not impede congestion feedback.</t>
          </dd>
          <dt>congestion_window:</dt>
          <dd>
            <t>Maximum number of bytes allowed to be in flight.</t>
          </dd>
          <dt>congestion_recovery_start_time:</dt>
          <dd>
            <t>The time the current recovery period started due to the detection of loss
or ECN. When a packet sent after this time is acknowledged, QUIC exits
congestion recovery.</t>
          </dd>
          <dt>ssthresh:</dt>
          <dd>
            <t>Slow start threshold in bytes.  When the congestion window is below ssthresh,
the mode is slow start and the window grows by the number of bytes
acknowledged.</t>
          </dd>
        </dl>
        <t>The congestion control pseudocode also accesses some of the variables from the
loss recovery pseudocode.</t>
      </section>
      <section anchor="initialization-1" numbered="true" toc="default">
        <name>Initialization</name>
        <t>At the beginning of the connection, initialize the congestion control
variables as follows:</t>
        <sourcecode type="pseudocode"><![CDATA[
congestion_window = kInitialWindow
bytes_in_flight = 0
congestion_recovery_start_time = 0
ssthresh = infinite
for pn_space in [ Initial, Handshake, ApplicationData ]:
  ecn_ce_counters[pn_space] = 0
]]></sourcecode>
      </section>
      <section anchor="on-packet-sent" numbered="true" toc="default">
        <name>On Packet Sent</name>
        <t>Whenever a packet is sent and it contains non-ACK frames, the packet
increases bytes_in_flight.</t>
        <sourcecode type="pseudocode"><![CDATA[
OnPacketSentCC(sent_bytes):
  bytes_in_flight += sent_bytes
]]></sourcecode>
      </section>
      <section anchor="on-packet-acknowledgment" numbered="true" toc="default">
        <name>On Packet Acknowledgment</name>
        <t>This is invoked from loss detection's OnAckReceived and is supplied with the
newly acked_packets from sent_packets.</t>
        <t>In congestion avoidance, implementers that use an integer representation
for congestion_window should be careful with division and can use
the alternative approach suggested in <xref section="2.1" sectionFormat="of" target="RFC3465" format="default"/>.</t>
        <sourcecode type="pseudocode"><![CDATA[
InCongestionRecovery(sent_time):
  return sent_time <= congestion_recovery_start_time

OnPacketsAcked(acked_packets):
  for acked_packet in acked_packets:
    OnPacketAcked(acked_packet)

OnPacketAcked(acked_packet):
  if (!acked_packet.in_flight):
    return;
  // Remove from bytes_in_flight.
  bytes_in_flight -= acked_packet.sent_bytes
  // Do not increase congestion_window if application
  // limited or flow control limited.
  if (IsAppOrFlowControlLimited())
    return
  // Do not increase congestion window in recovery period.
  if (InCongestionRecovery(acked_packet.time_sent)):
    return
  if (congestion_window < ssthresh):
    // Slow start.
    congestion_window += acked_packet.sent_bytes
  else:
    // Congestion avoidance.
    congestion_window +=
      max_datagram_size * acked_packet.sent_bytes
      / congestion_window
]]></sourcecode>
      </section>
      <section anchor="on-new-congestion-event" numbered="true" toc="default">
        <name>On New Congestion Event</name>
        <t>This is invoked from ProcessECN and OnPacketsLost when a new congestion event is
detected. If not already in recovery, this starts a recovery period and
reduces the slow start threshold and congestion window immediately.</t>
        <sourcecode type="pseudocode"><![CDATA[
OnCongestionEvent(sent_time):
  // No reaction if already in a recovery period.
  if (InCongestionRecovery(sent_time)):
    return

  // Enter recovery period.
  congestion_recovery_start_time = now()
  ssthresh = congestion_window * kLossReductionFactor
  congestion_window = max(ssthresh, kMinimumWindow)
  // A packet can be sent to speed up loss recovery.
  MaybeSendOnePacket()
]]></sourcecode>
      </section>
      <section anchor="process-ecn-information" numbered="true" toc="default">
        <name>Process ECN Information</name>
        <t>This is invoked when an ACK frame with an ECN section is received from the peer.</t>
        <sourcecode type="pseudocode"><![CDATA[
ProcessECN(ack, pn_space):
  // If the ECN-CE counter reported by the peer has increased,
  // this could be a new congestion event.
  if (ack.ce_counter > ecn_ce_counters[pn_space]):
    ecn_ce_counters[pn_space] = ack.ce_counter
    sent_time = sent_packets[ack.largest_acked].time_sent
    OnCongestionEvent(sent_time)
]]></sourcecode>
      </section>
      <section anchor="on-packets-lost" numbered="true" toc="default">
        <name>On Packets Lost</name>
        <t>This is invoked when DetectAndRemoveLostPackets deems packets lost.</t>
        <sourcecode type="pseudocode"><![CDATA[
OnPacketsLost(lost_packets):
  sent_time_of_last_loss = 0
  // Remove lost packets from bytes_in_flight.
  for lost_packet in lost_packets:
    if lost_packet.in_flight:
      bytes_in_flight -= lost_packet.sent_bytes
      sent_time_of_last_loss =
        max(sent_time_of_last_loss, lost_packet.time_sent)
  // Congestion event if in-flight packets were lost
  if (sent_time_of_last_loss != 0):
    OnCongestionEvent(sent_time_of_last_loss)

  // Reset the congestion window if the loss of these
  // packets indicates persistent congestion.
  // Only consider packets sent after getting an RTT sample.
  if (first_rtt_sample == 0):
    return
  pc_lost = []
  for lost in lost_packets:
    if lost.time_sent > first_rtt_sample:
      pc_lost.insert(lost)
  if (InPersistentCongestion(pc_lost)):
    congestion_window = kMinimumWindow
    congestion_recovery_start_time = 0
]]></sourcecode>
      </section>
      <section anchor="removing-discarded-packets-from-bytes-in-flight" numbered="true" toc="default">
        <name>Removing Discarded Packets from Bytes in Flight</name>
        <t>When Initial or Handshake keys are discarded, packets sent in that space no
longer count toward bytes in flight.</t>
        <t>Pseudocode for RemoveFromBytesInFlight follows:</t>
        <sourcecode type="pseudocode"><![CDATA[
RemoveFromBytesInFlight(discarded_packets):
  // Remove any unacknowledged packets from flight.
  foreach packet in discarded_packets:
    if packet.in_flight
      bytes_in_flight -= size
]]></sourcecode>
      </section>
    </section>
    <section numbered="false" anchor="contributors" toc="default">
      <name>Contributors</name>
      <t>The IETF QUIC Working Group received an enormous amount of support from many
people. The following people provided substantive contributions to this
document:</t>
      <ul spacing="compact">
        <li>
          <t><contact fullname="Alessandro Ghedini"/></t>
        </li>
        <li>
          <t><contact fullname="Benjamin Saunders"/></t>
        </li>
        <li>
          <t><contact fullname="Gorry Fairhurst"/></t>
        </li>
        <li>
          <t><contact asciiFullname="Kazu Yamamoto" fullname=""/></t>
        </li>
        <li>
          <t><contact asciiFullname="Kazuho Oku" fullname=" "/></t>
        </li>
        <li>
          <t><contact fullname="Lars Eggert"/></t>
        </li>
        <li>
          <t><contact fullname="Magnus Westerlund"/></t>
        </li>
        <li>
          <t><contact fullname="Marten Seemann"/></t>
        </li>
        <li>
          <t><contact fullname="Martin Duke"/></t>
        </li>
        <li>
          <t><contact fullname="Martin Thomson"/></t>
        </li>
        <li>
          <t><contact fullname="Mirja Khlewind"/></t>
        </li>
        <li>
          <t><contact fullname="Nick Banks"/></t>
        </li>
        <li>
          <t><contact fullname="Praveen Balasubramanian"/></t>
        </li>
      </ul>
    </section>
  </back>
</rfc>
