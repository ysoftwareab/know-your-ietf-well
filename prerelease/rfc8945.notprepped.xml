<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" submissionType="IETF"
     category="std" consensus="true" docName="draft-ietf-dnsop-rfc2845bis-09"
     number="8945" ipr="pre5378Trust200902" obsoletes="2845, 4635" updates=""
     xml:lang="en" tocInclude="true" tocDepth="3" symRefs="true"
     sortRefs="true" version="3"> 


  <!-- xml2rfc v2v3 conversion 2.46.0 -->
  <front>
    <title abbrev="DNS TSIG">Secret Key Transaction Authentication for DNS (TSIG)</title>
    <seriesInfo name="RFC" value="8945"/>
    <seriesInfo name="STD" value="93"/>
    <author fullname="Francis Dupont" initials="F" surname="Dupont">
      <organization abbrev="ISC">Internet Systems Consortium, Inc.</organization>
      <address>
        <postal>
          <street>PO Box 360</street>
          <city>Newmarket</city>
          <region>NH</region>
          <code>03857</code>
          <country>United States of America</country>
        </postal>
        <email>Francis.Dupont@fdupont.fr</email>
      </address>
    </author>

    <author fullname="Stephen Morris" initials="S" surname="Morris">
      <organization abbrev="Unaffiliated">Unaffiliated</organization>
      <address>
        <postal>
          <country>United Kingdom</country>
</postal>
        <email>sa.morris8@gmail.com</email>
      </address>
</author>
    
    <author fullname="Paul Vixie" initials="P" surname="Vixie">
      <organization abbrev="Farsight">Farsight Security Inc</organization>
      <address>
        <postal>
          <street>177 Bovet Road</street>
	  <extaddr>Suite 180</extaddr>
          <city>San Mateo</city>
          <region>CA</region>
          <code>94402</code>
          <country>United States of America</country>
        </postal>
        <email>paul@redbarn.org</email>
      </address>
    </author>
    <author fullname="Donald E. Eastlake 3rd" initials="D" surname="Eastlake 3rd">
      <organization abbrev="Futurewei">Futurewei Technologies</organization>
      <address>
        <postal>
          <street>2386 Panoramic Circle</street>
          <city>Apopka</city>
          <region>FL</region>
          <code>32703</code>
          <country>United States of America</country>
        </postal>
        <email>d3e3e3@gmail.com</email>
      </address>
    </author>
    <author fullname="Olafur Gudmundsson" initials="O" surname="Gudmundsson">
      <organization abbrev="Cloudflare">Cloudflare</organization>
      <address>
        <postal>
          <street/>
          <city></city>
          <region></region>
          <code></code>
          <country>United States of America</country>
        </postal>
        <email>olafur+ietf@cloudflare.com</email>
      </address>
    </author>
    <author fullname="Brian Wellington" initials="B" surname="Wellington">
      <organization abbrev="Akamai">Akamai</organization>
      <address>
        <postal>
          <street/>
          <country>United States of America</country>
        </postal>
        <email>bwelling@akamai.com</email>
      </address>
    </author>
    <date year="2020" month="November" />
    <area>Operations and Management Area</area>
    <workgroup>Internet Engineering Task Force</workgroup>



    <abstract>
      <t>This document describes a protocol for transaction-level authentication
      using shared secrets and one-way hashing.  It can be used to authenticate
      dynamic updates to a DNS zone as coming from an approved client or to
      authenticate responses as coming from an approved name server.</t> 
      <t>No recommendation is made here for distributing the shared secrets;
      it is expected that a network administrator will statically configure
      name servers and clients using some out-of-band mechanism.</t>
      <t>This document obsoletes RFCs 2845 and 4635.</t>
    </abstract>
  </front>
  <middle>
    <section numbered="true" toc="default">
      <name>Introduction</name>
      <section numbered="true" toc="default">
        <name>Background</name>
        <t>The Domain Name System (DNS) (<xref target="RFC1034"
	format="default"/> <xref target="RFC1035" format="default"/>) is a
	replicated hierarchical distributed 
        database system that provides information fundamental to Internet
        operations, such as name-to-address translation and mail-handling
	information.</t> 
        <t>This document specifies use of a message authentication code
        (MAC), generated using certain keyed hash functions, to
        provide an efficient means of point-to-point authentication and
        integrity checking for DNS transactions. Such transactions include
        DNS update requests and responses for which this can provide a lightweight
        alternative to the secure DNS dynamic update protocol described by
	<xref target="RFC3007" format="default"/>.</t> 
        <t>A further use of this mechanism is to protect zone transfers.
        In this case, the data covered would be the whole zone transfer
        including any glue records sent.  The protocol described by DNSSEC
        (<xref target="RFC4033" format="default"/>, <xref target="RFC4034" format="default"/>,
        <xref target="RFC4035" format="default"/>) does not protect glue records and unsigned
        records.</t>
        <t>The authentication mechanism proposed here provides a
        simple and efficient authentication between clients and servers,
        by using shared secret keys to establish a trust relationship between
        two entities.  Such keys must be protected in a manner similar to
        private keys, lest a third party masquerade as one of the intended
        parties (by forging the MAC).  The proposal is unsuitable for general
        server-to-server authentication and for servers that speak with many
        other servers, since key management would become unwieldy with the
        number of shared keys going up quadratically. But it is suitable for
        many resolvers on hosts that only talk to a few recursive servers.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Protocol Overview</name>
        <t>Secret Key Transaction Authentication makes use of signatures
         on messages sent between the parties involved (e.g., resolver and
         server).  These are known as "transaction signatures", or TSIG.
         For historical reasons, in this document, they are referred to as
         message authentication codes (MACs).</t>
        <t>Use of TSIG presumes prior agreement between the
         two parties involved (e.g., resolver and server) as to any
         algorithm and key to be used.  The way that this agreement
         is reached is outside the scope of the document.</t>
        <t>A DNS message exchange involves the sending of a query and the
         receipt of one of more DNS messages in response.  For
         the query, the MAC is calculated based on the hash of the contents
         and the agreed TSIG key.  The MAC for the response is similar but
         also includes the MAC of the query as part of the calculation.
         Where a response comprises multiple packets, the calculation of
         the MAC associated with the second and subsequent packets includes in
         its inputs the MAC for the preceding packet.
         In this way, it is possible to detect any interruption in the
         packet sequence, although not its premature termination.</t>
        <t>The MAC is contained in a TSIG resource record included
         in the additional section of the DNS message.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Document History</name>
        <t>TSIG was originally specified by <xref target="RFC2845" format="default"/>.
         In 2017, two name server implementations strictly following that document (and
         the related  <xref target="RFC4635" format="default"/>) were discovered to have
         security problems related to this feature (<xref
	 target="CVE-2017-3142" format="default"/>, 
         <xref target="CVE-2017-3143" format="default"/>, <xref
	 target="CVE-2017-11104" format="default"/>).  The implementations 
         were fixed, but to avoid similar problems in the future, the
         two documents were updated and merged, producing this revised
         specification for TSIG.</t>
        <t>While TSIG implemented according to this RFC provides for enhanced
         security, there are no changes in interoperability. TSIG on the wire
         is still the same mechanism described in <xref target="RFC2845"
	 format="default"/>; only the checking semantics have been
	 changed. 

	 See <xref target="issuesfixed" format="default"/> for
	further details.</t> 
      </section>
    </section>
    <section anchor="keywords" numbered="true" toc="default">
      <name>Key Words</name>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
    "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL 
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
    "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>", 
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are
    to be interpreted as 
    described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
    when, and only when, they appear in all capitals, as shown here.
        </t>
    </section>
    <section anchor="numbers" numbered="true" toc="default">
      <name>Assigned Numbers</name>
      <t>This document defines the following Resource Record (RR) type and
      associated value:</t> 
      <ul empty="true">
        <li>TSIG (250)</li>
      </ul>
      <t>In addition, the document also defines the following DNS RCODEs
      and associated names:</t>
      <ul empty="true" spacing="compact">
	<li>16 (BADSIG)</li>
        <li>17 (BADKEY)</li>
        <li>18 (BADTIME)</li>
        <li>22 (BADTRUNC)</li>
      </ul>
      <t>(See <xref target="RFC6895" sectionFormat="of" section="2.3"/>
      concerning the assignment of the value 16 to BADSIG.)</t>
      <t>These RCODES may appear within the "Error" field of a TSIG RR.</t>
    </section>
    <section numbered="true" toc="default">
      <name>TSIG RR Format</name>
      <section numbered="true" toc="default">
        <name>TSIG RR Type</name>
        <t>To provide secret key authentication, we use an RR
        type whose mnemonic is TSIG and whose type code is 250.
        TSIG is a meta-RR and <bcp14>MUST NOT</bcp14> be cached.  TSIG RRs are
        used for authentication between DNS entities that have
        established a shared secret key.  TSIG RRs are dynamically
        computed to cover a particular DNS transaction and are not
        DNS RRs in the usual sense.</t>
        <t>As the TSIG RRs are related to one DNS request/response,
        there is no value in storing or retransmitting them; thus, the
        TSIG RR is discarded once it has been used to authenticate a DNS
        message.</t>
      </section>
      <section anchor="format" numbered="true" toc="default">
        <name>TSIG Record Format</name>
        <t>The fields of the TSIG RR are described below.  All multi-octet integers in the record are sent in network byte
        order (see <xref target="RFC1035" sectionFormat="of" section="2.3.2"/>).</t>
        <dl newline="false" spacing="normal">
          <dt>NAME:</dt>
          <dd><t>The name of the key used, in domain
          name syntax.  The name should reflect the names of the
          hosts and uniquely identify the key among a set of keys
          these two hosts may share at any given time.  For example,
          if hosts
          A.site.example and B.example.net share a key, possibilities
          for the key name include &lt;id&gt;.A.site.example,
          &lt;id&gt;.B.example.net, and
          &lt;id&gt;.A.site.example.B.example.net.  It should be
          possible for more than one key to be in simultaneous use
          among a set of interacting hosts. This allows for periodic
          key rotation as per best operational practices, as well as
          algorithm agility as indicated by <xref target="RFC7696" format="default"/>.</t>
          <t>The name may be used as a local index
          to the key involved, but it is recommended that it be
          globally unique.  Where a key is just shared between two
          hosts, its name actually need only be meaningful to
          them, but it is recommended that the key name be mnemonic
          and incorporate the names of participating agents or
          resources as suggested above.</t></dd>
          <dt>TYPE:</dt>
          <dd>This <bcp14>MUST</bcp14> be TSIG (250: Transaction SIGnature).</dd>
          <dt>CLASS:</dt>
          <dd>This <bcp14>MUST</bcp14> be ANY.</dd>
          <dt>TTL:</dt>
          <dd>This <bcp14>MUST</bcp14> be 0.</dd>
          <dt>RDLENGTH:</dt>
          <dd>(variable)</dd>
          <dt>RDATA:</dt>
          <dd>The RDATA for a TSIG RR consists of a
          number of fields, described below:</dd>
        </dl>
        <artwork name="" type="" align="left" alt=""><![CDATA[
                         1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    /                         Algorithm Name                        /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    |          Time Signed          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                               |            Fudge              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          MAC Size             |                               /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+             MAC               /
    /                                                               /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          Original ID          |            Error              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |          Other Len            |                               /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+           Other Data          /
    /                                                               /
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
]]></artwork>
        <t>The contents of the RDATA fields are:</t>
        <dl newline="true" spacing="normal">
          <dt>Algorithm Name:</dt>
          <dd>an octet sequence identifying the TSIG algorithm in the
	  domain name syntax. (Allowed names are listed in <xref
	  target="allowed-algorithms" format="default"/>.) The name is stored
	  in the DNS name wire format as described in <xref target="RFC1034"
	  format="default"/>. As per <xref target="RFC3597"
	  format="default"/>, this name <bcp14>MUST NOT</bcp14> be
	  compressed.</dd> 
	  <dt>Time Signed:</dt>
          <dd>an unsigned 48-bit integer containing the time the message was
	  signed as seconds since 00:00 on 1970-01-01 UTC, ignoring leap
	  seconds.</dd> 
          <dt>Fudge:</dt>
	  <dd>an unsigned 16-bit integer specifying the allowed time
	  difference in seconds permitted in the Time Signed field.</dd> 
          <dt>MAC Size:</dt>
	  <dd>an unsigned 16-bit integer giving the length of the MAC field in
	  octets.  Truncation is indicated by a MAC Size less than the size of
	  the keyed hash produced by the algorithm specified by the Algorithm
	  Name.</dd> 
          <dt>MAC:</dt>
	  <dd>a sequence of octets whose contents are defined by the TSIG
	  algorithm used, possibly truncated as specified by the MAC Size. The
	  length of this field is given by the MAC Size. Calculation of the
	  MAC is detailed in <xref target="mac_computation"
	  format="default"/>.</dd>  
          <dt>Original ID:</dt>
	  <dd>an unsigned 16-bit integer holding the message ID of the
	  original request message. For a TSIG RR on a request, it is set
	  equal to the DNS message ID. In a TSIG attached to a response -- or
	  in cases such as the forwarding of a dynamic update request -- the
	  field contains the ID of the original DNS request.</dd> 
          <dt>Error:</dt>
	  <dd>in responses, an unsigned 16-bit integer containing the extended
	  RCODE covering TSIG processing.  In requests, this
	  <bcp14>MUST</bcp14> be zero.</dd> 
          <dt>Other Len:</dt>
	  <dd>an unsigned 16-bit integer specifying the length of the Other
	  Data field in octets.</dd> 
          <dt>Other Data:</dt>
	  <dd>additional data relevant to the TSIG record. In responses, this
	  will be empty (i.e., Other Len will be zero) unless the content of
	  the Error field is BADTIME, in which case it will be a 48-bit
	  unsigned integer containing the server's current time as the number
	  of seconds since 00:00 on 1970-01-01 UTC, ignoring leap seconds (see
	  <xref target="time_check" format="default"/>). This document assigns
	  no meaning to its contents in requests.</dd> 
        </dl>
      </section>
      <section anchor="mac_computation" numbered="true" toc="default">
        <name>MAC Computation</name>
        <t>When generating or verifying the contents of a TSIG record,
        the data listed in the rest of this section are passed,
        in the order listed below, as input to MAC computation.  The
        data are passed in network byte order or wire format,
        as appropriate and are fed into the hashing function
        as a continuous octet sequence with no interfield separator or
        padding.</t>
        <section numbered="true" toc="default">
          <name>Request MAC</name>
          <t>Only included in the computation of a MAC for a response message
          (or the first message in a multi-message response),
          the validated request MAC <bcp14>MUST</bcp14> be included in the MAC
          computation.  If the request MAC failed to validate, an unsigned
          error message <bcp14>MUST</bcp14> be returned instead (<xref
	  target="on_error" format="default"/>).</t> 
          <t>The request's MAC, comprising the following fields, is digested in
          wire format:</t>
          <table anchor="mac-field" align="center">
	    <name>Request's MAC</name>
            <thead>
              <tr>
                <th align="left">Field</th>
                <th align="left">Type</th>
                <th align="left">Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">MAC Size</td>
                <td align="left">Unsigned 16-bit integer</td>
                <td align="left">in network byte order</td>
              </tr>
              <tr>
                <td align="left">MAC Data</td>
                <td align="left">octet sequence</td>
                <td align="left">exactly as transmitted</td>
              </tr>
            </tbody>
          </table>
          <t>Special considerations apply to the TSIG calculation for the
	  second and subsequent messages in a response that consists of multiple
	  DNS messages (e.g., a zone transfer). 
	 
	  These are described in <xref
	  target="tcp" format="default"/>.</t> 
        </section>
        <section numbered="true" toc="default">
          <name>DNS Message</name>
          <t>In the MAC computation, the whole/complete DNS message in
	  wire format is used.</t>

	  
          <t>When creating an outgoing message, the TSIG is based on
	  the message content before
the TSIG
   RR has been added to the additional section and before the
   DNS Message Header's ARCOUNT has been incremented to include
   the TSIG RR.</t>

	  
          <t>When verifying an incoming message, the TSIG is checked against
   the message after the TSIG RR has been removed, the ARCOUNT 
   decremented, and the message ID replaced by the original message
   ID from the TSIG if those IDs differ.  (This could happen, for
   example, when forwarding a dynamic update request.)</t>
        </section>
        <section numbered="true" toc="default">
          <name>TSIG Variables</name>
          <t>Also included in the digest is certain information present
          in the TSIG RR.  Adding this data provides further protection against an
          attempt to interfere with the message.</t>
          <table anchor="tisg-field-names" align="center">
	    <name>TSIG Variables</name>
            <thead>
              <tr>
                <th align="left">Source</th>
                <th align="left">Field Name</th>
                <th align="left">Notes</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">TSIG RR</td>
                <td align="left">NAME</td>
                <td align="left">Key name, in canonical wire format</td>
              </tr>
              <tr>
                <td align="left">TSIG RR</td>
                <td align="left">CLASS</td>
                <td align="left"><bcp14>MUST</bcp14> be ANY</td>
              </tr>
              <tr>
                <td align="left">TSIG RR</td>
                <td align="left">TTL</td>
                <td align="left"><bcp14>MUST</bcp14> be 0</td>
              </tr>
              <tr>
                <td align="left">TSIG RDATA</td>
                <td align="left">Algorithm Name</td>
                <td align="left">in canonical wire format</td>
              </tr>
              <tr>
                <td align="left">TSIG RDATA</td>
                <td align="left">Time Signed</td>
                <td align="left">in network byte order</td>
              </tr>
              <tr>
                <td align="left">TSIG RDATA</td>
                <td align="left">Fudge</td>
                <td align="left">in network byte order</td>
              </tr>
              <tr>
                <td align="left">TSIG RDATA</td>
                <td align="left">Error</td>
                <td align="left">in network byte order</td>
              </tr>
              <tr>
                <td align="left">TSIG RDATA</td>
                <td align="left">Other Len</td>
                <td align="left">in network byte order</td>
              </tr>
              <tr>
                <td align="left">TSIG RDATA</td>
                <td align="left">Other Data</td>
                <td align="left">exactly as transmitted</td>
              </tr>
            </tbody>
          </table>
          <t>The RR RDLENGTH and RDATA MAC Size are not included in the
          input to MAC computation, since they are not guaranteed to be
          knowable before the MAC is generated.</t>
          <t>The Original ID field is not included in this section,
          as it has already been substituted for the message ID in
          the DNS header and hashed.</t>
          <t>For each label type, there must be a defined "Canonical
          wire format" that specifies how to express a label in an
          unambiguous way.  For label type 00, this is defined in <xref
	  target="RFC4034" sectionFormat="of" section="6.2"/>.  The use of
	  label types other than 00 is not defined for this specification.</t>
          <section numbered="true" toc="default">
            <name>Time Values Used in TSIG Calculations</name>
            <t>The data digested includes the two timer values in the
            TSIG header in order to defend against replay attacks.  If
            this were not done, an attacker could replay old messages
            but update the Time Signed and Fudge fields to make the
            message look new.  The two fields are collectively named "TSIG Timers", and
            for the purpose of MAC calculation, they are hashed in
            their wire format, in the following order: first
            Time Signed, then Fudge.</t>
          </section>
        </section>
      </section>
    </section>
    <section anchor="details" numbered="true" toc="default">
      <name>Protocol Details</name>
      <section numbered="true" toc="default">
        <name>Generation of TSIG on Requests</name>
        <t>Once the outgoing record has been constructed, the client performs
	the keyed hash (Hashed Message Authentication Code (HMAC))
	computation, appends a TSIG record with the 
	calculated MAC to the additional section (incrementing the
	ARCOUNT to reflect the additional RR), and transmits the request to
	the server.  This TSIG record <bcp14>MUST</bcp14> be the only TSIG RR
	in the message and <bcp14>MUST</bcp14> be the last record in the
	additional data section. The client <bcp14>MUST</bcp14> store the MAC
	and the key name from the request while awaiting an answer.</t> 
        <t>The digest components for a request are:</t>
        <ul empty="true" spacing="compact">
          <li>DNS Message (request)</li>
          <li>TSIG Variables (request)</li>
        </ul>
      </section>
      <section anchor="request_processing" numbered="true" toc="default">
        <name>Server Processing of Request</name>
        <t>If an incoming message contains a TSIG record, it <bcp14>MUST</bcp14>
        be the last record in the additional section.  Multiple
        TSIG records are not allowed.  If multiple TSIG records are detected
        or a TSIG record is present
        in any other position, the DNS message is dropped and a response
        with RCODE 1 (FORMERR) <bcp14>MUST</bcp14> be returned.  Upon receipt of
        a message with exactly one correctly placed TSIG RR, a copy of the
        TSIG RR is stored and the TSIG RR is removed from the DNS message
        and decremented out of the DNS message header's ARCOUNT.</t>
        <t>If the TSIG RR cannot be interpreted, the server <bcp14>MUST</bcp14>
        regard the message as corrupt and return a FORMERR to the server.
        Otherwise, the server is <bcp14>REQUIRED</bcp14> to return a TSIG RR in
        the response.</t>
        <t>To validate the received TSIG RR, the server <bcp14>MUST</bcp14> perform the
        following checks in the following order:</t>
        <ol type="1" spacing="normal">
           <li>Check key</li>
	   <li>Check MAC</li>
           <li>Check time values</li>
           <li>Check truncation policy</li>
        </ol>
        <section numbered="true" toc="default">
          <name>Key Check and Error Handling</name>
          <t>If a non-forwarding server does not recognize the key or
	  algorithm used by the client (or recognizes the algorithm but does
	  not implement it), the server <bcp14>MUST</bcp14> generate an error
	  response with RCODE 9 (NOTAUTH) and TSIG ERROR 17 (BADKEY). This
	  response <bcp14>MUST</bcp14> be unsigned as specified in <xref
	  target="on_error" format="default"/>. The server
	  <bcp14>SHOULD</bcp14> log the error. (Special considerations apply
	  to forwarding servers; see <xref target="forwarding"
	  format="default"/>.)</t> 
        </section>
        <section numbered="true" toc="default">
          <name>MAC Check and Error Handling</name>
          <t>Using the information in the TSIG, the server <bcp14>MUST</bcp14> verify
          the MAC by doing its own calculation and comparing the result with
          the MAC received. If the MAC fails to
          verify, the server <bcp14>MUST</bcp14> generate an
          error response as specified in <xref target="on_error" format="default"/> with
          RCODE 9 (NOTAUTH) and TSIG ERROR 16 (BADSIG).  This response
          <bcp14>MUST</bcp14> be unsigned, as specified in <xref
	  target="on_error" format="default"/>. 
          The server <bcp14>SHOULD</bcp14> log the error.</t>
          <section anchor="trunc" numbered="true" toc="default">
            <name>MAC Truncation</name>
            <t>When space is at a premium and the strength of the full
          length of a MAC is not needed, it is reasonable to truncate
          the keyed hash and use the truncated value for
          authentication.  HMAC SHA-1 truncated to 96 bits is an option
          available in several IETF protocols, including IPsec and TLS.
          However, while this option is kept for backwards compatibility,
          it may not provide a security level appropriate for all cases
          in the modern environment. In these cases, it is preferable to
          use a hashing algorithm such as SHA-256-128, SHA-384-192, or
          SHA-512-256 <xref target="RFC4868" format="default"/>. </t>
            <t>Processing of a truncated MAC follows these rules:</t>
            <dl spacing="normal">
              <dt>If the MAC Size field is greater than the keyed hash output
		length:</dt><dd>This case <bcp14>MUST NOT</bcp14> be generated and, if
		received, <bcp14>MUST</bcp14> cause the DNS message to be
		dropped and RCODE 1 (FORMERR) to be returned.</dd>

		
              <dt>If the MAC Size field equals the keyed hash output length:</dt><dd>The
	      entire keyed hash output is present and used.</dd> 
              <dt>If the MAC Size field is less than the larger of 10 (octets) and
		half the length of the hash function in use:</dt><dd>With the
		exception of certain TSIG error messages described 
		in <xref target="on_error" format="default"/>, where it is
		permitted that the MAC Size be zero, this case <bcp14>MUST
		NOT</bcp14> be generated and, if received, <bcp14>MUST</bcp14>
		cause the DNS message to be dropped and RCODE 1 (FORMERR) to
		be returned.</dd>
              <dt>Otherwise:</dt><dd>This is sent when the signer has truncated the keyed hash
		output to an allowable length, as described in <xref
		target="RFC2104" format="default"/>, taking initial octets and
		discarding trailing octets.  TSIG truncation can only be to an
		integral number of octets.  On receipt of a DNS message with
		truncation thus indicated, the locally calculated MAC is
		similarly truncated, and only the truncated values are compared
		for authentication.  The request MAC used when calculating the
		TSIG MAC for a reply is the truncated request MAC.</dd>
            </dl>
          </section>
        </section>
        <section anchor="time_check" numbered="true" toc="default">
          <name>Time Check and Error Handling</name>
          <t>If the server time is outside the time interval specified
          by the request (which is the Time Signed value plus/minus
	  the Fudge value),
          the server <bcp14>MUST</bcp14> generate an error response with RCODE 9
          (NOTAUTH) and TSIG ERROR 18 (BADTIME).  The server <bcp14>SHOULD</bcp14>
          also cache the most recent Time Signed value in a message
          generated by a key and <bcp14>SHOULD</bcp14> return BADTIME if a message
          received later has an earlier Time Signed value.  A
          response indicating a BADTIME error <bcp14>MUST</bcp14> be signed by the
          same key as the request.  It <bcp14>MUST</bcp14> include the client's
          current time in the Time Signed field, the server's current
          time (an unsigned 48-bit integer) in the Other Data field, and 6 in the
          Other Len field.  This is done so that the client
          can verify a message with a BADTIME error without the
          verification failing due to another BADTIME error.  In
          addition, the Fudge field <bcp14>MUST</bcp14> be set to the fudge value
          received from the client.  The data signed is specified in
          <xref target="on_error" format="default"/>.  The server
	  <bcp14>SHOULD</bcp14> log the error.</t> 
          <t>Caching the most recent Time Signed value and rejecting
          requests with an earlier one could lead to valid messages
          being rejected if transit through the network led to UDP
          packets arriving in a different order to the one in which
          they were sent.  Implementations should be aware of
          this possibility and be prepared to deal with it, e.g., by
          retransmitting the rejected request with a new TSIG once
          outstanding requests have completed or the time given by their
          Time Signed value plus the Fudge value has passed.  If implementations
          do retry requests in these cases, a limit <bcp14>SHOULD</bcp14> be placed
          on the maximum number of retries.</t>
        </section>
        <section anchor="trunc_check" numbered="true" toc="default">
          <name>Truncation Check and Error Handling</name>
          <t>If a TSIG is received with truncation that is permitted
          per <xref target="trunc" format="default"/> but the MAC is too short
          for the local policy in force, an RCODE 9 (NOTAUTH) and TSIG
          ERROR 22 (BADTRUNC) <bcp14>MUST</bcp14> be returned. The server <bcp14>SHOULD</bcp14>
          log the error.</t>
        </section>
      </section>
      <section anchor="answers" numbered="true" toc="default">
        <name>Generation of TSIG on Answers</name>
        <t>When a server has generated a response to a signed request,
        it signs the response using the same algorithm and key.  The
        server <bcp14>MUST NOT</bcp14> generate a signed response to a request if
        either the key is invalid (e.g., key name or algorithm name are unknown)
        or the MAC fails validation; see <xref target="on_error" format="default"/> for
        details of responding in these cases.</t>
        <t>It also <bcp14>MUST NOT</bcp14> generate a signed
        response to an unsigned request, except in the case of a
        response to a client's unsigned TKEY request if the secret key
        is established on the server side after the server processed the
        client's request.  Signing responses to unsigned TKEY requests
        <bcp14>MUST</bcp14> be explicitly specified in the description of an individual
        secret key establishment algorithm <xref target="RFC3645" format="default"/>.</t>
        <t>The digest components used to generate a TSIG on a response are:</t>
        <ul empty="true" spacing="compact">
          <li>Request MAC</li>
          <li>DNS Message (response)</li>
          <li>TSIG Variables (response)</li>
        </ul>
        <t>(This calculation is different for the second and subsequent message
        in a multi-message answer; see below.)</t>
        <t>If addition of the TSIG record will cause the message to be truncated,
        the server <bcp14>MUST</bcp14> alter the response so that a TSIG can be included.
        This response contains only the question and a TSIG
        record, has the TC bit set, and has an RCODE of 0 (NOERROR).
	At this point, the
        client <bcp14>SHOULD</bcp14> retry the request using TCP
        (as per <xref target="RFC1035" sectionFormat="of" section="4.2.2"/>).</t>
        <section anchor="tcp" numbered="true" toc="default">
          <name>TSIG on TCP Connections</name>
          <t>A DNS TCP session, such as a zone transfer, can include multiple
        DNS messages. Using TSIG on such a connection can protect the
        connection from an attack and provide data integrity.  The TSIG
        <bcp14>MUST</bcp14> be included on all DNS messages in the response.  For backward
        compatibility, a client that receives DNS messages and verifies
        TSIG <bcp14>MUST</bcp14> accept up to 99 intermediary messages without a TSIG and
        <bcp14>MUST</bcp14> verify that both the first and last message contain a TSIG.</t>
          <t>The first message is processed as a standard answer (see <xref
	  target="answers" format="default"/>), but subsequent messages have
	  the following digest components:</t> 
          <ul empty="true" spacing="compact">
            <li>Prior MAC (running)</li>
            <li>DNS Messages (any unsigned messages since the last TSIG)</li>
            <li>TSIG Timers (current message)</li>
          </ul>
          <t>The "Prior MAC" is the MAC from the TSIG attached to the last
        message containing a TSIG.  "DNS Messages" comprises the
        concatenation (in message order) of all messages after the last
        message that included a TSIG and includes the current message.
        "TSIG Timers" comprises the Time Signed and Fudge fields (in
        that order) pertaining to the message for which the TSIG was created;
        this means that the successive TSIG records in the stream will have
        non-decreasing Time Signed values. Note that only the
        timers are included in the second and subsequent messages, not all
        the TSIG variables.</t>
          <t>This allows the client to rapidly detect when the session has
        been altered; at which point, it can close the connection and retry.
        If a client TSIG verification fails, the client <bcp14>MUST</bcp14> close the
        connection.  If the client does not receive TSIG records frequently
        enough (as specified above), it <bcp14>SHOULD</bcp14> assume the connection has
        been hijacked, and it <bcp14>SHOULD</bcp14> close the connection.  The
	client <bcp14>SHOULD</bcp14> 
        treat this the same way as they would any other interrupted transfer
        (although the exact behavior is not specified).</t>
        </section>
        <section anchor="on_error" numbered="true" toc="default">
          <name>Generation of TSIG on Error Returns</name>
          <t>When a server detects an error relating to the key or MAC in the
        incoming request, the
        server <bcp14>SHOULD</bcp14> send back an unsigned error message (MAC Size == 0
        and empty MAC). It <bcp14>MUST NOT</bcp14> send back a signed error message.</t>
          <t>If an error is detected relating to the TSIG
        validity period or the MAC is too short for the local policy,
        the server <bcp14>SHOULD</bcp14> send back a signed error message.
        The digest components are:</t>
          <ul empty="true" spacing="compact">
            <li>Request MAC (if the request MAC validated)</li>
            <li>DNS Message (response)</li>
            <li>TSIG Variables (response)</li>
          </ul>
          <t>The reason that the request MAC is not included in this MAC in
        some cases is to make it possible for the client to verify the
        error.  If the error is not a TSIG error, the response <bcp14>MUST</bcp14> be
        generated as specified in <xref target="answers" format="default"/>.</t>
        </section>
      </section>
      <section anchor="client_proc_answer" numbered="true" toc="default">
        <name>Client Processing of Answer</name>
        <t>When a client receives a response from a server and
	    expects to see a TSIG, it first checks if the TSIG RR is
	    present in the response.  If not, the response is treated as
	    having a format error and is discarded.</t>
        <t>If the TSIG RR is present, the client performs the same checks as
        described in <xref target="request_processing" format="default"/>.  If the TSIG RR is
        unsigned as specified in <xref target="on_error" format="default"/> or does not
        validate, the message <bcp14>MUST</bcp14> be discarded unless the RCODE is 9 (NOAUTH).
        In this case, the client <bcp14>SHOULD</bcp14> attempt to verify the response as if it
        were a TSIG error, as described in the following subsections.</t>
        <t>Regardless of the RCODE, a message containing a TSIG RR that is
        unsigned as specified in <xref target="on_error" format="default"/> or that fails
        verification <bcp14>SHOULD NOT</bcp14> be considered an acceptable response, as it
        may have been spoofed or manipulated. Instead, the
        client <bcp14>SHOULD</bcp14> log an error and continue to wait for a signed response
        until the request times out.</t>
        <section numbered="true" toc="default">
          <name>Key Error Handling</name>
          <t>If an RCODE on a response is 9 (NOTAUTH), but the response
          TSIG validates and the TSIG key is recognized by the client
          but is different from that used on the request, then this is a
          key-related error.  The client <bcp14>MAY</bcp14> retry the request using the key
          specified by the server.  However, this should never occur, as
          a server <bcp14>MUST NOT</bcp14> sign a response with a different key to that
          used to sign the request.</t>
        </section>
        <section numbered="true" toc="default">
          <name>MAC Error Handling</name>
          <t>If the response RCODE is 9 (NOTAUTH) and TSIG ERROR
          is 16 (BADSIG), this is a MAC-related error, and clients <bcp14>MAY</bcp14> retry
          the request with a new request ID, but it would be better
          to try a different shared key if one is available.  Clients
          <bcp14>SHOULD</bcp14> keep track of how many MAC errors are associated
          with each key.  Clients <bcp14>SHOULD</bcp14> log this event.</t>
        </section>
        <section numbered="true" toc="default">
          <name>Time Error Handling</name>
          <t>If the response RCODE is 9 (NOTAUTH) and the TSIG ERROR
          is 18 (BADTIME) or the current time does not fall in the
          range specified in the TSIG record, then this is a time-related
          error.  This is an indication that the client and server
          clocks are not synchronized.  In this case, the client
          <bcp14>SHOULD</bcp14> log the event.  DNS resolvers <bcp14>MUST
	  NOT</bcp14> adjust any clocks in the client based on BADTIME errors,
	  but the server's time in the Other Data field <bcp14>SHOULD</bcp14>
	  be logged.</t> 
        </section>
        <section anchor="trunc_err" numbered="true" toc="default">
          <name>Truncation Error Handling</name>
          <t>If the response RCODE is 9 (NOTAUTH) and the TSIG ERROR
          is 22 (BADTRUNC), then this is a truncation-related error. The client
	  <bcp14>MAY</bcp14> retry with a lesser truncation up to the full
	  HMAC output (no truncation), using the truncation used in the
	  response as a hint for what the server policy allowed (<xref
	  target="trunc_pol" format="default"/>). Clients
	  <bcp14>SHOULD</bcp14> log this event.</t> 
        </section>
      </section>
      <section anchor="forwarding" numbered="true" toc="default">
        <name>Special Considerations for Forwarding Servers</name>
        <t>A server acting as a forwarding server of a DNS message
        <bcp14>SHOULD</bcp14> check for the existence of a TSIG record.  If the name on
        the TSIG is not of a secret that the server shares with the
        originator, the server <bcp14>MUST</bcp14> forward the message unchanged
        including the TSIG.  If the name of the TSIG is of a key this
        server shares with the originator, it <bcp14>MUST</bcp14> process the TSIG.  If
        the TSIG passes all checks, the forwarding server <bcp14>MUST</bcp14>, if
        possible, include a TSIG of its own to the destination or the
        next forwarder. If no transaction security is available to the
        destination and the message is a query, and if the
        corresponding response has the AD flag (see <xref target="RFC4035"
	format="default"/>) set, the forwarder <bcp14>MUST</bcp14> clear the
	AD flag 
        before adding the TSIG to the response and returning the result
        to the system from which it received the query.</t>
      </section>
    </section>
    <section anchor="algorithm_id" numbered="true" toc="default">
      <name>Algorithms and Identifiers</name>
      <t>The only message digest algorithm specified in the first
      version of these specifications <xref target="RFC2845" format="default"/> was
      "HMAC-MD5" (see <xref target="RFC1321" format="default"/> and <xref
      target="RFC2104" format="default"/>). 
      Although a review of its security some years ago <xref target="RFC6151"
      format="default"/> concluded 
      that "it may not be urgent to remove HMAC-MD5 from the existing
      protocols", with the availability of more secure alternatives, the
      opportunity has been taken to make the implementation of this
      algorithm optional. </t>
      <t><xref target="RFC4635" format="default"/> added mandatory support in
      TSIG for SHA-1 <xref target="FIPS180-4" format="default"/> <xref
      target="RFC3174" format="default"/>. SHA-1 collisions have been
      demonstrated <xref target="SHA1SHAMBLES" format="default"/>, so the MD5
      security considerations described in <xref target="RFC6151"
      sectionFormat="of" section="2"/> apply to SHA-1 in a similar manner.
      Although support for hmac-sha1 in TSIG is still mandatory for
      compatibility reasons, existing uses <bcp14>SHOULD</bcp14> be replaced
      with hmac-sha256 or other SHA-2 digest algorithms (<xref
      target="FIPS180-4" format="default"/>, <xref target="RFC3874"
      format="default"/>, <xref target="RFC6234" format="default"/>).</t> 
      <t>Use of TSIG between two DNS agents is by mutual
      agreement.  That agreement can include the support of additional
      algorithms and criteria as to which algorithms and truncations are
      acceptable, subject to the restriction and guidelines in
      <xref target="trunc" format="default"/>.
      Key agreement can be by the TKEY mechanism <xref target="RFC2930" format="default"/>
      or some other mutually agreeable method.</t>
      <t>Implementations that support TSIG <bcp14>MUST</bcp14>
      also implement HMAC SHA1 and HMAC SHA256 and <bcp14>MAY</bcp14> implement
      gss-tsig and the other algorithms listed below.  SHA-1 truncated
      to 96 bits (12 octets) <bcp14>SHOULD</bcp14> be implemented.</t>


      
      <table anchor="allowed-algorithms" align="center">
	<name>Algorithms for Implementations Supporting TSIG</name>
        <thead>
          <tr>
            <th align="left">Algorithm Name</th>
            <th align="left">Implementation</th>
            <th align="left">Use</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">HMAC-MD5.SIG-ALG.REG.INT</td>
            <td align="left"><bcp14>MAY</bcp14></td>
            <td align="left"><bcp14>MUST NOT</bcp14></td>
          </tr>
          <tr>
            <td align="left">gss-tsig</td>
            <td align="left"><bcp14>MAY</bcp14></td>
            <td align="left"><bcp14>MAY</bcp14></td>
          </tr>
          <tr>
            <td align="left">hmac-sha1</td>
            <td align="left"><bcp14>MUST</bcp14></td>
            <td align="left"><bcp14>NOT RECOMMENDED</bcp14></td>
          </tr>
          <tr>
            <td align="left">hmac-sha224</td>
            <td align="left"><bcp14>MAY</bcp14></td>
            <td align="left"><bcp14>MAY</bcp14></td>
          </tr>
          <tr>
            <td align="left">hmac-sha256</td>
            <td align="left"><bcp14>MUST</bcp14></td>
            <td align="left"><bcp14>RECOMMENDED</bcp14></td>
          </tr>
          <tr>
            <td align="left">hmac-sha256-128</td>
            <td align="left"><bcp14>MAY</bcp14></td>
            <td align="left"><bcp14>MAY</bcp14></td>
          </tr>
          <tr>
            <td align="left">hmac-sha384</td>
            <td align="left"><bcp14>MAY</bcp14></td>
            <td align="left"><bcp14>MAY</bcp14></td>
          </tr>
          <tr>
            <td align="left">hmac-sha384-192</td>
            <td align="left"><bcp14>MAY</bcp14></td>
            <td align="left"><bcp14>MAY</bcp14></td>
          </tr>
          <tr>
            <td align="left">hmac-sha512</td>
            <td align="left"><bcp14>MAY</bcp14></td>
            <td align="left"><bcp14>MAY</bcp14></td>
          </tr>
          <tr>
            <td align="left">hmac-sha512-256</td>
            <td align="left"><bcp14>MAY</bcp14></td>
            <td align="left"><bcp14>MAY</bcp14></td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="trunc_pol" numbered="true" toc="default">
      <name>TSIG Truncation Policy</name>
      <t>As noted above, two DNS agents (e.g., resolver and server) must
      mutually agree to use TSIG.
      Implicit in such an "agreement" are criteria as to acceptable keys,
      algorithms, and (with the extensions in this document) truncations.
      Local policies <bcp14>MAY</bcp14> require the rejection of TSIGs, even though
      they use an algorithm for which implementation is mandatory.</t>
      <t>When a local policy permits acceptance of a TSIG with a particular
      algorithm and a particular non-zero amount of truncation, it <bcp14>SHOULD</bcp14>
      also permit the use of that algorithm with lesser truncation (a
      longer MAC) up to the full keyed hash output.</t>
      <t>Regardless of a lower acceptable truncated MAC length specified by
      local policy, a reply <bcp14>SHOULD</bcp14> be sent with a MAC at least as long as
      that in the corresponding request. Note, if the request specified a MAC
      length longer than the keyed hash output, it will be rejected by
      processing rules (<xref target="trunc" format="default"/>, case 1).</t>
      <t>Implementations permitting multiple acceptable algorithms and/or
      truncations <bcp14>SHOULD</bcp14> permit this list to be ordered by presumed
      strength and <bcp14>SHOULD</bcp14> allow different truncations for the same
      algorithm to be treated as separate entities in this list.  When so
      implemented, policies <bcp14>SHOULD</bcp14> accept a presumed stronger algorithm and
      truncation than the minimum strength required by the policy.</t>
    </section>
    <section numbered="true" toc="default">
      <name>Shared Secrets</name>
      <t>Secret keys are very sensitive information and all available
      steps should be taken to protect them on every host on which they
      are stored.  Generally, such hosts need to be physically protected.
      If they are multi-user machines, great care should be taken so that
      unprivileged users have no access to keying material.  Resolvers
      often run unprivileged, which means all users of a host would be
      able to see whatever configuration data are used by the resolver.</t>
      <t>A name server usually runs privileged, which means its
      configuration data need not be visible to all users of the host.
      For this reason, a host that implements transaction-based
      authentication should probably be configured with a "stub
      resolver" and a local caching and forwarding name server.  This
      presents a special problem for <xref target="RFC2136" format="default"/>, which
      otherwise depends on clients to communicate only with a zone's
      authoritative name servers.</t>
      <t>Use of strong, random shared secrets is essential to the
      security of TSIG.  See <xref target="RFC4086" format="default"/> for a discussion
      of this issue.  The secret <bcp14>SHOULD</bcp14> be at least as long as the keyed hash
      output <xref target="RFC2104" format="default"/>.</t>
    </section>
    <section numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>IANA maintains a registry of algorithm names to be used as
      "Algorithm Names", as defined in <xref target="format"
      format="default"/> <xref target="IANA-TSIG"/>. Algorithm
      names are text strings encoded using the syntax of a domain name.  There
      is no structure to the names, and algorithm names are compared
      as if they were DNS names, i.e., comparison is case
      insensitive. Previous specifications (<xref target="RFC2845"
      format="default"/> and <xref target="RFC4635" format="default"/>)
      defined values for the HMAC-MD5 and some HMAC-SHA 
      algorithms. IANA has also registered "gss-tsig" as an identifier for TSIG
      authentication where the cryptographic operations are delegated to the
      Generic Security Service (GSS) <xref target="RFC3645" format="default"/>.  This document
      adds to the allowed algorithms, and the registry has been updated with the
      names listed in <xref target="allowed-algorithms" format="default"/>.</t>
      <t>New algorithms are assigned using
      the IETF Review policy defined in <xref target="RFC8126" format="default"/>.
      The algorithm name
      HMAC-MD5.SIG-ALG.REG.INT looks like a fully qualified domain
      name for historical reasons;
      other algorithm names are simple, single-component names.</t>


      <t>IANA maintains a registry of RCODEs (error codes) (see <xref
      target="IANA-RCODEs"/>, including
      "TSIG Error values" to be used for "Error" values, as defined in
      <xref target="format" format="default"/>.  This document defines the RCODEs as
      described in <xref target="numbers"/>.  New error codes are assigned and
      specified as in <xref target="RFC6895" format="default"/>.</t>
    </section>
    <section numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>The approach specified here is computationally much less
      expensive than the signatures specified in DNSSEC.  As long as
      the shared secret key is not compromised, strong authentication
      is provided between two DNS systems, e.g., for the last hop from
      a local name server to the user resolver or between primary and
      secondary name servers.</t>
      <t>Recommendations for choosing and maintaining secret keys can be found
      in <xref target="RFC2104" format="default"/>.  If the client host has been compromised,
      the server should suspend the use of all secrets known to that client.
      If possible, secrets should be stored in an encrypted form.  Secrets should
      never be transmitted in the clear over any network.  This document does
      not address the issue on how to distribute secrets except that it
      mentions the possibilities of manual configuration and the use of TKEY
      <xref target="RFC2930" format="default"/>.  Secrets <bcp14>SHOULD
      NOT</bcp14> be shared by more than two 
      entities; any such additional sharing would allow any party knowing the
      key to impersonate any other such party to members of the group.</t>
      <t>This mechanism does not authenticate source data, only its
      transmission between two parties who share some secret.  The
      original source data can come from a compromised zone master or
      can be corrupted during transit from an authentic zone master to
      some "caching forwarder".  However, if the server is faithfully
      performing the full DNSSEC security checks, then
      only security-checked data will be available to the client.</t>
      <t>A Fudge value that is too large may leave the server open
      to replay attacks.  A Fudge value that is too small may cause
      failures if machines are not time synchronized or there are unexpected
      network delays.  The <bcp14>RECOMMENDED</bcp14> value in most situations is 300
      seconds.</t>
      <t>To prevent cross-algorithm attacks, there <bcp14>SHOULD</bcp14> only be one
      algorithm associated with any given key name.</t>
      <t>In several cases where errors are detected, an unsigned error
      message must be returned. This can allow for an attacker to spoof
      or manipulate these responses.  <xref target="client_proc_answer" format="default"/>
      recommends logging these as errors and continuing to wait for a
      signed response until the request times out.</t>
      <t>Although the strength of an algorithm determines its security,
      there have been some arguments that mild truncation can
      strengthen a MAC by reducing the information available to an
      attacker.  However, excessive truncation clearly weakens authentication by
      reducing the number of bits an attacker has to try to break the
      authentication by brute force <xref target="RFC2104" format="default"/>.</t>
      <t>Significant progress has been made recently in cryptanalysis of hash
      functions of the types used here.  While the results so far should not
      affect HMAC, the stronger SHA-256 algorithm is being made mandatory as a
      precaution.</t>
      <t>See also the Security Considerations section of <xref
      target="RFC2104" format="default"/> from which the limits on truncation
      in this RFC were taken.</t> 
      <section anchor="issuesfixed" numbered="true" toc="default">
        <name>Issue Fixed in This Document</name>
        <t>When signing a DNS reply message using TSIG, the MAC
         computation uses the request message's MAC as an input to
         cryptographically relate the reply to the request.  The
         original TSIG specification <xref target="RFC2845" format="default"/> required
         that the time values be checked before the request's MAC.  If
         the time was invalid, some implementations failed to carry out
         further checks and could use an invalid request MAC in the
         signed reply.</t>
        <t>This document makes it mandatory that the request MAC
         is considered to be invalid until it has been validated;
         until then, any answer must be unsigned.  For this reason, the
         request MAC is now checked before the time values.</t>
      </section>
      <section numbered="true" toc="default">
        <name>Why Not DNSSEC?</name>


          <t>DNS has been extended by DNSSEC
           (<xref target="RFC4033" format="default"/>, <xref target="RFC4034"
	   format="default"/>, and 
           <xref target="RFC4035" format="default"/>) to provide for data origin
           authentication, and public key distribution, all based on
           public key cryptography and public key based digital
           signatures.  To be practical, this form of security
           generally requires extensive local caching of keys and
           tracing of authentication through multiple keys and
           signatures to a pre-trusted locally configured key.</t>
          <t>One difficulty with the DNSSEC scheme is that common DNS
           implementations include simple "stub" resolvers which do not
           have caches.  Such resolvers typically rely on a caching DNS
           server on another host.  It is impractical for these stub
           resolvers to perform general DNSSEC authentication and they
           would naturally depend on their caching DNS server to
           perform such services for them.  To do so securely requires
           secure communication of queries and responses.  DNSSEC
           provides public key transaction signatures to support this,
           but such signatures are very expensive computationally to
           generate.  In general, these require the same complex public
           key logic that is impractical for stubs.</t>
 

          <t>A second area where use of straight DNSSEC public key based
	  mechanisms may be impractical is authenticating dynamic update <xref
	  target="RFC2136" format="default"/> requests. DNSSEC provides for
	  request signatures but with DNSSEC they, like transaction
	  signatures, require computationally expensive public key
	  cryptography and complex authentication logic. Secure Domain Name
	  System Dynamic Update (<xref target="RFC3007" format="default"/>)
	  describes how different keys are used in dynamically updated
	  zones.</t> 

      </section>
    </section>
  </middle>
  <back>



    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <reference anchor="FIPS180-4" target="">
          <front>
            <title>Secure Hash Standard (SHS)</title>
            <seriesInfo name="FIPS" value="PUB 180-4"/>
            <author>
              <organization>National Institute of Standards and
              Technology</organization>
            </author>
            <date month="August" year="2015"/>
          </front>
	  <seriesInfo name="DOI" value="10.6028/NIST.FIPS.180-4"/>
        </reference>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1034.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1035.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2845.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3597.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4635.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
      </references>
      <references>
        <name>Informative References</name>
   
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7696.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1321.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2104.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2136.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2930.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3007.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3174.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3645.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3874.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4033.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4034.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4035.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4086.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4868.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6151.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6234.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6895.xml"/>
        <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
        <reference anchor="CVE-2017-3142" target="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-3142">
          <front>
            <title>CVE-2017-3142: An error in TSIG authentication can permit unauthorized zone transfers</title>
            <author>
              <organization>Common Vulnerabilities and Exposures</organization>
            </author>
            <date month="June" year="2017"/>
          </front>
        </reference>
        <reference anchor="CVE-2017-3143" target="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-3143">
          <front>
            <title>CVE-2017-3143: An error in TSIG authentication can permit unauthorized dynamic updates</title>
            <author>
              <organization>Common Vulnerabilities and Exposures</organization>
            </author>
            <date month="June" year="2017"/>
          </front>
        </reference>
        <reference anchor="CVE-2017-11104" target="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-11104">
          <front>
            <title>CVE-2017-11104: Improper TSIG validity period check can allow TSIG forgery</title>
            <author>
              <organization>Common Vulnerabilities and Exposures</organization>
            </author>
            <date month="June" year="2017"/>
          </front>
        </reference>
        <reference anchor="SHA1SHAMBLES" target="https://eprint.iacr.org/2020/014.pdf">
          <front>
            <title>SHA-1 is a Shambles</title>
            <author surname="Leurent" initials="G" fullname="Gaetan Leurent"/>
            <author surname="Peyrin" initials="T" fullname="Thomas Peyrin"/>
            <date month="January" year="2020"/>
          </front>
        </reference>

<reference anchor="IANA-TSIG"
           target="https://www.iana.org/assignments/tsig-algorithm-names/">
  <front>
    <title>TSIG Algorithm Names</title>
    <author><organization>IANA</organization></author>
  </front>
</reference>

<reference anchor="IANA-RCODEs"
           target="https://www.iana.org/assignments/dns-parameters/">
  <front>
    <title>DNS RCODEs</title>
    <author><organization>IANA</organization></author>
  </front>
</reference>
	
     </references>
    </references>


    <section anchor="acks" numbered="false" toc="default">
      <name>Acknowledgements</name>
 
      <t>The security problem addressed by this document was reported by
      <contact fullname="Clment Berthaux"/> from Synacktiv.</t> 
      <t><contact fullname="Peter van Dijk"/>, <contact fullname="Benno
      Overeinder"/>, <contact fullname="Willem Toroop"/>, <contact
      fullname="Ondrej Sury"/>, <contact fullname="Mukund Sivaraman"/>, and
      <contact fullname="Ralph Dolmans"/> participated in the discussions that
      prompted this document.  <contact fullname="Mukund Sivaraman"/>,
      <contact fullname="Martin Hoffman"/>, and <contact fullname="Tony
      Finch"/> made extremely helpful suggestions concerning the structure and
      wording of the updated document.</t>

      <t>Stephen Morris would like to thank Internet Systems Consortium for its
  support of his participation in the creation of this document.</t>
    </section>
  </back>
</rfc>
