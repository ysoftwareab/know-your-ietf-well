<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" xml:lang="en" submissionType="IETF"
category="std" consensus="true" docName="draft-ietf-regext-rdap-sorting-and-paging-20" 
number="8977" updates="" obsoletes="" ipr="trust200902" tocInclude="true" tocDepth="4" 
sortRefs="true" symRefs="true" version="3">

  <front>
    <title abbrev="RDAP Sorting and Paging">Registration Data Access Protocol (RDAP) Query Parameters for Result Sorting and Paging</title>
    <seriesInfo name="RFC" value="8977"/>
    <author fullname="Mario Loffredo" initials="M." surname="Loffredo">
      <organization>IIT-CNR/Registro.it</organization>
      <address>
        <postal>
          <street>Via Moruzzi,1</street>
          <city>Pisa</city>
          <country>Italy</country>
          <code>56124</code>
        </postal>
        <email>mario.loffredo@iit.cnr.it</email>
        <uri>https://www.iit.cnr.it</uri>
      </address>
    </author>
    <author fullname="Maurizio Martinelli" initials="M." surname="Martinelli">
      <organization>IIT-CNR/Registro.it</organization>
      <address>
        <postal>
          <street>Via Moruzzi,1</street>
          <city>Pisa</city>
          <country>Italy</country>
          <code>56124</code>
        </postal>
        <email>maurizio.martinelli@iit.cnr.it</email>
        <uri>https://www.iit.cnr.it</uri>
      </address>
    </author>
    <author initials="S." surname="Hollenbeck" fullname="Scott Hollenbeck">
      <organization>Verisign Labs</organization>
      <address>
        <postal>
          <street>12061 Bluemont Way</street>
          <city>Reston</city>
          <region>VA</region>
          <code>20190</code>
          <country>United States of America</country>
        </postal>
        <email>shollenbeck@verisign.com</email>
        <uri>https://www.verisignlabs.com/</uri>
      </address>
    </author>
    <date year="2021" month="January" />
    <area>Applications and Real-Time</area>
    <workgroup>Registration Protocols Extensions</workgroup>
    <keyword>RDAP</keyword>
    <keyword>Sorting</keyword>
    <keyword>Paging</keyword>
    <abstract>
      <t>The Registration Data Access Protocol (RDAP) does not include core functionality for clients to provide sorting and paging parameters for control of large result sets.  This omission can lead to unpredictable server processing of queries and client processing of responses.  This unpredictability can be greatly reduced if clients can provide servers with their preferences for managing large responses.  This document describes RDAP query extensions that allow clients to specify their preferences for sorting and paging result sets.</t>
    </abstract>
  </front>
  <middle>
    <section>
      <name>Introduction</name>
      <t>The availability of functionality for result sorting and paging provides benefits to both clients and servers in the implementation of RESTful services <xref target="REST"/>.  These benefits include:</t>
      <ul>
        <li>reducing the server response bandwidth requirements</li>
        <li>improving server response time</li>
        <li>improving query precision and, consequently, obtaining more relevant results</li>
        <li>decreasing server query processing load</li>
        <li>reducing client response processing time</li>
      </ul>
      <t>Approaches to implementing features for result sorting and paging can be grouped into two main categories:</t>
      <ol type="1"><li>
          <t>Sorting and paging are implemented through the introduction of additional parameters in the query string (e.g., the Open Data Protocol (ODATA) <xref target="ODATA-PART1"/>).</t>

        </li>
        <li>Information related to the number of results and the specific portion of the result set to be returned, in addition to a set of ready-made links for the result set scrolling, are inserted in the HTTP header of the request/response <xref target="RFC7231"/>.</li>
      </ol>
      <t>However, there are some drawbacks associated with the use of the HTTP header.  First, the header properties cannot be set directly from a web browser.  Moreover, in an HTTP session, the information on the status (i.e., the session identifier) is usually inserted in the header or a cookie, while the information on the resource identification or the search type is included in the query string.  Finally, providing custom information through HTTP headers assumes the client has prior knowledge of the server implementation, which is widely considered a Representational State Transfer (REST) design anti-pattern.  As a result, this document describes a specification based on the use of query parameters.</t>
      <t>Currently, RDAP <xref target="RFC7482"/> defines two query types:</t>


<dl>

<dt>lookup:
</dt>
<dd>the server returns only one object
</dd>

<dt>search:
</dt>
<dd>the server returns a collection of objects
</dd>

</dl>


      <t>While the lookup query does not raise issues regarding response size management, the search query can potentially generate a large result set that is often truncated according to server limits.  Besides, it is not possible to obtain the total number of objects found that might be returned in a search query response <xref target="RFC7483"/>.  Lastly, there is no way to specify sort criteria to return the most relevant objects at the beginning of the result set.  Therefore, the client might traverse the whole result set to find the relevant objects or, due to truncation, might not find them at all.</t>
      <t>The specification described in this document extends RDAP query capabilities to enable result sorting and paging by adding new query parameters that can be applied to RDAP search path segments.  The service is implemented using the Hypertext Transfer Protocol (HTTP) <xref target="RFC7230"/> and the conventions described in <xref target="RFC7480"/>.</t>
      <t>The implementation of the new parameters is technically feasible, as operators for counting, sorting, and paging rows are currently supported by the major relational database management systems.</t>
      <section>
        <name>Conventions Used in This Document</name>



        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
    "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
    "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are
    to be interpreted as described in BCP&nbsp;14 <xref target="RFC2119"/>
    <xref target="RFC8174"/> when, and only when, they appear in all capitals,
    as shown here.
        </t>




      </section>
    </section>
    <section anchor="rdap-query-parameter-specification">
      <name>RDAP Query Parameter Specification</name>
      <t>The new query parameters are <bcp14>OPTIONAL</bcp14> extensions of path segments defined in <xref target="RFC7482"/>.  They are as follows:</t>



<dl>

<dt>"count":
</dt>
<dd>a boolean value that allows a client to request the return of the total number of objects found
</dd>

<dt>"sort":
</dt>
<dd>a string value that allows a client to request a specific sort order for the result set
</dd>

<dt>"cursor":
</dt>
<dd>a string value representing a pointer to a specific fixed-size portion of the result set
</dd>

</dl>

      <t>Augmented Backus-Naur Form (ABNF) <xref target="RFC5234"/> is used in the following sections to describe the formal syntax of these new parameters.</t>
      <section anchor="sorting_and_paging_metadata">
        <name>Sorting and Paging Metadata</name>





        <t>According to most advanced principles in REST design, collectively
        known as HATEOAS (Hypermedia as the Engine of Application State)
        <xref target="HATEOAS"/>, a client entering a REST application through
        an initial URI should use server-provided links to dynamically
        discover available actions and access the resources it needs.  In this
        way, the client is neither required to have prior knowledge of the
        service nor, consequently, to hard code the URIs of different
        resources.  This allows the server to make URI changes as the API
        evolves without breaking clients.  Definitively, a REST service should
        be as self-descriptive as possible.</t>

        <t>Therefore, servers implementing the query parameters described in this specification <bcp14>SHOULD</bcp14> provide additional information in their responses about both the available sorting criteria and possible pagination.  Such information is collected in two <bcp14>OPTIONAL</bcp14> response elements named "sorting_metadata" and "paging_metadata".</t>
        <t>The "sorting_metadata" element contains the following properties:</t>

<dl newline="true">

<dt>"currentSort": "String" (<bcp14>OPTIONAL</bcp14>)
</dt>
<dd>Either the value of the "sort" parameter as specified in the query string or
the sort applied by default, if any.
</dd>

<dt>"availableSorts": "AvailableSort[]" (<bcp14>OPTIONAL</bcp14>)
</dt>

<dd><t>An array of objects, with each element describing an available sort criterion. The AvailableSort object includes the following members:</t>

<dl newline="true">

<dt>"property": "String" (<bcp14>REQUIRED</bcp14>)
</dt>
<dd>The name that can be used by the client to request the sort criterion.
</dd>

<dt>"default": "Boolean" (<bcp14>REQUIRED</bcp14>)
</dt>
<dd>Indicator of whether the sort criterion is applied by default. An RDAP server <bcp14>MUST</bcp14> define only one default sorting property for each object class.
</dd>

<dt>"jsonPath": "String" (<bcp14>OPTIONAL</bcp14>)
</dt>
<dd>The JSONPath expression of the RDAP field corresponding to the property.
</dd>

<dt>"links": "Link[]" (<bcp14>OPTIONAL</bcp14>)
</dt>
<dd>An array of links as described in <xref target="RFC8288"/> containing the
query string that applies the sort criterion.
</dd>

</dl>

</dd>
  

</dl>

        <t>At least one of the "currentSort" and "availableSorts" properties
        <bcp14>MUST</bcp14> be present.</t>
        <t>The "paging_metadata" element contains the following fields:</t>


<dl newline="true">

<dt>"totalCount": "Numeric" (<bcp14>OPTIONAL</bcp14>)
</dt>
<dd>A numeric value representing the total number of objects found.  It
<bcp14>MUST</bcp14> be provided if and only if the query string contains the
"count" parameter.
</dd>

<dt>"pageSize": "Numeric" (<bcp14>OPTIONAL</bcp14>)
</dt>
<dd>A numeric value representing the number of objects that should have been
returned in the current page.  It <bcp14>MUST</bcp14> be provided if and only
if the total number of objects exceeds the page size.  This property is
redundant for RDAP clients because the page size can be derived from the
length of the search results array, but it can be helpful if the end user
interacts with the server through a web browser.
</dd>



<dt>"pageNumber": "Numeric" (<bcp14>OPTIONAL</bcp14>)
</dt>
<dd>A numeric value representing the number of the current page in the result
set.  It <bcp14>MUST</bcp14> be provided if and only if the total number of
objects found exceeds the page size.
</dd>

<dt>"links": "Link[]" (<bcp14>OPTIONAL</bcp14>)
</dt>
<dd>An array of links as described in <xref target="RFC8288"/> containing the
reference to the next page.  In this specification, only forward pagination is
described because it is all that is necessary to traverse the result set.
</dd>
</dl>

        <section anchor="rdap-conformance">
          <name>RDAP Conformance</name>
          <t>Servers returning the "paging_metadata" element in their response
          <bcp14>MUST</bcp14> include the string literal "paging" in the
          rdapConformance array.  Servers returning the "sorting_metadata"
          element <bcp14>MUST</bcp14> include the string literal
          "sorting".</t>
        </section>
      </section>
      <section anchor="count-parameter">
        <name>"count" Parameter</name>
        <t>Currently, RDAP does not allow a client to determine
        the total number of results in a query response when the result
        set is truncated.  This is inefficient because the user cannot
        determine if the result set is complete.</t>
        <t>The "count" parameter provides additional functionality that allows
        a client to request information from the server that specifies the
        total number of objects matching the search pattern.</t>
        <t>The following is an example of an RDAP query including the "count" parameter:</t>
        <t>https://example.com/rdap/domains?name=example*.com&amp;count=true
        </t>
        <t>The ABNF syntax is the following:</t>
<sourcecode type="abnf">
   count = "count=" ( trueValue / falseValue )
   trueValue = ("true" / "yes" / "1")
   falseValue = ("false" / "no" / "0")
</sourcecode>
        <t>A trueValue means that the server <bcp14>MUST</bcp14> provide the
        total number of objects in the "totalCount" field of the
        "paging_metadata" element (<xref
        target="count-in-response-example"/>).  A falseValue means that the
        server <bcp14>MUST NOT</bcp14> provide this number.</t>
        <figure anchor="count-in-response-example">
          <name>Example of RDAP Response with "paging_metadata" Element Containing the "totalCount" Field</name>
<sourcecode type="json">
{
  "rdapConformance": [
        "rdap_level_0",
        "paging"
  ],
  ...
  "paging_metadata": {
    "totalCount": 43
  },
  "domainSearchResults": [
    ...
  ]
}
</sourcecode>
        </figure>
      </section>
      <section anchor="sort-parameter">
        <name>"sort" Parameter</name>
        <t>RDAP does not provide any capability to specify the result set sort criteria.  A server could implement a default sorting scheme according to the object class, but this feature is not mandatory and might not meet user requirements.  Sorting can be addressed by the client, but this solution is rather inefficient.  Sorting features provided by the RDAP server could help avoid truncation of relevant results.</t>
        <t>The "sort" parameter allows the client to ask the server to sort the results according to the values of one or more properties and according to the sort direction of each property.  The ABNF syntax is the following:</t>
<sourcecode type="abnf">
   sort = "sort=" sortItem *( "," sortItem )
   sortItem = property-ref [":" ( "a" / "d" ) ]
   property-ref = ALPHA *( ALPHA / DIGIT / "_" )
</sourcecode>


        <t>"a" means that an ascending sort <bcp14>MUST</bcp14> be applied; "d" means that a descending sort <bcp14>MUST</bcp14> be applied.  If the sort direction is absent, an ascending sort <bcp14>MUST</bcp14> be applied.</t>
        <t>The following are examples of RDAP queries that include the "sort" parameter:</t>

<t>
https://example.com/rdap/domains?name=example*.com&amp;sort=name
</t> 
<t>
https://example.com/rdap/
domains?name=example*.com&amp;sort=registrationDate:d
</t>
<t>
https://example.com/rdap/
domains?name=example*.com&amp;sort=lockedDate,name
</t>
        <t>Except for sorting IP addresses and values denoting dates and times, servers <bcp14>MUST</bcp14> implement sorting according to the JSON value type of the RDAP field the sorting property refers to.  That is, JSON strings <bcp14>MUST</bcp14> be sorted lexicographically, and JSON numbers <bcp14>MUST</bcp14> be sorted numerically.  Values denoting dates and times <bcp14>MUST</bcp14> be sorted in chronological order.  If IP addresses are represented as JSON strings, they <bcp14>MUST</bcp14> be sorted based on their numeric conversion.</t>

        <t>The conversion of an IPv4 address to a number is possible since each dotted format IPv4 address is a representation of a number written in a 256-based manner; for example, 192.168.0.1 means 1*256^0 + 0*256^1 + 168*256^2 + 192*256^3 = 3232235521.  Similarly,  an IPv6 address can be converted into a number by applying the base 65536.  Therefore, the numerical representation of the IPv6 address 2001:0db8:85a3:0:0:8a2e:0370:7334 is 42540766452641154071740215577757643572.  Built-in functions and libraries for converting IP addresses into numbers are available in most known programming languages and relational database management systems.</t>
        <t>If the "sort" parameter presents an allowed sorting property, it <bcp14>MUST</bcp14> be provided in the "currentSort" field of the "sorting_metadata" element.</t>
        <section anchor="sorting_properties">
          <name>Sorting Properties Declaration</name>
          <t>In the "sort" parameter ABNF syntax, the element named "property-ref" represents a reference to a property of an RDAP object.  Such a reference could be expressed by using a JSONPath expression (named "jsonpath" in the following).</t>
          <t>JSONPath is a syntax, originally based on the XML XPath notation <xref target="W3C.CR-xpath-31-20170321"/>, which represents a path to select an element (or a set of elements) in a JSON document <xref target="RFC8259"/>.  For example, the jsonpath to select the value of the ASCII name inside an RDAP domain lookup response is "$.ldhName", where $ identifies the root of the document object model (DOM).  Another way to select a value inside a JSON document is the JSON Pointer <xref target="RFC6901"/>.</t>
          <t>While JSONPath and JSON Pointer are both commonly adopted
          notations to select any value inside JSON data, neither is
          particularly concise and easy to use
          (e.g., "$.domainSearchResults[*].events[?(@.eventAction='registration')].eventDate"
          is the jsonpath of the registration date in an RDAP domain search
          response).</t>
          <t>Therefore, this specification defines the "property-ref" element in terms of names identifying RDAP properties.  However, not all the RDAP properties are suitable to be used in sort criteria. These properties include:</t>
          <ul>
            <li>
              <t>properties providing service information (e.g., links, notices, and remarks)</t>
            </li>
            <li>
              <t>multivalued properties (e.g., status, roles, and variants)</t>
            </li>
            <li>properties representing relationships to other objects (e.g., entities)</li>
          </ul>
          <t>On the contrary, properties expressed as values of other
          properties (e.g., registration date) could be used in such a
          context.</t>
          <t>A list of properties an RDAP server <bcp14>MAY</bcp14> implement
          is defined.  The properties are divided into two groups:
          object-common properties and object-specific properties.</t>

          <ul>
            <li><t>Object-common properties. Object-common properties are derived from merging the "eventAction" and the "eventDate" properties. The following values of the "sort" parameter are defined:</t>

<ul>

<li>registrationDate
</li>

<li>reregistrationDate
</li>

<li>lastChangedDate
</li>

<li>expirationDate
</li>

<li>deletionDate
</li>

<li>reinstantiationDate
</li>

<li>transferDate
</li>

<li>lockedDate
</li>

<li>unlockedDate
</li>


</ul>

</li>

<li><t>Object-specific properties. Note that some of these properties are also defined as query path segments. These properties include:</t>
<ul>
<li>Domain: name
</li>

<li>Nameserver: name, ipv4, ipv6
</li>

<li>Entity: fn, handle, org, email, voice, country, cc, city
</li>

</ul>

            </li>
          </ul>

          <t>The correspondence between these sorting properties and the RDAP
          object classes is shown in <xref
          target="table_sorting_properties_definition"/>.  Some of the sorting
          properties defined for the RDAP entity class are related to jCard
          elements <xref target="RFC7095"/>, but because jCard is the JSON format
          for vCard, the corresponding definitions
          are included in the vCard specification <xref target="RFC6350"/>.</t>
          <t>An RDAP server <bcp14>MUST NOT</bcp14> use the defined sorting
          properties with a meaning other than that described in <xref
          target="table_sorting_properties_definition"/>.</t>
          <table anchor="table_sorting_properties_definition">
            <name>Definitions of Sorting Properties</name>
            <thead>
              <tr>
                <th align="left">Object class</th>
                <th align="left">Sorting property</th>
                <th align="left">RDAP property</th>
                <th align="left">RFC 7483</th>
                <th align="left">RFC 6350</th>
                <th align="left">RFC 8605</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">Searchable objects</td>
                <td align="left">Common properties</td>
                <td align="left">eventAction values suffixed by "Date"</td>
                <td align="left"><xref target="RFC7483" section="4.5" sectionFormat="bare"/></td>
                <td align="left"/>
                <td align="left"/>
              </tr>

              <tr>
                <td align="left">Domain</td>
                <td align="left">name</td>
                <td align="left">unicodeName/ ldhName</td>
                <td align="left"><xref target="RFC7483" section="5.3" sectionFormat="bare"/></td>
                <td align="left"/>
                <td align="left"/>
              </tr>

              <tr>
                <td align="left">Nameserver</td>
                <td align="left">name</td>
                <td align="left">unicodeName/ ldhName</td>
                <td align="left"><xref target="RFC7483" section="5.2" sectionFormat="bare"/></td>
                <td align="left"/>
                <td align="left"/>
              </tr>
              <tr>
                <td align="left"/>
                <td align="left">ipv4</td>
                <td align="left">v4 ipAddress</td>
                <td align="left"><xref target="RFC7483" section="5.2" sectionFormat="bare"/></td>
                <td align="left"/>
                <td align="left"/>
              </tr>
              <tr>
                <td align="left"/>
                <td align="left">ipv6</td>
                <td align="left">v6 ipAddress</td>
                <td align="left"><xref target="RFC7483" section="5.2" sectionFormat="bare"/></td>
                <td align="left"/>
                <td align="left"/>
              </tr>

              <tr>
                <td align="left">Entity</td>
                <td align="left">handle</td>
                <td align="left">handle</td>
                <td align="left"><xref target="RFC7483" section="5.1" sectionFormat="bare"/></td>
                <td align="left"/>
                <td align="left"/>
              </tr>
              <tr>
                <td align="left"/>
                <td align="left">fn</td>
                <td align="left">jCard fn</td>
                <td align="left"><xref target="RFC7483" section="5.1" sectionFormat="bare"/></td>
                <td align="left"><xref target="RFC6350" section="6.2.1" sectionFormat="bare"/></td>
                <td align="left"/>
              </tr>
              <tr>
                <td align="left"/>
                <td align="left">org</td>
                <td align="left">jCard org</td>
                <td align="left"><xref target="RFC7483" section="5.1" sectionFormat="bare"/></td>
                <td align="left"><xref target="RFC6350" section="6.6.4" sectionFormat="bare"/></td>
                <td align="left"/>
              </tr>
              <tr>
                <td align="left"/>
                <td align="left">voice</td>
                <td align="left">jCard tel with type="voice"</td>
                <td align="left"><xref target="RFC7483" section="5.1" sectionFormat="bare"/></td>
                <td align="left"><xref target="RFC6350" section="6.4.1" sectionFormat="bare"/></td>
                <td align="left"/>
              </tr>
              <tr>
                <td align="left"/>
                <td align="left">email</td>
                <td align="left">jCard email</td>
                <td align="left"><xref target="RFC7483" section="5.1" sectionFormat="bare"/></td>
                <td align="left"><xref target="RFC6350" section="6.4.2" sectionFormat="bare"/></td>
                <td align="left"/>
              </tr>
              <tr>
                <td align="left"/>
                <td align="left">country</td>
                <td align="left">country name in jCard adr</td>
                <td align="left"><xref target="RFC7483" section="5.1" sectionFormat="bare"/></td>
                <td align="left"><xref target="RFC6350" section="6.3.1" sectionFormat="bare"/></td>
                <td align="left"/>
              </tr>
              <tr>
                <td align="left"/>
                <td align="left">cc</td>
                <td align="left">country code in jCard adr</td>
                <td align="left"><xref target="RFC7483" section="5.1" sectionFormat="bare"/></td>
                <td align="left"/>
                <td align="left"><xref target="RFC8605" section="3.1" sectionFormat="bare"/></td>
              </tr>
              <tr>
                <td align="left"/>
                <td align="left">city</td>
                <td align="left">locality in jCard adr</td>
                <td align="left"><xref target="RFC7483" section="5.1" sectionFormat="bare"/></td>
                <td align="left"><xref target="RFC6350" section="6.3.1" sectionFormat="bare"/></td>
                <td align="left"/>
              </tr>
            </tbody>
          </table>
          <t>Regarding the definitions in <xref target="table_sorting_properties_definition"/>, some further considerations are needed to disambiguate some cases:</t>
          <ul>
            <li>
              <t>Since the response to a search on either domains or nameservers might include both A-labels and U-labels <xref target="RFC5890"/> in general, a consistent sorting policy <bcp14>MUST</bcp14> treat the unicodeName and ldhName as two representations of the same value.  The unicodeName value <bcp14>MUST</bcp14> be used while sorting if it is present; when the unicodeName is unavailable, the value of the ldhName <bcp14>MUST</bcp14> be used instead.</t>
            </li>
            <li>
              <t>The jCard "sort-as" parameter <bcp14>MUST</bcp14> be ignored for the sorting capability described in this document.</t>
            </li>
            <li>
              <t>Even if a nameserver can have multiple IPv4 and IPv6 addresses, the most common configuration includes one address for each IP version.  Therefore, this specification makes the assumption that nameservers have a single IPv4 and/or IPv6 value.  When more than one address per IP version is presented, sorting <bcp14>MUST</bcp14> be applied to the first value.</t>
            </li>
            <li>
              <t>Multiple events with a given action on an object might be returned.  If this occurs, sorting <bcp14>MUST</bcp14> be applied to the most recent event.</t>

            </li>
            <li>Except for handle values, all the sorting properties defined for entity objects can be multivalued according to the definition of vCard as given in <xref target="RFC6350"/>.  When more than one value is presented, sorting <bcp14>MUST</bcp14> be applied to the preferred value identified by the parameter pref="1".  If the "pref" parameter is missing, sorting <bcp14>MUST</bcp14> be applied to the first value.</li>
          </ul>
          <t>The "jsonPath" field in the "sorting_metadata" element is used to clarify the RDAP response field the sorting property refers to.  The mapping between the sorting properties and the jsonpaths of the RDAP response fields is shown below.  The JSONPath operators used herein are described in <xref target="jsonpath-operators"/>.</t>
          <ul >
            <li>
              <t>Searchable objects
              </t>
              <dl newline="true">
                <dt>registrationDate</dt>

                <dd>
<t>$.domainSearchResults[*].events[?(@.eventAction=="registration")].eventDate</t>
                </dd>
                <dt>reregistrationDate</dt>
                <dd>
                  <t>$.domainSearchResults[*].events[?(@.eventAction=="reregistration")].eventDate</t>

                </dd>
                <dt>lastChangedDate</dt>
                <dd>
                  <t>$.domainSearchResults[*].events[?(@.eventAction=="last changed")].eventDate</t>

                </dd>
                <dt>expirationDate</dt>
                <dd>
                  <t>$.domainSearchResults[*].events[?(@.eventAction=="expiration")].eventDate</t>

                </dd>
                <dt>deletionDate</dt>
                <dd>
                  <t>$.domainSearchResults[*].events[?(@.eventAction=="deletion")].eventDate</t>

                </dd>
                <dt>reinstantiationDate</dt>
                <dd>
                  <t>$.domainSearchResults[*].events[?(@.eventAction=="reinstantiation")].eventDate</t>

                </dd>
                <dt>transferDate</dt>
                <dd>
                  <t>$.domainSearchResults[*].events[?(@.eventAction=="transfer")].eventDate</t>

                </dd>
                <dt>lockedDate</dt>
                <dd>
                  <t>$.domainSearchResults[*].events[?(@.eventAction=="locked")].eventDate</t>

                </dd>
                <dt>unlockedDate</dt>
                <dd>
                  <t>$.domainSearchResults[*].events[?(@.eventAction=="unlocked")].eventDate</t>

                </dd>
              </dl>
            </li>
            <li>
              <t>Domain
              </t>
              <dl newline="true">
                <dt>name</dt>
                <dd>
                  <t>$.domainSearchResults[*].[unicodeName,ldhName]</t>

                </dd>
              </dl>
            </li>
            <li>
              <t>Nameserver
              </t>
              <dl newline="true">
                <dt>name</dt>
                <dd>
                  <t>$.nameserverSearchResults[*].[unicodeName,ldhName]</t>

                </dd>
                <dt>ipv4</dt>
                <dd>
                  <t>$.nameserverSearchResults[*].ipAddresses.v4[0]</t>

                </dd>
                <dt>ipv6</dt>
                <dd>
                  <t>$.nameserverSearchResults[*].ipAddresses.v6[0]</t>

                </dd>
              </dl>
            </li>
            <li>
              <t>Entity
              </t>
              <dl newline="true">
                <dt>handle</dt>
                <dd>
                  <t>$.entitySearchResults[*].handle</t>

                </dd>
                <dt>fn</dt>
                <dd>
                  <t>$.entitySearchResults[*].vcardArray[1][?(@[0]=="fn")][3]</t>

                </dd>
                <dt>org</dt>
                <dd>
                  <t>$.entitySearchResults[*].vcardArray[1][?(@[0]=="org")][3]</t>

                </dd>
                <dt>voice</dt>
                <dd>
                  <t>$.entitySearchResults[*].vcardArray[1][?(@[0]=="tel" &amp;&amp; @[1].type=="voice")][3]</t>

                </dd>
                <dt>email</dt>
                <dd>
                  <t>$.entitySearchResults[*].vcardArray[1][?(@[0]=="email")][3]</t>

                </dd>
                <dt>country</dt>
                <dd>
                  <t>$.entitySearchResults[*].vcardArray[1][?(@[0]=="adr")][3][6]</t>

                </dd>
                <dt>cc</dt>
                <dd>
                  <t>$.entitySearchResults[*].vcardArray[1][?(@[0]=="adr")][1].cc</t>

                </dd>
                <dt>city</dt>
                <dd>
                  <t>$.entitySearchResults[*].vcardArray[1][?(@[0]=="adr")][3][3]</t>

                </dd>
              </dl>
            </li>
          </ul>
          <t>Additional notes on the provided jsonpaths:</t>
          <ul>
            <li>
              <t>Those related to the event dates are defined only for the
              "domain" object.  To obtain the equivalent jsonpaths for
              "entity" and "nameserver", the path segment
              "domainSearchResults" must be replaced with
              "entitySearchResults" and "nameserverSearchResults",
              respectively.</t>

            </li>
            <li>Those related to jCard elements are specified without taking
            into account the "pref" parameter.  Servers that sort those values
            identified by the "pref" parameter <bcp14>SHOULD</bcp14> update a
            jsonpath by adding an appropriate filter.  For example, if the
            email values identified by pref="1" are considered for sorting,
            the jsonpath of the "email" sorting property should be
            $.entitySearchResults[*].vcardArray[1][?(@[0]=="email" &amp;&amp;
            @[1].pref=="1")][3].</li>

          </ul>
        </section>



        <section anchor="sorting_links">
          <name>Representing Sorting Links</name>
          <t>An RDAP server <bcp14>MAY</bcp14> use the "links" array of the "sorting_metadata" element to provide ready-made references <xref target="RFC8288"/> to the available sort criteria (<xref target="sort-link-in-response-example"/>).  Each link represents a reference to an alternate view of the results.</t>
          <t>The "value", "rel", and "href" JSON values <bcp14>MUST</bcp14> be specified.  All other JSON values are <bcp14>OPTIONAL</bcp14>.</t>
          <figure anchor="sort-link-in-response-example">
            <name>Example of a "sorting_metadata" Instance to Implement Result Sorting</name>


          <sourcecode type="json">
{
  "rdapConformance": [
    "rdap_level_0",
    "sorting"
  ],
  ...
  "sorting_metadata": {
     "currentSort": "name",
     "availableSorts": [
       {
       "property": "registrationDate",
       "jsonPath": "$.domainSearchResults[*]
          .events[?(@.eventAction==\"registration\")].eventDate",
       "default": false,
       "links": [
         {
         "value": "https://example.com/rdap/domains?name=example*.com
                   &amp;sort=name",
         "rel": "alternate",
         "href": "https://example.com/rdap/domains?name=example*.com
                  &amp;sort=registrationDate",
         "title": "Result Ascending Sort Link",
         "type": "application/rdap+json"
         },
         {
         "value": "https://example.com/rdap/domains?name=example*.com
                   &amp;sort=name",
         "rel": "alternate",
         "href": "https://example.com/rdap/domains?name=example*.com
                  &amp;sort=registrationDate:d",
         "title": "Result Descending Sort Link",
         "type": "application/rdap+json"
         }
       ]
       },
       ...      
     ]
  },
  "domainSearchResults": [
    ...
  ]
}
	  </sourcecode>
          </figure>
        </section>
      </section>
      <section anchor="cursor-parameter">
        <name>"cursor" Parameter</name>

        <t>The "cursor" parameter defined in this specification can be used to
        encode information about any pagination method.  For example, in the
        case of a simple implementation of the "cursor" parameter to represent
        offset pagination information, the "cursor" value
        "b2Zmc2V0PTEwMCxsaW1pdD01MA==" is the base64 encoding of
        "offset=100,limit=50".  Likewise, in a simple implementation to
        represent keyset pagination information, the "cursor" value
        "ZXhhbXBsZS1OLmNvbQ==" represents the base64 encoding of
        "key=example-N.com" whereby the key value identifies the last row of
        the current page.</t>

        <t>Note that this specification uses a base64 encoding for cursor
        obfuscation just for example.  RDAP servers are <bcp14>NOT
        RECOMMENDED</bcp14> to obfuscate the "cursor" value through a mere
        base64 encoding.</t>

        <t>This solution lets RDAP providers implement a pagination method
        according to their needs, a user's access level, and the submitted
        query.  Besides, servers can change the method over time without
        announcing anything to clients.  The considerations that have led to
        this solution are described in more detail in <xref
        target="approaches-to-result-pagination"/>.</t>

        <t>The ABNF syntax of the "cursor" parameter is the following:</t>
<sourcecode type="abnf">
   cursor = "cursor=" 1*( ALPHA / DIGIT / "/" / "=" / "-" / "_" )
</sourcecode>
        <t>The following is an example of an RDAP query including the "cursor" parameter:</t>
        <t>https://example.com/rdap/domains?name=example*.com
&amp;cursor=wJlCDLIl6KTWypN7T6vc6nWEmEYe99Hjf1XY1xmqV-M=
        </t>
        <section anchor="cursor_paging_links">
          <name>Representing Paging Links</name>
          <t>An RDAP server <bcp14>SHOULD</bcp14> use the "links" array of the "paging_metadata" element to provide a ready-made reference <xref target="RFC8288"/> to the next page of the result set (<xref target="cursor-pagination-link-in-response-example"/>).  Examples of additional "rel" values a server <bcp14>MAY</bcp14> implement are "first", "last", and "prev".</t>
          <figure anchor="cursor-pagination-link-in-response-example">
            <name>Example of a "paging_metadata" Instance to Implement Cursor Pagination</name>
<sourcecode type="json">
{
  "rdapConformance": [
    "rdap_level_0",
    "paging"
  ],
  ...
  "notices": [
    {
      "title": "Search query limits",
      "type": "result set truncated due to excessive load",
      "description": [
      "search results for domains are limited to 50"
      ]
    }
  ],
  "paging_metadata": {
    "totalCount": 73,
    "pageSize": 50,
    "pageNumber": 1, 
    "links": [
      {
      "value": "https://example.com/rdap/domains?name=example*.com",
      "rel": "next",
      "href": "https://example.com/rdap/domains?name=example*.com
              &amp;cursor=wJlCDLIl6KTWypN7T6vc6nWEmEYe99Hjf1XY1xmqV-M=",
      "title": "Result Pagination Link",
      "type": "application/rdap+json"
      }
    ]
  },
  "domainSearchResults": [
    ...
  ]
}
</sourcecode>
          </figure>
        </section>
      </section>
    </section>
    <section anchor="negative-answers">
      <name>Negative Answers</name>

      <t>The constraints for the values of parameters are defined by their ABNF
      syntax.  Therefore, each request that includes an invalid value for a
      parameter <bcp14>SHOULD</bcp14> produce an HTTP 400 (Bad Request)
      response code.  The same response <bcp14>SHOULD</bcp14> be returned in
      the following cases:

</t>
      <ul>

        <li>
<t>if sorting by either single or multiple properties, the client provides an
unsupported value for the "sort" parameter, as well as a value related to an
object property not included in the response
</t>

        </li>
        <li>if the client submits an invalid value for the "cursor" parameter</li>
      </ul>
      <t>Optionally, the response <bcp14>MAY</bcp14> include additional information regarding either the supported sorting properties or the correct "cursor" value in the HTTP entity body (<xref target="sorting-property-error"/>).</t>




      <figure anchor="sorting-property-error">
        <name>Example of RDAP Error Response Due to an Invalid Domain Sorting Property Included in the Request</name>
<sourcecode type="json">       
{
    "errorCode": 400,
    "title": "Domain sorting property 'unknown' is not valid",
    "description": [
        "Supported domain sorting properties are:"
        "'aproperty', 'anotherproperty'"
    ]

}
</sourcecode>
      </figure>
    </section>
    <section anchor="implementation-considerations">
      <name>Implementation Considerations</name>
      <t>Implementation of the new parameters is technically feasible, as
      operators for counting, sorting, and paging are currently supported by
      the major relational database management systems.  Similar operators are
      completely or partially supported by the most well-known NoSQL databases
      (e.g., MongoDB, CouchDB, HBase, Cassandra, Hadoop, etc.).  Additional
      implementation notes are included in <xref
      target="additional-implementation-notes"/>.</t>
    </section>
    <section anchor="IANA-considerations">
      <name>IANA Considerations</name>

      <t>IANA has registered the following values in the "RDAP Extensions"
      registry:</t>

<dl spacing="compact">

<dt>Extension identifier:
</dt>
<dd>paging
</dd>

<dt>Registry operator:
</dt>
<dd>Any
</dd>

<dt>Published specification:
</dt>
<dd>RFC 8977
</dd>

<dt>Contact:
</dt>
<dd>IETF &lt;iesg@ietf.org&gt;
</dd>

<dt>Intended usage:
</dt>
<dd>This extension describes a best practice for result set paging.
</dd>

</dl>




<dl spacing="compact">

<dt>Extension identifier:
</dt>
<dd>sorting
</dd>

<dt>Registry operator:
</dt>
<dd>Any
</dd>

<dt>Published specification:
</dt>
<dd>RFC 8977
</dd>

<dt>Contact:
</dt>
<dd>IETF &lt;iesg@ietf.org&gt;
</dd>

<dt>Intended usage: 
</dt>
<dd>This extension describes a best practice for result set sorting.
</dd>

</dl>



    </section>

    <section anchor="security-considerations">
      <name>Security Considerations</name>
      <t>Security services for the operations specified in this document are described in <xref target="RFC7481"/>.</t>
      <t>A search query typically requires more server resources (such as memory, CPU cycles, and network bandwidth) when compared to a lookup query.  This increases the risk of server resource exhaustion and subsequent denial of service.  This risk can be mitigated by either restricting search functionality or limiting the rate of search requests.  Servers can also reduce their load by truncating the results in a response.  However, this last security policy can result in a higher inefficiency or risk due to acting on incomplete information if the RDAP server does not provide any functionality to return the truncated results.</t>
      <t>The new parameters presented in this document provide RDAP operators with a way to implement a server that reduces inefficiency risks.  The "count" parameter gives the client the ability to evaluate the completeness of a response.  The "sort" parameter allows the client to obtain the most relevant information at the beginning of the result set.  This can reduce the number of unnecessary search requests.  Finally, the "cursor" parameter enables the user to scroll the result set by submitting a sequence of sustainable queries within server-acceptable limits.</t>
    </section>
  </middle>
  <back>

    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5234.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5890.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6350.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7095.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7231.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7480.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7481.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7482.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7483.xml"/>

        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8259.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8288.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8605.xml"/>
      </references>
      <references>
        <name>Informative References</name>

        <reference anchor="CURSOR" target="https://www.sitepoint.com/paginating-real-time-data-cursor-based-pagination/">
          <front>
            <title>Paginating Real-Time Data with Cursor Based Pagination</title>
            <author initials="R." surname="Nimesh" fullname="Rakhitha Nimesh">
		</author>
            <date year="2014" month="July"/>
          </front>
        </reference>

        <reference anchor="CURSOR-API1" target="https://developers.facebook.com/docs/graph-api/using-graph-api">
          <front>
            <title>Facebook for Developers -- Using the Graph API</title>
            <author>
              <organization>Facebook</organization>
            </author>
            <date />
          </front>
        </reference>

        <reference anchor="CURSOR-API2" target="https://developer.twitter.com/en/docs/twitter-ads-api">
          <front>
            <title>Twitter Ads API</title>
            <author>
              <organization>Twitter</organization>
            </author>
            <date />
          </front>
        </reference>

        <reference anchor="GOESSNER-JSON-PATH" target="https://goessner.net/articles/JsonPath/">
          <front>
            <title>JSONPath - XPath for JSON</title>
            <author initials="S." surname="Goessner" fullname="Stefan Goessner">
                </author>
            <date year="2007" month="February"/>
          </front>
        </reference>


        <reference anchor="HATEOAS" target="https://www.e4developer.com/2018/02/16/hateoas-simple-explanation/">
          <front>
            <title>HATEOAS - a simple explanation</title>
            <author initials="B." surname="Jedrzejewski" fullname="Bartosz Jedrzejewski">
		</author>
            <date year="2018" month="February"/>
          </front>
        </reference>


        <reference anchor="JSONPATH-COMPARISON" target="https://cburgmer.github.io/json-path-comparison/">
          <front>
            <title>JSONPath Comparison</title>
            <author/>
            <date />
          </front>
        </reference>


        <reference anchor="JSONPATH-WG" target="https://datatracker.ietf.org/wg/jsonpath/about/">
          <front>
            <title>JSON Path (jsonpath)</title>
            <author><organization>IETF</organization></author>
            <date/>
          </front>
        </reference>


        <reference anchor="ODATA-PART1" target="https://docs.oasis-open.org/odata/odata/v4.0/errata03/os/complete/part1-protocol/odata-v4.0-errata03-os-part1-protocol-complete.pdf">
          <front>
            <title>OData Version 4.0. Part 1: Protocol Plus Errata 03</title>
            <author initials="M." surname="Pizzo" fullname="Michael Pizzo">
		</author>
            <author initials="R." surname="Handl" fullname="Ralf Handl">
		</author>
            <author initials="M." surname="Zurmuehl" fullname="Martin Zurmuehl">
		</author>
            <date year="2016" month="June"/>
          </front>
        </reference>


        <reference anchor="REST" target="https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf">
          <front>
            <title>Architectural Styles and the Design of Network-based Software Architectures</title>
            <author initials="R." surname="Fielding" fullname="Roy Thomas Fielding">
              <organization>PH.D. DISSERTATION, UNIVERSITY OF CALIFORNIA, IRVINE</organization>
            </author>
            <date year="2000"/>
          </front>
        </reference>

        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6901.xml"/>


        <reference anchor="SEEK" target="https://www.eversql.com/faster-pagination-in-mysql-why-order-by-with-limit-and-offset-is-slow/">
          <front>
            <title>Faster Pagination in Mysql - Why Order By With Limit and Offset is Slow?</title>
            <author>
              <organization>EverSQL</organization>
            </author>
            <date year="2017" month="July"/>
          </front>
        </reference>

        <reference anchor="W3C.CR-xpath-31-20170321" target="https://www.w3.org/TR/2017/REC-xpath-31-20170321/">
          <front>
            <title>XML Path Language (XPath) 3.1</title>
            <author initials="J." surname="Robie" fullname="Jonathan Robie">
              <organization/>
            </author>
            <author initials="M." surname="Dyck" fullname="Michael Dyck">
              <organization/>
            </author>
            <author initials="J." surname="Spiegel" fullname="Josh Spiegel">
              <organization/>
            </author>
            <date month="March" year="2017"/>
          </front>
          <refcontent>World Wide Web Consortium Recommendation REC-xpath-31-20170321</refcontent>
        </reference>
      </references>

    </references>


    <section anchor="jsonpath-operators">
      <name>JSONPath Operators</name>
      <t>The jsonpaths used in this document are provided according to the Goessner proposal <xref target="GOESSNER-JSON-PATH"/>.</t>
      <t>Such specification requires that implementations support a set of
      "basic operators".  These operators are used to access the elements of a
      JSON structure like objects and arrays, as well as their subelements
      (object members and array items, respectively).  No operations are
      defined for retrieving parent or sibling elements of a given element.
      The root element is always referred to as $ regardless of it being an
      object or array.</t>
      <t>Additionally, the specification permits implementations to support
      arbitrary script expressions.  These can be used to index into an object
      or array, or to filter elements from an array.  While script expression
      behavior is implementation-defined, most implementations support the
      basic relational and logical operators as well as both object member and
      array item access, sufficiently similar for the purpose of this
      document.  Commonly supported operators/functions divided into
      "top-level operators" and "filter operators" are documented in Tables <xref
      target="table_json_path_top_level_operators" format="counter"/> and <xref
      target="table_json_path_filter_operators" format="counter"/>, respectively.</t>
      <t>For more information on implementation interoperability issues, see
      <xref target="JSONPATH-COMPARISON" format="default"/>.  At the time
      of writing, work is beginning on a standardization effort too (see
      <xref target="JSONPATH-WG" format="default"/>).</t>
      <table anchor="table_json_path_top_level_operators">
        <name>JSONPath Top-Level Operators</name>
        <thead>
          <tr>
            <th align="left">Operator</th>
            <th align="left">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">$</td>
            <td align="left">Root element</td>
          </tr>
          <tr>
            <td align="left">.&lt;name&gt;</td>
            <td align="left">Object member access (dot-notation)</td>
          </tr>
          <tr>
            <td align="left">['&lt;name&gt;']</td>
            <td align="left">Object member access (bracket-notation)</td>
          </tr>
          <tr>
            <td align="left">[&lt;number&gt;]</td>
            <td align="left">Array item access</td>
          </tr>
          <tr>
            <td align="left">*</td>
            <td align="left">All elements within the specified scope</td>
          </tr>
          <tr>
            <td align="left">[?(&lt;expression&gt;)]</td>
            <td align="left">Filter expression</td>
          </tr>
        </tbody>
      </table>
      <table anchor="table_json_path_filter_operators">
        <name>JSONPath Filter Operators</name>
        <thead>
          <tr>
            <th align="left">Operator</th>
            <th align="left">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">@</td>
            <td align="left">Current element being processed</td>
          </tr>
          <tr>
            <td align="left">.&lt;name&gt;</td>
            <td align="left">Object member access</td>
          </tr>
          <tr>
            <td align="left">.[&lt;name1&gt;,&lt;name2&gt;]</td>
            <td align="left">Union of object members</td>
          </tr>
          <tr>
            <td align="left">[&lt;number&gt;]</td>
            <td align="left">Array item access</td>
          </tr>
          <tr>
            <td align="left">==</td>
            <td align="left">Left is equal to right</td>
          </tr>
          <tr>
            <td align="left">!=</td>
            <td align="left">Left is not equal to right</td>
          </tr>
          <tr>
            <td align="left">&lt;</td>
            <td align="left">Left is less than right</td>
          </tr>
          <tr>
            <td align="left">&lt;=</td>
            <td align="left">Left is less than or equal to right</td>
          </tr>
          <tr>
            <td align="left">&gt;</td>
            <td align="left">Left is greater than right</td>
          </tr>
          <tr>
            <td align="left">&gt;=</td>
            <td align="left">Left is greater than or equal to right</td>
          </tr>
          <tr>
            <td align="left">&amp;&amp;</td>
            <td align="left">Logical conjunction</td>
          </tr>
          <tr>
            <td align="left">||</td>
            <td align="left">Logical disjunction</td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="approaches-to-result-pagination">


      <name>Approaches to Result Pagination</name>
      <t>An RDAP query could return a response with hundreds, even thousands, of objects, especially when partial matching is used.  For this reason, the "cursor" parameter addressing result pagination is defined to make responses easier to handle.</t>
      <t>Presently, the most popular methods to implement pagination in a REST API include offset pagination and keyset pagination.  Neither pagination method requires the server to handle the result set in a storage area across multiple requests since a new result set is generated each time a request is submitted.  Therefore, they are preferred to any other method requiring the management of a REST session.</t>
      <t>Using limit and offset operators represents the traditionally used method to implement result pagination.  Both of them can be used individually: 
      </t>
<dl>

<dt>"limit=N":
</dt>
<dd>means that the server returns the first N objects of the result set
</dd>

<dt>"offset=N": 
</dt>
<dd>means that the server skips the first N objects and returns objects starting from position N+1
</dd>


</dl>


      <t>When limit and offset are used together, they provide the ability to identify a specific portion of the result set.  For example, the pair "offset=100,limit=50" returns the first 50 objects starting from position 101 of the result set.</t>
      <t>Though easy to implement, offset pagination also includes drawbacks:
      </t>
      <ul>
        <li>
          <t>When offset has a very high value, scrolling the result set could take some time.</t>

        </li>
        <li>
          <t>It always requires fetching all rows before dropping as many rows as specified by offset.</t>

        </li>
        <li>It may return inconsistent pages when data are frequently updated (i.e., real-time data).</li>
      </ul>
      <t>Keyset pagination <xref target="SEEK"/> adds a query condition that enables the selection of the only data not yet returned.  This method has been taken as the basis for the implementation of a "cursor" parameter <xref target="CURSOR"/> by some REST API providers <xref target="CURSOR-API1"/> <xref target="CURSOR-API2"/>.  The cursor is a URL-safe string opaque to the client and representing a logical pointer to the first result of the next page.</t>


      <t>Nevertheless, even keyset pagination can be troublesome:
      </t>
      <ul>
        <li>
          <t>It needs at least one key field.</t>

        </li>
        <li>
          <t>It does not allow sorting simply by any field because the sorting
          criterion must contain a key.</t>

        </li>
        <li>

          <t>It works best with full composite values supported by database
          management systems (i.e., [x,y]&gt;[a,b]); emulation is possible but
          inelegant and less efficient.</t>

        </li>
        <li>
          <t>It does not allow direct navigation to arbitrary pages because
          the result set must be scrolled in sequential order starting from
          the initial page.</t>

        </li>
        <li>Implementing bidirectional navigation is tedious because all
        comparison and sort operations have to be reversed.</li>
      </ul>
      <section anchor="pagination-in-rdap">
        <name>Specific Issues Raised by RDAP</name>
        <t>Some additional considerations can be made in the RDAP context:
        </t>
        <ul>
          <li>
            <t>An RDAP object is a conceptual aggregation of information
            generally collected from more than one data structure (e.g.,
            table), and this makes it even harder to implement keyset
            pagination, a task that is already quite difficult.  For example,
            the entity object can include information from different data
            structures (registrars, registrants, contacts, resellers), each
            one with its key field mapping the RDAP entity handle.</t>

          </li>
          <li>
            <t>Depending on the number of page results as well as the number
            and the complexity of the properties of each RDAP object in the
            response, the time required by offset pagination to skip the
            previous pages could be much faster than the processing time
            needed to build the current page.  In fact, RDAP objects are
            usually formed by information belonging to multiple data
            structures and containing multivalued properties (i.e., arrays);
            therefore, data selection might be a time-consuming
            process.  This situation occurs even though the selection is
            supported by indexes.</t>

          </li>
          <li>Depending on the access levels defined by each RDAP operator,
          the increase in complexity and the decrease in flexibility of keyset
          pagination in comparison to offset pagination could be considered
          impractical.</li>
        </ul>
        <t>Ultimately, both pagination methods have benefits and
        drawbacks.</t>
      </section>
    </section>
    <section anchor="additional-implementation-notes">

      <name>Implementation Notes</name>

      <t>This section contains an overview of the main choices made during the
      implementation of the capabilities defined in this document in the RDAP public test
      server of Registro.it at the Institute of Informatics and Telematics of
      the National Research Council (IIT-CNR).  The content of this section
      can represent guidance for implementers who plan to provide RDAP
      users with those capabilities.  The RDAP public test server can be
      accessed at <eref target="https://rdap.pubtest.nic.it/"
      brackets="angle"/>.  Further documentation about the server features is
      available at <eref target="https://rdap.pubtest.nic.it/doc/README.html"
      brackets="angle"/>.</t>


      <section>
        <name>Sorting</name>
        <t>If no sort criterion is specified in the query string, the results are sorted by a default property: "name" for domains and nameservers, and "handle" for entities.  The server supports multiple property sorting but the "sorting_metadata" object includes only the links to alternative result set views sorted by a single property just to show the list of sorting properties allowed for each searchable object.  The server supports all the object-specific sorting properties described in the specification except for nameserver sorting based on unicodeName, that is, the "name" sorting property is mapped onto the "ldhName" response field.  Regarding the object-common properties, sorting by registrationDate, expirationDate, lastChangedDate, and transferDate is supported.</t>
      </section>
      <section>
        <name>Counting</name>

        <t>The counting operation is implemented through a separate query.  Some relational database management systems support custom operators to get the total count together with the rows, but the resulting query can be considerably more expensive than that performed without the total count.  Therefore, as "totalCount" is an optional response information, always fetching the total number of rows has been considered an inefficient solution.  Furthermore, to avoid the processing of unnecessary queries, when the "count" parameter is included in the submitted query, it is not also repeated in the query strings of the "links" array provided in both "paging_metadata" and "sorting_metadata" objects.</t>
      </section>
      <section>
        <name>Paging</name>

        <t>The server implements the cursor pagination through the keyset
        pagination when sorting by a unique property is requested or the
        default sort is applied. Otherwise, it implements the cursor
        pagination through the offset pagination.  As most relational database
        management systems don't support the comparison of full composite
        values natively, the implementation of full keyset pagination seem to
        be troublesome so, at least initially, a selective applicability of
        keyset pagination is advisable.  Moreover, the "cursor" value encodes
        not only information about pagination but also about the search
        pattern and the other query parameters in order to check the
        consistency of the entire query string.  If the "cursor" value is
        inconsistent with the rest of the query string, the server returns an
        error response.</t>
      </section>
    </section>
    <section numbered="false">
      <name>Acknowledgements</name>
      <t>The authors would like to acknowledge <contact fullname="Brian Mountford"/>, <contact fullname="Tom Harrison"/>, <contact fullname="Karl Heinz Wolf"/>, <contact fullname="Jasdip Singh"/>, <contact fullname="Erik Kline"/>, <contact fullname="ric Vyncke"/>, <contact fullname="Benjamin Kaduk"/>, and <contact fullname="Roman Danyliw"/> for their contributions to the development of this document.</t>
    </section>


  </back>
</rfc>
