<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" docName="draft-ietf-avtcore-multiplex-guidelines-12" number="8872" ipr="trust200902" submissionType="IETF" category="info" consensus="true" obsoletes="" updates="" xml:lang="en" tocInclude="true" tocDepth="3" symRefs="true" sortRefs="true" version="3">

  <!-- xml2rfc v2v3 conversion 2.45.3 -->
  <front>
    <title abbrev="Guidelines for Multiplexing in RTP">Guidelines for
      Using the Multiplexing Features of RTP to Support Multiple Media
      Streams</title>
    <seriesInfo name="RFC" value="8872"/>
    <author fullname="Magnus Westerlund" initials="M." surname="Westerlund">
      <organization>Ericsson</organization>
      <address>
        <postal>
          <street>Torshamnsgatan 23</street>
          <code>164 80</code>
          <city>Kista</city>
          <country>Sweden</country>
        </postal>
        <email>magnus.westerlund@ericsson.com</email>
      </address>
    </author>
    <author fullname="Bo Burman" initials="B." surname="Burman">
      <organization>Ericsson</organization>
      <address>
        <postal>
          <street>Gronlandsgatan 31</street>
          <code>164 60</code>
          <city>Kista</city>
          <country>Sweden</country>
        </postal>
        <email>bo.burman@ericsson.com</email>
      </address>
    </author>
    <author fullname="Colin Perkins" initials="C." surname="Perkins">
      <organization>University of Glasgow</organization>
      <address>
        <postal>
          <extaddr>School of Computing Science</extaddr>
          <city>Glasgow</city>
          <code>G12 8QQ</code>
          <country>United Kingdom</country>
        </postal>
        <email>csp@csperkins.org</email>
      </address>
    </author>
    <author fullname="Harald Tveit Alvestrand" initials="H." surname="Alvestrand">
      <organization>Google</organization>
      <address>
        <postal>
          <street>Kungsbron 2</street>
          <city>Stockholm</city>
          <code>11122</code>
          <country>Sweden</country>
        </postal>
        <email>harald@alvestrand.no</email>
      </address>
    </author>
    <author fullname="Roni Even" initials="R." surname="Even">
      <address>
        <email>ron.even.tlv@gmail.com</email>
      </address>
    </author>
    <date month="January" year="2021"/>

<keyword>Simulcast</keyword>

    <abstract>
      <t>The Real-time Transport Protocol (RTP) is a flexible protocol that
        can be used in a wide range of applications, networks, and system
        topologies. That flexibility makes for wide applicability but can
        complicate the application design process. One particular design
        question that has received much attention is how to support multiple
        media streams in RTP. This memo discusses the available options and
        design trade-offs, and provides guidelines on how to use the
        multiplexing features of RTP to support multiple media streams.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="sect-1" numbered="true" toc="default">
      <name>Introduction</name>
      <t>The Real-time Transport Protocol (RTP)
        <xref target="RFC3550" format="default"/>
        is a commonly used protocol for real-time media transport. It is a
        protocol that provides great flexibility and can support a large set
        of different applications. From the beginning, RTP was designed for
        multiple participants in a communication session. It supports many
        topology paradigms and usages, as defined in
        <xref target="RFC7667" format="default"/>. RTP has several multiplexing points designed
        for different purposes; these points enable support of multiple RTP streams
        and switching between different encoding or packetization techniques for the
        media. By using multiple RTP sessions, sets of RTP streams can be
        structured for efficient processing or identification. Thus, 
to meet an application's needs, an RTP application designer needs to understand how best to use the RTP
        session, the RTP stream identifier (synchronization source (SSRC)), and the RTP payload type.</t>
      <t>There has been increased interest in more-advanced usage of RTP.
        For example, multiple RTP streams can be used when a single endpoint
        has multiple media sources (like multiple cameras or microphones) from
        which streams of media need to be sent simultaneously. Consequently, questions are raised
        regarding the most appropriate RTP usage. The limitations in some
        implementations, RTP/RTCP extensions, and signaling have also been
        exposed. This document aims to clarify the usefulness
        of some functionalities in RTP that, hopefully, will result in future
        implementations that are more complete.</t>
      <t>The purpose of this document is to provide clear information about
        the possibilities of RTP when it comes to multiplexing. The RTP
        application designer needs to understand the implications arising
        from a particular usage of the RTP multiplexing points. This document
        provides some guidelines and recommends against some usages as
        being unsuitable, in general or for particular purposes.</t>
      <t>This document starts with some definitions and then goes into
        existing RTP functionalities around multiplexing. Both the desired
        behavior and the implications of a particular behavior depend on
        which topologies are used; therefore, this topic requires some
        consideration. We then discuss some choices regarding multiplexing
        behavior and the impacts of those choices. Some designs of RTP usage
        are also discussed. Finally, some
        guidelines and examples are provided.</t>
    </section>
    <section anchor="sect-2" numbered="true" toc="default">
      <name>Definitions</name>
      <section anchor="sect-2.1" numbered="true" toc="default">
        <name>Terminology</name>
        <t>The definitions in <xref target="RFC3550" sectionFormat="of"
        section="3"/> are referenced normatively.</t> 
        <t>The taxonomy defined in <xref target="RFC7656" format="default"/>
        is referenced normatively.</t> 
        <t>The following terms and abbreviations are used in this document:</t>
        <dl newline="true" spacing="normal">
          <dt>Multi-party:</dt>
          <dd>Communication that includes multiple endpoints.
          In this document, "multi-party" will be used to refer to scenarios where
            more than two endpoints communicate.</dd>
          <dt>Multiplexing:</dt>
          <dd>An operation that takes multiple entities as input, aggregating
          them onto some common resource while keeping the individual entities
          addressable such that they can later be fully and unambiguously
          separated (demultiplexed) again.</dd>
          <dt>RTP Receiver:</dt>
          <dd>An endpoint or middlebox receiving RTP streams and RTCP
          messages. It uses at least one SSRC to send RTCP messages. An RTP
          receiver may also be an RTP sender.</dd> 
          <dt>RTP Sender:</dt>
          <dd>An endpoint sending one or more RTP streams but also sending
          RTCP messages.</dd> 
          <dt>RTP Session Group:</dt>
          <dd>One or more RTP sessions that are used together to perform some
          function. Examples include multiple RTP sessions used to carry different
          layers of a layered encoding. In an RTP Session Group, CNAMEs are
          assumed to be valid across all RTP sessions and designate
          synchronization contexts that can cross RTP sessions; i.e., SSRCs
          that map to a common CNAME can be assumed to have RTCP Sender Report
          (SR) timing information derived from a common clock such that they
          can be synchronized for playout.</dd> 
          <dt>Signaling:</dt>
          <dd>The process of configuring endpoints to participate in one or
          more RTP sessions.</dd> 
        </dl>
        <aside><t> Note: The above definitions of "RTP receiver" and "RTP sender" are
          consistent with the usage in <xref target="RFC3550" format="default"/>.
        </t></aside>
      </section>
      <section anchor="sect-2.2" numbered="true" toc="default">
        <name>Focus of This Document</name>
        <t>This document is focused on issues that affect RTP. Thus, issues
        that involve signaling protocols -- such as whether SIP
        <xref target="RFC3261" format="default"/>, Jingle <xref target="JINGLE" format="default"/>, or some
          other protocol is in use for session configuration; the particular
          syntaxes used to define RTP session properties; or the constraints
          imposed by particular choices in the signaling protocols -- are
          mentioned only as examples in order to describe the RTP issues more
          precisely.</t>
        <t>This document assumes that the applications will use RTCP. While there
          are applications that don't send RTCP, they do not conform to the RTP
          specification and thus can be regarded as reusing the RTP packet
          format but not implementing RTP.</t>
      </section>
    </section>
    <section anchor="sect-3" numbered="true" toc="default">
      <name>RTP Multiplexing Overview</name>
      <section anchor="sect-3.1" numbered="true" toc="default">
        <name>Reasons for Multiplexing and Grouping RTP Streams</name>
        <t>There are several reasons why an endpoint might choose to send
          multiple media streams. In the discussion below, please keep in mind
          that the reasons for having multiple RTP streams vary and include, but
          are not limited to, the following:</t>
        <ul spacing="normal">
          <li>There might be multiple media sources.</li>
          <li>
            <t>Multiple RTP streams might be needed to represent one media
            source, for example:
            </t>
            <ul spacing="normal">
              <li>To carry different layers of a scalable encoding of a media source</li>
              <li>Alternative encodings during simulcast, using different codecs for the
                   same audio stream</li>
              <li>Alternative formats during simulcast, multiple resolutions of the same
                   video stream</li>
            </ul>
          </li>
          <li>A retransmission stream might repeat some parts of the content of
              another RTP stream.</li>
          <li>A Forward Error Correction (FEC) stream might provide material that
              can be used to repair another RTP stream.</li>
        </ul>
        <t>For each of these reasons, it is necessary to decide whether each
          additional RTP stream is sent within the same RTP session as the other
          RTP streams or it is necessary to use additional RTP sessions to
          group the RTP streams. For a combination of reasons, the suitable choice for one situation might not
          be the suitable choice for another situation. The choice is easiest
          when multiplexing multiple media sources of the same
          media type. However, all reasons warrant discussion and clarification
          regarding how to deal with them. As the discussion below will show, 
a single solution does not suit all purposes.
 To utilize RTP well and as efficiently as
          possible, both are needed.
The real issue is knowing when to create multiple RTP sessions versus when to
send multiple RTP streams in a single RTP session.</t>
      </section>
      <section anchor="sect-3.2" numbered="true" toc="default">
        <name>RTP Multiplexing Points</name>
        <t>This section describes the multiplexing points present in RTP
          that can be used to distinguish RTP streams and groups of RTP
          streams. <xref target="ref-rtp-demultiplexing-process"/> outlines
          the process of demultiplexing incoming RTP 
          streams, starting with one or more sockets representing the reception of one
          or more transport flows, e.g., based on the UDP destination port. It also demultiplexes
          RTP/RTCP from any other protocols, such as Session Traversal
          Utilities for NAT (STUN) <xref target="RFC5389" format="default"/>
          and DTLS-SRTP <xref target="RFC5764" format="default"/> on the same transport as
          described in <xref target="RFC7983" format="default"/>.
 The Processing and Buffering (PB)
          step in <xref target="ref-rtp-demultiplexing-process"/> terminates
          RTP/RTCP and prepares the 
          RTP payload for input to the decoder.</t>
        <figure anchor="ref-rtp-demultiplexing-process">
          <name>RTP Demultiplexing Process</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
                   |   |   |
                   |   |   | packets
        +--        v   v   v
        |        +------------+
        |        |  Socket(s) |   Transport Protocol Demultiplexing
        |        +------------+
        |            ||  ||
   RTP  |       RTP/ ||  |+-----> DTLS (SRTP keying, SCTP, etc.)
Session |       RTCP ||  +------> STUN (multiplexed using same port)
        +--          ||
        +--          ||
        |      ++(split by SSRC)-++---> Identify SSRC collision
        |      ||    ||    ||    ||
        | (associate with signaling by MID/RID)
        |      vv    vv    vv    vv
  RTP   |     +--+  +--+  +--+  +--+ Jitter buffer,
Streams |     |PB|  |PB|  |PB|  |PB| process RTCP, etc.
        |     +--+  +--+  +--+  +--+
        +--     |    |      |    |
          (select decoder based on payload type (PT))
        +--     |   /       |  /
        |       +-----+     | /
        |         /   |     |/
Payload |        v    v     v
Formats |     +---+ +---+ +---+
        |     |Dec| |Dec| |Dec| Decoders
        |     +---+ +---+ +---+
        +--]]></artwork>
        </figure>
        <section anchor="sect-3.2.1" numbered="true" toc="default">
          <name>RTP Session</name>
          <t>An RTP session is the highest semantic layer in RTP
            and represents an association between a group of communicating
            endpoints. RTP does not contain a session identifier, yet different
            RTP sessions must be possible to identify both across a set of different
            endpoints and from the perspective of a single endpoint.</t>
          <t>For RTP session separation across endpoints, the set of
            participants that form an RTP session is defined as those that share a
            single SSRC space
            <xref target="RFC3550" format="default"/>. That is, if a group of participants are each
            aware of the SSRC identifiers belonging to the other
            participants, then those participants are in a single RTP session. A
            participant can become aware of an SSRC identifier by
            receiving an RTP packet containing the identifier in the SSRC field or
            contributing source (CSRC) list,
            by receiving an RTCP packet listing it in an SSRC field, or through
            signaling (e.g., the Session Description Protocol (SDP)
            <xref target="RFC4566" format="default"/>
            "a=ssrc:" attribute
            <xref target="RFC5576" format="default"/>). Thus, the scope of an RTP session is
            determined by the participants' network interconnection topology, in
            combination with RTP and RTCP forwarding strategies deployed by the
            endpoints and any middleboxes, and by the signaling.</t>
          <t>For RTP session separation within a single endpoint, RTP relies on
            the underlying transport layer and the signaling to identify RTP
            sessions in a manner that is meaningful to the application. A single
            endpoint can have one or more transport flows for the same RTP
            session, and a single RTP session can span multiple transport-layer flows even if all endpoints use a single transport-layer flow per endpoint
            for that RTP session. The signaling layer might give RTP sessions an explicit
            identifier, or the identification might be implicit based on the
            addresses and ports used. Accordingly, a single RTP session can have
            multiple associated identifiers, explicit and implicit, belonging to
            different contexts. For example, when running RTP on top of UDP/IP, an
            endpoint can identify and delimit an RTP session from other RTP
            sessions by their UDP source and destination IP addresses and
            their UDP port numbers.
            A single RTP session can be using multiple IP/UDP flows for receiving and/or
            sending RTP packets to other endpoints or middleboxes, even if the
            endpoint does not have multiple IP addresses. Using multiple IP addresses
            only makes it more likely that multiple IP/UDP flows will be
            required. Another example is SDP media descriptions (the "m=" line and the
            subsequent associated lines) that signal the transport flow and RTP session
            configuration for the endpoint's part of the RTP session. The SDP grouping
            framework
            <xref target="RFC5888" format="default"/>
            allows labeling of the media descriptions to be used so that
            RTP Session Groups can be created. Through the use of 
            <xref target="RFC8843">"Negotiating Media Multiplexing Using the
            Session Description Protocol (SDP)"</xref>,
            multiple media descriptions become part of a common RTP session where each
            media description represents the RTP streams sent or received for a media source.</t>
          <t>RTP makes no normative statements about the
            relationship between different RTP sessions; however, applications
            that use more than one RTP session need to understand how the
            different RTP sessions that they create relate to one another.</t>
        </section>
        <section anchor="sect-3.2.2" numbered="true" toc="default">
          <name>Synchronization Source (SSRC)</name>
          <t>An SSRC identifies a source of an RTP
            stream, or an RTP receiver when sending RTCP. Every endpoint has at
            least one SSRC identifier, even if it does not send RTP packets. RTP
            endpoints that are only RTP receivers still send RTCP and use their
            SSRC identifiers in the RTCP packets they send. An endpoint can have
            multiple SSRC identifiers if it sends multiple RTP streams. Endpoints
            that function as both RTP sender and RTP receiver use the same SSRC(s) in
            both roles.</t>
          <t>The SSRC is a 32-bit identifier. It is present in every RTP and
            RTCP packet header and in the payload of some RTCP packet types. It
            can also be present in SDP signaling. Unless presignaled, e.g.,
            using the SDP "a=ssrc:" attribute
            <xref target="RFC5576" format="default"/>, the SSRC is chosen at random. It is not
            dependent on the network address of the endpoint and is intended to
            be unique within an RTP session. SSRC collisions can occur and are
            handled as specified in
            <xref target="RFC3550" format="default"/>
            and
            <xref target="RFC5576" format="default"/>, resulting in the SSRC of the colliding RTP
            streams or receivers changing. An endpoint that changes
            its network transport address during a session has to choose a new
            SSRC identifier to avoid being interpreted as a looped source, unless
            a mechanism providing a virtual transport (such as Interactive
            Connectivity Establishment (ICE)
            <xref target="RFC8445" format="default"/>) abstracts the changes.</t>
          <t>SSRC identifiers that belong to the same synchronization context
            (i.e., that represent RTP streams that can be synchronized using
            information in RTCP SR packets) use identical CNAME chunks in
            corresponding RTCP source description (SDES) packets. SDP signaling can also be used to
            provide explicit SSRC grouping
            <xref target="RFC5576" format="default"/>.</t>
          <t>In some cases, the same SSRC identifier value is used to relate
            streams in two different RTP sessions, such as in RTP retransmission
            <xref target="RFC4588" format="default"/>. This is to be avoided, since there is no
            guarantee that SSRC values are unique across RTP sessions. In the
            case of RTP retransmission
            <xref target="RFC4588" format="default"/>,
            it is recommended to use explicit binding of the source RTP
            stream and the redundancy stream, e.g., using the RepairedRtpStreamId
            RTCP SDES item <xref target="RFC8852" format="default"/>. The
            RepairedRtpStreamId is a rather recent mechanism, so one cannot expect
            older applications to follow this recommendation.
          </t>
          <t>Note that the RTP sequence number and RTP timestamp are scoped by the
            SSRC and are thus specific per RTP stream.</t>
          <t>Different types of entities use an SSRC to identify themselves, as
          follows:
          </t>
          <ul spacing="normal">
            <li>A real media source uses the SSRC to identify a "physical" media source.</li>
            <li>A conceptual media source uses the SSRC to identify the result of
                applying some filtering function in a network node -- for example, a
                filtering function in an RTP mixer that provides the most active
                speaker based on some criteria, or a mix representing a set of other
                sources.</li>
            <li>An RTP receiver uses the SSRC to identify itself as the
                source of its RTCP reports.</li>
          </ul>
          <t>An endpoint that generates more than one media type, e.g.,
            a conference participant sending both audio and video, need not (and,
            indeed, should not) use the same SSRC value across RTP
            sessions. Using RTCP compound
            packets containing the CNAME SDES item is the designated method for
            binding an SSRC to a CNAME, effectively cross-correlating SSRCs within
            and between RTP sessions as coming from the same endpoint. The main
            property attributed to SSRCs associated with the same CNAME is that
            they are from a particular synchronization context and can be
            synchronized at playback.</t>
          <t>An RTP receiver receiving a previously unseen SSRC value will
            interpret it as a new source. It might in fact be a previously
            existing source that had to change its SSRC number due to an SSRC
            conflict. Using the media identification (MID) extension
            <xref target="RFC8843" format="default"/> helps to identify
            which media source the new SSRC represents, and using the
            restriction identifier (RID) extension
            <xref target="RFC8851" format="default"/> helps to identify what encoding
            or redundancy stream it represents, even though the SSRC changed.
            However, the originator of the previous SSRC ought to have
            ended the conflicting source by sending an RTCP BYE for it prior to
            starting to send with the new SSRC, making the new SSRC a new source.</t>
        </section>
        <section anchor="sect-3.2.3" numbered="true" toc="default">
          <name>Contributing Source (CSRC)</name>
          <t>The CSRC is not a separate identifier. Rather,
            an SSRC identifier is listed as a CSRC in the RTP header of a packet
            generated by an RTP mixer or video Multipoint Control Unit (MCU) /
            switch, if the corresponding SSRC
            was in the header of one of the packets that contributed to the output.</t>
          <t>It is not possible, in general, to extract media represented by an
            individual CSRC, since it is typically the result of a media merge
            (e.g., mix) operation on the individual media streams
            corresponding to the CSRC identifiers. The exception is the case where
            only a single CSRC is indicated, as this represents the forwarding of an RTP
            stream that might have been modified. The RTP header extension (<xref target="RFC6465">"A Real-time Transport Protocol (RTP)
            Header Extension for Mixer-to-Client Audio Level Indication"</xref>)
            expands on the receiver's information about a packet with a CSRC list.
            Due to these restrictions, a CSRC will not be considered a fully
            qualified multiplexing point and will be disregarded in the rest of
            this document.</t>
        </section>
        <section anchor="sect-3.2.4" numbered="true" toc="default">
          <name>RTP Payload Type</name>
          <t>Each RTP stream utilizes one or more RTP payload formats. An RTP
            payload format describes how the output of a particular media codec is
            framed and encoded into RTP packets. The payload format is
            identified by the payload type (PT) field in the RTP packet header.
            The combination of SSRC and PT therefore identifies a specific RTP stream
            in a specific encoding format. The format definition can be taken from
            <xref target="RFC3551" format="default"/>
            for statically allocated payload types but ought to be explicitly
            defined in signaling, such as SDP, for both static and dynamic
            payload types. The term "format" here includes those aspects described
            by out-of-band signaling means; in SDP, the term "format" includes
            media type, RTP  timestamp sampling rate, codec, codec configuration,
            payload format configurations, and various robustness mechanisms such
            as redundant encodings <xref target="RFC2198" format="default"/>.</t>
          <t>The RTP payload type is scoped by the sending endpoint within an
            RTP session. PT has the same meaning across all RTP streams in an RTP
            session. All SSRCs sent from a single endpoint share the same payload
            type definitions. The RTP payload type is designed such that only a
            single payload type is valid at any instant in time in the RTP stream's
            timestamp timeline, effectively time-multiplexing different payload
            types if any change occurs. The payload type can change on a
            per-packet basis for an SSRC -- for example, a speech codec making use of
            generic comfort noise
            <xref target="RFC3389" format="default"/>. If there is a true need to send multiple
            payload types for the same SSRC that are valid for the same instant,
            then redundant encodings
            <xref target="RFC2198" format="default"/>
            can be used. Several additional constraints, other than those mentioned
            above, need to be met to enable this usage, one of which is that the
            combined payload sizes of the different payload types ought not exceed
            the transport MTU.</t>
          <t>Other aspects of using the RTP payload format are described in 
            <xref target="RFC8088">"How to Write an RTP Payload Format"</xref>.</t>
          <t>The payload type is not a multiplexing point at the RTP layer (see
            <xref target="sect-a" format="default"/>
            for a detailed discussion of why using the payload type as an RTP
            multiplexing point does not work). The RTP payload type is, however,
            used to determine how to consume and decode an RTP stream. The RTP
            payload type number is sometimes used to associate an RTP stream with
            the signaling, which in general requires that unique RTP payload
            type numbers be used in each context. Using MID, e.g., when bundling "m=" sections
            <xref target="RFC8843" format="default"/>,
            can replace the payload type as a signaling association, and unique
            RTP payload types are then no longer required for that purpose.</t>
        </section>
      </section>
      <section anchor="sect-3.3" numbered="true" toc="default">
        <name>Issues Related to RTP Topologies</name>
        <t>The impact of how RTP multiplexing is performed will in general
          vary with how the RTP session participants are interconnected,
          as described in
          <xref target="RFC7667">"RTP Topologies"</xref>.</t>
        <t>Even the most basic use case -- "Topo-Point-to-Point" as described in
          <xref target="RFC7667" format="default"/> -- raises a number of
          considerations, which are
          discussed in detail in the following sections. They range over such
          aspects as the following:</t>
        <ul spacing="normal">
          <li>Does my communication peer support RTP as defined with multiple
              SSRCs per RTP session?</li>
          <li>Do I need network differentiation in the form of QoS 
          (<xref target="sect-4.2.1" format="default"/>)?</li>
          <li>Can the application more easily process and handle the media
              streams if they are in different RTP sessions?</li>
          <li>Do I need to use additional RTP streams for RTP retransmission or FEC?</li>
        </ul>
        <t>For some point-to-multipoint topologies (e.g., Topo-ASM and
          Topo-SSM 
          <xref target="RFC7667" format="default"/>), multicast is used to interconnect the
          session participants. Special considerations (documented in
          <xref target="sect-4.2.3" format="default"/>) are then needed, as multicast is a
          one-to-many distribution system.</t>
        <t>Sometimes, an RTP communication session can end up in a situation where the
          communicating peers are not compatible, for various reasons:</t>
        <ul spacing="normal">
          <li>No common media codec for a media type, thus requiring transcoding.</li>
          <li>Different support for multiple RTP streams and RTP sessions.</li>
          <li>Usage of different media transport protocols (i.e., one peer
          uses RTP, but the other peer uses a different transport protocol).</li>
          <li>Usage of different transport protocols, e.g., UDP, the Datagram
          Congestion Control Protocol (DCCP), or TCP.</li>
          <li>Different security solutions (e.g., IPsec, TLS, DTLS, or the
          Secure Real-time Transport Protocol (SRTP)) with
          different keying mechanisms.</li>
        </ul>
        <t>These compatibility issues can often be resolved by the inclusion of a
          translator between the two peers -- the Topo-PtP-Translator, as
          described in
          <xref target="RFC7667" format="default"/>. The translator's main purpose is to make the
          peers look compatible to each other. There can also be reasons other 
          than compatibility for inserting a translator in the form of a middlebox
          or gateway -- for example, a need to monitor the RTP streams. Beware that
          changing the stream transport characteristics in the translator
          can require a thorough understanding of aspects ranging from congestion control
          and media-level adaptations to application-layer semantics.</t>
        <t>Within the uses enabled by the RTP standard, the point-to-point
          topology can contain one or more RTP sessions
          with one or more media sources per session, each having one or more
          RTP streams per media source.</t>
      </section>
      <section anchor="sect-3.4" numbered="true" toc="default">
        <name>Issues Related to RTP and RTCP</name>
        <t>Using multiple RTP streams is a well-supported feature of RTP.
          However, for most implementers or people writing RTP/RTCP applications
          or extensions attempting to apply multiple streams, it can be unclear
          when it is most appropriate to add an additional RTP stream in an
          existing RTP session and when it is better to use multiple RTP
          sessions. This section discusses the various considerations that
        need to be taken into account.</t>
        <section anchor="sect-3.4.1" numbered="true" toc="default">
          <name>The RTP Specification</name>
          <t>RFC 3550 contains some
          recommendations and a numbered list (<xref target="RFC3550"
          sectionFormat="of" section="5.2"/>) of five arguments regarding different
          aspects of RTP multiplexing. Please review <xref target="RFC3550"
          sectionFormat="of" section="5.2"/>. Five important aspects are
          quoted below.</t> 
          <ol spacing="normal" type="1">
            <li><blockquote>If, say, two audio streams shared the same RTP session and the same
                SSRC value, and one were to change encodings and thus acquire a
                different RTP payload type, there would be no general way of
                identifying which stream had changed encodings.</blockquote>
          <t>This argument advocates the use of different SSRCs for each individual RTP
          stream, as this is fundamental to RTP operation.</t></li>
            <li><blockquote>An SSRC is defined to identify a single timing and sequence number
                space. Interleaving multiple payload types would require different
                timing spaces if the media clock rates differ and would require
                different sequence number spaces to tell which payload type suffered
                packet loss.</blockquote>
          <t>This argument advocates against demultiplexing RTP
            streams within a session based only on their RTP payload type numbers;
            it still stands, as can be seen by the extensive list of issues
            discussed in <xref target="sect-a"/>.</t></li>
<!-- Note:  "Section 6.4" is in RFC 3550, so no xref -->
            <li><blockquote>The RTCP sender and receiver reports (see Section 6.4) can only
                describe one timing and sequence number space per SSRC and do not
                carry a payload type field.</blockquote>
          <t>This argument is yet another argument against payload type
              multiplexing.</t></li>
            <li><blockquote>An RTP mixer would not be able to combine interleaved streams of
            incompatible media into one stream.</blockquote>
          <t>This argument advocates against multiplexing RTP packets that
            require different handling into the same session. In most cases,
              the RTP mixer must embed application logic
            to handle streams; the separation of streams according to
            stream type is just another piece of application logic, which might or
            might not be appropriate for a particular application. One type of
            application that can mix different media sources blindly is the
            audio-only telephone bridge, although the ability to do that comes
            from the well-defined scenario that is aided by the use of a single media
            type, even though individual streams may use incompatible codec types;
            most other types of applications need application-specific logic to
            perform the mix correctly.</t></li>
            <li><blockquote><t>Carrying multiple media in one RTP session precludes: the use of
                different network paths or network resource allocations if
                appropriate; reception of a subset of the media if desired, for
                example just audio if video would exceed the available bandwidth; and
                receiver implementations that use separate processes for the different
                media, whereas using separate RTP sessions permits either single- or
                multiple-process implementations.</t></blockquote>
          <t>This argument discusses network aspects that are described in
            <xref target="sect-4.2" format="default"/>. It also goes into aspects of
            implementation, like split component terminals (see 
            <xref target="RFC7667" sectionFormat="of" section="3.10"/>) -- endpoints where different processes or
            interconnected devices handle different aspects of the whole
            multimedia session.</t></li>
          </ol>
          <t>To summarize, RFC 3550's view on multiplexing is to use unique SSRCs
            for anything that is its own media/packet stream and use
            different RTP sessions for media streams that don't share a media
            type.  This document supports the first point; it is very valid.  The
            latter needs further discussion, as imposing a single solution on all
            usages of RTP is inappropriate.  <xref target="RFC8860">"Sending
            Multiple Types of Media in a Single RTP Session"</xref>
            updates RFC 3550 to allow multiple media types in an RTP session
            and provides a detailed analysis of the potential benefits 
            and issues related to having 
            multiple media types in the same RTP session.  Thus, <xref target="RFC8860"/> provides
            a wider scope for an RTP session and considers multiple media types
            in one RTP session as a possible choice for the RTP application
            designer.</t>
        </section>
        <section anchor="sect-3.4.2" numbered="true" toc="default">
          <name>Multiple SSRCs in a Session</name>

          <t>Using multiple SSRCs at one endpoint in an RTP session requires
          that some unclear aspects of the RTP specification be resolved. These
          items could potentially lead to some interoperability issues as
          well as some potential significant inefficiencies, as further
          discussed in "Sending Multiple RTP Streams in a Single RTP Session"
          <xref target="RFC8108" format="default"/>. An RTP
          application designer should consider these issues and the 
          application's possible impact caused by a lack of appropriate RTP handling or
          optimization in the peer endpoints.</t>

          <t>Using multiple RTP sessions can potentially mitigate application
            issues caused by multiple SSRCs in an RTP session.</t>
        </section>
        <section anchor="sect-3.4.3" numbered="true" toc="default">
          <name>Binding Related Sources</name>
          <t>A common problem in a number of various RTP extensions has been how
            to bind related RTP streams together. This issue is common to both
            using additional SSRCs and multiple RTP sessions.</t>
          <t>The solutions can be divided into a few groups:</t>
          <ul spacing="normal">
            <li>RTP/RTCP based</li>
            <li>Signaling based, e.g., SDP</li>
            <li>Grouping related RTP sessions</li>
            <li>Grouping SSRCs within an RTP session</li>
          </ul>
          <t>Most solutions are explicit, but some implicit methods have also
            been applied to the problem.</t>
          <t>The SDP-based signaling solutions are:</t>
          <dl newline="true" spacing="normal">
            <dt>SDP media description grouping:</dt>
            <dd>The SDP grouping framework <xref target="RFC5888"
            format="default"/> uses various semantics to group any number of
            media descriptions. SDP media description grouping has primarily
            been used to group RTP sessions,
            but in combination with <xref target="RFC8843" format="default"/>,
            it can also group multiple media descriptions within a single RTP
            session.</dd> 
            <dt>SDP media multiplexing:</dt>
            <dd><xref target="RFC8843">"Negotiating Media
            Multiplexing Using the Session Description Protocol (SDP)"</xref>
uses information taken from both SDP and RTCP to associate RTP streams to SDP media
            descriptions. This allows both SDP and RTCP to group RTP streams belonging to
            an SDP media description and group multiple SDP media
            descriptions into a single RTP session.</dd> 
            <dt>SDP SSRC grouping:</dt>
            <dd><xref target="RFC5576">"Source-Specific Media Attributes in
            the Session Description Protocol (SDP)"</xref> includes a solution for grouping
 SSRCs in the same
            way that the grouping framework groups media descriptions.</dd> 
          </dl>
          <t>The above grouping constructs support many use cases. Those solutions have
            shortcomings in cases where the session's dynamic properties are such
            that it is difficult or a drain on resources to keep the list of related
            SSRCs up to date.</t>
          <t>One RTP/RTCP-based grouping solution is to use the RTCP SDES CNAME to bind
            related RTP streams to an endpoint or a synchronization context. For
            applications with a single RTP stream per type (media, source, or
            redundancy stream), the CNAME is sufficient for that purpose, independent of whether one or more RTP sessions
            are used. However, some applications choose not to use a CNAME because of
            perceived complexity or a desire not to implement RTCP and instead use
            the same SSRC value to bind related RTP streams across multiple RTP
            sessions. RTP retransmission
            <xref target="RFC4588" format="default"/>,
            when configured to use multiple RTP sessions, and generic FEC
            <xref target="RFC5109" format="default"/>
            both use the CNAME method to relate the RTP streams, which may work but might have some
            downsides in RTP sessions with many participating SSRCs. It is not recommended to
            use identical SSRC values across RTP sessions to relate RTP streams; when an SSRC
            collision occurs, this will force a change of that SSRC in all RTP
            sessions and will thus resynchronize all of the streams instead of only the single
            media stream experiencing the collision.</t>
          <t>Another method for implicitly binding SSRCs is used by RTP
            retransmission
            <xref target="RFC4588" format="default"/>
            when using the same RTP session as the source RTP stream for retransmissions.
            A receiver that is missing a packet issues an RTP retransmission
            request and then awaits a new SSRC carrying the RTP retransmission
            payload, where that SSRC is from the same CNAME. This limits a
            requester to having only one outstanding retransmission request on any
            new SSRCs per endpoint.</t>
          <t><xref target="RFC8851">"RTP Payload Format Restrictions"</xref>
            provides an RTP/RTCP-based mechanism to unambiguously identify the RTP
            streams within an RTP session and restrict the streams' payload format
            parameters in a codec-agnostic way beyond what is provided with the
            regular payload types. The mapping is done by specifying an "a=rid"
            value in the SDP offer/answer signaling and having the corresponding
            RtpStreamId value as an SDES item and an RTP header extension
            <xref target="RFC8852"/>. The
            RID solution also includes a solution for binding redundancy RTP
            streams to their original source RTP streams, given that those
            streams use RID
            identifiers. The redundancy stream uses the RepairedRtpStreamId
            SDES item and RTP header extension to declare the RtpStreamId
            value of the source stream to create the binding.</t>
          <t>Experience has shown that an explicit binding between the RTP streams,
            agnostic of SSRC values, behaves well. That way, solutions using
            multiple RTP streams in a single RTP session and in multiple RTP sessions
            will use the same type of binding.</t>
        </section>
        <section anchor="sect-3.4.4" numbered="true" toc="default">
          <name>Forward Error Correction</name>
          <t>There exist a number of FEC-based schemes designed to mitigate packet loss in the original streams.
            Most of the FEC schemes protect a single source flow. This
            protection is achieved by transmitting a certain amount of redundant
            information that is encoded such that it can repair one or more
            instances of packet
            loss over the set of packets the redundant information protects.
            This sequence of redundant information needs to be transmitted as
            its own media stream or, in some cases, instead of the original media
            stream. Thus, many of these schemes create a need for binding related
            flows, as discussed above. Looking at the history of these schemes,
            there are schemes using multiple SSRCs and schemes using multiple RTP
            sessions, and some schemes that support both modes of operation.</t>
          <t>Using multiple RTP sessions supports the case where some set of
            receivers might not be able to utilize the FEC information. By placing
            it in a separate RTP session and if separating RTP sessions at the
            transport level, FEC can easily be ignored at the transport level,
            without considering any RTP-layer information.</t>
          <t>In usages involving multicast, sending FEC information in a separate multicast group allows for similar flexibility. This is especially
            useful when receivers see heterogeneous packet loss rates. A receiver
            can decide, based on measurement of experienced packet loss rates,
            whether to join a multicast group with suitable FEC data repair
            capabilities.</t>
        </section>
      </section>
    </section>
    <section anchor="sect-4" numbered="true" toc="default">
      <name>Considerations for RTP Multiplexing</name>
      <section anchor="sect-4.1" numbered="true" toc="default">
        <name>Interworking Considerations</name>
        <t>There are several different kinds of interworking, and this section
          discusses two: interworking directly between different applications and
          the interworking of applications through an RTP translator. The discussion includes
          the implications of potentially different RTP multiplexing point
          choices and limitations that have to be considered when working with
          some legacy applications.</t>
        <section anchor="sect-4.1.1" numbered="true" toc="default">
          <name>Application Interworking</name>
          <t>It is not uncommon that applications or services of similar but not
            identical usage, especially those intended for interactive
            communication, encounter a situation where one wants to interconnect
            two or more of these applications.</t>
          <t>In these cases, one ends up in a situation where one might use a
            gateway to interconnect applications. This gateway must then either
            change the multiplexing structure or adhere to the respective
            limitations in each application.</t>
          <t>There are two fundamental approaches to building a gateway: using
            RTP translator interworking (RTP bridging), where the gateway acts
            as an RTP translator with the two interconnected applications being
            members of the same RTP session; or using gateway interworking
            (<xref target="sect-4.1.3"/>) with
            RTP termination, where there are independent RTP sessions between
          each interconnected application and the gateway.</t>
          <t>For interworking to be feasible, any security solution in use needs
            to be compatible and capable of exchanging keys with either the peer
            or the gateway under the trust model being used. Secondly, the applications
            need to use media streams in a way that makes sense in both applications.
          </t>
        </section>
        <section anchor="sect-4.1.2" numbered="true" toc="default">
          <name>RTP Translator Interworking</name>
          <t>From an RTP perspective, the RTP translator approach could work if
            all the applications are using the same codecs with the same payload
            types, have made the same multiplexing choices, and have the same
            capabilities regarding the number of simultaneous RTP streams combined with the
            same set of RTP/RTCP extensions being supported. Unfortunately, this
            might not always be true.</t>
          <t>When a gateway is implemented via an RTP translator, an important
            consideration is if the two applications being interconnected need to
            use the same approach to multiplexing. If one side is using RTP
            session multiplexing and the other is using SSRC multiplexing with BUNDLE
            <xref target="RFC8843" format="default"/>, it may be possible
            for the RTP translator to map the RTP streams between both
            sides using some method, e.g., based on the number and order of SDP "m="
            lines from each side. There are also challenges related to
            SSRC collision handling, since, unless SSRC translation is applied on the
            RTP translator, there may be a collision on the SSRC multiplexing
            side that the RTP session multiplexing side will not be aware of.
            Furthermore, if one of the applications is capable of
            working in several modes (such as being able to use additional RTP
            streams in one RTP session or multiple RTP sessions at will) and the
            other one is not, successful interconnection depends on locking the
            more flexible application into the operating mode where
            interconnection can be successful, even if none of the participants are using
            the less flexible application when the RTP sessions are being created.</t>
        </section>
        <section anchor="sect-4.1.3" numbered="true" toc="default">
          <name>Gateway Interworking</name>
          <t>When one terminates RTP sessions at the gateway, there are certain
            tasks that the gateway has to carry out:</t>
          <ul spacing="normal">
            <li>Generating appropriate RTCP reports for all RTP streams (possibly
                based on incoming RTCP reports) originating from SSRCs controlled by
                the gateway.</li>
            <li>Handling SSRC collision resolution in each application's RTP sessions.</li>
            <li>Signaling, choosing, and policing appropriate bitrates for each
                session.</li>
          </ul>
          <t>For applications that use any security mechanism, e.g., in the form
            of SRTP, the gateway needs to be able to decrypt and verify source
            integrity of the incoming packets and then re-encrypt, integrity protect,
            and sign the packets as the peer in the other application's security context.
            This is necessary even if all that's needed is a simple remapping of SSRC
            numbers. If this is done, the gateway also needs to be a member of the
            security contexts of both sides and thus a trusted entity.</t>
          <t>The gateway might also need to apply transcoding (for
            incompatible codec types), media-level adaptations that cannot be
            solved through media negotiation (such as rescaling for incompatible
            video size requirements), suppression of content that is known not to
            be handled in the destination application, or the addition or removal
            of redundancy coding or scalability layers to fit the needs of the
            destination domain.</t>
          <t>From the above, we can see that the gateway needs to have an
            intimate knowledge of the application requirements; a gateway is by
            its nature application specific and not a commodity product.</t>
          <t>These gateways might therefore potentially block
            application evolution by blocking RTP and RTCP extensions that the
            applications have been extended with but that are unknown to the
            gateway.</t>
          <t>If one uses a security mechanism like SRTP, the gateway and the
            necessary trust in it by the peers pose an additional risk to 
            communication security. The gateway also incurs additional
            complexities in the 
            form of the decrypt-encrypt cycles needed for each forwarded packet.
            SRTP, due to its keying structure, also requires that each RTP session
            need different master keys, as the use of the same key in two RTP
            sessions can, for some ciphers, result in a reuse of a one-time pad that
            completely breaks the confidentiality of the packets.</t>
        </section>
        <section anchor="sect-4.1.4" numbered="true" toc="default">
          <name>Legacy Considerations for Multiple SSRCs</name>
          <t>Historically, the most common RTP use cases have been point-to-point
            Voice over IP (VoIP) or streaming applications, commonly with no
            more than one media source per endpoint and media type (typically
            audio or video). Even in conferencing applications, especially
            voice-only, the conference focus or bridge provides to each participant a single stream
            containing a mix of the other participants. It is
            also common to have individual RTP sessions between each endpoint and
            the RTP mixer, meaning that the mixer functions as an RTP-terminating
            gateway.</t>
          <t>Applications and systems that aren't updated to handle multiple streams following
            these recommendations can have issues with participating in RTP
            sessions containing multiple SSRCs within a single session, such as:</t>
          <ol spacing="normal" type="1">
            <li>The need to handle more than one stream simultaneously rather than
                replacing an already-existing stream with a new one.</li>
            <li>Being capable of decoding multiple streams simultaneously.</li>
            <li>Being capable of rendering multiple streams simultaneously.</li>
          </ol>
          <t>This indicates that gateways attempting to interconnect to this
            class of devices have to make sure that only one RTP stream of each
            media type gets delivered to the endpoint if it's expecting only one and
            that the multiplexing format is what the device expects. It is highly
            unlikely that RTP translator-based interworking can be made to
            function successfully in such a context.</t>
        </section>
      </section>
      <section anchor="sect-4.2" numbered="true" toc="default">
        <name>Network Considerations</name>
        <t>The RTP implementer needs to consider that the RTP multiplexing choice
          also impacts network-level mechanisms.</t>
        <section anchor="sect-4.2.1" numbered="true" toc="default">
          <name>Quality of Service</name>
          <t>QoS mechanisms are either flow based or packet marking
            based. RSVP
            <xref target="RFC2205" format="default"/>
            is an example of a flow-based mechanism, while Diffserv
            <xref target="RFC2474" format="default"/>
            is an example of a packet-marking-based mechanism.</t>
          <t>For a flow-based scheme, additional SSRCs will receive the
            same QoS as all other RTP streams being part of the same 5-tuple
            (protocol, source address, destination address, source port,
            destination port), which is the most common selector for flow-based QoS.</t>
          <t>For a packet-marking-based scheme, the method of multiplexing will
            not affect the possibility of using QoS. Different
            Differentiated Services Code Points (DSCPs) can be assigned to
            different packets within a transport flow (5-tuple) as well as within an RTP stream,
            assuming the usage of UDP or other transport protocols that do not have issues
            with packet reordering within the transport flow (5-tuple). 
            To avoid packet-reordering issues, packets belonging to the same RTP
            flow should limit their use of DSCPs to packets whose corresponding
            Per-Hop Behavior (PHB) do not enable reordering. If the transport protocol being used assumes in&nbhy;order
            delivery of packets (e.g., TCP and the Stream Control Transmission
            Protocol (SCTP)),
            then a single DSCP should be used. 
            For more discussion on this topic, see <xref target="RFC7657" format="default"/>.</t>
          <t>The method for assigning marking to packets can impact what number
            of RTP sessions to choose. If this marking is done using a network
            ingress function, it can have issues discriminating the different RTP
            streams. The network API on the endpoint also needs to be capable of
            setting the marking on a per-packet basis to reach full
            functionality.</t>
        </section>
        <section anchor="sect-4.2.2" numbered="true" toc="default">
          <name>NAT and Firewall Traversal</name>
          <t>In today's networks, there exist a large number of middleboxes. Those
            that normally have the most impact on RTP are Network Address
            Translators (NATs) and Firewalls (FWs).</t>
          <t>Below, we analyze and comment on the impact of requiring more
            underlying transport flows in the presence of NATs and FWs:</t>
          <dl newline="true" spacing="normal">
            <dt>Endpoint Port Consumption:</dt>
            <dd>A given IP address only has 65536
                available local ports per transport protocol for all consumers of
                ports that exist on the machine. This is normally never an issue for
                an end-user machine. It can become an issue for servers that
                handle a
                large number of simultaneous streams. However, if the application uses
                ICE to authenticate STUN requests, a server can serve multiple
                endpoints from the same local port and use the whole 5-tuple (source
                and destination address, source and destination port, protocol) as
                the identifier of flows after having securely bound them to the remote
                endpoint address using the STUN request. In theory, the minimum number
                of media server ports needed is the maximum number of simultaneous
                RTP sessions a single endpoint can use. In practice, implementations
                will probably benefit from using more server ports to simplify
                implementation or avoid performance bottlenecks.</dd>
            <dt>NAT State:</dt>
            <dd>If an endpoint sits behind a NAT, each flow it generates
                to an external address will result in a state that has to be kept in
                the NAT. That state is a limited resource. In home or Small
                Office&wj;/Home Office (SOHO) NATs, the most limited resource is
                memory or processing. For large-scale NATs serving many internal
                endpoints, available external ports are likely the scarce resource.
                Port limitations are primarily a problem for larger centralized NATs
                where endpoint-independent mapping requires each flow to use one port
                for the external IP address. This affects the maximum number of
                internal users per external IP address. However, as a comparison, a
                real-time video conference session with audio and video likely uses
                less than 10 UDP flows, compared to certain web applications that can
                use 100+ TCP flows to various servers from a single browser
            instance.</dd> 
            <dt>Extra Delay Added by NAT Traversal:</dt>
            <dd>Performing the NAT/FW traversal takes a
                certain amount of time for each flow. The best-case scenario for
                additional NAT/FW traversal time after finding the first valid candidate
                pair following the specified ICE procedures is 1.5*RTT +
                Ta*(Additional_Flows-1), where Ta is the pacing timer. That assumes a
                message in one direction, immediately followed by a
return message in the opposite direction to confirm reachability.
                It isn't more, because ICE first finds one candidate pair
                that works, prior to attempting to establish multiple flows. Thus,
                there is no extra time until one has found a working candidate pair.
                Based on that working pair, the extra time is needed to 
                establish the additional flows (two or three, in most cases)
                in parallel. However, packet
                loss causes extra delays of at least 500 ms (the minimal
                retransmission timer for ICE).</dd>
            <dt>NAT Traversal Failure Rate:</dt>
            <dd>Due to the need to establish more than a
                single flow through the NAT, there is some risk that establishing the
                first flow will succeed but one or more of the additional
                flows will fail.
                The risk of this happening is hard to quantify but should be fairly
                low, as one flow from the same interfaces has just been successfully
                established. Thus, only such rare events as NAT resource overload, 
                selecting particular port numbers that are filtered, etc., ought to be
                reasons for failure.</dd>
            <dt>Deep Packet Inspection and Multiple Streams:</dt>
            <dd>FWs differ in how
                deeply they inspect packets. 
                Previous experience using FWs and Session Border Gateways
                (SBGs) with RTP shows that there is a significant risk that
                the FWs and SBGs will reject RTP sessions that use multiple SSRCs.</dd>
          </dl>
          <t>Using additional RTP streams in the same RTP session and transport
            flow does not introduce any additional NAT traversal complexities per
            RTP stream. This can be compared with (normally) one or two additional
            transport flows per RTP session when using multiple RTP sessions.
            Additional lower-layer transport flows will be needed, unless an
            explicit demultiplexing layer is added between RTP and the transport
            protocol. At the time of this writing, no such mechanism was defined.</t>
        </section>
        <section anchor="sect-4.2.3" numbered="true" toc="default">
          <name>Multicast</name>
          <t>Multicast groups provide a powerful tool for a number of real-time
            applications, especially those that desire broadcast-like
            behaviors with one endpoint transmitting to a large number of
            receivers, like in IPTV. An RTP/RTCP extension to
            better support Source-Specific Multicast (SSM)
            <xref target="RFC5760" format="default"/> is also available. Many-to-many communication, which RTP
            <xref target="RFC3550" format="default"/>
            was originally built to support, has several limitations in common with
            multicast.</t>
          <t>One limitation is that, for any group, sender-side adaptations with the
            intent to suit all receivers would have to adapt to the most limited
            receiver experiencing the worst conditions among the group participants,
            which imposes degradation for all participants. For broadcast-type
            applications with a large number of receivers, this is not
            acceptable. Instead, various receiver-based solutions are employed to
            ensure that the receivers achieve the best possible performance. By using
            scalable encoding and placing each scalability layer in a different
            multicast group, the receiver can control the amount of traffic it
            receives. To have each scalability layer in a different multicast
            group, one RTP session per multicast group is used.</t>
          <t>In addition, the transport flow considerations in multicast are a
            bit different from unicast; NATs with port translation are not useful
            in the multicast environment, meaning that the entire port range of
            each multicast address is available for distinguishing between RTP
            sessions.</t>
          <t>Thus, when using broadcast applications it appears easiest and most
            straightforward to use multiple RTP sessions for sending different
            media flows used for adapting to network conditions. It is also common
            that streams improving transport robustness are sent in their own
            multicast group to allow for interworking with legacy applications or to support
            different levels of protection.</t>
          <t>Many-to-many applications have different needs, and the most
            appropriate multiplexing choice will depend on how the actual application is
            realized. Multicast applications that are capable of using sender-side
            congestion control can avoid the use of multiple multicast sessions and RTP
            sessions that result from the use of receiver-side congestion control.</t>
          <t>The properties of a broadcast application using RTP multicast are
          as follows:</t>
          <ol spacing="normal" type="1">
            <li>The application uses a group of RTP sessions -- not just one. Each endpoint will need to
                be a member of a number of RTP sessions in order to perform well.</li>
            <li>Within each RTP session, the number of RTP receivers is likely to
                be much larger than the number of RTP senders.</li>
            <li>The application needs signaling functions to identify the
                relationships between RTP sessions.</li>
            <li>The application needs signaling or RTP/RTCP functions to identify
                the relationships between SSRCs in different RTP sessions when 
more complex relations than those that can be expressed by the CNAME exist.</li>
          </ol>
          <t>Both broadcast and many-to-many multicast applications share a
            signaling requirement; all of the participants need the
            same RTP and payload type configuration. Otherwise, A could, for
            example, be using payload type 97 as the video codec H.264 while B
            thinks it is MPEG-2. SDP offer/answer
            <xref target="RFC3264" format="default"/>
            is not appropriate for ensuring this property in a broadcast/multicast
            context. The signaling aspects of broadcast/multicast are not
            explored further in this memo.</t>
          <t>Security solutions for this type of group communication are also
            challenging. First, the key-management mechanism and the security protocol need
            to support group communication. Second, source authentication requires
            special solutions. For more discussion on this topic, please review <xref target="RFC7201">"Options for Securing RTP Sessions"</xref>.</t>
        </section>
      </section>
      <section anchor="sect-4.3" numbered="true" toc="default">
        <name>Security and Key-Management Considerations</name>
        <t>When dealing with point-to-point two-member RTP sessions only, there
          are few security issues that are relevant to the choice of having one
          RTP session or multiple RTP sessions. However, there are a few aspects
          of multi-party sessions that might warrant consideration. For general
          information regarding possible methods of securing RTP, please review
          <xref target="RFC7201"/>.</t>
        <section anchor="sect-4.3.1" numbered="true" toc="default">
          <name>Security Context Scope</name>
          <t>When using SRTP
            <xref target="RFC3711" format="default"/>,
            the security context scope is important and can be a necessary
            differentiation in some applications. As SRTP's crypto suites are (so
            far) built around symmetric keys, the receiver will need to have the
            same key as the sender. As a result, no one in a multi-party
            session can be certain that a received packet was really sent by the
            claimed sender and not by another party having access to the key. The
            single SRTP algorithm not having this property is Timed
            Efficient Stream Loss-Tolerant Authentication (TESLA) source
            authentication <xref target="RFC4383" format="default"/>. However, TESLA adds delay
            to achieve source authentication. In most cases, symmetric ciphers
            provide sufficient security properties, but in a few cases they can create issues.</t>
          <t>The first case is when someone leaves a multi-party session and one
            wants to ensure that the party that left can no longer access the RTP
            streams. This requires that everyone rekey without disclosing the
            new keys to the excluded party.</t>
          <t>A second case is when security is used as an enforcing mechanism for
            stream access differentiation between different receivers. Take, for
            example, a scalable layer or a high-quality simulcast version that only
            users paying a premium are allowed to access. The mechanism preventing a receiver
            from getting the high-quality stream can be based on the stream being
            encrypted with a key that users can't access without paying a premium,
            using the key-management mechanism to limit access to the key.</t>
          <t>As specified in <xref target="RFC3711" format="default"/>, SRTP uses
            unique keys per SSRC;
            however, the original assumption was a single-session master key from
            which SSRC-specific RTP and RTCP keys were derived. However, that
            assumption was proven incorrect, as the application usage and
            the developed key-management mechanisms have chosen many different
            methods for ensuring unique keys per SSRC. The key-management functions have different
            abilities to establish different sets of keys, normally on a
            per-endpoint basis. For example, DTLS-SRTP
            <xref target="RFC5764" format="default"/>
            and Security Descriptions
            <xref target="RFC4568" format="default"/>
            establish different keys for outgoing and incoming traffic from an
            endpoint. This key usage has to be written into the cryptographic
            context, possibly associated with different SSRCs. Thus, limitations
            do exist, depending on the chosen key-management method and due to
            the integration
            of particular implementations of the key-management method and SRTP.</t>
        </section>
        <section anchor="sect-4.3.2" numbered="true" toc="default">
          <name>Key Management for Multi-party Sessions</name>
          <t>The capabilities of the key-management method combined with the RTP multiplexing
            choices affect the resulting security properties, control over the
            secured media, and who has access to it.</t>
          <t>Multi-party sessions contain at least one RTP stream from each active
            participant. Depending on the multi-party topology
            <xref target="RFC7667" format="default"/>,
            each participant can both send and receive multiple RTP streams.
            Transport translator-based sessions (Topo-Trn-Translator) and multicast
            sessions (Topo-ASM) can use neither Security Descriptions
            <xref target="RFC4568" format="default"/>
            nor DTLS-SRTP
            <xref target="RFC5764" format="default"/>
            without an extension, because each endpoint provides its own set of
            keys. In
            centralized conferences, the signaling counterpart is a conference
            server, and the transport translator is the media-plane unicast
            counterpart (to which DTLS messages would be sent). Thus, an extension
            like Encrypted Key Transport <xref target="RFC8870" format="default"/>
            or a solution based on Multimedia Internet KEYing (MIKEY) <xref target="RFC3830" format="default"/> that allows for
            keying all session participants with the same master key is needed.</t>
          <t>Privacy-Enhanced RTP Conferencing (PERC) also enables a different
            trust model with semi-trusted media-switching RTP middleboxes
            <xref target="RFC8871" format="default"/>.</t>
        </section>
        <section anchor="sect-4.3.3" numbered="true" toc="default">
          <name>Complexity Implications</name>
          <t>There can be complex interactions between the choice of
          multiplexing and topology and the security functions. This becomes especially
            evident in RTP topologies having any type of middlebox that processes
            or modifies RTP/RTCP packets. While the overhead of
            an RTP translator or mixer rewriting an SSRC value in the RTP packet
            of an unencrypted session is low, the cost is higher when using cryptographic
            security functions. For example, if using SRTP
            <xref target="RFC3711" format="default"/>, the actual security context and exact crypto
            key are determined by the SSRC field value. If one changes the
            SSRC value, the
            encryption and authentication must use another key. Thus, changing the
            SSRC value implies a decryption using the old SSRC and its security
            context, followed by an encryption using the new one.</t>
        </section>
      </section>
    </section>
    <section anchor="sect-5" numbered="true" toc="default">
      <name>RTP Multiplexing Design Choices</name>
      <t>This section discusses how some RTP multiplexing design choices can
        be used in applications to achieve certain goals and summarizes the
        implications of such choices. The benefits and downsides of each
      design are also discussed.</t>
      <section anchor="sect-5.1" numbered="true" toc="default">
        <name>Multiple Media Types in One Session</name>
        <t>This design uses a single RTP session for multiple different media
          types, like audio and video, and possibly also transport robustness
          mechanisms like FEC or retransmission. An endpoint can send zero,
          one, or multiple media sources per media type, resulting in a number of RTP
          streams of various media types for both source and redundancy streams.</t>
        <t>Advantages:</t>
        <ol spacing="normal" type="1">
          <li>
            <t>Only a single RTP session is used, which implies:</t>
            <ul spacing="normal">
              <li>Minimal need to keep NAT/FW state.</li>
              <li>Minimal NAT/FW traversal cost.</li>
              <li>Fate-sharing for all media flows.</li>
              <li>Minimal overhead for security association establishment.</li>
            </ul>
          </li>
          <li>Dynamic allocation of RTP streams can be handled almost entirely
          at the RTP level.
          The extent to which this allocation can be kept at the RTP level depends on the application's needs
          for an explicit indication of stream usage and in how timely a
          fashion that information can be signaled.</li>
        </ol>
        <t>Disadvantages:</t>
        <ol spacing="normal" type="1">
          <li>It is less suitable for interworking with other applications that use
              individual RTP sessions per media type or multiple sessions for a
              single media type, due to the risk of SSRC collisions and thus a potential
              need for SSRC translation.</li>
          <li>Negotiation of individual bandwidths for the different media types is
              currently only possible in SDP when using RID
              <xref target="RFC8851" format="default"/>.</li>
          <li>It is not suitable for split component terminals (see
              <xref target="RFC7667" sectionFormat="of" section="3.10"/>).</li>
          <li>Flow-based QoS cannot be used to provide separate treatment of RTP
              streams compared to others in the single RTP session.</li>
          <li>If there is significant asymmetry between the RTP streams' RTCP
              reporting needs, there are some challenges related to configuration and usage
              to avoid wasting RTCP reporting on the RTP stream that does not need
              such frequent reporting.</li>
          <li>It is not suitable for applications where some receivers like to receive
              only a subset of the RTP streams, especially if multicast or a transport
              translator is being used.</li>
          <li>There are some additional concerns regarding legacy implementations that do
              not support the RTP specification fully when it comes to handling multiple
              SSRCs per endpoint, as multiple simultaneous media types are sent as
              separate SSRCs in the same RTP session.</li>
          <li>If the applications need finer control over which session
              participants are included in different sets of security
              associations, most key-management mechanisms will have difficulties establishing
              such a session.</li>
        </ol>
      </section>
      <section anchor="sect-5.2" numbered="true" toc="default">
        <name>Multiple SSRCs of the Same Media Type</name>
        <t>In this design, each RTP session serves only a single media type.
          The RTP session can contain multiple RTP streams, from either a single
          endpoint or multiple endpoints. This commonly creates a low
          number of RTP sessions, typically only one for audio and one for
          video, with a corresponding need for two listening ports when using
          RTP/RTCP multiplexing
          <xref target="RFC5761" format="default"/>.</t>
        <t>Advantages:</t>
        <ol spacing="normal" type="1">
          <li>It works well with split component terminals (see <xref
          target="RFC7667" sectionFormat="of" section="3.10"/>) where the
          split is per media type.</li> 
          <li>It enables flow-based QoS with different prioritization levels between media
              types.</li>
          <li>For applications with dynamic usage of RTP streams (i.e.,
          streams are frequently
              added and removed), having much of the state associated with the RTP
              session rather than per individual SSRC can avoid the need for
              in-session signaling of meta-information about each SSRC. In simple
                          cases, this allows for unsignaled RTP streams where session-level 
                          information and an RTCP SDES item (e.g., CNAME) are
                          sufficient. In the more complex cases where more source-specific metadata needs to be 
                          signaled, the SSRC can be associated with an intermediate identifier, 
                          e.g., the MID conveyed as an SDES item as defined in
                          <xref target="RFC8843" sectionFormat="of" section="15"/>.</li>
          <li>The overhead of security association establishment is low.</li>
        </ol>
        <t>Disadvantages:</t>
        <ol spacing="normal" type="1">
          <li>
            <t>A slightly higher number of RTP sessions are needed, compared
              to multiple media types in one session
              (<xref target="sect-5.1" format="default"/>). This implies the following:
            </t>
            <ul spacing="normal">
              <li>More NAT/FW state is needed.</li>
              <li>The cost of NAT/FW traversal is increased in terms of both processing and delay.</li>
            </ul>
          </li>
          <li>There is some potential for concern regarding legacy implementations that don't
              support the RTP specification fully when it comes to handling multiple
              SSRCs per endpoint.</li>
          <li>It is not possible to control security associations for sets of RTP
              streams within the same media type with today's key-management
              mechanisms, unless these are split into different RTP sessions
              (<xref target="sect-5.3" format="default"/>).</li>
        </ol>
        <t>For RTP applications where all RTP streams of the same media type
          share the same usage, this structure provides efficiency gains in
          the amount
          of network state used and provides more fate-sharing with other media
          flows of the same type. At the same time, it still maintains
          almost all functionalities for the negotiation signaling of properties per
          individual media type and also
          enables flow-based QoS prioritization between media types. It handles
          multi-party sessions well, independently of multicast or centralized
          transport distribution, as additional sources can dynamically enter
          and leave the session.</t>
      </section>
      <section anchor="sect-5.3" numbered="true" toc="default">
        <name>Multiple Sessions for One Media Type</name>
        <t>This design goes one step further than the design discussed in <xref target="sect-5.2" format="default"/>
          by also using multiple RTP sessions for a single media type. The main
          reason for going in this direction is that the RTP application needs
          separation of the RTP streams according to their usage, such as, for example, scalability
          over multicast, simulcast, the need for extended QoS prioritization, or the need
          for fine-grained signaling using RTP session-focused signaling tools.</t>
        <t>Advantages:</t>
        <ol spacing="normal" type="1">
          <li>This design is more suitable for multicast usage where receivers can individually
              select which RTP sessions they want to participate in, assuming
              that each
              RTP session has its own multicast group.</li>
          <li>When multiple different usages exist, the application can
          indicate its usage of the RTP streams at the RTP
              session level.</li>
          <li>There is less need for SSRC-specific explicit signaling for each media
              stream and thus a reduced need for explicit and timely signaling when
              RTP streams are added or removed.</li>
          <li>It enables detailed QoS prioritization for flow-based mechanisms.</li>
          <li>It works well with split component terminals (see
              <xref target="RFC7667" sectionFormat="of" section="3.10"/>).</li>
          <li>The scope for who is included in a security association can be
              structured around the different RTP sessions, thus enabling such
              functionality with existing key-management mechanisms.</li>
        </ol>
        <t>Disadvantages:</t>
        <ol spacing="normal" type="1">
          <li>There is an increased amount of session configuration state compared
              to multiple SSRCs of the same media type (<xref target="sect-5.2"/>), due to the increased amount
              of RTP sessions.</li>
          <li>For RTP streams that are part of scalability, simulcast, or
              transport robustness, a method for binding sources across multiple RTP
              sessions is needed.</li>
          <li>There is some potential for concern regarding legacy implementations that
              don't support the RTP specification fully when it comes to handling
              multiple SSRCs per endpoint.</li>
          <li>The overhead of security association establishment is higher, due
              to the increased number of RTP sessions.</li>
          <li>If the applications need finer control over which participants
     in a given RTP session are included in different sets of
     security associations, most of today's key-management mechanisms
     will have difficulties establishing such a session.</li>
        </ol>
        <t>For more-complex RTP applications that have several different
          usages for RTP streams of the same media type or that use scalability or
          simulcast, this solution can enable those functions, at the cost of
          increased overhead associated with the additional sessions. This type
          of structure is suitable for more-advanced applications as well as
          multicast-based applications requiring differentiation to different
          participants.</t>
      </section>
      <section anchor="sect-5.4" numbered="true" toc="default">
        <name>Single SSRC per Endpoint</name>
        <t>In this design, each endpoint in a point-to-point session has only a
          single SSRC; thus, the RTP session contains only two SSRCs -- one local
          and one remote. This session can be used either unidirectionally
          (i.e., one SSRC sends an RTP stream that is received by the other
          SSRC) or bidirectionally (i.e., the two SSRCs both send an RTP
          stream and receive the RTP stream sent by the other endpoint).
 If the application needs additional media flows
          between the endpoints, it will have to establish additional RTP
          sessions.</t>
        <t>Advantages:</t>
        <ol spacing="normal" type="1">
          <li>This design has great potential for interoperability with legacy
          applications, as it will
              not tax any RTP stack implementations.</li>
          <li>The signaling system makes it possible to negotiate and describe
     the exact formats and bitrates for each RTP stream, especially
     using today's tools in SDP.</li>
          <li>It is possible to control security associations per RTP stream with
              current key-management functions, since each RTP stream is directly related to
              an RTP session and the most commonly used keying mechanisms operate on a
              per-session basis.</li>
        </ol>
        <t>Disadvantages:</t>
        <ol spacing="normal" type="1">
          <li>The amount of NAT/FW state grows linearly with the number
              of RTP streams.</li>
          <li>NAT/FW traversal increases delay and resource consumption.</li>
          <li>There are likely more signaling message and signaling processing
              requirements due to the increased amount of session-related information.</li>
          <li>There is higher potential for a single RTP stream to fail during
              transport between the endpoints, due to the need for a separate
              NAT/FW traversal for every RTP stream, since there is only one stream per session.</li>
          <li>The amount of explicit state for relating RTP streams grows, depending
               on how the application relates RTP streams.</li>
          <li>Port consumption might become a problem for centralized
              services, where the central node's port or 5-tuple filter consumption
              grows rapidly with the number of sessions.</li>
          <li>For applications where RTP stream usage is highly dynamic,
          i.e., entities frequently enter and leave sessions, the amount of signaling can become high. Issues
              can also arise from the need for timely establishment of additional RTP
              sessions.</li>
          <li>If, against the recommendation in <xref target="RFC3550"/>, the same SSRC value is reused in
              multiple RTP sessions rather than being randomly chosen, interworking
              with applications that use a different multiplexing structure will
              require SSRC translation.</li>
        </ol>
        <t>RTP applications with a strong need to interwork with legacy RTP
          applications can potentially benefit from this structure. However, a
          large number of media descriptions in SDP can also run into issues
          with existing implementations. For any application needing a larger
          number of media flows, the overhead can become very significant. This
          structure is also not suitable for non-mixed multi-party sessions, as any given
          RTP stream from each participant, although having the same usage in the
          application, needs its own RTP session. In addition, the dynamic
          behavior that can arise in multi-party applications can tax the
          signaling system and make timely media establishment more difficult.</t>
      </section>
      <section anchor="sect-5.5" numbered="true" toc="default">
        <name>Summary</name>
        <t>Both the "single SSRC per endpoint" (<xref
        target="sect-5.4"/>) and "multiple media types in one
          session" (<xref target="sect-5.1"/>) cases require full explicit signaling of the media
          stream relationships. However, they operate on two different levels, where
          the first primarily enables session-level binding and the second
          needs SSRC-level binding. From another perspective, the two solutions
          are the two extremes when it comes to the number of RTP sessions
          needed.</t>
        <t>The two other designs -- multiple SSRCs of the same media type
        (<xref target="sect-5.2"/>) and
          multiple sessions for one media type (<xref target="sect-5.3"/>) -- are two examples that primarily
          allow for some implicit mapping of the role or usage of the RTP
          streams based on which RTP session they appear in. Thus, they potentially
          allow for less signaling and, in particular, reduce the need for
          real-time signaling in sessions with a dynamically changing number
          of RTP streams. They also represent points
          between the first two designs when it comes to the amount of RTP
          sessions established, i.e., they represent an attempt to balance the
          amount of RTP sessions with the functionality the communication
          session provides at both the network level and the signaling level.</t>
      </section>
    </section>
    <section anchor="sect-6" numbered="true" toc="default">
      <name>Guidelines</name>
      <t>This section contains a number of multi-stream guidelines for
        implementers, system designers, and specification writers.</t>
      <dl newline="true" spacing="normal">
        <dt>Do not require the use of the same SSRC value across RTP sessions:</dt>
        <dd>
            As discussed in <xref target="sect-3.4.3" format="default"/>,
            there are downsides to using the same SSRC in multiple RTP sessions
            as a mechanism to bind related RTP streams together. It is instead
            recommended to use a mechanism to explicitly signal the relationship,
            in either RTP&wj;/RTCP or the signaling mechanism used to establish
            the RTP session(s).</dd>
        <dt>Use additional RTP streams for additional media sources:</dt>
        <dd>In
            the cases where an RTP endpoint needs to transmit additional RTP
            streams of the same media type in the application, with the same
            processing requirements at the network and RTP layers, it is suggested
            to send them in the same RTP session. For example, in the case of a telepresence room
            where there are three cameras and each camera captures two persons
            sitting at the table, we suggest that each camera send its own RTP stream within
            a single RTP session.</dd>
        <dt>Use additional RTP sessions for streams with different requirements:</dt>
        <dd>
            When RTP streams have different processing requirements from the network or
            the RTP layer at the endpoints, it is suggested that the different
            types of streams be put in different RTP sessions. This includes the
            case where different participants want different subsets of the set of
            RTP streams.</dd>
        <dt>Use grouping when using multiple RTP sessions:</dt>
        <dd> When
            using multiple RTP session solutions, it is suggested to explicitly
            group the involved RTP sessions when needed using a signaling
            mechanism -- for example, see <xref target="RFC5888">"The Session
            Description Protocol (SDP) Grouping Framework"</xref> -- using some appropriate grouping semantics.</dd>
        <dt>Ensure that RTP/RTCP extensions support multiple RTP streams as well as multiple RTP sessions:</dt>
        <dd>When
            defining an RTP or RTCP extension, the creator needs to consider if
            this extension is applicable for use with additional SSRCs and multiple
            RTP sessions. Any extension intended to be generic must support both.
            Extensions that are not as generally applicable will have to consider
            whether interoperability is better served by defining a single solution or
            providing both options.</dd>
        <dt>Provide adequate extensions for transport support:</dt>
        <dd>When defining new RTP/RTCP
            extensions intended for transport support, like the retransmission or
            FEC mechanisms, they must include support for both multiple RTP
            streams in the same RTP session and multiple RTP sessions, such that
            application developers can choose freely from the set of mechanisms
            without concerning themselves with which of the multiplexing choices a
            particular solution supports.</dd>
      </dl>
    </section>
    <section anchor="sect-8" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>This document has no IANA actions.</t>
    </section>
    <section anchor="sect-9" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>The security considerations discussed in the RTP specification
        <xref target="RFC3550" format="default"/>;
        any applicable RTP profile
        <xref target="RFC3551" format="default"/> <xref target="RFC4585"
        format="default"/> <xref target="RFC3711" format="default"/>;
          and the extensions for sending multiple media types in a single RTP
          session
        <xref target="RFC8860" format="default"/>, RID
        <xref target="RFC8851" format="default"/>, BUNDLE
        <xref target="RFC8843" format="default"/>,
        <xref target="RFC5760" format="default"/>, and
        <xref target="RFC5761" format="default"/> apply if selected and thus need to be considered in the evaluation.</t>
      <t><xref target="sect-4.3" format="default"/> discusses the security implications of choosing
        multiple SSRCs vs. multiple RTP sessions.</t>
    </section>
  </middle>
  <back>
    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3550.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3551.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3711.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4585.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5576.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5760.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5761.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7656.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7667.xml"/>

<!-- draft-ietf-avtcore-multi-media-rtp-session (RFC 8860) -->
<reference anchor="RFC8860" target="https://www.rfc-editor.org/info/rfc8860">
  <front>
    <title>Sending Multiple Types of Media in a Single RTP Session</title>
    <author initials="M." surname="Westerlund" fullname="Magnus Westerlund">
      <organization/>
    </author>
    <author initials="C." surname="Perkins" fullname="Colin Perkins">
      <organization/>
    </author>
    <author initials="J." surname="Lennox" fullname="Jonathan Lennox">
      <organization/>
    </author>
     <date month="January" year="2021"/>
   </front>
   <seriesInfo name="RFC" value="8860"/>
   <seriesInfo name="DOI" value="10.17487/RFC8860"/>
</reference>

<!-- draft-ietf-mmusic-rid (RFC 8851) -->
<reference anchor='RFC8851' target="https://www.rfc-editor.org/info/rfc8851">
<front>
<title>RTP Payload Format Restrictions</title>
<author initials='A.B.' surname='Roach' fullname='Adam Roach' role="editor">
    <organization />
</author>
<date month='January' year='2021' />
</front>
<seriesInfo name="RFC" value="8851"/>
<seriesInfo name="DOI" value="10.17487/RFC8851"/> 
</reference>

<!-- draft-ietf-mmusic-sdp-bundle-negotiation (RFC 8843) -->
    <reference anchor="RFC8843" target="https://www.rfc-editor.org/info/rfc8843">
      <front>
        <title>Negotiating Media Multiplexing Using the Session Description Protocol (SDP)</title>
        <author initials="C" surname="Holmberg" fullname="Christer Holmberg">
          <organization/>
        </author>
        <author initials="H" surname="Alvestrand" fullname="Harald Alvestrand">
          <organization/>
        </author>
        <author initials="C" surname="Jennings" fullname="Cullen Jennings">
          <organization/>
        </author>
        <date month="January" year="2021"/>
      </front>
        <seriesInfo name="RFC" value="8843"/>
        <seriesInfo name="DOI" value="10.17487/RFC8843"/>
    </reference>

<!-- draft-ietf-avtext-rid (RFC 8852) -->
<reference anchor='RFC8852' target="https://www.rfc-editor.org/info/rfc8852">
<front>
<title>RTP Stream Identifier Source Description (SDES)</title>
<author initials='A.B.' surname='Roach' fullname='Adam Roach'>
    <organization />
</author>
<author initials='S' surname='Nandakumar' fullname='Suhas Nandakumar'>
    <organization />
</author>
<author initials='P' surname='Thatcher' fullname='Peter Thatcher'>
    <organization />
</author>
<date month='January' year='2021' />
</front>
<seriesInfo name="RFC" value="8852"/>
<seriesInfo name="DOI" value="10.17487/RFC8852"/>
</reference>

<!-- draft-ietf-perc-srtp-ekt-diet (RFC 8870) -->
<reference anchor="RFC8870" target="https://www.rfc-editor.org/info/rfc8870">
 <front>
  <title>Encrypted Key Transport for DTLS and Secure RTP</title>
    <author initials="C" surname="Jennings" fullname="Cullen Jennings">
    <organization>company</organization>
    </author>
    <author initials="J" surname="Mattsson" fullname="John Mattsson">
    <organization>company</organization>
    </author>
    <author initials="D" surname="McGrew" fullname="David A. McGrew">
    <organization>company</organization>
    </author>
    <author initials="D" surname="Wing" fullname="Dan Wing">
    <organization>company</organization>
    </author>
    <author initials="F" surname="Andreasen" fullname="Flemming Andreasen">
    <organization>company</organization>
    </author>
   <date month="January" year="2021"/>
  </front>
  <seriesInfo name="RFC" value="8870"/>
  <seriesInfo name="DOI" value="10.17487/RFC8870"/>
</reference>

      </references>
      <references>
        <name>Informative References</name>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2198.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2205.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2474.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2974.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3261.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3264.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3389.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3830.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4103.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4383.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4566.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4568.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4588.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5104.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5109.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5389.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5764.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5888.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6465.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7201.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7657.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7826.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7983.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8088.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8108.xml"/>
<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8445.xml"/>

<!-- draft-ietf-perc-private-media-framework (RFC 8871) -->
<reference anchor='RFC8871' target="https://www.rfc-editor.org/info/rfc8871">
<front>
<title>A Solution Framework for Private Media in Privacy-Enhanced RTP Conferencing (PERC)</title>
<author initials='P' surname='Jones' fullname='Paul Jones'>
    <organization />
</author>
<author initials='D' surname='Benham' fullname='David Benham'>
    <organization />
</author>
<author initials='C' surname='Groves' fullname='Christian Groves'>
    <organization />
</author>
<date month='January' year='2021'/>
</front>
<seriesInfo name="RFC" value="8871"/>
<seriesInfo name="DOI" value="10.17487/RFC8871"/>
</reference>

        <reference anchor="JINGLE" target="https://xmpp.org/extensions/xep-0166.html">
          <front>
            <title>XEP-0166: Jingle</title>
            <author initials="S." surname="Ludwig">
          </author>
            <author initials="J." surname="Beda">
          </author>
            <author initials="P." surname="Saint-Andre">
          </author>
            <author initials="R." surname="McQueen">
          </author>
            <author initials="S." surname="Egan">
          </author>
            <author initials="J." surname="Hildebrand">
          </author>
            <date month="September" year="2018"/>
          </front>
        </reference>
      </references>
    </references>
    <section anchor="sect-a" numbered="true" toc="default">
      <name>Dismissing Payload Type Multiplexing</name>
      <t>This section documents a number of reasons why using the payload
        type as a multiplexing point is unsuitable for most issues related to
        multiple RTP streams. Attempting to use payload type multiplexing
        beyond its defined usage has well-known negative effects on RTP, as
        discussed below.
        To use the payload type as the single discriminator for multiple streams
        implies that all the different RTP streams are being sent with the
        same SSRC, thus using the same timestamp and sequence number space.
        The many effects of using payload type multiplexing are as follows:</t>
      <ol spacing="normal" type="1">
        <li>Constraints are placed on the RTP timestamp rate for the multiplexed media.
            For example, RTP streams that use different RTP timestamp rates cannot
            be combined, as the timestamp values need to be consistent across all
            multiplexed media frames. Thus, streams are forced to use the same RTP
            timestamp rate. When this is not possible, payload type multiplexing
            cannot be used.</li>
        <li>Many RTP payload formats can fragment a media object over multiple
            RTP packets, like parts of a video frame. These payload formats need
            to determine the order of the fragments to correctly decode them.
            Thus, it is important to ensure that all fragments related to a frame
            or a similar media object are transmitted in sequence and without
            interruptions within the object. This can be done relatively easily
            on the sender side by ensuring that the fragments of each RTP stream
            are sent in sequence.</li>
        <li>Some media formats require uninterrupted sequence number space
            between media parts. These are media formats where any missing RTP
            sequence number will result in decoding failure or invoking a repair
            mechanism within a single media context. The text&wj;/t140 payload format
            <xref target="RFC4103" format="default"/>
            is an example of such a format. These formats will need a sequence
            numbering abstraction function between RTP and the individual RTP
            stream before being used with payload type multiplexing.</li>
        <li>Sending multiple media streams in the same sequence number space
        makes it
            impossible to determine which media stream lost a packet.
            Such a scenario causes difficulties, since the receiver cannot determine to which stream it should
            apply packet-loss concealment or other stream-specific
            loss-mitigation mechanisms.</li>
        <li>If RTP retransmission
            <xref target="RFC4588" format="default"/>
            is used and packet loss occurs, it is possible to ask for the missing
            packet(s) by SSRC and sequence number -- not by payload type. If only
            some of the payload type multiplexed streams are of interest, there is
            no way to tell which missing packet or packets belong to the
            stream or streams of interest, and all lost packets need to be requested, wasting bandwidth.</li>
        <li>The current RTCP feedback mechanisms are built around providing
            feedback on RTP streams based on stream ID (SSRC), packet (sequence
            numbers), and time interval (RTP timestamps). There is almost never a
            field to indicate which payload type is reported, so sending feedback
            for a specific RTP payload type is difficult without extending
            existing RTCP reporting.</li>
        <li>The current RTCP media control messages specification
            <xref target="RFC5104" format="default"/>
            is oriented around controlling particular media flows,
            i.e., requests are done by addressing a particular SSRC. Such mechanisms
            would need to be redefined to support payload type multiplexing.</li>
        <li>The number of payload types is inherently limited. Accordingly,
            using payload type multiplexing limits the number of streams that can
            be multiplexed and does not scale. This limitation is exacerbated if
            one uses solutions like RTP and RTCP multiplexing
            <xref target="RFC5761" format="default"/>
            where a number of payload types are blocked due to the overlap between
            RTP and RTCP.</li>
        <li>At times, there is a need to group multiplexed streams. This is
            currently possible for RTP sessions and SSRCs, but there is no
            defined way to group payload types.</li>
        <li>It is currently not possible to signal bandwidth requirements per
            RTP stream when using payload type multiplexing.</li>
        <li>Most existing SDP media-level attributes cannot be applied on a
            per-payload-type basis and would require redefinition in that context.</li>
        <li>A legacy endpoint that does not understand the indication that
            different RTP payload types are different RTP streams might be
            slightly confused by the large amount of possibly overlapping or
            identically defined RTP payload types.</li>
      </ol>
    </section>
    <section anchor="sect-b" numbered="true" toc="default">
      <name>Signaling Considerations</name>
      <t>Signaling is not an architectural consideration for RTP itself, so
        this discussion has been moved to an appendix. However, it is extremely
        important for anyone building complete applications, so it is
        deserving of discussion.</t>
      <t>We document some issues here that need to be addressed when using some form of signaling to establish RTP sessions. These
           issues cannot be addressed by simply tweaking, extending, or profiling
           RTP; rather, they require a dedicated and in-depth look at the signaling
           primitives that set up the RTP sessions.</t>
      <t>There exist various signaling solutions for establishing RTP
        sessions. Many are based on SDP
        <xref target="RFC4566" format="default"/>;
        however, SDP functionality is also dependent on the signaling
        protocols carrying the SDP. The Real-Time Streaming Protocol (RTSP)
        <xref target="RFC7826" format="default"/>
        and the Session Announcement Protocol (SAP)
        <xref target="RFC2974" format="default"/>
        both use SDP in a declarative fashion, while SIP
        <xref target="RFC3261" format="default"/>
        uses SDP with the additional definition of offer/answer
        <xref target="RFC3264" format="default"/>. The impact on signaling,
        and especially on SDP,
          needs to be considered, as it can greatly affect how to deploy a
          certain multiplexing point choice.</t>
      <section anchor="sect-b.1" numbered="true" toc="default">
        <name>Session-Oriented Properties</name>
        <t>One aspect of existing signaling protocols is that they are focused on
          RTP sessions or, in the case of SDP, the concept of media
          descriptions. A number of things are signaled at the media
          description level, but those are not necessarily strictly bound to
          an RTP session and could be of interest for signaling, especially
          for a particular RTP stream (SSRC) within the session.
  The following properties have been
 identified as being potentially useful for signaling, and not only
 at the RTP session level:</t>
        <ul spacing="normal">
          <li>Bitrate and/or bandwidth can be specified today only as an
          aggregate limit, or as a common "any RTP stream" limit, unless
 either codec-specific bandwidth limiting or
              RTCP signaling using Temporary Maximum Media Stream Bit Rate
              Request (TMMBR) messages <xref target="RFC5104"
              format="default"/> is used.
</li>
          <li>Which SSRC will use which RTP payload type (this information will be
              visible in the first media packet but is sometimes useful to have
              before the packet arrives).</li>
        </ul>
        <t>Some of these issues are clearly SDP's problem rather than RTP
          limitations. However, if the aim is to deploy a solution that uses
          several SSRCs and contains several sets of RTP streams with
          different properties (encoding/packetization parameters, bitrate,
          etc.), putting each set in a different RTP session would directly
          enable negotiation of the parameters for each set. If insisting on
          additional SSRCs only, a number of signaling extensions are needed to
          clarify that there are multiple sets of RTP streams with different
          properties and that they in fact need to be kept different, since a
          single set will not satisfy the application's requirements.</t>
        <t>For some parameters, such as RTP payload type, resolution, and
          frame rate, an SSRC-linked mechanism has been proposed in
          <xref target="RFC8851" format="default"/>.</t>
      </section>
      <section anchor="sect-b.2" numbered="true" toc="default">
        <name>SDP Prevents Multiple Media Types</name>
        <t>SDP uses the "m=" line to both delineate an RTP session and specify
 the top-level media type: audio, video, text, image, application.
 This media type is used as the top-level media type for identifying
 the actual payload format and is bound to a particular payload type
 using the "a=rtpmap:" attribute.  This binding has to be loosened in
 order to use SDP to describe RTP sessions containing multiple
 top-level media types.</t>
        <t><xref target="RFC8843" format="default"/>
          describes how to let multiple SDP media descriptions use a single
          underlying transport in SDP, which allows the definition of one RTP session
          with different top-level media types.</t>
      </section>
      <section anchor="sect-b.3" numbered="true" toc="default">
        <name>Signaling RTP Stream Usage</name>
        <t>RTP streams being transported in RTP have a particular usage in
          an RTP application. In many applications to date, this usage of the RTP
          stream is implicitly signaled. For example, an application
          might choose to take all incoming audio RTP streams, mix them, and play
          them out. However, in more-advanced applications that use multiple RTP
          streams, there will be more than a single usage or purpose among the
          set of RTP streams being sent or received. RTP applications will need
          to somehow signal this usage. The signaling that is used will have to
          identify the RTP streams affected by their RTP-level identifiers,
          which means that they have to be identified by either their session or
          their SSRC + session.</t>
        <t>In some applications, the receiver cannot utilize the RTP stream at
          all before it has received the signaling message describing the RTP
          stream and its usage. In other applications, there exists a default
          handling method that is appropriate.</t>
        <t>If all RTP streams in an RTP session are to be treated in the same
          way, identifying the session is enough. If SSRCs in a session are to
          be treated differently, signaling needs to identify both the session
          and the SSRC.</t>
        <t>If this signaling affects how any RTP central node, like an RTP
          mixer or translator that selects, mixes, or processes streams, treats
          the streams, the node will also need to receive the same signaling to
          know how to treat RTP streams with different usages in the right
          fashion.</t>
      </section>
    </section>
    <section numbered="false" toc="default">
      <name>Acknowledgments</name>
      <t>The authors would like to acknowledge and thank <contact fullname="Cullen
      Jennings"/>, <contact fullname="Dale R. Worley"/>, <contact
      fullname="Huang Yihong (Rachel)"/>, <contact fullname="Benjamin
      Kaduk"/>, <contact fullname="Mirja Khlewind"/>, and <contact
      fullname="Vijay Gurbani"/> for review and comments.</t> 
    </section>
    <section numbered="false" toc="default">
      <name>Contributors</name>
      <t><contact fullname="Hui Zheng (Marvin)"/> contributed to WG draft versions -04
        and -05 of the document.
      </t>
    </section>
  </back>
</rfc>
