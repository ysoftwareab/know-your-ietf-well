<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc [
  <!ENTITY nbsp    "&#160;">
  <!ENTITY zwsp   "&#8203;">
  <!ENTITY nbhy   "&#8209;">
  <!ENTITY wj     "&#8288;">
]>

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" docName="draft-ietf-emu-eap-noob-06" number="9140" ipr="trust200902" obsoletes="" updates="" submissionType="IETF" category="std" consensus="true" xml:lang="en" tocInclude="true" tocDepth="4" symRefs="true" sortRefs="true" version="3">

  <!-- xml2rfc v2v3 conversion 3.9.1 -->
  <front>
    <title abbrev="EAP-NOOB">Nimble Out-of-Band Authentication for EAP (EAP&nbhy;NOOB)</title>
    <seriesInfo name="RFC" value="9140"/>
    <author initials="T" surname="Aura" fullname="Tuomas Aura">
      <organization>Aalto University</organization>
      <address>
        <postal>
          <street/>
          <city>Aalto</city>
          <code>00076</code>
          <country>Finland</country>
        </postal>
        <email>tuomas.aura@aalto.fi</email>
      </address>
    </author>
    <author initials="M" surname="Sethi" fullname="Mohit Sethi">
      <organization>Ericsson</organization>
      <address>
        <postal>
          <street/>
          <city>Jorvas</city>
          <code>02420</code>
          <country>Finland</country>
        </postal>
        <email>mohit@iki.fi</email>
      </address>
    </author>
    <author initials="A" surname="Peltonen" fullname="Aleksi Peltonen">
      <organization>Aalto University</organization>
      <address>
        <postal>
          <street/>
          <city>Aalto</city>
          <code>00076</code>
          <country>Finland</country>
        </postal>
        <email>aleksi.peltonen@aalto.fi</email>
      </address>
    </author>
    <date year="2021" month="December"/>
    <area>Security</area>
    <workgroup>EAP Method Update</workgroup>

    <keyword>IoT security</keyword>
    <keyword>cybersecurity</keyword>
    <keyword>network access authorization</keyword>
    <keyword>Extensible Authentication Protocol</keyword>
    <keyword>key exchange</keyword> 

    <abstract>
      <t>The Extensible Authentication Protocol (EAP) provides support for multiple
      authentication methods.
      This document defines the EAP-NOOB authentication method for
      nimble out-of-band (OOB) authentication and key derivation. The EAP method is intended
      for bootstrapping all kinds of Internet-of-Things (IoT) devices that have no
      preconfigured authentication credentials. The method makes use of a user-assisted,
      one-directional, out-of-band (OOB) message between the peer device and authentication
      server to
      authenticate the in-band key exchange. The device must have a nonnetwork input or
      output interface, such as a display, microphone, speaker, or blinking light, that can
      send or receive dynamically generated messages of tens of bytes in length.</t>
    </abstract>
  </front>
  <middle>
    <section anchor="introduction" numbered="true" toc="default">
      <name>Introduction</name>
      <t>This document describes a method for registration, authentication, and key derivation
      for network-connected smart devices, such as consumer and enterprise appliances that are
      part of the Internet of Things (IoT). These devices may be off-the-shelf hardware that
      is sold and distributed without any prior registration or credential-provisioning
      process, or they may be recycled devices after a hard reset. Thus, the device
      registration in a server database, ownership of the device, and the authentication
      credentials for both network access and application-level security must all be
      established at the time of the device deployment. Furthermore, many such devices have
      only limited user interfaces that could be used for their configuration. Often, the user
      interfaces are limited to either only input (e.g., a camera) or output (e.g., a display
      screen). The device configuration is made more challenging by the fact that the devices
      may exist in large numbers and may have to be deployed or reconfigured nimbly based on
      user needs.</t>
      <t>To summarize, devices may have the following characteristics:</t>
      <ul spacing="normal">
        <li>no preestablished relation with the intended server or user,</li>
        <li>no preprovisioned device identifier or authentication credentials, or</li>
        <li>an input or output interface that may be capable of only one-directional
	out-of-band communication.</li>
      </ul>
      <t>Many proprietary out-of-band (OOB) configuration methods exist for specific IoT
      devices. The goal of this specification is to provide an open standard and a generic
      protocol for bootstrapping the security of network-connected appliances, such as
      displays, printers, speakers, and cameras. The security bootstrapping in this
      specification makes use of a user-assisted OOB channel. The device authentication relies
      on a user having physical access to the device, and the key exchange security is based
      on the assumption that attackers are not able to observe or modify the messages conveyed
      through the OOB channel. We follow the common approach taken in pairing protocols:
      performing a Diffie-Hellman key exchange over the insecure network and authenticating
      the established key with the help of the OOB channel in order to prevent impersonation
      attacks.</t>
      <t>The solution presented here is intended for devices that have either a nonnetwork
      input or output interface, such as a camera, microphone, display screen, speaker, or
      blinking Light Emitting Diode (LED) light, that is able to send or receive dynamically
      generated messages of
      tens of bytes in length. Naturally, this solution may not be appropriate for very small
      sensors or actuators that have no user interface at all or for devices that are
      inaccessible to the user. We also assume that the OOB channel is at least partly
      automated (e.g., a camera scanning a bar code); thus, there is no need to absolutely
      minimize the length of the data transferred through the OOB channel. This differs, for
      example, from Bluetooth pairing <xref target="Bluetooth" format="default"/>,
      where it is essential to minimize the length of the manually transferred or compared
      codes. The OOB messages in this specification are dynamically generated. Thus, we do not
      support static printed registration codes. One reason for requiring dynamic OOB messages
      is that the receipt of the OOB message authorizes the server to take ownership of the
      device. Dynamic OOB messages are more secure than static printed codes, which could be
      leaked and later misused.</t>
    </section>
    <section anchor="terminology" numbered="true" toc="default">
      <name>Terminology</name>
      <t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
      "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
      NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
      "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
      "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be
      interpreted as
      described in BCP&nbsp;14 <xref target="RFC2119"/> <xref target="RFC8174"/> 
      when, and only when, they appear in all capitals, as shown here.</t>
      <t>In addition, this document frequently uses the following terms as they have been
      defined in <xref target="RFC5216" format="default"/>:</t>
      <dl newline="true" spacing="normal" indent="6">
        <dt>authenticator</dt>
        <dd>The entity initiating EAP authentication.</dd>
        <dt>peer</dt>
        <dd>The entity that responds to the authenticator. In <xref target="IEEE-802.1X"
	format="default"/>, this entity is known as the supplicant. (We use the terms peer,
	device, and peer device interchangeably.)</dd>
        <dt>server</dt>
        <dd>The entity that terminates the EAP authentication method with the peer. In the
	case where no backend authentication server is used, the EAP server is part of the
	authenticator. In the case where the authenticator operates in pass-through mode, the
	EAP server is located on the backend authentication server.</dd>
      </dl>
    </section>
    <section anchor="eap-noob" numbered="true" toc="default">
      
      <name>EAP-NOOB Method</name>
      <t>This section defines the EAP-NOOB method. The protocol is a generalized version of
      the original idea presented by <xref target="Sethi14" format="default">Sethi et
      al.</xref>.</t>
      <section anchor="overview" numbered="true" toc="default">
        <name>Protocol Overview</name>
        <t>One EAP-NOOB method execution spans two or more EAP conversations, called
	Exchanges in this specification. Each Exchange consists of several EAP
	request-response pairs. At least two separate EAP conversations are needed to give the
	human user time to deliver the OOB message between them.</t>

        <t>The overall protocol starts with the Initial Exchange, which comprises four EAP
	request-response pairs. In the Initial Exchange, the server allocates an identifier to
	the peer, and the server and peer negotiate the protocol version and cryptosuite
	(i.e., cryptographic algorithm suite), exchange nonces, and perform an Ephemeral
	Elliptic Curve Diffie-Hellman (ECDHE) key exchange. The user-assisted OOB Step then
	takes place. This step requires only one out-of-band message, either from the peer to
	the server or from the server to the peer. While waiting for the OOB Step action, the
	peer <bcp14>MAY</bcp14> probe the server by reconnecting to it with EAP-NOOB. If the
	OOB Step has already taken place, the probe leads to the Completion Exchange, which
	completes the mutual authentication and key confirmation. On the other hand, if the
	OOB Step has not yet taken place, the probe leads to the Waiting Exchange, and the
	peer will perform another probe after a server-defined minimum waiting time. The
	Initial Exchange and Waiting Exchange always end in EAP-Failure, while the Completion
	Exchange may result in EAP-Success. Once the peer and server have performed a
	successful Completion Exchange, both endpoints store the created association in
	persistent storage, and the OOB Step is not repeated. Thereafter, creation of new
	temporal keys, ECDHE rekeying, and updates of cryptographic algorithms can be achieved
	with the Reconnect Exchange.</t>
        <figure anchor="fig-statemachine">
          <name>EAP-NOOB Server-Peer Association State Machine</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
                                    OOB Output/Initial Exchange/
                                               Waiting Exchange
                                                 .-----.
                                                 |     v
     .------------------.   Initial       .------------------.
     |                  |   Exchange      |                  |
  .->| Unregistered (0) |---------------->|Waiting for OOB(1)|
  |  |   (ephemeral)    |                 |   (ephemeral)    |
  |  |                  |                 |                  |  
  |  '------------------'                 '------------------'
  |                                         |      |      ^
 User Reset                 Completion      |      |      |
  |                         Exchange        |     OOB   OOB
  |<-------.      .-------------------------'    Input  Reject/
  |        |      |                                |    Initial
  |        |      |                                |    Exchange
  |        |      v                                v      |
  |  .------------------.   Completion    .------------------.
  |  |                  |   Exchange      |                  |
  |  |  Registered (4)  |<----------------| OOB Received (2) |
  |  |   (persistent)   |                 |   (ephemeral)    |
  |  |                  |                 |                  |
  |  '------------------'                 '------------------'
  |        |      ^
  |  Mobility/    |
  |  Timeout/   Reconnect
  |  Failure    Exchange
  |        |      |
  |        v      |
  |  .------------------.
  |  |                  |
  '--| Reconnecting (3) |
     |   (persistent)   |
     |                  |
     '------------------'             
]]></artwork>
        </figure>
        <t><xref target="fig-statemachine" format="default"/> shows the association state
	machine, which is the same for the server and for the peer. (For readability, only the
	main state transitions are shown. The complete table of transitions can be found in
	<xref target="exchangeappendix" format="default"/>.) When the peer initiates the
	EAP-NOOB method, the server chooses the ensuing message exchange based on the
	combination of the server and peer states. The EAP server and peer are initially in
	the Unregistered (0) state, in which no state information needs to be stored. Before a
	successful Completion Exchange, the server-peer association state is ephemeral in both
	the server and peer (ephemeral states 0..2), and a timeout or error may cause one or
	both endpoints to go back to the Unregistered (0) state so that the Initial Exchange
	is
	repeated. After the Completion Exchange has resulted in EAP-Success, the association
	state becomes persistent (persistent states 3..4). Only user reset or memory failure
	can cause the return of the server or the peer from the persistent states to the
	ephemeral states and to the Initial Exchange.</t>
        <t>The server <bcp14>MUST NOT</bcp14> repeat a successful OOB Step with the same peer
	except if the association with the peer is explicitly reset by the user or lost due to
	failure of the persistent storage in the server. More specifically, once the
	association has entered the Registered (4) state, the server <bcp14>MUST NOT</bcp14>
	delete the association or go back to the ephemeral states 0..2 without explicit user
	approval. Similarly, the peer <bcp14>MUST NOT</bcp14> repeat the OOB Step unless the
	user explicitly deletes the association with the server from the peer or resets the
	peer to the Unregistered (0) state. The server and peer <bcp14>MAY</bcp14> implement
	user
	reset of the association by deleting the state data from that endpoint. If an endpoint
	continues to store data about the association after the user reset, its behavior
	<bcp14>MUST</bcp14> be equivalent to having deleted the association data.</t>
        <t>It can happen that the peer accidentally (or through user reset) loses its
	persistent
	state and reconnects to the server without a previously allocated peer identifier. In
	that case, the server <bcp14>MUST</bcp14> treat the peer as a new peer. The server
	<bcp14>MAY</bcp14> use auxiliary information, such as the PeerInfo field received in
	the Initial Exchange, to detect multiple associations with the same peer. However, it
	<bcp14>MUST NOT</bcp14> delete or merge redundant associations without user or
	application approval because EAP-NOOB internally has no secure way of verifying that
	the two peers are the same physical device. Similarly, the server might lose the
	association state because of a memory failure or user reset. In that case, the only
	way to recover is that the user also resets the peer.</t>
        <t>A special feature of the EAP-NOOB method is that the server is not assumed to have
	any a priori knowledge of the peer. Therefore, the peer initially uses the generic
	identity string "noob@eap-noob.arpa" as its Network Access Identifier (NAI). The
	server then allocates a server-specific identifier to the peer. The generic NAI serves
	two purposes: firstly, it tells the server that the peer supports and expects the
	EAP-NOOB method; secondly, it allows routing of the EAP-NOOB sessions to a
	specific authentication server in an Authentication, Authorization, and Accounting
	(AAA) architecture.</t>
        <t>EAP-NOOB is an unusual EAP method in that the peer has to have multiple EAP
	conversations with the server before it can receive EAP-Success. The reason is that,
	while EAP allows delays between the request-response pairs, e.g., for repeated
	password entry, the user delays in OOB authentication can be much longer than in
	password trials. Moreover, EAP-NOOB supports peers with no input capability in the
	user interface (e.g., LED light bulbs). Since users cannot initiate the protocol in
	these devices, the devices have to perform the Initial Exchange opportunistically and
	hope for the OOB Step to take place within a timeout period (NoobTimeout), which is
	why the timeout needs to be several minutes rather than seconds. To support such
	high-latency OOB channels, the peer and server perform the Initial Exchange in one EAP
	conversation, then allow time for the OOB message to be delivered, and later perform
	the Waiting Exchange and Completion Exchange in different EAP conversations.</t>
      </section>
      <section anchor="protocol" numbered="true" toc="default">
        <name>Protocol Messages and Sequences</name>
        <t>This section defines the EAP-NOOB exchanges, which correspond to EAP conversations.
	The exchanges start with a common handshake, which determines the type of the
	following exchange. The common handshake messages and the subsequent messages for each
	exchange type are listed in the diagrams below. The diagrams also specify the data
	fields present in each message. Each exchange comprises multiple EAP request-response
	pairs and ends in either EAP-Failure, indicating that authentication is not (yet)
	successful, or in EAP-Success.</t>
        <section anchor="commonhandshake" numbered="true" toc="default">
          <name>Common Handshake in All EAP-NOOB Exchanges</name>
          <t>All EAP-NOOB exchanges start with common handshake messages. The handshake begins
	  with the identity request and response that are common to all EAP methods. Their
	  purpose is to enable the AAA architecture to route the EAP conversation to the EAP
	  server and to enable the EAP server to select the EAP method. The handshake then
	  continues with one EAP-NOOB request-response pair in which the server discovers the
	  peer identifier used in EAP-NOOB and the peer state.</t>
          <t>In more detail, each EAP-NOOB exchange begins with the authenticator sending an
	  EAP-Request/Identity packet to the peer. From this point on, the EAP conversation
	  occurs between the server and the peer, and the authenticator acts as a pass-through
	  device. The peer responds to the authenticator with an EAP-Response/Identity packet,
	  which contains the Network Access Identifier (NAI). The authenticator, acting as a
	  pass-through device, forwards this response and the following EAP conversation
	  between the peer and the AAA architecture. The AAA architecture routes the
	  conversation to a specific AAA server (called "EAP server" or simply "server" in
	  this specification) based on the realm part of the NAI. The server selects the
	  EAP-NOOB method based on the user part of the NAI, as defined in <xref target="nai"
	  format="default"/>.</t>
          <t>After receiving the EAP-Response/Identity message, the server sends the first
	  EAP-NOOB request (Type=1) to the peer, which responds with the peer identifier
	  (PeerId) and state (PeerState) in the range 0..3. However, the peer
	  <bcp14>SHOULD</bcp14> omit the PeerId from the response (Type=1) when PeerState=0.
	  The server then chooses the EAP-NOOB exchange, i.e., the ensuing message sequence,
	  as explained below. The peer recognizes the exchange based on the message type field
	  (Type) of the next EAP-NOOB request received from the server.</t>
          <t>The server <bcp14>MUST</bcp14> determine the exchange type based on the
	  combination of the peer and server states as follows (also summarized in <xref
	  target="tab-exchanges" format="default"/>). If either the peer or server is in the
	  Unregistered (0) state and the other is in one of the ephemeral states (0..2), the
	  server chooses the Initial Exchange. If either the peer or server is in the OOB
	  Received (2) state and the other is either in the Waiting for OOB (1) or OOB
	  Received (2) state, the OOB Step has taken place and the server chooses the
	  Completion Exchange. If both the server and peer are in the Waiting for OOB (1)
	  state, the server chooses the Waiting Exchange. If the peer is in the Reconnecting
	  (3) state and the server is in the Registered (4) or Reconnecting (3) state, the
	  server chooses the Reconnect Exchange. All other state combinations are error
	  situations where user action is required, and the server <bcp14>SHOULD</bcp14>
	  indicate such errors to the peer with the error code 2002 (see <xref
	  target="statemismatch" format="default"/>). Note also that the peer <bcp14>MUST
	  NOT</bcp14> initiate EAP-NOOB when the peer is in the Registered (4) state.</t>
          <figure anchor="fig-commonhandshake">
            <name>Common Handshake in All EAP-NOOB Exchanges</name>
            <artwork align="center" name="" type="" alt=""><![CDATA[   
EAP Peer                      Authenticator    EAP Server
  |                                   |              |
  |<----------- EAP-Request/Identity -|              |
  |                                                  |
  |                                                  |
  |------------ EAP-Response/Identity -------------->|
  |      (NAI=noob@eap-noob.arpa)                    |
  |                                                  |
  |                                                  |
  |<----------- EAP-Request/EAP-NOOB ----------------|
  |      (Type=1)                                    |
  |                                                  |
  |                                                  |
  |------------ EAP-Response/EAP-NOOB -------------->|
  |      (Type=1,[PeerId],PeerState=1)               |
  |                                                  |
  |  continuing with exchange-specific messages...   |
]]></artwork>
          </figure>
        </section>
        <section anchor="initialexchange" numbered="true" toc="default">
          <name>Initial Exchange</name>
          <t>The Initial Exchange comprises the common handshake and two further EAP-NOOB
	  request-response pairs: one for version, cryptosuite, and parameter negotiation and
	  the other for the ECDHE key exchange. The first EAP-NOOB request (Type=2) from the
	  server contains a newly allocated PeerId for the peer and an optional NewNAI for
	  assigning a new NAI to the peer. The server allocates a new PeerId in the Initial
	  Exchange regardless of any old PeerId received in the previous response (Type=1).
	  The server also sends in the request a list of the protocol versions (Vers) and
	  cryptosuites (Cryptosuites) it supports, an indicator of the OOB channel directions
	  it supports (Dirs), and a ServerInfo object. The peer chooses one of the versions
	  and cryptosuites. The peer sends a response (Type=2) with the selected protocol
	  version (Verp), the received PeerId, the selected cryptosuite (Cryptosuitep), an
	  indicator of the OOB channel direction(s) selected by the peer (Dirp), and a
	  PeerInfo object. In the second EAP-NOOB request and response (Type=3), the server
	  and peer exchange the public components of their ECDHE keys and nonces
	  (PKs, Ns, PKp, and Np). The ECDHE keys <bcp14>MUST</bcp14> be based on the
	  negotiated
	  cryptosuite, i.e., Cryptosuitep. The Initial Exchange always ends with EAP-Failure
	  from the server because the authentication cannot yet be completed.</t>
          <figure anchor="fig-initial">
            <name>Initial Exchange</name>
            <artwork align="center" name="" type="" alt=""><![CDATA[
EAP Peer                                        EAP Server
  |       ...continuing from common handshake        |
  |                                                  |
  |<----------- EAP-Request/EAP-NOOB ----------------|
  |      (Type=2,Vers,PeerId,[NewNAI],               |
  |       Cryptosuites,Dirs,ServerInfo)              |
  |                                                  |
  |                                                  |
  |------------ EAP-Response/EAP-NOOB -------------->|
  |      (Type=2,Verp,PeerId,Cryptosuitep,           |
  |        Dirp,PeerInfo)                            |
  |                                                  |
  |                                                  |
  |<----------- EAP-Request/EAP-NOOB ----------------|
  |      (Type=3,PeerId,PKs,Ns,[SleepTime])          |
  |                                                  |
  |                                                  |
  |------------ EAP-Response/EAP-NOOB -------------->|
  |      (Type=3,PeerId,PKp,Np)                      |
  |                                                  |
  |                                                  |
  |<----------- EAP-Failure -------------------------|
  |                                                  |
]]></artwork>
          </figure>
          <t>At the conclusion of the Initial Exchange, both the server and the peer move to
	  the Waiting for OOB (1) state.</t>
        </section>
        <section anchor="oobstep" numbered="true" toc="default">
          <name>OOB Step</name>
          <t>The OOB Step, labeled as OOB Output and OOB Input in <xref
	  target="fig-statemachine" format="default"/>, takes place after the Initial
	  Exchange. Depending on the negotiated OOB channel direction, the peer or the server
	  outputs the OOB message as shown in Figures <xref target="fig-oob1"
	  format="counter"/> or
	  <xref target="fig-oob2" format="counter"/>, respectively. The data fields are the
	  PeerId, the secret nonce Noob, and the cryptographic fingerprint Hoob. The contents
	  of the data fields are defined in <xref target="messagedatafields"
	  format="default"/>. The OOB message is delivered to the other endpoint via a
	  user-assisted OOB channel.</t>
          <t>For brevity, we will use the terms OOB sender and OOB receiver in addition to the
	  already familiar EAP server and EAP peer. If the OOB message is sent in the
	  server-to-peer direction, the OOB sender is the server and the OOB receiver is the
	  peer. On the other hand, if the OOB message is sent in the peer-to-server direction,
	  the OOB sender is the peer and the OOB receiver is the server.</t>
          <figure anchor="fig-oob1">
            <name>OOB Step, from Peer to EAP Server</name>
            <artwork align="center" name="" type="" alt=""><![CDATA[
EAP Peer                                        EAP Server
  |                                                  |
  |=================OOB=============================>|
  |             (PeerId,Noob,Hoob)                   |
  |                                                  |
]]></artwork>
          </figure>

          <figure anchor="fig-oob2">
            <name>OOB Step, from EAP Server to Peer</name>
            <artwork align="center" name="" type="" alt=""><![CDATA[                
EAP Peer                                        EAP Server
  |                                                  |
  |<================OOB==============================|
  |             (PeerId,Noob,Hoob)                   |
  |                                                  |
]]></artwork>
          </figure>
          <t>The OOB receiver <bcp14>MUST</bcp14> compare the received value of the
	  fingerprint Hoob (see <xref target="messagedatafields" format="default"/>) with a
	  value that it computed locally for the PeerID received. This integrity check ensures
	  that the endpoints agree on contents of the Initial Exchange. If the values are
	  equal, the receiver moves to the OOB Received (2) state. Otherwise, the receiver
	  <bcp14>MUST</bcp14> reject the OOB message. For usability reasons, the OOB receiver
	  <bcp14>SHOULD</bcp14> indicate the acceptance or rejection of the OOB message to the
	  user. The receiver <bcp14>SHOULD</bcp14> reject invalid OOB messages without
	  changing its state in the association state machine until an application-specific
	  number of invalid messages (OobRetries) has been reached; after which, the receiver
	  <bcp14>SHOULD</bcp14> consider it an error and go back to the Unregistered (0)
	  state.</t>
          <t>The server or peer <bcp14>MAY</bcp14> send multiple OOB messages with different
	  Noob values while in the Waiting for OOB (1) state. The OOB sender
	  <bcp14>SHOULD</bcp14> remember the Noob values until they expire and accept any one
	  of them in the following Completion Exchange. The Noob values sent by the server
	  expire after an application-dependent timeout (NoobTimeout), and the server
	  <bcp14>MUST NOT</bcp14> accept Noob values older than that in the Completion
	  Exchange. The <bcp14>RECOMMENDED</bcp14> value for NoobTimeout is 3600 seconds if
	  there are no application-specific reasons for making it shorter or longer. The Noob
	  values sent by the peer expire, as defined in <xref target="waitingexchange"
	  format="default"/>.</t>
          <t>The OOB receiver does not accept further OOB messages after it has accepted one
	  and moved to the OOB Received (2) state. However, the receiver <bcp14>MAY</bcp14>
	  buffer redundant OOB messages in case an OOB message expiry or similar error
	  detected in the Completion Exchange causes it to return to the Waiting for OOB (1)
	  state. It is <bcp14>RECOMMENDED</bcp14> that the OOB receiver notifies the user
	  about redundant OOB messages, but it <bcp14>MAY</bcp14> instead discard them
	  silently.</t>
          <t>The sender will typically generate a new Noob, and therefore a new OOB message,
	  at constant time intervals (NoobInterval). The <bcp14>RECOMMENDED</bcp14> interval
	  is</t> 
          <t indent="3">NoobInterval = NoobTimeout / 2</t>
          <t>in which case, the receiver of the OOB will at any given time
          accept either of the two latest Noob values. However, the timing of
          the Noob generation may also be based on user interaction or on
          implementation considerations.</t>
          <t>Even though not recommended (see <xref target="datafields" format="default"/>),
	  this specification allows both directions to be negotiated (Dirp=3) for the OOB
	  channel. In that case, both sides <bcp14>SHOULD</bcp14> output the OOB message, and
	  it is up to the user to deliver at least one of them.</t>
          <t>The details of the OOB channel implementation including the message encoding are
	  defined by the application. <xref target="urloob" format="default"/> gives an
	  example of how the OOB message can be encoded as a URL that may be embedded in a
	  dynamic QR code or NFC (Near Field Communication) tag.</t>
        </section>
        <section anchor="completionexchange" numbered="true" toc="default">
          <name>Completion Exchange</name>
          <t>After the Initial Exchange, if the OOB channel directions selected by the peer
	  include the peer-to-server direction, the peer <bcp14>SHOULD</bcp14> initiate the
	  EAP-NOOB method again after an applications-specific waiting time in order to probe
	  for completion of the OOB Step. If the OOB channel directions selected by the peer
	  include the server-to-peer direction and the peer receives the OOB message, it
	  <bcp14>SHOULD</bcp14> initiate the EAP-NOOB method immediately. Depending on the
	  combination of the peer and server states, the server continues with the Completion
	  Exchange or Waiting Exchange (see <xref target="commonhandshake" format="default"/>
	  on how the server makes this decision).</t>
          <t>The Completion Exchange comprises the common handshake and one or two further
	  EAP-NOOB request-response pairs. If the peer is in the Waiting for OOB (1) state,
	  the OOB message has been sent in the peer-to-server direction. In that case, only
	  one request-response pair (Type=6) takes place. In the request, the server sends the
	  NoobId value (see <xref target="messagedatafields" format="default"/>), which the
	  peer uses to identify the exact OOB message received by the server. On the other
	  hand, if the peer is in the OOB Received (2) state, the direction of the OOB message
	  is from server to peer. In this case, two request-response pairs (Type=5 and Type=6)
	  are needed. The purpose of the first request-response pair (Type=5) is that it
	  enables the server to discover NoobId, which identifies the exact OOB message
	  received by the peer. The server returns the same NoobId to the peer in the latter
	  request.</t>
          <t>In the last request-response pair (Type=6) of the Completion Exchange, the server
	  and peer exchange message authentication codes. Both sides <bcp14>MUST</bcp14>
	  compute the keys Kms and Kmp, as defined in <xref target="keyderivation"
	  format="default"/>, and the message authentication codes MACs and MACp, as defined
	  in <xref target="messagedatafields" format="default"/>. Both sides
	  <bcp14>MUST</bcp14>
	  compare the received message authentication code with a locally computed value. If
	  the peer finds that it has received the correct value of MACs and the server finds
	  that it has received the correct value of MACp, the Completion Exchange ends in
	  EAP-Success.
	  Otherwise, the endpoint where the comparison fails indicates this with
	  an error message (error code 4001, see <xref target="cryptofailure"
	  format="default"/>), and the Completion Exchange ends in EAP-Failure.</t>
          <t>After the successful Completion Exchange, both the server and the peer move to
	  the
	  Registered (4) state. They also derive the output keying material and store the
	  persistent EAP-NOOB association state, as defined in Sections <xref
	  target="fastreconnect"
	  format="counter"/> and <xref target="keyderivation" format="counter"/>.</t>
          <t>It is possible that the OOB message expires before it is received. In that case,
	  the sender of the OOB message no longer recognizes the NoobId that it receives in
	  the Completion Exchange. Another reason why the OOB sender might not recognize the
	  NoobId is if the received OOB message was spoofed and contained an
	  attacker-generated Noob value. The recipient of an unrecognized NoobId indicates
	  this with an error message (error code 2003, see <xref target="invalidmessages"
	  format="default"/>), and the Completion Exchange ends in EAP-Failure. The recipient
	  of the error message 2003 moves back to the Waiting for OOB (1) state. This state
	  transition is called OOB Reject in <xref target="fig-statemachine"
	  format="default"/> (even though it really is a specific type of failed Completion
	  Exchange). On the other hand, the sender of the error message stays in its
	  previous state.</t>
          <t>Although it is not expected to occur in practice, poor user interface design
	  could lead to two OOB messages delivered simultaneously, one from the peer to the
	  server and the other from the server to the peer. The server detects this event in
	  the beginning of the Completion Exchange by observing that both the server and peer
	  are in the OOB Received (2) state. In that case, as a tiebreaker, the server
	  <bcp14>MUST</bcp14> behave as if only the server-to-peer message had been
	  delivered.</t>
          <figure anchor="fig-completion">
            <name>Completion Exchange</name>
            <artwork align="center" name="" type="" alt=""><![CDATA[                
EAP Peer                                        EAP Server
  |       ...continuing from common handshake        |
  |                                                  |
  |<----------- [ EAP-Request/EAP-NOOB ] ------------|
  |      (Type=5,PeerId)                             |
  |                                                  |
  |                                                  |
  |------------ [ EAP-Response/EAP-NOOB ] ---------->|
  |      (Type=5,PeerId,NoobId)                      |
  |                                                  |
  |                                                  |
  |<----------- EAP-Request/EAP-NOOB ----------------|
  |      (Type=6,PeerId,NoobId,MACs)                 |
  |                                                  |
  |                                                  |
  |------------ EAP-Response/EAP-NOOB -------------->|
  |      (Type=6,PeerId,MACp)                        |
  |                                                  |
  |                                                  |
  |<----------- EAP-Success -------------------------|
  |                                                  |
]]></artwork>
          </figure>
        </section>
        <section anchor="waitingexchange" numbered="true" toc="default">
          <name>Waiting Exchange</name>
          <t>As explained in <xref target="completionexchange" format="default"/>, the peer
	  <bcp14>SHOULD</bcp14> probe the server for completion of the OOB Step. When the
	  combination of the peer and server states indicates that the OOB message has not yet
	  been delivered, the server chooses the Waiting Exchange (see <xref
	  target="commonhandshake" format="default"/> on how the server makes this decision).
	  The Waiting Exchange comprises the common handshake and one further request-response
	  pair, and it always ends in EAP-Failure.</t>
          <t>In order to limit the rate at which peers probe the server, the server
	  <bcp14>MAY</bcp14> send to the peer either in the Initial Exchange or in the Waiting
	  Exchange a minimum time to wait before probing the server again. A peer that has not
	  received an OOB message <bcp14>SHOULD</bcp14> wait at least the server-specified
	  minimum waiting time in seconds (SleepTime) before initiating EAP again with the
	  same server. The peer uses the latest SleepTime value that it has received in or
	  after the Initial Exchange. If the server has not sent any SleepTime value, the peer
	  <bcp14>MUST</bcp14> wait for an application-specified minimum time
	  (SleepTimeDefault).</t>
          <t>After the Waiting Exchange, the peer <bcp14>MUST</bcp14> discard (from its local
	  ephemeral storage) Noob values that it has sent to the server in OOB messages that
	  are older than the application-defined timeout NoobTimeout (see <xref
	  target="oobstep" format="default"/>). The peer <bcp14>SHOULD</bcp14> discard such
	  expired Noob values even if the probing failed because of, e.g., failure to connect
	  to the EAP server or an incorrect message authentication code. The timeout of
	  peer-generated Noob values is defined like this in order to allow the peer to probe
	  the server once after it has waited for the server-specified SleepTime.</t>
          <t>If the server and peer have negotiated to use only the server-to-peer direction
	  for the OOB channel (Dirp=2), the peer <bcp14>SHOULD</bcp14> nevertheless probe the
	  server. The purpose of this is to keep the server informed about the peers that are
	  still waiting for OOB messages. The server <bcp14>MAY</bcp14> set SleepTime to a
	  high number (e.g., 3600) to prevent the peer from probing the server frequently.</t>
          <figure anchor="fig-waiting">
            <name>Waiting Exchange</name>
            <artwork align="center" name="" type="" alt=""><![CDATA[                
EAP Peer                                        EAP Server
  |       ...continuing from common handshake        |
  |                                                  |
  |<----------- EAP-Request/EAP-NOOB ----------------|
  |      (Type=4,PeerId,[SleepTime])                 |
  |                                                  |
  |                                                  |
  |------------ EAP-Response/EAP-NOOB -------------->|
  |      (Type=4,PeerId)                             |
  |                                                  |
  |                                                  |
  |<----------- EAP-Failure -------------------------|
  |                                                  |
]]></artwork>
          </figure>
        </section>
      </section>
      <section anchor="datafields" numbered="true" toc="default">
        <name>Protocol Data Fields</name>
        <t>This section defines the various identifiers and data fields used in the EAP-NOOB
	method.</t>
        <section anchor="nai" numbered="true" toc="default">
          <name>Peer Identifier and NAI</name>
          <t>The server allocates a new peer identifier (PeerId) for the peer in the Initial
	  Exchange. The peer identifier <bcp14>MUST</bcp14> follow the syntax of the
	  utf8-username specified in <xref target="RFC7542" format="default"/>. The server
	  <bcp14>MUST</bcp14> generate the identifiers in such a way that they do not repeat
	  and cannot be guessed by the peer or third parties before the server sends them to
	  the peer in the Initial Exchange. One way to generate the identifiers is to choose a
	  random 16-byte identifier and to base64url encode it without padding <xref
	  target="RFC4648" format="default"/> into a 22-character ASCII string. Another way to
	  generate the identifiers is to choose a random 22-character alphanumeric ASCII
	  string. It is <bcp14>RECOMMENDED</bcp14> to not use identifiers longer than this
	  because they result in longer OOB messages.</t>
          <t>The peer uses the allocated PeerId to identify itself to the server in the
	  subsequent exchanges. The peer <bcp14>MUST</bcp14> copy the PeerId byte by byte from
	  the message where it was allocated, and the server <bcp14>MUST</bcp14> perform a
	  byte-by-byte comparison between the received and the previously allocated PeerID.
	  The peer sets the PeerId value in response type 1 as follows. As stated in <xref
	  target="commonhandshake" format="default"/>, when the peer is in the Unregistered
	  (0) state, it <bcp14>SHOULD</bcp14> omit the PeerId from response type 1. When the
	  peer is in one of the states 1..2, it <bcp14>MUST</bcp14> use the PeerId that the
	  server assigned to it in the latest Initial Exchange. When the peer is in one of the
	  persistent states 3..4, it <bcp14>MUST</bcp14> use the PeerId from its persistent
	  EAP-NOOB association. (The PeerId is written to the association when the peer moves
	  to the Registered (4) state after a Completion Exchange.)</t>
          <t>The default NAI for the peer is "noob@eap-noob.arpa". The peer implementation
	  <bcp14>MAY</bcp14> allow the user or application to configure a different NAI, which
	  overrides the default NAI. Furthermore, the server <bcp14>MAY</bcp14> assign a new
	  NAI to the peer in the Initial Exchange or Reconnect Exchange in the NewNAI field
	  of request types 2 and 7 to override any previous NAI value. When the peer is in
	  the Unregistered (0) state, or when the peer is in one of the states 1..2 and the
	  server did not send a NewNAI in the latest Initial Exchange, the peer
	  <bcp14>MUST</bcp14> use the configured NAI or, if it does not exist, the default
	  NAI. When the peer is in one of the states 1..2 and the server sent a NewNAI in the
	  latest Initial Exchange, the peer <bcp14>MUST</bcp14> use this server-assigned NAI.
	  When the peer moves to the Registered (4) state after the Completion Exchange, it
	  writes to the persistent EAP-NOOB association the same NAI value that it used in the
	  Completion Exchange. When the peer is in the Reconnecting (3) or Registered (4)
	  state, it <bcp14>MUST</bcp14> use the NAI from its persistent EAP-NOOB association.
	  When the server sends NewNAI in the Reconnect Exchange, the peer writes its value to
	  the persistent EAP-NOOB association when it moves from the Reconnecting (3) state to
	  the Registered (4) state. All the NAI values <bcp14>MUST</bcp14> follow the syntax
	  specified in <xref target="RFC7542" format="default"/>. </t>
          <t>The purpose of the server-assigned NAI is to enable more flexible routing of the
	  EAP sessions over the AAA infrastructure, including roaming scenarios (see <xref
	  target="roaming" format="default"/>). Moreover, some authenticators or AAA servers
	  use the realm part of the assigned NAI to determine peer-specific connection
	  parameters, such as isolating the peer to a specific VLAN. On the other hand, the
	  user- or application-configured NAI enables registration of new devices while
	  roaming. It also enables manufacturers to set up their own AAA servers for
	  bootstrapping of new peer devices.</t>
          <t>The peer's PeerId and server-assigned NAI are ephemeral until a successful
	  Completion Exchange takes place. Thereafter, the values become parts of the
	  persistent EAP-NOOB association until the user resets the peer and server or
	  until a new NAI is assigned in the Reconnect Exchange.</t>
        </section>
        <section anchor="messagedatafields" numbered="true" toc="default">
          <name>Message Data Fields</name>
          <t><xref target="tab-datafields" format="default"/> defines the data fields in the
	  protocol messages. The in-band messages are formatted as JSON objects <xref
	  target="RFC8259" format="default"/> in UTF-8 encoding. The JSON member names are in
	  the left-hand column of the table.</t>
          <table anchor="tab-datafields" align="center">
            <name>Message Data Fields</name>
            <thead>
              <tr>
                <th align="left">Data Field</th>
                <th align="left">Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">Vers, Verp</td>
                <td align="left">EAP-NOOB protocol versions supported by the EAP server and
		the protocol version chosen by the peer. Vers is a JSON array of unsigned
		integers, and Verp is an unsigned integer. Example values are "[1]" and "1",
		respectively.</td>
              </tr>
              <tr>
                <td align="left">PeerId</td>
                <td align="left">Peer identifier, as defined in <xref target="nai"
		format="default"/>.</td>
              </tr>
              <tr>
                <td align="left">NAI, NewNAI</td>
                <td align="left">Peer NAI and server-assigned new peer NAI, as defined in
		<xref target="nai" format="default"/>.</td>
              </tr>
              <tr>
                <td align="left">Type</td>
                <td align="left">EAP-NOOB message type. The type is an integer in the range
		0..9. EAP-NOOB requests and the corresponding responses share the same type
		value.</td>
              </tr>
               <tr>
                <td align="left">PeerState</td>
                <td align="left">Peer state is an integer in the range 0..4 (see <xref
		target="fig-statemachine" format="default"/>). However, only values 0..3 are
		ever sent in the protocol messages.</td>
              </tr>
              <tr>
                <td align="left">PKs, PKp</td>
                <td align="left">The public components of the ECDHE keys of the server and
		peer. PKs and PKp are sent in the JSON Web Key (JWK) format <xref
		target="RFC7517" format="default"/>. The detailed format of the JWK object is
		defined by the cryptosuite.</td>
              </tr>
              <tr>
                <td align="left">Cryptosuites, Cryptosuitep</td>
                <td align="left">The identifiers of cryptosuites supported by the server and
		of the cryptosuite selected by the peer. The server-supported cryptosuites in
		Cryptosuites are formatted as a JSON array of the identifier integers. The
		server <bcp14>MUST</bcp14> send a nonempty array with no repeating elements,
		ordered by decreasing priority. The peer <bcp14>MUST</bcp14> respond with
		exactly one suite in the Cryptosuitep value, formatted as an identifier
		integer. Mandatory-to-implement cryptosuites and the registration procedure
		for new cryptosuites are specified in <xref target="cryptosuites"
		format="default"/>. Example values are "[1]" and "1", respectively.</td>
              </tr>
              <tr>
                <td align="left">Dirs, Dirp</td>
                <td align="left">An integer indicating the OOB channel directions supported by
		the server and the directions selected by the peer. The possible values are
		1=peer-to-server, 2=server-to-peer, and 3=both directions.</td>
              </tr>
              <tr>
                <td align="left">Dir</td>
                <td align="left">The actual direction of the OOB message (1=peer-to-server,
		2=server-to-peer). This value is not sent over any communication channel, but
		it is included in the computation of the cryptographic fingerprint Hoob.</td>
              </tr>
              <tr>
                <td align="left">Ns, Np</td>
                <td align="left">32-byte nonces for the Initial Exchange.</td>
              </tr>
              <tr>
                <td align="left">ServerInfo</td>
                <td align="left">This field contains information about the server to be passed
		from the EAP method to the application layer in the peer. The information is
		specific to the application or to the OOB channel, and it is encoded as a JSON
		object of at most 500 bytes. It could include, for example, the access-network
		name and server name, a Uniform Resource Locator (URL) <xref
		target="RFC3986" format="default"/>, or some other information that helps the
		user deliver the OOB message to the server through the out-of-band
		channel.</td>
              </tr>
              <tr>
                <td align="left">PeerInfo</td>
                <td align="left">This field contains information about the peer to be passed
		from the EAP method to the application layer in the server. The information is
		specific to the application or to the OOB channel, and it is encoded as a JSON
		object of at most 500 bytes. It could include, for example, the peer brand,
		model, and serial number, which help the user distinguish between devices
		and deliver the OOB message to the correct peer through the out-of-band
		channel.</td>
              </tr>
              <tr>
                <td align="left">SleepTime</td>
                <td align="left">The number of seconds for which the peer <bcp14>MUST
		NOT</bcp14> start a new execution of the EAP-NOOB method with the
		authenticator, unless the peer receives the OOB message or the sending is
		triggered by an application-specific user action. The server can use this
		field to limit the rate at which peers probe it. SleepTime is an unsigned
		integer in the range 0..3600.</td>
              </tr>
              <tr>
                <td align="left">Noob</td>
                <td align="left">16-byte secret nonce sent through the OOB channel and used
		for the session key derivation. The endpoint that received the OOB message
		uses this secret in the Completion Exchange to authenticate the exchanged key
		to the endpoint that sent the OOB message.</td>
              </tr>
              <tr>
                <td align="left">Hoob</td>
                <td align="left">16-byte cryptographic fingerprint (i.e., hash value) computed
		from all the parameters exchanged in the Initial Exchange and in the OOB
		message. Receiving this fingerprint over the OOB channel guarantees the
		integrity of the key exchange and parameter negotiation. Hence, it
		authenticates the exchanged key to the endpoint that receives the OOB
		message.</td>
              </tr>
              <tr>
                <td align="left">NoobId</td>
                <td align="left">16-byte identifier for the OOB message, computed with a
		one-way function from the nonce Noob in the message.</td>
              </tr>
              <tr>
                <td align="left">MACs, MACp</td>
                <td align="left">Message authentication codes (HMAC) for mutual
		authentication, key confirmation, and integrity check on the exchanged
		information. The input to the HMAC is defined below, and the key for the HMAC
		is defined in <xref target="keyderivation" format="default"/>.</td>
              </tr>
              <tr>
                <td align="left">Ns2, Np2</td>
                <td align="left">32-byte nonces for the Reconnect Exchange.</td>
              </tr>
              <tr>
                <td align="left">KeyingMode</td>
                <td align="left">Integer indicating the key derivation method. 0 in the
		Completion Exchange, and 1..3 in the Reconnect Exchange.</td>
              </tr>
              <tr>
                <td align="left">PKs2, PKp2</td>
                <td align="left">The public components of the ECDHE keys of the server and
		peer for the Reconnect Exchange. PKp2 and PKs2 are sent in the JSON Web Key
		(JWK) format <xref target="RFC7517" format="default"/>. The detailed format of
		the JWK object is defined by the cryptosuite.</td>
              </tr>
              <tr>
                <td align="left">MACs2, MACp2</td>
                <td align="left">Message authentication codes (HMAC) for mutual
		authentication, key confirmation, and integrity check on the Reconnect
		Exchange. The input to the HMAC is defined below, and the key for the HMAC is
		defined in <xref target="keyderivation" format="default"/>.</td>
              </tr>
              <tr>
                <td align="left">ErrorCode</td>
                <td align="left">Integer indicating an error condition. Defined in <xref
		target="errorcodes" format="default"/>.</td>
              </tr>
              <tr>
                <td align="left">ErrorInfo</td>
                <td align="left">Textual error message for logging and debugging purposes. A
		UTF-8 string of at most 500 bytes.</td>
              </tr>
            </tbody>
          </table>
          <t>It is <bcp14>RECOMMENDED</bcp14> for servers to support both OOB channel
	  directions (Dirs=3) unless the type of the OOB channel limits them to one direction
	  (Dirs=1 or Dirs=2). On the other hand, it is <bcp14>RECOMMENDED</bcp14> that the
	  peer selects only one direction (Dirp=1 or Dirp=2) even when both directions
	  (Dirp=3) would be technically possible. The reason is that, if value 3 is
	  negotiated, the user may be presented with two OOB messages, one for each direction,
	  even though only one of them needs to be delivered. This can be confusing to the
	  user. Nevertheless, the EAP-NOOB protocol is designed to also cope with the value 3;
	  in which case, it uses the first delivered OOB message. In the unlikely case of
	  simultaneously delivered OOB messages, the protocol prioritizes the server-to-peer
	  direction.</t>
          <t>The nonces in the in-band messages (Ns, Np, Ns2, Np2) are 32-byte fresh random
	  byte strings, and the secret nonce Noob is a 16-byte fresh random byte string. All
	  the nonces are generated by the endpoint that sends the message.</t>
          <t>The fingerprint Hoob and the identifier NoobId are computed with the
	  cryptographic hash function H, which is specified in the negotiated cryptosuite and
	  truncated to the 16 leftmost bytes of the output. The message authentication codes
	  (MACs, MACp, MACs2, MACp2) are computed with the function HMAC, which is the hashed
	  message authentication code <xref target="RFC2104" format="default"/> based on the
	  cryptographic hash function H and truncated to the 32 leftmost bytes of the
	  output.</t>
          <t>The inputs to the hash function for computing the fingerprint Hoob and to the
	  HMAC for computing MACs, MACp, MACs2, and MACp2 are JSON arrays containing a fixed
	  number (17) of elements. The array elements <bcp14>MUST</bcp14> be copied to
	  the
	  array verbatim from the sent and received in-band messages. When the element is a
	  JSON object, its members <bcp14>MUST NOT</bcp14> be reordered or reencoded.
	  White space <bcp14>MUST NOT</bcp14> be added anywhere in the JSON structure.
	  Implementers should check that their JSON library copies the elements as UTF-8
	  strings, does not modify them in any way, and does not add white space to
	  the HMAC input.</t>
          <t>The inputs for computing the fingerprint and message authentication codes are the
	  following:</t>
<sourcecode type="pseudocode">
Hoob = H(Dir,Vers,Verp,PeerId,Cryptosuites,Dirs,ServerInfo,
Cryptosuitep,Dirp,NAI,PeerInfo,0,PKs,Ns,PKp,Np,Noob).

NoobId = H("NoobId",Noob).

MACs = HMAC(Kms; 2,Vers,Verp,PeerId,Cryptosuites,Dirs,ServerInfo,
Cryptosuitep,Dirp,NAI,PeerInfo,0,PKs,Ns,PKp,Np,Noob).
           
MACp = HMAC(Kmp; 1,Vers,Verp,PeerId,Cryptosuites,Dirs,ServerInfo,
Cryptosuitep,Dirp,NAI,PeerInfo,0,PKs,Ns,PKp,Np,Noob).

MACs2 = HMAC(Kms2; 2,Vers,Verp,PeerId,Cryptosuites,"",[ServerInfo],
Cryptosuitep,"",NAI,[PeerInfo],KeyingMode,[PKs2],Ns2,[PKp2],Np2,"")

MACp2 = HMAC(Kmp2; 1,Vers,Verp,PeerId,Cryptosuites,"",[ServerInfo],
Cryptosuitep,"",NAI,[PeerInfo],KeyingMode,[PKs2],Ns2,[PKp2],Np2,"")
</sourcecode>
          <t>The inputs denoted with "" above are not present, and the values in brackets
          [] are optional. Both kinds of missing input values are represented by empty strings
	  "" in the HMAC input (JSON array). The NAI included in the inputs is the NAI value
	  that will be in the persistent EAP-NOOB association if the Completion Exchange or
	  Reconnect Exchange succeeds.
	  In the Completion Exchange, the NAI is the NewNAI value
	  assigned by the server in the preceding Initial Exchange or, if no NewNAI was sent,
	  the NAI used by the client in the Initial Exchange. In the Reconnect Exchange,
	  the NAI is the NewNAI value assigned by the server in the same Reconnect Exchange
	  or, if
	  no NewNAI was sent, the unchanged NAI from the persistent EAP-NOOB association. Each
	  of the values in brackets for the computation of Macs2 and Macp2 <bcp14>MUST</bcp14>
	  be included if it was sent or received in the same Reconnect Exchange; otherwise,
	  the value is replaced by an empty string "".</t>
          <t>The parameter Dir indicates the direction in which the OOB message containing the
	  Noob value is being sent (1=peer-to-server, 2=server-to-peer). This field is
	  included in the Hoob input to prevent the user from accidentally delivering the OOB
	  message back to its originator in the rare cases where both OOB directions have been
	  negotiated. The keys (Kms, Kmp, Kms2, and Kmp2) for the HMACs are defined in <xref
	  target="keyderivation" format="default"/>.</t>
          <t>The nonces (Ns, Np, Ns2, Np2, and Noob) and the hash value (NoobId)
	  <bcp14>MUST</bcp14> be base64url encoded <xref target="RFC4648" format="default"/>
	  when they are used as input to the cryptographic functions H or HMAC. These values
	  and the message authentication codes (MACs, MACp, MACs2, and MACp2)
	  <bcp14>MUST</bcp14>
	  also be base64url encoded when they are sent as JSON strings in the in-band
	  messages. The values Noob and Hoob in the OOB channel <bcp14>MAY</bcp14> be
	  base64url encoded if that is appropriate for the application and the OOB channel.
	  All base64url encoding is done without padding. The base64url-encoded values will
	  naturally consume more space than the number of bytes specified above (e.g., a
	  22-character
	  string for a 16-byte nonce and a 43-character string for a 32-byte nonce or message
	  authentication code). In the key derivation in <xref target="keyderivation"
	  format="default"/>, on the other hand, the unencoded nonces (raw bytes) are used as
	  input to the key derivation function.</t>
          <t>The ServerInfo and PeerInfo are JSON objects with UTF-8 encoding. The length of
	  either encoded object as a byte array <bcp14>MUST NOT</bcp14> exceed 500 bytes. The
	  format and semantics of these objects <bcp14>MUST</bcp14> be defined by the
	  application that uses the EAP-NOOB method.</t>
        </section>
      </section>
      <section anchor="fastreconnect" numbered="true" toc="default">
        <name>Fast Reconnect and Rekeying</name>
        <t>EAP-NOOB implements fast reconnect (<xref target="RFC3748" sectionFormat="comma"
	section="7.2.1"/>), which avoids repeated use of the user-assisted OOB channel.</t>
        <t>The rekeying and the Reconnect Exchange may be needed for several reasons. New EAP
	output values Main Session Key (MSK) and Extended Main Session Key (EMSK) may be
	needed because of mobility or timeout of session keys. Software or hardware failure or
	user action may also cause the authenticator, EAP server, or peer to lose its
	nonpersistent state data. The failure would typically be detected by the peer or
	authenticator when session keys are no longer accepted by the other endpoint. Changes
	in the supported cryptosuites in the EAP server or peer may also cause the need for a
	new key exchange. When the EAP server or peer detects any one of these events, it
	<bcp14>MUST</bcp14> change from the Registered (4) state to the Reconnecting (3)
	state. These state
	transitions are labeled Mobility/Timeout/Failure in <xref target="fig-statemachine"
	format="default"/>. The EAP-NOOB method will then perform the Reconnect Exchange the
	next time when EAP is triggered.</t>
        <section anchor="persistentassociation" numbered="true" toc="default">
          <name>Persistent EAP-NOOB Association</name>
          <t>To enable rekeying, the EAP server and peer store the session state in persistent
	  memory after a successful Completion Exchange. This state data, called "persistent
	  EAP-NOOB association", <bcp14>MUST</bcp14> include at least the data fields shown in
	  <xref target="tab-persistent" format="default"/>. They are used for identifying and
	  authenticating the peer in the Reconnect Exchange. When a persistent EAP-NOOB
	  association exists, the EAP server and peer are in the Registered (4) state or
	  Reconnecting (3) state, as shown in <xref target="fig-statemachine"
	  format="default"/>.</t>
          <table anchor="tab-persistent" align="center">
            <name>Persistent EAP-NOOB Association</name>
            <thead>
              <tr>
                <th align="left">Data Field</th>
                <th align="left">Value</th>
                <th align="left">Type</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td align="left">PeerId</td>
                <td align="left">Peer identifier allocated by server</td>
                <td align="left">UTF-8 string (typically 22 ASCII characters)</td>
              </tr>
              <tr>
                <td align="left">Verp</td>
                <td align="left">Negotiated protocol version</td>
                <td align="left">integer</td>
              </tr>
              <tr>
                <td align="left">Cryptosuitep</td>
                <td align="left">Negotiated cryptosuite</td>
                <td align="left">integer</td>
              </tr>
              <tr>
                <td align="left">CryptosuitepPrev (at peer only)</td>
                <td align="left">Previous cryptosuite</td>
                <td align="left">integer</td>
              </tr>
              <tr>
                <td align="left">NAI</td>
                <td align="left">NAI assigned by the server or configured by the user or the
		default NAI "noob@eap-noob.arpa"</td>
                <td align="left">UTF-8 string</td>
              </tr>
              <tr>
                <td align="left">Kz</td>
                <td align="left">Persistent key material</td>
                <td align="left">32 bytes</td>
              </tr>
              <tr>
                <td align="left">KzPrev (at peer only)</td>
                <td align="left">Previous Kz value</td>
                <td align="left">32 bytes</td>
              </tr>
            </tbody>
          </table>
        </section>
        <section anchor="reconnectexchange" numbered="true" toc="default">
          <name>Reconnect Exchange</name>
          <t>The server chooses the Reconnect Exchange when both the peer and the server are
	  in a persistent state and fast reconnection is needed (see <xref
	  target="commonhandshake" format="default"/> for details).</t>
          <t>The Reconnect Exchange comprises the common handshake and three further EAP-NOOB
	  request-response pairs: one for cryptosuite and parameter negotiation, another for
	  the nonce and ECDHE key exchange, and the last one for exchanging message
	  authentication codes. In the first request and response (Type=7), the server and peer
	  negotiate a protocol version and cryptosuite in the same way as in the Initial
	  Exchange. The server <bcp14>SHOULD NOT</bcp14> offer and the peer <bcp14>MUST
	  NOT</bcp14> accept protocol versions or cryptosuites that it knows to be weaker than
	  the one currently in the Cryptosuitep field of the persistent EAP-NOOB association.
	  The server <bcp14>SHOULD NOT</bcp14> needlessly change the cryptosuites it offers to
	  the same peer because peer devices may have limited ability to update their
	  persistent storage. However, if the peer has different values in the Cryptosuitep
	  and CryptosuitepPrev fields, it <bcp14>SHOULD</bcp14> also accept offers that are
	  not weaker than CryptosuitepPrev. Note that Cryptosuitep and CryptosuitePrev from
	  the persistent EAP-NOOB association are only used to support the negotiation as
	  described above; all actual cryptographic operations use the newly negotiated
	  cryptosuite. The request and response (Type=7) <bcp14>MAY</bcp14> additionally
	  contain PeerInfo and ServerInfo objects.</t>
          <t>The server then determines the KeyingMode (defined in <xref
	  target="keyderivation" format="default"/>) based on changes in the negotiated
	  cryptosuite and whether it desires to achieve forward secrecy or not. The server
	  <bcp14>SHOULD</bcp14> only select KeyingMode 3 when the negotiated cryptosuite
	  differs from the Cryptosuitep in the server's persistent EAP-NOOB association,
	  although it is technically possible to select this value without changing the
	  cryptosuite. In the second request and response (Type=8), the server informs the
	  peer about the KeyingMode and the server and peer exchange nonces (Ns2, Np2). When
	  KeyingMode is 2 or 3 (rekeying with ECDHE), they also exchange public components of
	  ECDHE keys (PKs2, PKp2). The server ECDHE key <bcp14>MUST</bcp14> be fresh, i.e.,
	  not previously used with the same peer, and the peer ECDHE key <bcp14>SHOULD</bcp14>
	  be fresh, i.e., not previously used.</t>
          <t>In the third and final request and response (Type=9), the server and peer
	  exchange message authentication codes. Both sides <bcp14>MUST</bcp14> compute the
	  keys Kms2 and Kmp2, as defined in <xref target="keyderivation" format="default"/>,
	  and the message authentication codes MACs2 and MACp2, as defined in <xref
	  target="messagedatafields" format="default"/>. Both sides <bcp14>MUST</bcp14>
	  compare the received message authentication code with a locally computed value.</t>
          <t>The rules by which the peer compares the received MACs2 are nontrivial because,
	  in addition to authenticating the current exchange, MACs2 may confirm the success or
	  failure of a recent cryptosuite upgrade. The peer processes the final request
	  (Type=9) as follows:</t>
          <ol spacing="normal" type="1">
	    <li>The peer first compares the received MACs2 value with one it computed using
	    the Kz stored in the persistent EAP-NOOB association. If the received and computed
	    values match, the peer deletes any data stored in the CryptosuitepPrev and KzPrev
	    fields of the persistent EAP-NOOB association. It does this because the received
	    MACs2 confirms that the peer and server share the same Cryptosuitep and Kz, and
	    any previous values must no longer be accepted.</li>
            <li>On the other hand, if the peer finds that the received MACs2 value does not
	    match the one it computed locally with Kz, the peer checks whether the KzPrev
	    field in the persistent EAP-NOOB association stores a key. If it does, the peer
	    repeats the key derivation (<xref target="keyderivation" format="default"/>) and
	    local MACs2 computation (<xref target="messagedatafields" format="default"/>)
	    using KzPrev in place of Kz. If this second computed MACs2 matches the received
	    value, the match indicates synchronization failure caused by the loss of the last
	    response (Type=9) in a previously attempted cryptosuite upgrade. In this case, the
	    peer rolls back that upgrade by overwriting Cryptosuitep with CryptosuitepPrev and
	    Kz with KzPrev in the persistent EAP-NOOB association. It also clears the
	    CryptosuitepPrev and KzPrev fields.</li>
            <li>If the received MACs2 matched one of the locally computed values, the peer
	    proceeds to send the final response (Type=9). The peer also moves to the
	    Registered (4) state. When KeyingMode is 1 or 2, the peer stops here. When
	    KeyingMode is 3, the peer also updates the persistent EAP-NOOB association with
	    the negotiated Cryptosuitep and the newly derived Kz value. To prepare for
	    possible synchronization failure caused by the loss of the final response (Type=9)
	    during cryptosuite upgrade, the peer copies the old Cryptosuitep and Kz values in
	    the persistent EAP-NOOB association to the CryptosuitepPrev and KzPrev fields.</li>
            <li>Finally, if the peer finds that the received MACs2 does not match either of
	    the two values that it computed locally (or one value if no KzPrev was stored),
	    the peer sends an error message (error code 4001, see <xref
	    target="cryptofailure" format="default"/>), which causes the Reconnect Exchange
	    to end in EAP-Failure.</li>
          </ol>
          <t>The server rules for processing the final message are simpler than the peer rules
	  because the server does not store previous keys and it never rolls back a
	  cryptosuite upgrade. Upon receiving the final response (Type=9), the server compares
	  the received value of MACp2 with one it computes locally. If the values match, the
	  Reconnect Exchange ends in EAP-Success. When KeyingMode is 3, the server also
	  updates Cryptosuitep and Kz in the persistent EAP-NOOB association. On the other
	  hand, if the server finds that the values do not match, it sends an error message
	  (error code 4001), and the Reconnect Exchange ends in EAP-Failure.</t>
          <t>The endpoints <bcp14>MAY</bcp14> send updated NewNAI, ServerInfo, and PeerInfo
	  objects in the Reconnect Exchange. When there is no update to the values, they
	  <bcp14>SHOULD</bcp14> omit this information from the messages. If the NewNAI was
	  sent, each side updates NAI in the persistent EAP-NOOB association when moving to
	  the Registered (4) state.</t>
          <figure anchor="fig-reconnect">
            <name>Reconnect Exchange</name>
            <artwork align="center" name="" type="" alt=""><![CDATA[
EAP Peer                                        EAP Server
  |       ...continuing from common handshake        |
  |                                                  |
  |<----------- EAP-Request/EAP-NOOB ----------------|
  |      (Type=7,Vers,PeerId,Cryptosuites,           |
  |       [NewNAI],[ServerInfo])                     |
  |                                                  |
  |                                                  |
  |------------ EAP-Response/EAP-NOOB -------------->|
  |      (Type=7,Verp,PeerId,Cryptosuitep,[PeerInfo])|
  |                                                  |
  |                                                  |
  |<----------- EAP-Request/EAP-NOOB ----------------|
  |      (Type=8,PeerId,KeyingMode,[PKs2],Ns2)       |
  |                                                  |
  |                                                  |
  |------------ EAP-Response/EAP-NOOB -------------->|
  |      (Type=8,PeerId,[PKp2],Np2)                  |
  |                                                  |
  |                                                  |
  |<----------- EAP-Request/EAP-NOOB ----------------|
  |      (Type=9,PeerId,MACs2)                       |
  |                                                  |
  |                                                  |
  |------------ EAP-Response/EAP-NOOB -------------->|
  |      (Type=9,PeerId,MACp2)                       |
  |                                                  |
  |                                                  |
  |<----------- EAP-Success -------------------------|
  |                                                  |
]]></artwork>
          </figure>
        </section>
        <section anchor="userreset" numbered="true" toc="default">
          <name>User Reset</name>
          <t>As shown in the association state machine in <xref target="fig-statemachine"
	  format="default"/>, the only specified way for the association to return from the
	  Registered (4) state to the Unregistered (0) state is through user-initiated reset.
	  After the reset, a new OOB message will be needed to establish a new association
	  between the EAP server and peer. Typical situations in which the user reset is
	  required are when the other side has accidentally lost the persistent EAP-NOOB
	  association data or when the peer device is decommissioned.</t>
          <t>The server could detect that the peer is in the Registered or Reconnecting state,
	  but the server itself is in one of the ephemeral states 0..2 (including situations
	  where the server does not recognize the PeerId). In this case, effort should be made
	  to recover the persistent server state, for example, from a backup storage --
	  especially if many peer devices are similarly affected. If that is not possible, the
	  EAP server <bcp14>SHOULD</bcp14> log the error or notify an administrator. The only
	  way to continue from such a situation is by having the user reset the peer
	  device.</t>
          <t>On the other hand, if the peer is in any of the ephemeral states 0..2, including
	  the Unregistered state, the server will treat the peer as a new peer device and
	  allocate a new PeerId to it. The PeerInfo can be used by the user as a clue to which
	  physical device has lost its state. However, there is no secure way of matching the
	  "new" peer with the old PeerId without repeating the OOB Step. This situation will
	  be resolved when the user performs the OOB Step and thus identifies the physical
	  peer device. The server user interface <bcp14>MAY</bcp14> support situations where
	  the "new" peer is actually a previously registered peer that has been reset by a
	  user or otherwise lost its persistent data. In those cases, the user could choose to
	  merge the new peer identity with the old one in the server. The alternative is to
	  treat the device just like a new peer.</t>
        </section>
      </section>
      <section anchor="keyderivation" numbered="true" toc="default">
        <name>Key Derivation</name>
        <t>EAP-NOOB derives the EAP output values MSK and EMSK and other secret keying
	material from the output of an Ephemeral Elliptic Curve Diffie-Hellman (ECDHE)
	algorithm following the NIST specification <xref target="NIST-DH" format="default"/>.
	In NIST terminology, we use a C(2e, 0s, ECC CDH) scheme, i.e., two ephemeral keys and
	no static keys. In the Initial Exchange and Reconnect Exchange, the server and peer
	compute the ECDHE shared secret Z, as defined in Section 6.1.2 of the NIST specification <xref target="NIST-DH" />. In the Completion
	Exchange and
	Reconnect Exchange, the server and peer compute the secret keying material from Z
	with the one-step key derivation function (KDF) defined in Section 5.8.2.1 of the NIST
	specification. The auxiliary function H is a hash function, and it is taken from the
	negotiated cryptosuite.</t>
        <table anchor="keyingmodes" align="center">
          <name>Keying Modes</name>
          <thead>
            <tr>
              <th align="left">KeyingMode</th>
              <th align="left">Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0</td>
              <td align="left">Completion Exchange (always with ECDHE)</td>
            </tr>
            <tr>
              <td align="left">1</td>
              <td align="left">Reconnect Exchange, rekeying without ECDHE</td>
            </tr>
            <tr>
              <td align="left">2</td>
              <td align="left">Reconnect Exchange, rekeying with ECHDE, no change in
	      cryptosuite</td>
            </tr>
            <tr>
              <td align="left">3</td>
              <td align="left">Reconnect Exchange, rekeying with ECDHE, new cryptosuite
	      negotiated</td>
            </tr>
          </tbody>
        </table>
        <t>The key derivation has four different modes (KeyingMode), which are specified in
	<xref target="keyingmodes" format="default"/>. <xref target="tab-keyderivationinput"
	format="default"/> defines the inputs to KDF in each KeyingMode.</t>
        <t>In the Completion Exchange (KeyingMode=0), the input Z comes from the preceding
	Initial exchange. The KDF takes some additional inputs (FixedInfo), for which we use
	the
	concatenation format defined in Section
	5.8.2.1.1 of the NIST specification <xref target="NIST-DH" />. FixedInfo consists of the AlgorithmId,
	PartyUInfo, PartyVInfo, and SuppPrivInfo fields. The first three fields are
	fixed-length bit strings, and SuppPrivInfo is a variable-length string with a one-byte
	Datalength counter. AlgorithmId is the fixed-length, 8-byte ASCII string "EAP-NOOB".
	The other input values are the server and peer nonces. In the Completion Exchange, the
	inputs also include the secret nonce Noob from the OOB message.</t>
        <t>In the simplest form of the Reconnect Exchange (KeyingMode=1), fresh nonces are
	exchanged, but no ECDHE keys are sent. In this case, input Z to the KDF is replaced
	with the shared key Kz from the persistent EAP-NOOB association. The result is
	rekeying without the computational cost of the ECDHE exchange but also without
	forward secrecy.</t>
        <t>When forward secrecy is desired in the Reconnect Exchange (KeyingMode=2 or
	KeyingMode=3), both nonces and ECDHE keys are exchanged. Input Z is the fresh shared
	secret from the ECDHE exchange with PKs2 and PKp2. The inputs also include the shared
	secret Kz from the persistent EAP-NOOB association. This binds the rekeying output to
	the previously authenticated keys.</t>
        <table anchor="tab-keyderivationinput" align="center">
          <name>Key Derivation Input</name>
          <thead>
            <tr>
              <th align="left">KeyingMode</th>
              <th align="left">KDF input field</th>
              <th align="left">Value</th>
              <th align="left">Length (bytes)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" rowspan="6">0 Completion</td>
              <td align="left">Z</td>
              <td align="left">ECDHE shared secret from PKs and PKp</td>
              <td align="left">variable</td>
            </tr>
            <tr>
              <td align="left">AlgorithmId</td>
              <td align="left">"EAP-NOOB"</td>
              <td align="left">8</td>
            </tr>
            <tr>
              <td align="left">PartyUInfo</td>
              <td align="left">Np</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left">PartyVInfo</td>
              <td align="left">Ns</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left">SuppPubInfo</td>
              <td align="left">(not allowed)</td>
              <td align="left"/>
            </tr>
            <tr>
              <td align="left">SuppPrivInfo</td>
              <td align="left">Noob</td>
              <td align="left">16</td>
            </tr>
            <tr>
              <td align="left" rowspan="6">1 Reconnect, rekeying without ECDHE</td>
              <td align="left">Z</td>
              <td align="left">Kz</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left">AlgorithmId</td>
              <td align="left">"EAP-NOOB"</td>
              <td align="left">8</td>
            </tr>
            <tr>
              <td align="left">PartyUInfo</td>
              <td align="left">Np2</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left">PartyVInfo</td>
              <td align="left">Ns2</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left">SuppPubInfo</td>
              <td align="left">(not allowed)</td>
              <td align="left"/>
            </tr>
            <tr>
              <td align="left">SuppPrivInfo</td>
              <td align="left">(null)</td>
              <td align="left">0</td>
            </tr>
            <tr>
              <td align="left" rowspan="6">2 or 3 Reconnect, rekeying, with ECDHE, same or new cryptosuite</td>
              <td align="left">Z</td>
              <td align="left">ECDHE shared secret from PKs2 and PKp2</td>
              <td align="left">variable</td>
            </tr>
            <tr>
              <td align="left">AlgorithmId</td>
              <td align="left">"EAP-NOOB"</td>
              <td align="left">8</td>
            </tr>
            <tr>
              <td align="left">PartyUInfo</td>
              <td align="left">Np2</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left">PartyVInfo</td>
              <td align="left">Ns2</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left">SuppPubInfo</td>
              <td align="left">(not allowed)</td>
              <td align="left"/>
            </tr>
            <tr>
              <td align="left">SuppPrivInfo</td>
              <td align="left">Kz</td>
              <td align="left">32</td>
            </tr>
          </tbody>
        </table>	
        <t><xref target="tab-keyderivationoutput" format="default"/> defines how the output
	bytes of the KDF are used. In addition to the EAP output values MSK and EMSK, the
	server and peer derive another shared secret key AMSK (Application Main Session Key),
	which <bcp14>MAY</bcp14> be used for
	application-layer security. Further output bytes are used internally by EAP-NOOB for
	the message authentication keys (Kms, Kmp, Kms2, and Kmp2).</t>
        <t>The Completion Exchange (KeyingMode=0) produces the shared secret Kz, which the
	server and peer store in the persistent EAP-NOOB association. When a new cryptosuite
	is negotiated in the Reconnect Exchange (KeyingMode=3), it similarly produces a new
	Kz. In that case, the server and peer update both the cryptosuite and Kz in the
	persistent EAP-NOOB association. Additionally, the peer stores the previous
	Cryptosuitep and Kz values in the CryptosuitepPrev and KzPrev fields of the persistent
	EAP-NOOB association.</t>
        <table anchor="tab-keyderivationoutput" align="center">
          <name>Key Derivation Output</name>
          <thead>
            <tr>
              <th align="left">KeyingMode</th>
              <th align="left">KDF output bytes</th>
              <th align="left">Used as</th>
              <th align="left">Length (bytes)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left" rowspan="7">0 Completion</td>
              <td align="left">0..63</td>
              <td align="left">MSK</td>
              <td align="left">64</td>
            </tr>
            <tr>
              <td align="left">64..127</td>
              <td align="left">EMSK</td>
              <td align="left">64</td>
            </tr>
            <tr>
              <td align="left">128..191</td>
              <td align="left">AMSK</td>
              <td align="left">64</td>
            </tr>
            <tr>
              <td align="left">192..223</td>
              <td align="left">MethodId</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left">224..255</td>
              <td align="left">Kms</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left">256..287</td>
              <td align="left">Kmp</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left">288..319</td>
              <td align="left">Kz</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left" rowspan="6">1 or 2 Reconnect, rekeying without ECDHE, or with ECDHE and unchanged cryptosuite</td>
              <td align="left">0..63</td>
              <td align="left">MSK</td>
              <td align="left">64</td>
            </tr>
            <tr>
              <td align="left">64..127</td>
              <td align="left">EMSK</td>
              <td align="left">64</td>
            </tr>
            <tr>
              <td align="left">128..191</td>
              <td align="left">AMSK</td>
              <td align="left">64</td>
            </tr>
            <tr>
              <td align="left">192..223</td>
              <td align="left">MethodId</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left">224..255</td>
              <td align="left">Kms2</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left">256..287</td>
              <td align="left">Kmp2</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left" rowspan="7">3 Reconnect, rekeying with ECDHE, new cryptosuite</td>
              <td align="left">0..63</td>
              <td align="left">MSK</td>
              <td align="left">64</td>
            </tr>
            <tr>
              <td align="left">64..127</td>
              <td align="left">EMSK</td>
              <td align="left">64</td>
            </tr>
            <tr>
              <td align="left">128..191</td>
              <td align="left">AMSK</td>
              <td align="left">64</td>
            </tr>
            <tr>
              <td align="left">192..223</td>
              <td align="left">MethodId</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left">224..255</td>
              <td align="left">Kms2</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left">256..287</td>
              <td align="left">Kmp2</td>
              <td align="left">32</td>
            </tr>
            <tr>
              <td align="left">288..319</td>
              <td align="left">Kz</td>
              <td align="left">32</td>
            </tr>
          </tbody>
        </table>
        <t>Finally, every EAP method must export a Server-Id, Peer-Id, and Session-Id <xref
	target="RFC5247" format="default"/>. In EAP-NOOB, the exported Peer-Id is the PeerId
	that the server has assigned to the peer. The exported Server-Id is a zero-length
	string (i.e., null string) because EAP-NOOB neither knows nor assigns any server
	identifier.  
The exported Session-Id is created by concatenating the one-byte Type-Code 0x38 (decimal value 56) with the
MethodId, which is obtained from the KDF output, as shown in <xref
target="tab-keyderivationoutput" format="default"/>.</t>
      </section>
      <section anchor="failure" numbered="true" toc="default">
        <name>Error Handling</name>
        <t>Various error conditions in EAP-NOOB are handled by sending an error notification
	message (Type=0) instead of a next EAP request or response message. Both the EAP
	server and the peer may send the error notification, as shown in Figures <xref
	target="fig-servererror" format="counter"/> and <xref target="fig-peererror"
	format="counter"/>. After sending or receiving an error notification, the server
	<bcp14>MUST</bcp14> send an EAP-Failure (as required by <xref target="RFC3748"
	sectionFormat="comma" section="4.2"/>). The notification <bcp14>MAY</bcp14> contain an
	ErrorInfo field, which is a UTF-8-encoded text string with a maximum length of 500
	bytes. It is used for sending descriptive information about the error for logging and
	debugging purposes.</t>
        <figure anchor="fig-servererror">
          <name>Error Notification from Server to Peer</name>
          <artwork align="center" name="" type="" alt=""><![CDATA[
EAP Peer                                        EAP Server
  ...                                                ...
  |                                                  |
  |<----------- EAP-Request/EAP-NOOB ----------------|
  |        (Type=0,[PeerId],ErrorCode,[ErrorInfo])   |
  |                                                  |
  |                                                  |
  |<----------- EAP-Failure -------------------------|
  |                                                  |
]]></artwork>
        </figure>
        <figure anchor="fig-peererror">
          <name>Error Notification from Peer to Server</name>
          <artwork align="center" name="" type="" alt=""><![CDATA[
EAP Peer                                        EAP Server
  ...                                                ...
  |                                                  |
  |------------ EAP-Response/EAP-NOOB -------------->|
  |        (Type=0,[PeerId],ErrorCode,[ErrorInfo])   |
  |                                                  |
  |                                                  |
  |<----------- EAP-Failure -------------------------|
  |                                                  |
]]></artwork>
        </figure>
        <t>After the exchange fails due to an error notification, the server and peer set the
	association state as follows. In the Initial Exchange, both the sender and recipient
	of the error notification <bcp14>MUST</bcp14> set the association state to the
	Unregistered (0) state. In the Waiting Exchange and Completion Exchange, each side
	<bcp14>MUST</bcp14> remain in its old state as if the failed exchange had not taken
	place, with the exception that the recipient of error code 2003 processes it as
	specified in <xref target="completionexchange" format="default"/>. In the Reconnect
	Exchange, both sides <bcp14>MUST</bcp14> set the association state to the Reconnecting
	(3) state.</t>
        <t>Errors that occur in the OOB channel are not explicitly notified in-band.</t>
        <section anchor="invalidmessages" numbered="true" toc="default">
          <name>Invalid Messages</name>
          <t>If the NAI structure is invalid, the server <bcp14>SHOULD</bcp14> send the error
	  code 1001 to the peer. The recipient of an EAP-NOOB request or response
	  <bcp14>SHOULD</bcp14> send the following error codes back to the sender: 1002 if it
	  cannot parse the message as a JSON object or the top-level JSON object has missing
	  or unrecognized members; 1003 if a data field has an invalid value, such as an
	  integer out of range, and there is no more specific error code available; 1004 if
	  the received message type was unexpected in the current state; 2004 if the PeerId
	  has an unexpected value; 2003 if the NoobId is not recognized; and 1005 if the ECDHE
	  key is invalid.</t>
        </section>
        <section anchor="unwantedpeer" numbered="true" toc="default">
          <name>Unwanted Peer</name>
          <t>The preferred way for the EAP server to rate limit EAP-NOOB connections from a
	  peer is to use the SleepTime parameter in the Waiting Exchange. However, if the EAP
	  server receives repeated EAP-NOOB connections from a peer that apparently should
	  not connect to this server, the server <bcp14>MAY</bcp14> indicate that the
	  connections are unwanted by sending the error code 2001. After receiving this error
	  message, the peer <bcp14>MAY</bcp14> refrain from reconnecting to the same EAP
	  server, and, if possible, both the EAP server and peer <bcp14>SHOULD</bcp14>
	  indicate
	  this error condition to the user or server administrator. However, in order to avoid
	  persistent denial of service, peer devices that are unable to alert a user
	  <bcp14>SHOULD</bcp14> continue to try to reconnect infrequently (e.g., approximately
	  every 3600 seconds). </t>
        </section>
        <section anchor="statemismatch" numbered="true" toc="default">
          <name>State Mismatch</name>
          <t>In the states indicated by "-" in <xref target="tab-exchanges" format="default"/>
	  in <xref target="exchangeappendix" format="default"/>, user action is required to
	  reset the association state or to recover it, for example, from backup storage. In
	  those cases, the server sends the error code 2002 to the peer. If possible, both the
	  EAP server and peer <bcp14>SHOULD</bcp14> indicate this error condition to the user
	  or server administrator.</t>
        </section>
        <section anchor="negotiationfailure" numbered="true" toc="default">
          <name>Negotiation Failure</name>
          <t>If there is no matching protocol version, the peer sends the error code 3001 to
	  the server. If there is no matching cryptosuite, the peer sends the error code 3002
	  to the server. If there is no matching OOB direction, the peer sends the error code
	  3003 to the server.</t>
          <t>In practice, there is no way of recovering from these errors without software or
	  hardware changes. If possible, both the EAP server and peer <bcp14>SHOULD</bcp14>
	  indicate these error conditions to the user.</t>
        </section>
        <section anchor="cryptofailure" numbered="true" toc="default">
          <name>Cryptographic Verification Failure</name>
          <t>If the receiver of the OOB message detects an unrecognized PeerId or incorrect
	  fingerprint (Hoob) in the OOB message, the receiver <bcp14>MUST</bcp14> remain in
	  the Waiting for OOB (1) state as if no OOB message was received. The receiver
	  <bcp14>SHOULD</bcp14> indicate the failure to accept the OOB message to the user. No
	  in-band error message is sent.</t>
          <t>Note that if the OOB message was delivered from the server to the peer and the
	  peer does not recognize the PeerId, the likely cause is that the user has
	  unintentionally delivered the OOB message to the wrong peer device. If possible, the
	  peer <bcp14>SHOULD</bcp14> indicate this to the user; however, the peer device may
	  not have the capability for many different error indications to the user, and it
	  <bcp14>MAY</bcp14> use the same indication as in the case of an incorrect
	  fingerprint.</t>
          <t>The rationale for the above is that the invalid OOB message could have been
	  presented to the receiver by mistake or intentionally by a malicious party;
	  thus, it should be ignored in the hope that the honest user will soon deliver a
	  correct OOB message.</t>
          <t>If the EAP server or peer detects an incorrect message authentication code (MACs,
	  MACp, MACs2, or MACp2), it sends the error code 4001 to the other side. As
	  specified in
	  the beginning of <xref target="failure" format="default"/>, the failed Completion
	  Exchange will not result in server or peer state changes, while an error in the
	  Reconnect Exchange will put both sides to the Reconnecting (3) state and thus lead
	  to another reconnect attempt.</t>
          <t>The rationale for this is that the invalid cryptographic message may have been
	  spoofed by a malicious party; thus, it should be ignored. In particular, a
	  spoofed message on the in-band channel should not force the honest user to perform
	  the OOB Step again. In practice, however, the error may be caused by other failures,
	  such as a software bug. For this reason, the EAP server <bcp14>MAY</bcp14> limit the
	  rate of peer connections with SleepTime after the above error. Also, there
	  <bcp14>SHOULD</bcp14> be a way for the user to reset the peer to the Unregistered
	  (0) state so that the OOB Step can be repeated as the last resort.</t>
        </section>
        <section anchor="appfailure" numbered="true" toc="default">
          <name>Application-Specific Failure</name>
          <t>Applications <bcp14>MAY</bcp14> define new error messages for failures that are
	  specific to the application or to one type of OOB channel. They <bcp14>MAY</bcp14>
	  also use the generic application-specific error code 5001 or the error codes 5002
	  and 5004, which have been reserved for indicating invalid data in the ServerInfo and
	  PeerInfo fields, respectively. Additionally, anticipating OOB channels that make use
	  of a URL, the error code 5003 has been reserved for indicating an invalid server
	  URL.</t>
        </section>
      </section>
    </section>
    <section anchor="serverinfo-peerinfo-meaning" numbered="true" toc="default">
      <name>ServerInfo and PeerInfo Contents</name>
      <t>The ServerInfo and PeerInfo fields in the Initial Exchange and Reconnect Exchange
      enable the server and peer, respectively, to send information about themselves to the
      other endpoint. They contain JSON objects whose structure may be specified separately
      for each application and each type of OOB channel. ServerInfo and PeerInfo
      <bcp14>MAY</bcp14> contain auxiliary data needed for the OOB channel messaging and for
      EAP channel binding (see <xref target="channel-binding" format="default"/>). This
      section describes the optional initial data fields for ServerInfo and PeerInfo
      registered by this specification. Further specifications may request new
      application-specific ServerInfo and PeerInfo data fields from IANA (see Sections <xref
      target="serverinfo-data-fields" format="counter"/> and <xref
      target="peerinfo-data-fields" format="counter"/>).
      </t>
      <table anchor="tab-serverinfo-meaning" align="center">
        <name>ServerInfo Data Fields</name>
        <thead>
          <tr>
            <th align="left">Data Field</th>
            <th align="left">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">Type</td>
            <td align="left">Type-tag string that can be used by the peer as a hint for how to
	    interpret the ServerInfo contents.</td>
          </tr>
          <tr>
            <td align="left">ServerName</td>
            <td align="left">String that may be used to aid human identification of the
	    server.</td>
          </tr>
          <tr>
            <td align="left">ServerURL</td>
            <td align="left">Prefix string when the OOB message is formatted as a URL, as
	    suggested in <xref target="urloob" format="default"/>.</td>
          </tr>
          <tr>
            <td align="left">SSIDList</td>
            <td align="left">List of IEEE 802.11 wireless network service set identifier
	    (SSID) strings
	    used for roaming support, as suggested in <xref target="roaming"
	    format="default"/>. JSON array of ASCII-encoded SSID strings.</td>
          </tr>
          <tr>
            <td align="left">Base64SSIDList</td>
            <td align="left">List of IEEE 802.11 wireless network identifier (SSID) strings
	    used for roaming support, as suggested in <xref target="roaming"
	    format="default"/>. JSON array of SSIDs, each of which is base64url-encoded
	    without padding. Peers <bcp14>SHOULD</bcp14> send at most one of the fields
	    SSIDList and Base64SSIDList in PeerInfo, and the server <bcp14>SHOULD</bcp14>
	    ignore SSIDList if Base64SSIDList is included.</td>
          </tr>
        </tbody>
      </table>
      <table anchor="tab-peerinfo-meaning" align="center">
        <name>PeerInfo Data Fields</name>
        <thead>
          <tr>
            <th align="left">Data Field</th>
            <th align="left">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">Type</td>
            <td align="left">Type-tag string that can be used by the server as a hint for how
	    to interpret the PeerInfo contents.</td>
          </tr>
          <tr>
            <td align="left">PeerName</td>
            <td align="left">String that may be used to aid human identification of the
	    peer.</td>
          </tr>
          <tr>
            <td align="left">Manufacturer</td>
            <td align="left">Manufacturer or brand string.</td>
          </tr>
          <tr>
            <td align="left">Model</td>
            <td align="left">Manufacturer-specified model string.</td>
          </tr>
          <tr>
            <td align="left">SerialNumber</td>
            <td align="left">Manufacturer-assigned serial number.</td>
          </tr>
          <tr>
            <td align="left">MACAddress</td>
            <td align="left">Peer link-layer 48-bit extended unique identifier (EUI-48) in
	    the 12-digit base-16 form
	    <xref target="EUI-48" format="default"/>. The string <bcp14>MAY</bcp14> be in
	    upper or lower case and <bcp14>MAY</bcp14> include additional colon ':' or dash
	    '-' characters that <bcp14>MUST</bcp14> be ignored by the server.</td>
          </tr>
          <tr>
            <td align="left">SSID</td>
            <td align="left">IEEE 802.11 network SSID for channel binding. The SSID is an
	    ASCII string.</td>
          </tr>
          <tr>
            <td align="left">Base64SSID</td>
            <td align="left">IEEE 802.11 network SSID for channel binding. The SSID is
	    base64url encoded. Peer <bcp14>SHOULD</bcp14> send at most one of the fields SSID
	    and Base64SSID in PeerInfo, and the server <bcp14>SHOULD</bcp14> ignore SSID if
	    Base64SSID is included.</td>
          </tr>
          <tr>
            <td align="left">BSSID</td>
            <td align="left">Wireless network basic service set identifier (BSSID) (EUI-48)
	    in the 12-digit base-16 form
	    <xref target="EUI-48" format="default"/> for channel binding. The string
	    <bcp14>MAY</bcp14> be in upper or lower case and <bcp14>MAY</bcp14> include
	    additional colon ':' or dash '-' characters that <bcp14>MUST</bcp14> be ignored by
	    the server.</td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="iana" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>This section provides information
      regarding registration of values related to the EAP-NOOB method, in accordance with
      <xref target="RFC8126" format="default"/>.</t>
      <t>The EAP Method Type for EAP-NOOB (value 56) has been assigned in the "Method Types"
      subregistry of the "Extensible Authentication Protocol (EAP) Registry".</t>
      <t>Per this memo, IANA has created and will maintain a new registry entitled "Nimble
      Out-of-Band Authentication for EAP Parameters (EAP-NOOB)" in the Extensible Authentication Protocol
      (EAP) category. Also, IANA has created and will maintain the subregistries defined in
      the following subsections. </t>
      <section anchor="cryptosuites" numbered="true" toc="default">
        <name>Cryptosuites</name>
        <t>IANA has created and will maintain a new subregistry entitled "EAP-NOOB
	Cryptosuites" in the "Nimble Out-of-Band Authentication for EAP Parameters (EAP-NOOB)" registry.
	Cryptosuites are identified by an integer. Each cryptosuite <bcp14>MUST</bcp14>
	specify an ECDHE curve for the key exchange, encoding of the ECDHE public key as a JWK
	object, and a cryptographic hash function for the fingerprint and HMAC computation and
	key derivation. The hash value output by the cryptographic hash function
	<bcp14>MUST</bcp14> be at least 32 bytes in length. The initial values for this
	registry are:</t>
        <table anchor="tab-cryptosuites" align="center">
          <name>EAP-NOOB Cryptosuites</name>
          <thead>
            <tr>
              <th align="left">Cryptosuite</th>
              <th align="left">Algorithms</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0</td>
              <td align="left">Reserved</td>
            </tr>
            <tr>
              <td align="left">1</td>
              <td align="left">ECDHE curve Curve25519 <xref target="RFC7748"
	      format="default"/>, public-key format <xref target="RFC7517" format="default"/>,
	      hash function SHA-256 <xref target="RFC6234" format="default"/>. The JWK
	      encoding of Curve25519 public key is defined in <xref target="RFC8037"
	      format="default"/>. For clarity, the "crv" parameter is "X25519", the "kty"
	      parameter is "OKP", and the public-key encoding contains only an
	      x-coordinate.</td>
            </tr>
            <tr>
              <td align="left">2</td>
              <td align="left">ECDHE curve NIST P-256 <xref target="FIPS186-4"
	      format="default"/>, public-key format <xref target="RFC7517" format="default"/>,
	      hash function SHA-256 <xref target="RFC6234" format="default"/>. The JWK
	      encoding of NIST P-256 public key is defined in <xref target="RFC7518"
	      format="default"/>. For clarity, the "crv" parameter is "P-256", the "kty"
	      parameter is "EC", and the public-key encoding has both an x and y coordinate,
	      as defined in <xref target="RFC7518" sectionFormat="of" section="6.2.1"/>.</td>
            </tr>
          </tbody>
        </table>
        <t>EAP-NOOB implementations <bcp14>MUST</bcp14> support Cryptosuite 1. Support for
	Cryptosuite 2 is <bcp14>RECOMMENDED</bcp14>. An example of a Cryptosuite 1 public-key
	encoded as a JWK object is given below. (Line breaks are for readability only.)</t>
<sourcecode type="json">    
"jwk":{"kty":"OKP","crv":"X25519","x":"3p7bfXt9wbTTW2HC7OQ1Nz-
DQ8hbeGdNrfx-FG-IK08"}
</sourcecode>
          <t>Assignment of new values for new cryptosuites <bcp14>MUST</bcp14> be done through
          IANA with "Specification Required", as defined in <xref target="RFC8126"
	  format="default"/>.</t>
      </section>
      <section anchor="messagetypes" numbered="true" toc="default">
        <name>Message Types</name>
        <t>IANA has created and will maintain a new subregistry entitled "EAP-NOOB
	Message Types" in the "Nimble Out-of-Band Authentication for EAP Parameters (EAP-NOOB)" registry.
	EAP-NOOB request and response pairs are identified by an integer Message Type. The
	initial values for this registry are:</t>
        <table anchor="tab-messagetypes" align="center">
          <name>EAP-NOOB Message Types</name>
          <thead>
            <tr>
              <th align="left">Message Type</th>
              <th align="left">Used in Exchange</th>
              <th align="left">Purpose</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">0</td>
              <td align="left">Error</td>
              <td align="left">Error notification</td>
            </tr>
            <tr>
              <td align="left">1</td>
              <td align="left">All exchanges</td>
              <td align="left">PeerId and PeerState discovery</td>
            </tr>
            <tr>
              <td align="left">2</td>
              <td align="left">Initial</td>
              <td align="left">Version, cryptosuite, and parameter negotiation</td>
            </tr>
            <tr>
              <td align="left">3</td>
              <td align="left">Initial</td>
              <td align="left">Exchange of ECDHE keys and nonces</td>
            </tr>
            <tr>
              <td align="left">4</td>
              <td align="left">Waiting</td>
              <td align="left">Indication to the peer that the server has not yet received an
	      OOB message</td>
            </tr>
            <tr>
              <td align="left">5</td>
              <td align="left">Completion</td>
              <td align="left">NoobId discovery</td>
            </tr>
            <tr>
              <td align="left">6</td>
              <td align="left">Completion</td>
              <td align="left">Authentication and key confirmation with HMAC</td>
            </tr>
            <tr>
              <td align="left">7</td>
              <td align="left">Reconnect</td>
              <td align="left">Version, cryptosuite, and parameter negotiation</td>
            </tr>
            <tr>
              <td align="left">8</td>
              <td align="left">Reconnect</td>
              <td align="left">Exchange of ECDHE keys and nonces</td>
            </tr>
            <tr>
              <td align="left">9</td>
              <td align="left">Reconnect</td>
              <td align="left">Authentication and key confirmation with HMAC</td>
            </tr>
          </tbody>
        </table>
        <t>Assignment of new values for new Message Types <bcp14>MUST</bcp14> be done through
	IANA with "Specification Required", as defined in <xref target="RFC8126"
	format="default"/>.</t>
      </section>
      <section anchor="errorcodes" numbered="true" toc="default">
        <name>Error Codes</name>
        <t>IANA has created and will maintain a new subregistry entitled "EAP-NOOB
	Error codes" in the "Nimble Out-of-Band Authentication for EAP Parameters (EAP-NOOB)" registry.
	Cryptosuites are identified by an integer. The initial values for this registry
	are:</t>
        <table anchor="tab-errors" align="center">
          <name>EAP-NOOB Error Codes</name>
          <thead>
            <tr>
              <th align="left">Error code</th>
              <th align="left">Purpose</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">1001</td>
              <td align="left">Invalid NAI</td>
            </tr>
            <tr>
              <td align="left">1002</td>
              <td align="left">Invalid message structure</td>
            </tr>
            <tr>
              <td align="left">1003</td>
              <td align="left">Invalid data</td>
            </tr>
            <tr>
              <td align="left">1004</td>
              <td align="left">Unexpected message type</td>
            </tr>
            <tr>
              <td align="left">1005</td>
              <td align="left">Invalid ECDHE key</td>
            </tr>
            <tr>
              <td align="left">2001</td>
              <td align="left">Unwanted peer</td>
            </tr>
            <tr>
              <td align="left">2002</td>
              <td align="left">State mismatch, user action required</td>
            </tr>
            <tr>
              <td align="left">2003</td>
              <td align="left">Unrecognized OOB message identifier</td>
            </tr>
            <tr>
              <td align="left">2004</td>
              <td align="left">Unexpected peer identifier</td>
            </tr>
            <tr>
              <td align="left">3001</td>
              <td align="left">No mutually supported protocol version</td>
            </tr>
            <tr>
              <td align="left">3002</td>
              <td align="left">No mutually supported cryptosuite</td>
            </tr>
            <tr>
              <td align="left">3003</td>
              <td align="left">No mutually supported OOB direction</td>
            </tr>
            <tr>
              <td align="left">4001</td>
              <td align="left">HMAC verification failure</td>
            </tr>
            <tr>
              <td align="left">5001</td>
              <td align="left">Application-specific error</td>
            </tr>
            <tr>
              <td align="left">5002</td>
              <td align="left">Invalid server info</td>
            </tr>
            <tr>
              <td align="left">5003</td>
              <td align="left">Invalid server URL</td>
            </tr>
            <tr>
              <td align="left">5004</td>
              <td align="left">Invalid peer info</td>
            </tr>
            <tr>
              <td align="left">6001-6999</td>
              <td align="left">Reserved for Private and Experimental Use</td>
            </tr>
          </tbody>
        </table>
        <t>Assignment of new error codes <bcp14>MUST</bcp14> be done through IANA with
	"Specification Required", as defined in <xref target="RFC8126" format="default"/>,
	except for the range 6001-6999. This range is reserved for "Private Use" and
	"Experimental Use", both locally and on the open Internet.</t>
      </section>
      <section anchor="serverinfo-data-fields" numbered="true" toc="default">
        <name>ServerInfo Data Fields</name>
        <t>IANA has created and will maintain a new subregistry entitled "EAP-NOOB
	ServerInfo Data Fields" in the "Nimble Out-of-Band Authentication for EAP Parameters (EAP-NOOB)"
	registry. The initial values for this registry are:</t>
        <table anchor="tab-serverinfo-data-fields" align="center">
          <name>ServerInfo Data Fields</name>
          <thead>
            <tr>
              <th align="left">Data Field</th>
              <th align="left">Specification</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">Type</td>
              <td align="left">RFC 9140, <xref target="serverinfo-peerinfo-meaning"
	      format="default"/></td>
            </tr>
            <tr>
              <td align="left">ServerName</td>
              <td align="left">RFC 9140, <xref target="serverinfo-peerinfo-meaning"
	      format="default"/></td>
            </tr>
            <tr>
              <td align="left">ServerURL</td>
              <td align="left">RFC 9140, <xref target="serverinfo-peerinfo-meaning"
	      format="default"/></td>
            </tr>
            <tr>
              <td align="left">SSIDList</td>
              <td align="left">RFC 9140, <xref target="serverinfo-peerinfo-meaning"
	      format="default"/></td>
            </tr>
            <tr>
              <td align="left">Base64SSIDList</td>
              <td align="left">RFC 9140, <xref target="serverinfo-peerinfo-meaning"
	      format="default"/></td>
            </tr>
          </tbody>
        </table>
        <t>Assignment of new values for new ServerInfo data fields <bcp14>MUST</bcp14> be done
	through IANA with "Specification Required", as defined in <xref target="RFC8126"
	format="default"/>. </t>
      </section>
      <section anchor="peerinfo-data-fields" numbered="true" toc="default">
        <name>PeerInfo Data Fields</name>
        <t>IANA is requested to create and maintain a new subregistry entitled "EAP-NOOB
	PeerInfo Data Fields" in the "Nimble Out-of-Band Authentication for EAP Parameters (EAP-NOOB)"
	registry. The initial values for this registry are:</t>
        <table anchor="peerinfo-data-fields-table" align="center">
          <name>PeerInfo Data Fields</name>
          <thead>
            <tr>
              <th align="left">Data Field</th>
              <th align="left">Specification</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">Type</td>
              <td align="left">RFC 9140, <xref target="serverinfo-peerinfo-meaning"
	      format="default"/></td>
            </tr>
            <tr>
              <td align="left">PeerName</td>
              <td align="left">RFC 9140, <xref target="serverinfo-peerinfo-meaning"
	      format="default"/></td>
            </tr>
            <tr>
              <td align="left">Manufacturer</td>
              <td align="left">RFC 9140, <xref target="serverinfo-peerinfo-meaning"
	      format="default"/></td>
            </tr>
            <tr>
              <td align="left">Model</td>
              <td align="left">RFC 9140, <xref target="serverinfo-peerinfo-meaning"
	      format="default"/></td>
            </tr>
            <tr>
              <td align="left">SerialNumber</td>
              <td align="left">RFC 9140, <xref target="serverinfo-peerinfo-meaning"
	      format="default"/></td>
            </tr>
            <tr>
              <td align="left">MACAddress</td>
              <td align="left">RFC 9140, <xref target="serverinfo-peerinfo-meaning"
	      format="default"/></td>
            </tr>
            <tr>
              <td align="left">SSID</td>
              <td align="left">RFC 9140, <xref target="serverinfo-peerinfo-meaning"
	      format="default"/></td>
            </tr>
            <tr>
              <td align="left">Base64SSID</td>
              <td align="left">RFC 9140, <xref target="serverinfo-peerinfo-meaning"
	      format="default"/></td>
            </tr>
            <tr>
              <td align="left">BSSID</td>
              <td align="left">RFC 9140, <xref target="serverinfo-peerinfo-meaning"
	      format="default"/></td>
            </tr>
          </tbody>
        </table>
        <t>Assignment of new values for new PeerInfo data fields <bcp14>MUST</bcp14> be done
	through IANA with "Specification Required", as defined in <xref target="RFC8126"
	format="default"/>.</t>
      </section>
      <section anchor="specialdomainname" numbered="true" toc="default">
        <name>Domain Name Reservation</name>
        <t>The special-use domain "eap-noob.arpa" has been registered in the .arpa registry
	(<eref target="https://www.iana.org/domains/arpa"/>) and the "Special-Use Domain
	Names" registry (<eref target="https://www.iana.org/assignments/special-use-domain-names"/>).</t>
      </section>
      <section anchor="expertguidance" numbered="true" toc="default">
        <name>Guidance for Designated Experts</name>
        <t>Experts <bcp14>SHOULD</bcp14> be conservative in the allocation of new
	Cryptosuites. Experts <bcp14>MUST</bcp14> ascertain that the requested values match
	the current Crypto Forum Research Group (CFRG) guidance on cryptographic algorithm
	security. Experts <bcp14>MUST</bcp14> ensure that any new Cryptosuites fully specify
	the encoding of the ECDHE public key and should include details, such as the value of
	the "kty" (key type) parameter when JWK <xref target="RFC7517" format="default"/> encoding
	is used.</t>
        <t>Experts <bcp14>SHOULD</bcp14> be conservative in the allocation of new Message
	Types. Experts <bcp14>SHOULD</bcp14> ascertain that a well-defined specification for
	the new Message Type is permanently and publicly available.</t>
        <t>Experts <bcp14>SHOULD</bcp14> be conservative in the allocation of new Error codes,
	since the 6001-6999 range is already reserved for private and experimental use.</t>
        <t>Experts <bcp14>MAY</bcp14> be liberal in the allocation of new ServerInfo and
	PeerInfo data fields. Experts <bcp14>MUST</bcp14> ensure that the data field requested
	has a unique name that is not easily confused with existing registrations. For
	example, requests for a new PeerInfo data field "ssid" should be rejected even though
	it is unique because it can be confused with the existing registration of "SSID".
	Experts <bcp14>MUST</bcp14> ensure that a suitable Description for the data field is
	available.</t>
      </section>
    </section>
    <section anchor="securityconsiderations" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>EAP-NOOB is an authentication and key derivation protocol; thus, security
      considerations can be found in most sections of this specification. In the following, we
      explain the protocol design and highlight some other special considerations.</t>
      <section anchor="authenticationprinciple" numbered="true" toc="default">
        <name>Authentication Principle</name>
        <t>EAP-NOOB establishes a shared secret with an authenticated ECDHE key exchange. The
	mutual authentication in EAP-NOOB is based on two separate features, both conveyed in
	the OOB message. The first authentication feature is the secret nonce Noob. The peer
	and server use this secret in the Completion Exchange to mutually authenticate the
	session key previously created with ECDHE. The message authentication codes computed
	with the secret nonce Noob are alone sufficient for authenticating the key exchange.
	The second authentication feature is the integrity-protecting fingerprint Hoob. Its
	purpose is to prevent impersonation attacks even in situations where the attacker is
	able to eavesdrop on the OOB channel and the nonce Noob is compromised. In some
	human-assisted OOB channels, such as human-perceptible audio or a user-typed URL, it
	may be easier to detect tampering than disclosure of the OOB message, and such
	applications benefit from the second authentication feature.</t>
        <t>The additional security provided by the cryptographic fingerprint Hoob is somewhat
	intricate to understand. The endpoint that receives the OOB message uses Hoob to
	verify the integrity of the ECDHE exchange. Thus, the OOB receiver can detect
	impersonation attacks that may have happened on the in-band channel. The other
	endpoint, however, is not equally protected because the OOB message and fingerprint
	are sent only in one direction. Some protection to the OOB sender is afforded by the
	fact that the user may notice the failure of the association at the OOB receiver and
	therefore reset the OOB sender. Other device-pairing protocols have solved similar
	situations by requiring the user to confirm to the OOB sender that the association was
	accepted by the OOB receiver, e.g., with a button press on the sender side.
	Applications <bcp14>MAY</bcp14> implement EAP-NOOB in this way. Nevertheless, since
	EAP-NOOB was designed to work with strictly one-directional OOB communication and the
	fingerprint is only the second authentication feature, the EAP-NOOB specification does
	not mandate such explicit confirmation to the OOB sender.</t>
        <t>To summarize, EAP-NOOB uses the combined protection of the secret nonce Noob and
	the cryptographic fingerprint Hoob, both conveyed in the OOB message. The secret nonce
	Noob alone is sufficient for mutual authentication unless the attacker can eavesdrop
	on it from the OOB channel. Even if an attacker is able to eavesdrop on the secret
	nonce Noob, it nevertheless cannot perform a full impersonation attack on the in-band
	channel because a mismatching fingerprint would alert the OOB receiver, which would
	reject the OOB message. The attacker that eavesdropped on the secret nonce can
	impersonate the OOB receiver to the OOB sender. If it does, the association will
	appear to be complete only on the OOB sender side, and such situations have to be
	resolved by the user by resetting the OOB sender to the initial state.</t>
        <t>The expected use cases for EAP-NOOB are ones where it replaces a user-entered
	access credential in IoT appliances. In wireless network access without EAP, the
	user-entered credential is often a passphrase that is shared by all the network
	stations. The advantage of an EAP-based solution, including EAP-NOOB, is that it
	establishes a different shared secret for each peer device, which makes the system
	more resilient against device compromise. Another advantage is that it is possible to
	revoke the security association for an individual device on the server side.</t>
        <t>Forward secrecy during fast reconnect in EAP-NOOB is optional. The Reconnect
	Exchange in EAP-NOOB provides forward secrecy only if both the server and peer send
	their fresh ECDHE keys. This allows both the server and peer to limit the
	frequency of the costly computation that is required for forward secrecy. The server
	<bcp14>MAY</bcp14> adjust the frequency of its attempts at ECDHE rekeying based on
	what it knows about the peer's computational capabilities.</t>
        <t>Another way in which some servers may control their computational load is to reuse
	the same ECDHE key for all peers over a short server-specific time window. In that
	case, forward secrecy will be achieved only after the server updates its ECDHE key,
	which may be a reasonable trade-off between security and performance. However, the
	server <bcp14>MUST NOT</bcp14> reuse the same ECDHE key with the same peer when
	rekeying with ECDHE (KeyingMode=2 or KeyingMode=3). Instead, it can simply not send an
	ECDHE key (KeyingMode=1).</t>
        <t>The users delivering the OOB messages will often authenticate themselves to the EAP
	server, e.g., by logging into a secure web page or API. In this case, the server can
	associate the peer device with the user account. Applications that make use of
	EAP-NOOB can use this information for configuring the initial owner of the
	freshly registered device.</t>
      </section>
      <section anchor="deviceidentification" numbered="true" toc="default">
        <name>Identifying Correct Endpoints</name>
        <t>Potential weaknesses in EAP-NOOB arise from the fact that the user must physically
	identify the correct peer device. If the user mistakenly delivers the OOB message
	from the wrong peer device to the server, the server may create an association with
	the wrong peer. The reliance on the user in identifying the correct endpoints is an
	inherent property of user-assisted, out-of-band authentication. To understand the
	potential consequences of the user mistake, we need to consider a few different
	scenarios. In the first scenario, there is no malicious party, and the user makes an
	accidental mistake between two out-of-the-box devices that are both ready to be
	registered to a server. If the user delivers the OOB message from the wrong device to
	the server, confusion may arise but usually no security issues. In the second
	scenario, an attacker intentionally tricks the user, for example, by substituting the
	original peer device with a compromised one. This is essentially a supply chain attack
	where the user accepts a compromised physical device. </t>
        <t>There is also a third scenario, in which an opportunistic attacker tries to take
	advantage of the user's accidental mistake. For example, the user could play an audio
	or a blinking LED message to a device that is not expecting to receive it. In simple
	security bootstrapping solutions that transfer a primary key to the device via the OOB
	channel, the device could misuse or leak the accidentally received primary key.
	EAP-NOOB is not vulnerable to such opportunistic attackers because the OOB message has
	no value to anyone who did not take part in the corresponding Initial Exchange.</t>
        <t>One mechanism that can mitigate user mistakes is certification of peer devices. A
	certificate or an attestation token (e.g., <xref target="I-D.tschofenig-tls-cwt"
	format="default"/> and <xref target="I-D.ietf-rats-eat" format="default"/>) can convey
	to the server authentic identifiers and attributes, such as model and serial number,
	of the peer device. Compared to a fully certificate-based authentication, however,
	EAP-NOOB can be used without trusted third parties and does not require the user to
	know any identifier of the peer device; physical access to the device is sufficient
	for bootstrapping with EAP-NOOB.</t>
        <t>Similarly, the attacker can try to trick the user into delivering the OOB message
	to
	the wrong server so that the peer device becomes associated with the wrong server. If
	the EAP server is accessed through a web user interface, the attack is akin to
	phishing attacks where the user is tricked into accessing the wrong URL and wrong web
	page. OOB implementation with a dedicated app on a mobile device, which communicates
	with a server API at a preconfigured URL, can protect against such attacks. </t>
        <t>After the device registration, an attacker could clone the device identity by
	copying the keys from the persistent EAP-NOOB association into another device. The
	attacker can be an outsider who gains access to the keys or the device owner who wants
	to have two devices matching the same registration. The cloning threats can be
	mitigated by creating the cryptographic keys and storing the persistent EAP-NOOB
	association on the peer device in a secure hardware component such as a trusted
	execution environment (TEE). Furthermore, remote attestation on the application level
	could provide assurance to the server that the device has not been cloned. Reconnect
	Exchange with a new cryptosuite (KeyingMode=3) will also disconnect all but the first
	clone that performs the update.</t>
      </section>
      <section anchor="trustedpath" numbered="true" toc="default">
        <name>Trusted Path Issues and Misbinding Attacks</name>
        <t>Another potential threat is spoofed user input or output on the peer device. When
	the user is delivering the OOB message to or from the correct peer device, a trusted
	path between the user and the peer device is needed. That is, the user must
	communicate directly with an authentic operating system and EAP-NOOB implementation in
	the peer device and not with a spoofed user interface. Otherwise, a registered device
	that is under the control of the attacker could emulate the behavior of an
	unregistered device. The secure path can be implemented, for example, by having the
	user press a reset button to return the device to the Unregistered (0) state and to
	invoke
	a trusted UI. The problem with such trusted paths is that they are not standardized
	across devices.</t>
        <t>Another potential consequence of a spoofed UI is the misbinding attack where the
	user tries to register a correct but compromised device, which tricks the user into
	registering another (uncompromised) device instead. For example, the compromised
	device might have a malicious, full-screen app running, which presents to the user QR
	codes copied, in real time, from another device's screen. If the unwitting user scans
	the QR code and delivers the OOB message in it to the server, the wrong device may
	become registered in the server. Such misbinding vulnerabilities arise because the
	user does not have any secure way of verifying that the in-band cryptographic
	handshake and the out-of-band physical access are terminated at the same physical
	device. Sethi et al. <xref target="Sethi19" format="default"/> analyze the misbinding
	threat against device-pairing protocols and also EAP-NOOB. Essentially, all protocols
	where the authentication relies on the user's physical access to the device are
	vulnerable to misbinding, including EAP-NOOB.</t>
        <t>A standardized trusted path for communicating directly with the trusted computing
	base in a physical device would mitigate the misbinding threat, but such paths rarely
	exist in practice. Careful asset tracking on the server side can also prevent most
	misbinding attacks if the peer device sends its identifiers or attributes in the
	PeerInfo field and the server compares them with the expected values. The wrong but
	uncompromised device's PeerInfo will not match the expected values. Device
	certification by the manufacturer can further strengthen the asset tracking.</t>
      </section>
      <section anchor="peeridentifiers" numbered="true" toc="default">
        <name>Peer Identifiers and Attributes</name>
        <t>The PeerId value in the protocol is a server-allocated identifier for its
	association with the peer and <bcp14>SHOULD NOT</bcp14> be shown to the user because
	its value is initially ephemeral. Since the PeerId is allocated by the server and the
	scope of the identifier is the single server, the so-called identifier squatting
	attacks, where a malicious peer could reserve another peer's identifier, are not
	possible in EAP-NOOB. The server <bcp14>SHOULD</bcp14> assign a random or
	pseudorandom PeerId to each new peer. It <bcp14>SHOULD NOT</bcp14> select the PeerId
	based on any peer characteristics that it may know, such as the peer's link-layer
	network address.</t>
        <t>User reset or failure in the OOB Step can cause the peer to perform many Initial
	Exchanges with the server, which allocates many PeerId values and stores the ephemeral
	protocol state for them. The peer will typically only remember the latest ones.
	EAP-NOOB leaves it to the implementation to decide when to delete these ephemeral
	associations. There is no security reason to delete them early, and the server does
	not have any way to verify that the peers are actually the same one. Thus, it is
	safest to store the ephemeral states on the server for at least one day. If the OOB
	messages are sent only in the server-to-peer direction, the server <bcp14>SHOULD
	NOT</bcp14> delete the ephemeral state before all the related Noob values have
	expired.</t>
        <t>After completion of EAP-NOOB, the server may store the PeerInfo data, and the user
	may use it to identify the peer and its attributes, such as the make and model or
	serial number. A compromised peer could lie in the PeerInfo that it sends to the
	server. If the server stores any information about the peer, it is important that this
	information is approved by the user during or after the OOB Step. Without verification
	by the user or authentication on the application level, the PeerInfo is not
	authenticated information and should not be relied on. One possible use for the
	PeerInfo field is EAP channel binding (see <xref target="channel-binding"
	format="default"/>).</t>
      </section>
      <section anchor="downgrading" numbered="true" toc="default">
        <name>Downgrading Threats</name>
        <t>The fingerprint Hoob protects all the information exchanged in the Initial
	Exchange, including the cryptosuite negotiation. The message authentication codes MACs
	and MACp also protect the same information. The message authentication codes MACs2 and
	MACp2 protect information exchanged during key renegotiation in the Reconnect
	Exchange. This prevents downgrading attacks to weaker cryptosuites, as long as the
	possible attacks take more time than the maximum time allowed for the EAP-NOOB
	completion. This is typically the case for recently discovered cryptanalytic
	attacks.</t>
        <t>As an additional precaution, the EAP server and peer <bcp14>MUST</bcp14> check for
	downgrading attacks in the Reconnect Exchange as follows. As long as the server or
	peer saves any information about the other endpoint, it <bcp14>MUST</bcp14> also
	remember the previously negotiated cryptosuite and <bcp14>MUST NOT</bcp14> accept
	renegotiation of any cryptosuite that is known to be weaker than the previous one,
	such as a deprecated cryptosuite. Determining the relative strength of the
	cryptosuites is out of scope of this specification and may be managed by
	implementations or by local policies at the peer and server.</t>
        <t>Integrity of the direction negotiation cannot be verified in the same way as the
	integrity of the cryptosuite negotiation. That is, if the OOB channel used in an
	application is critically insecure in one direction, an on-path attacker could modify
	the negotiation messages and thereby cause that direction to be used. Applications
	that support OOB messages in both directions <bcp14>SHOULD</bcp14>, therefore, ensure
	that the OOB channel has sufficiently strong security in both directions. While this
	is a theoretical vulnerability, it could arise in practice if EAP-NOOB is deployed in
	new applications. Currently, we expect most peer devices to support only one OOB
	direction; in which case, interfering with the direction negotiation can only prevent
	the completion of the protocol.</t>
        <t>The long-term shared key material Kz in the persistent EAP-NOOB association is
	established with an ECDHE key exchange when the peer and server are first associated.
	It is a weaker secret than a manually configured random shared key because advances in
	cryptanalysis against the used ECDHE curve could eventually enable the attacker to
	recover Kz. EAP-NOOB protects against such attacks by allowing cryptosuite upgrades in
	the Reconnect Exchange and by updating the shared key material Kz whenever the
	cryptosuite is upgraded. We do not expect the cryptosuite upgrades to be frequent,
	but,
	if an upgrade becomes necessary, it can be done without manual reset and reassociation
	of the peer devices.</t>
      </section>
      <section anchor="indicators" numbered="true" toc="default">
        <name>Protected Success and Failure Indications</name>
        <t><xref target="RFC3748" sectionFormat="of" section="7.16"/> allows EAP methods to
	specify protected result indications because EAP-Success and EAP-Failure packets are
	neither acknowledged nor integrity protected. <xref target="RFC3748"
	format="default"/> notes that these indications may be explicit or implicit.</t>
        <t>EAP-NOOB relies on implicit, protected success indicators in the Completion
	Exchange and
	Reconnect Exchange. Successful verification of MACs and MACs2 in the EAP-Request
	message from the server (message type 6 and message type 9, respectively) acts as an
	implicit, protected success indication to the peer. Similarly, successful verification
	of MACp and MACp2 in the EAP-Response message from the peer (message type 6 and
	message type 9, respectively) act as an implicit, protected success indication to the
	server. </t>
        <t>EAP-NOOB failure messages are not protected. Protected failure result indications
	would not significantly improve availability since EAP-NOOB reacts to most malformed
	data by ending the current EAP conversation in EAP-Failure. However, since EAP-NOOB
	spans multiple conversations, failure in one conversation usually means no state
	change on the level of the EAP-NOOB state machine.</t>
      </section>
      <section anchor="channel-binding" numbered="true" toc="default">
        <name>Channel Binding</name>
        <t>EAP channel binding, defined in <xref target="RFC6677" format="default"/>, means
	that the endpoints compare their perceptions of network properties, such as
	lower-layer identifiers, over the secure channel established by EAP authentication.
	<xref target="RFC6677" sectionFormat="of" section="4.1"/> defines two approaches to
	channel binding. EAP-NOOB follows the first approach, in which the peer and server
	exchange plaintext information about the network over a channel that is integrity
	protected with keys derived during the EAP execution. More specifically, channel
	information is exchanged in the plaintext PeerInfo and ServerInfo objects and is later
	verified with message authentication codes (MACp, MACs, MACp2, and MACs2). This allows
	policy-based comparison with locally perceived network properties on either side, as
	well as logging for debugging purposes. The peer <bcp14>MAY</bcp14> include in
	PeerInfo any data items that it wants to bind to the EAP-NOOB association and to the
	exported keys. These can be properties of the authenticator or the access link, such
	as the SSID and BSSID of the wireless network (see <xref
	target="tab-serverinfo-meaning" format="default"/>). As noted in <xref
	target="RFC6677" sectionFormat="of" section="4.3"/>, the scope of the channel binding
	varies between deployments. For example, the server may have less link-layer
	information available from roaming networks than from a local enterprise network, and
	it may be unable to verify all the network properties received in PeerInfo. There are
	also privacy considerations related to exchanging the ServerInfo and PeerInfo while
	roaming (see <xref target="privacyconsiderations" format="default"/>). </t>
	<t>Channel binding to secure channels, defined in <xref target="RFC5056"
	format="default"/>, binds authentication at a higher protocol layer to a secure
	channel at a lower layer.  Like most EAP methods, EAP-NOOB exports the session keys
	MSK and EMSK, and an outer tunnel or a higher-layer protocol can bind its
	authentication to these keys. Additionally, EAP-NOOB exports the key AMSK, which may
	be used to bind application-layer authentication to the secure channel created by
	EAP-NOOB and to the session keys MSK and EMSK.</t>
      </section>
      <section anchor="dos" numbered="true" toc="default">
        <name>Denial of Service</name>
        <t>While denial-of-service (DoS) attacks by on-link attackers cannot be fully
	prevented, the design goal in EAP-NOOB is to void long-lasting failure caused by an
	attacker who is present only temporarily or intermittently. The main defense mechanism
	is the persistent EAP-NOOB association, which is never deleted automatically due to
	in-band messages or error indications. Thus, the endpoints can always use the
	persistent association for reconnecting after the DoS attacker leaves the network. In
	this sense, the persistent association serves the same function in EAP-NOOB as a
	permanent primary key or certificate in other authentication protocols. We discuss
	logical attacks against the updates of the persistent association in <xref
	target="completion-loss" format="default"/>. </t>
        <t>In addition to logical DoS attacks, it is necessary to consider resource exhaustion
	attacks against the EAP server. The number of persistent EAP-NOOB associations created
	in the server is limited by the need for a user to assist in delivering the OOB
	message. The users can be authenticated for the input or output of the OOB message at
	the EAP server, and any users who create excessive numbers of persistent associations
	can be held accountable and their associations can be deleted by the server
	administrator. What the attacker can do without user authentication is to perform the
	Initial Exchange repeatedly and create a large number of ephemeral associations
	(server in Waiting for OOB (1) state) without ever delivering the OOB message. In
	<xref target="peeridentifiers" format="default"/>, it was suggested that the server
	should store the ephemeral states for at least a day. This may require off-loading the
	state storage from memory to disk during a DoS attack. However, if the server
	implementation is unable to keep up with a rate of Initial Exchanges performed by a
	DoS attacker and needs to drop some ephemeral states, no damage is caused to
	already-created persistent associations, and the honest users can resume registering
	new peers when the DoS attacker leaves the network.</t>
        <t>There are some trade-offs in the protocol design between politely backing off and
	giving
	way to DoS attackers. An on-link DoS attacker could spoof the SleepTime value in the
	Initial Exchange or Waiting Exchange to cause denial of service against a specific
	peer device. There is an upper limit on the SleepTime (3600 seconds) to
	mitigate the
	spoofing threat. This means that, in the presence of an on-link DoS attacker who
	spoofs the SleepTime, it could take up to one hour after the delivery of the OOB
	message before the device performs the Completion Exchange and becomes functional.
	Similarly, the Unwanted peer error (error code 2001) could cause the peer to stop
	connecting to the network. If the peer device is able to alert the user about the
	error condition, it can safely stop connecting to the server and wait for the user to
	trigger a reconnection attempt, e.g., by resetting the device. As mentioned in <xref
	target="unwantedpeer" format="default"/>, peer devices that are unable to alert the
	user should continue to retry the Initial Exchange infrequently to avoid a permanent
	DoS condition. We believe a maximum backoff time of 3600 seconds is reasonable for a
	new protocol because malfunctioning or misconfigured peer implementations are at least
	as great a concern as DoS attacks, and politely backing off within some reasonable
	limits will increase the acceptance of the protocol. The maximum backoff times could
	be updated to be shorter as the protocol implementations mature.</t>
      </section>
      <section anchor="completion-loss" numbered="true" toc="default">
        <name>Recovery from Loss of Last Message</name>
        <t>The EAP-NOOB Completion Exchange, as well as the Reconnect Exchange with
	cryptosuite update, results in a persistent state change that should take place either
	on both endpoints or on neither; otherwise, the result is a state mismatch that
	requires user action to resolve. The state mismatch can occur if the final EAP
	response of the exchanges is lost. In the Completion Exchange, the loss of the final
	response (Type=6) results in the peer moving to the Registered (4) state and creating
	a persistent EAP-NOOB association while the server stays in an ephemeral state (1 or
	2). In the Reconnect Exchange, the loss of the final response (Type=9) results in the
	peer moving to the Registered (4) state and updating its persistent key material Kz
	while the server stays in the Reconnecting (3) state and keeps the old key
	material.</t>
        <t>The state mismatch is an example of an unavoidable problem in distributed systems:
	it is theoretically impossible to guarantee synchronous state changes in endpoints
	that communicate asynchronously. The protocol will always have one critical message
	that may get lost, so that one side commits to the state change and the other side
	does not. In EAP, the critical message is the final response from the peer to the
	server. While the final response is normally followed by EAP-Success, <xref
	target="RFC3748" sectionFormat="comma" section="4.2"/> states that the peer
	<bcp14>MAY</bcp14> assume that the EAP-Success was lost and the authentication was
	successful. Furthermore, EAP method implementations in the peer do not receive
	notification of the EAP-Success message from the parent EAP state machine <xref
	target="RFC4137" format="default"/>. For these reasons, EAP-NOOB on the peer side
	commits to a state change already when it sends the final response.</t>
        <t>The best available solution to the loss of the critical message is to keep trying.
	EAP retransmission behavior defined in <xref target="RFC3748" sectionFormat="of"
	section="4.3"/> suggests 3-5 retransmissions. In the absence of an attacker, this
	would be sufficient to reduce the probability of failure to an acceptable level.
	However, a determined attacker on the in-band channel can drop the final EAP-Response
	message and all subsequent retransmissions. In the Completion Exchange (KeyingMode=0)
	and Reconnect Exchange with cryptosuite upgrade (KeyingMode=3), this could
	result in a state mismatch and persistent denial of service until the user resets the
	peer state.</t>
        <t>EAP-NOOB implements its own recovery mechanism that allows unlimited retries of the
	Reconnect Exchange. When the DoS attacker eventually stops dropping packets on the
	in-band channel, the protocol will recover. The logic for this recovery mechanism is
	specified in <xref target="reconnectexchange" format="default"/>.</t>
        <t>EAP-NOOB does not implement the same kind of retry mechanism in the Completion
	Exchange. The reason is that there is always a user involved in the initial
	association process, and the user can repeat the OOB Step to complete the association
	after the DoS attacker has left. On the other hand, Reconnect Exchange needs to work
	without user involvement.</t>
      </section>
      <section anchor="privacyconsiderations" numbered="true" toc="default">
        <name>Privacy Considerations</name>
        <t>There are privacy considerations related to performing the Reconnect Exchange while
	roaming. The peer and server may send updated PeerInfo and ServerInfo fields in the
	Reconnect Exchange. This data is sent unencrypted between the peer and the EAP
	authenticator, such as a wireless access point. Thus, it can be observed by both
	outsiders and the access network. The PeerInfo field contains identifiers and other
	information about the peer device (see <xref target="tab-serverinfo-meaning"
	format="default"/>). While the information refers to the peer device and not directly
	to the user, it can leak information about the user to the access network and to
	outside observers. The ServerInfo, on the other hand, can leak information about the
	peer's affiliation with the home network. For this reason, the optional PeerInfo and
	ServerInfo in the Reconnect Exchange <bcp14>SHOULD</bcp14> be omitted unless some
	critical data has changed and it cannot be updated on the application layer.</t>
        <t>Peer devices that randomize their Layer 2 address to prevent tracking can do this
	whenever the user resets the EAP-NOOB association. During the lifetime of the
	association, the PeerId is a unique identifier that can be used to track the peer in
	the access network. Later versions of this specification may consider updating the
	PeerId at each Reconnect Exchange. In that case, it is necessary to consider how the
	authenticator and access-network administrators can recognize and add misbehaving peer
	devices to a deny list, as well as how to avoid loss of synchronization between the
	server and the peer if messages are lost during the identifier update.</t>
        <t>To enable stronger identity protection in later versions of EAP-NOOB, the optional
	server-assigned NAI (NewNAI) <bcp14>SHOULD</bcp14> have a constant username part. The
	<bcp14>RECOMMENDED</bcp14> username is "noob". The server <bcp14>MAY</bcp14>, however,
	send a different username in NewNAI to avoid username collisions within its realm or
	to conform to a local policy on usernames. </t>
      </section>
      <section anchor="securityclaims" numbered="true" toc="default">
        <name>EAP Security Claims</name>
        <t>EAP security claims are defined in <xref target="RFC3748" sectionFormat="of"
	section="7.2.1"/>. The security claims for EAP-NOOB are listed in <xref
	target="tab-securityclaims" format="default"/>.</t>
        <table anchor="tab-securityclaims" align="center">
          <name>EAP Security Claims</name>
          <thead>
            <tr>
              <th align="left">Security Property</th>
              <th align="left">EAP-NOOB Claim</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="left">Authentication mechanism</td>
              <td align="left">ECDHE key exchange with out-of-band authentication</td>
            </tr>
            <tr>
              <td align="left">Protected cryptosuite negotiation</td>
              <td align="left">yes</td>
            </tr>
            <tr>
              <td align="left">Mutual authentication</td>
              <td align="left">yes</td>
            </tr>
            <tr>
              <td align="left">Integrity protection</td>
              <td align="left">yes</td>
            </tr>
            <tr>
              <td align="left">Replay protection</td>
              <td align="left">yes</td>
            </tr>
            <tr>
              <td align="left">Confidentiality</td>
              <td align="left">no</td>
            </tr>
            <tr>
              <td align="left">Key derivation</td>
              <td align="left">yes</td>
            </tr>
            <tr>
              <td align="left">Key strength</td>
              <td align="left">The specified cryptosuites provide key strength of at least 128
	      bits.</td>
            </tr>
            <tr>
              <td align="left">Dictionary attack protection</td>
              <td align="left">yes</td>
            </tr>
            <tr>
              <td align="left">Fast reconnect</td>
              <td align="left">yes</td>
            </tr>
            <tr>
              <td align="left">Cryptographic binding</td>
              <td align="left">not applicable</td>
            </tr>
            <tr>
              <td align="left">Session independence</td>
              <td align="left">yes</td>
            </tr>
            <tr>
              <td align="left">Fragmentation</td>
              <td align="left">no</td>
            </tr>
            <tr>
              <td align="left">Channel binding</td>
              <td align="left">yes (The ServerInfo and PeerInfo can be used to convey
	      integrity-protected channel properties, such as network SSID or peer MAC
	      address.)</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>
  </middle>
  <back>

    <displayreference target="I-D.tschofenig-tls-cwt" to="TLS-CWT"/>
    <displayreference target="I-D.ietf-rats-eat" to="RATS-EAT"/>

    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2104.xml"/> 
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3748.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5247.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6234.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7517.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7518.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7542.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7748.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8037.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8126.xml"/>
      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8259.xml"/>

      <reference anchor="NIST-DH"		target="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-56Ar3.pdf">
          <front>
            <title>Recommendation for Pair-Wise Key-Establishment Schemes Using Discrete
	    Logarithm Cryptography</title>
            <author initials="E." surname="Barker" fullname="Elaine Barker">
              <organization>National Institute of Standards and Technology</organization>
            </author>
            <author initials="L." surname="Chen" fullname="Lily Chen">
              <organization>National Institute of Standards and Technology</organization>
            </author>
            <author initials="A." surname="Roginsky" fullname="Allen Roginsky">
              <organization>National Institute of Standards and Technology</organization>
            </author>
            <author initials="A." surname="Vassilev" fullname="Apostol Vassilev">
              <organization>National Institute of Standards and Technology</organization>
            </author>
            <author initials="R." surname="Davis" fullname="Richard Davis">
              <organization>National Security Agency</organization>
            </author>
            <date month="April" year="2018"/>
          </front>
	  <seriesInfo name="DOI" value="10.6028/NIST.SP.800-56Ar3"/>
          <seriesInfo name="NIST Special Publication" value="800-56A Revision 3"/>
        </reference>

        <reference anchor="FIPS186-4">
          <front>
            <title>Digital Signature Standard (DSS)</title>
            <author>
              <organization>National Institute of Standards and Technology (NIST)</organization>
            </author>
            <date month="July" year="2013"/>
          </front>
	  <seriesInfo name="DOI" value="10.6028/NIST.FIPS.186-4"/>
          <seriesInfo name="FIPS" value="186-4"/>
        </reference>

        <reference anchor="EUI-48">
          <front>
            <title>IEEE Standard for Local and Metropolitan Area Networks: Overview and
	    Architecture</title>
            <author>
              <organization>IEEE</organization>
            </author>
            <date month="June" year="2014"/>
          </front>
	  <seriesInfo name="DOI" value="10.1109/IEEESTD.2014.6847097"/>
          <seriesInfo name="IEEE Standard" value="802-2014"/>
        </reference>
      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2904.xml"/>
	<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.4137.xml"/>
	<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml"/>
	<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5056.xml"/>
	<xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6677.xml"/>

      <xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.tschofenig-tls-cwt.xml"/>

      <xi:include href="https://datatracker.ietf.org/doc/bibxml3/reference.I-D.ietf-rats-eat.xml"/>

      
      <reference anchor="IEEE-802.1X">
          <front>
            <title>IEEE Standard for Local and Metropolitan Area Networks--Port-Based
	    Network Access Control</title>
            <author>
              <organization>IEEE</organization>
            </author>
            <date month="February" year="2020"/>
          </front>
          <seriesInfo name="IEEE Standard" value="802.1X-2020"/>
        </reference>

        <reference anchor="Sethi14" target="http://dx.doi.org/10.1145/2632048.2632049">
          <front>
            <title>Secure bootstrapping of cloud-managed ubiquitous displays</title>
            <author initials="M." surname="Sethi" fullname="Mohit Sethi">
              <organization>Ericsson</organization>
            </author>
            <author initials="E." surname="Oat" fullname="Elena Oat">
              <organization>Aalto University</organization>
            </author>
            <author initials="M." surname="Di Francesco" fullname="Mario Di Francesco">
              <organization>Aalto University</organization>
            </author>
            <author initials="T." surname="Aura" fullname="Tuomas Aura">
              <organization>Aalto University</organization>
            </author>
            <date month="September" year="2014"/>
          </front>
	  <seriesInfo name="DOI" value="10.1145/2632048.2632049"/>
          <refcontent>Proceedings of ACM International Joint Conference on Pervasive and
	  Ubiquitous Computing (UbiComp 2014), pp. 739-750, Seattle, USA</refcontent>
        </reference>

        <reference anchor="Bluetooth" target="https://www.bluetooth.com/specifications/bluetooth-core-specification">
          <front>
            <title>Bluetooth Core Specification Version 5.3</title>
            <author>
              <organization>Bluetooth Special Interest Group</organization>
            </author>
            <date year="2021" month="July"/>
          </front>
        </reference>

        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5216.xml"/>

      <reference anchor="Sethi19" target="https://arxiv.org/abs/1902.07550">
          <front>
            <title>Misbinding Attacks on Secure Device Pairing and Bootstrapping</title>
            <author initials="M." surname="Sethi" fullname="Mohit Sethi">
          </author>
            <author initials="A." surname="Peltonen" fullname="Aleksi Peltonen">
          </author>
            <author initials="T." surname="Aura" fullname="Tuomas Aura">
          </author>
            <date year="2019" month="February"/>
          </front>
	  <seriesInfo name="DOI" value="10.1145/3321705.3329813"/>
        </reference>
      </references>
    </references>
    <section anchor="exchangeappendix" numbered="true" toc="default">
      <name>Exchanges and Events per State</name>
      <t><xref target="tab-exchanges" format="default"/> shows how the EAP server chooses the
      exchange type depending on the server and peer states. In the state combinations
      marked with hyphen "-", there is no possible exchange and user action is required to
      make progress. Note that peer state 4 is omitted from the table because the peer never
      connects to the server when the peer is in that state. The table also shows the
      handling of errors in each exchange. A notable detail is that the recipient of error
      code 2003 moves to state 1.</t>
      <table anchor="tab-exchanges">
        <name>How the Server Chooses the Exchange Type</name>
	<thead>
	  <tr>
	    <th>Peer States</th>
	    <th>Exchange Chosen by the Server</th>
	    <th>Next Peer and Server States</th>
	  </tr>
	</thead>
	<tbody>      
	  <tr>
	    <td colspan="3" align="center">Server State: Unregistered (0)</td>
	  </tr>
	  <tr>
	    <td>0..2</td>
	    <td>Initial Exchange</td>
	    <td>both 1 (0 on error)</td>
	  </tr>
	  <tr>
	    <td>3</td>
	    <td>-</td>
	  <td>no change, notify user</td></tr>
	  <tr>
	    <td colspan="3" align="center">Server State: Waiting for OOB (1)</td>
	  </tr>
	  <tr>
	    <td>0</td>
	    <td>Initial Exchange</td>
	    <td>both 1 (0 on error)</td>
	  </tr>
	  
	  <tr>
	    <td>1</td>
	    <td>Waiting Exchange</td>
	    <td>both 1 (no change on error)</td>
	  </tr>
	  
	  <tr>
	    <td>2</td>
	    <td>Completion Exchange</td>
	    <td>both 4 (A)</td>
	  </tr>
	  
	  <tr>
	    <td>3</td>
	    <td>-</td>
	    <td>no change, notify user</td>
	  </tr>
	  
	  <tr>
	    <td colspan="3" align="center">Server State: OOB Received (2)</td>
	  </tr>
	  
	  <tr>
	    <td>0</td>
	    <td>Initial Exchange</td>
	    <td>both 1 (0 on error)</td>
	  </tr>
	  
	  <tr>
	    <td>1</td>
	    <td>Completion Exchange</td>
	    <td>both 4 (B)</td>
	  </tr>
	  
	  <tr>
	    <td>2</td>
	    <td>Completion Exchange</td>
	    <td>both 4 (A)</td>
	  </tr>
	  
	  <tr>
	    <td>3</td>
	    <td>-</td>
	    <td>no change, notify user</td>
	  </tr>
	  
	  <tr>
	    <td colspan="3" align="center">Server State: Reconnecting (3) or Registered
	    (4)</td>
	  </tr>
	  <tr>
	    <td>0..2</td>
	    <td>-</td>
	    <td>no change, notify user</td>
	  </tr>
	  <tr>
	    <td>3</td>
	    <td>Reconnect Exchange</td>
	  <td>both 4 (3 on error)</td></tr>
	</tbody>
      </table>

      <dl>
	<dt>(A)</dt>
	<dd>peer to 1 on error 2003; no other changes on error</dd>
	<dt>(B)</dt>
	<dd>server to 1 on error 2003; no other changes on error</dd>
      </dl>
      <t><xref target="tab-localevents" format="default"/> lists the local events that can
      take place in the server or peer. Both the server and peer output and accept OOB
      messages in association state 1, leading the receiver to state 2. Communication errors
      and timeouts in states 0..2 lead back to state 0, while similar errors in states 3..4
      lead to state 3. An application request for rekeying (e.g., to refresh session keys or
      to upgrade cryptosuite) also takes the association from state 3..4 to state 3. The user
      can always reset the association state to 0. Recovering association data, e.g., from a
      backup, leads to state 3.</t>
      <table anchor="tab-localevents">
        <name>Local Events in the Server and Peer</name>
	<thead>
	  <tr>
	    <th>Server/Peer State</th>  
	    <th>Possible Local Events in the Server and Peer</th>
	    <th>Next State</th>
	  </tr>
	</thead>
	<tbody>
	  <tr>
	    <td>1</td>
	    <td>OOB Output</td>
	    <td>1</td>
	  </tr>
	  <tr>
	    <td>1</td>
	    <td>OOB Input</td>
	    <td>2 (1 on error)</td>
	  </tr>
	  <tr>
	    <td>0..2</td>
	    <td>Mobility/timeout/network failure</td>
	    <td>0</td>
	  </tr>
	  <tr>
	    <td>3..4</td>
	    <td>Mobility/timeout/network failure</td>
	    <td>3</td>
	  </tr>
	  <tr>
	    <td>3..4</td>
	    <td>Rekeying request</td>
	    <td>3</td>
	  </tr>
	  <tr>
	    <td>0..4</td>
	    <td>User resets association</td>
	    <td>0</td>
	  </tr>
	  <tr>
	    <td>0..4</td>
	    <td>Association state recovery</td>
	    <td>3</td>
	  </tr>
	</tbody>
      </table>
    </section>
    <section anchor="oobchannelappendix" numbered="true" toc="default">
      <name>Application-Specific Parameters</name>
      <t><xref target="tab-oobchannel" format="default"/> lists OOB channel parameters that
      need to be specified in each application that makes use of EAP-NOOB. The list is not
      exhaustive and is included for the convenience of implementers only.</t>
      <table anchor="tab-oobchannel" align="center">
        <name>OOB Channel Characteristics</name>
        <thead>
          <tr>
            <th align="left">Parameter</th>
            <th align="left">Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td align="left">OobDirs</td>
            <td align="left">Allowed directions of the OOB channel.</td>
          </tr>
          <tr>
            <td align="left">OobMessageEncoding</td>
            <td align="left">How the OOB message data fields are encoded for the OOB
	    channel.</td>
          </tr>
          <tr>
            <td align="left">SleepTimeDefault</td>
            <td align="left">Default minimum time in seconds that the peer should sleep before
	    the next Waiting Exchange.</td>
          </tr>
          <tr>
            <td align="left">OobRetries</td>
            <td align="left">Number of received OOB messages with invalid Hoob, after which the
	    receiver moves to Unregistered (0) state. When the OOB channel has error detection
	    or correction, the <bcp14>RECOMMENDED</bcp14> value is 5.</td>
          </tr>
          <tr>
            <td align="left">NoobTimeout</td>
            <td align="left">How many seconds the sender of the OOB message remembers the sent
	    Noob value. The <bcp14>RECOMMENDED</bcp14> value is 3600 seconds.</td>
          </tr>
          <tr>
            <td align="left">ServerInfoType</td>
            <td align="left">The value of the Type field and the other required fields in
	    ServerInfo.</td>
          </tr>
          <tr>
            <td align="left">PeerInfoType</td>
            <td align="left">The value of the Type field and the other required fields in
	    PeerInfo.</td>
          </tr>
        </tbody>
      </table>
    </section>
    <section anchor="roaming" numbered="true" toc="default">
      <name>EAP-NOOB Roaming</name>
      <t>AAA architectures <xref target="RFC2904" format="default"/> allow for roaming of
      network-connected appliances that are authenticated over EAP. While the peer is roaming
      in a visited network, authentication still takes place between the peer and an
      authentication server at its home network. EAP-NOOB supports such roaming by allowing
      the server to assign a NAI to the peer. After the NAI has been assigned, it enables the
      visited network to route the EAP session to the peer's home AAA server.</t>
      <t>A peer device that is new or has gone through a hard reset should be connected first
      to the home network and establish an EAP-NOOB association with its home AAA server
      before it is able to roam. After that, it can perform the Reconnect Exchange from the
      visited network.</t>
      <t>Alternatively, the device may provide some method for the user to configure the NAI
      of the home network. This is the user or application-configured NAI mentioned in <xref
      target="nai" format="default"/>. In that case, the EAP-NOOB association can be created
      while roaming. The configured NAI enables the EAP messages to be routed correctly to the
      home AAA server. </t>
      <t>While roaming, the device needs to identify the networks where the EAP-NOOB
      association can be used to gain network access. For 802.11 access networks, the server
      <bcp14>MAY</bcp14> send a list of SSID strings in the ServerInfo field, called either
      SSIDList or Base64SSIDList. The list is formatted as explained in <xref
      target="tab-serverinfo-meaning" format="default"/>. If present, the peer
      <bcp14>MAY</bcp14> use this list as a hint to determine the networks where the EAP-NOOB
      association can be used for access authorization, in addition to the access network
      where the Initial Exchange took place.</t>
    </section>
    <section anchor="urloob" numbered="true" toc="default">
      <name>OOB Message as a URL</name>
      <t>While EAP-NOOB does not mandate any particular OOB communication channel, typical OOB
      channels include graphical displays and emulated NFC tags. In the peer-to-server
      direction, it may be convenient to encode the OOB message as a URL, which is then
      encoded as a QR code for displays and printers or as an NFC Data Exchange Format (NDEF)
      record for dynamic NFC
      tags. A user can then simply scan the QR code or NFC tag and open the URL, which causes
      the OOB message to be delivered to the authentication server. The URL
      <bcp14>MUST</bcp14> specify https or another server-authenticated scheme so that there
      is a secure connection to the server and the on-path attacker cannot read or modify the
      OOB message.</t>
      <t>The ServerInfo in this case includes a field called ServerURL of the following format
      with a <bcp14>RECOMMENDED</bcp14> length of at most 60 characters:</t>
      <t><tt>https://&lt;host&gt;[:&lt;port&gt;]/[&lt;path&gt;]</tt></t>
      <t>To this, the peer appends the OOB message fields (PeerId, Noob, and Hoob) as a query
      string. PeerId is provided to the peer by the server and might be a 22-character ASCII
      string. The peer base64url encodes, without padding, the 16-byte values Noob and Hoob
      into 22-character ASCII strings. The query parameters <bcp14>MAY</bcp14> be in any
      order. The resulting URL is of the following format:</t>
      <t><tt>https://&lt;host&gt;[:&lt;port&gt;]/[&lt;path&gt;]?P=&lt;PeerId&gt;&amp;N=&lt;Noob&gt;&amp;H=&lt;Hoob&gt;</tt> </t>
      
      <t>The following is an example of a well-formed URL encoding the OOB message (without
      line breaks):</t>
      <t><tt>https://aaa.example.com/eapnoob?P=mcm5BSCDZ45cYPlAr1ghNw&amp;N=rMinS0-F4EfCU8D9ljxX_A&amp;H=QvnMp4UGxuQVFaXPW_14UW</tt></t>
    </section>
    <section anchor="acks" numbered="false" toc="default">
      <name>Acknowledgments</name>
      <t><contact fullname="Max Crone"/>, <contact fullname="Shiva Prasad TP"/>, and <contact
      fullname="Raghavendra MS"/> implemented parts of this protocol with wpa_supplicant and
      hostapd. <contact fullname="Eduardo Ingls"/> and <contact fullname="Dan
      Garcia-Carrillo"/> were involved in the
      implementation of this protocol on Contiki. Their inputs helped us in improving the
      specification.</t>
      <t>The authors would like to thank <contact fullname="Rhys Smith"/> and <contact
      fullname="Josh Howlett"/> for providing valuable feedback, as well as new use cases and
      requirements for the protocol. Thanks to <contact fullname="Eric Rescorla"/>, <contact
      fullname="Alan Dekok"/>, <contact fullname="Darshak Thakore"/>, <contact
      fullname="Stefan Winter"/>, <contact fullname="Hannes Tschofenig"/>, <contact
      fullname="Daniel Migault"/>, <contact fullname="Roman Danyliw"/>, <contact
      fullname="Benjamin Kaduk"/>, <contact fullname="Francesca Palombini"/>, <contact
      fullname="Steve Hanna"/>, <contact fullname="Lars Eggert"/>, and <contact fullname="ric
      Vyncke"/> for their comments and reviews.</t>
      <t>We would also like to express our sincere gratitude to <contact fullname="Dave
      Thaler"/> for his thorough review of the document.</t>
    </section>
  </back>
</rfc>
