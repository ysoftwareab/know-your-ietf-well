<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc number="8698" xmlns:xi="http://www.w3.org/2001/XInclude" category="exp"
     docName="draft-ietf-rmcat-nada-13" ipr="trust200902" obsoletes=""
     updates="" submissionType="IETF" consensus="true" xml:lang="en"
     tocInclude="true"
     sortRefs="true" symRefs="true" version="3">


  <front>
    <title abbrev="NADA">
    Network-Assisted Dynamic Adaptation (NADA): A Unified Congestion Control
    Scheme for Real-Time Media
    </title>
    <seriesInfo name="RFC" value="8698"/>
    <author fullname="Xiaoqing Zhu" initials="X" surname="Zhu">
      <organization>Cisco Systems</organization>
      <address>
        <postal>
          <street>12515 Research Blvd., Building 4</street>
          <city>Austin</city>
          <region>TX</region>
          <code>78759</code>
          <country>United States of America</country>
        </postal>
        <email>xiaoqzhu@cisco.com</email>
      </address>
    </author>

    <author fullname="Rong Pan" initials="R" surname="Pan">
      <organization>Intel Corporation</organization>
      <address>
        <postal>
          <street>2200 Mission College Blvd
	  </street>
          <city>Santa Clara</city>
          <region>CA</region>
          <code>95054</code>
          <country>United States of America</country>
        </postal>
        <email>rong.pan@intel.com</email>
      </address>      
    </author>

    <author fullname="Michael A. Ramalho" initials="M." surname="Ramalho">
      <organization abbrev="AcousticComms">AcousticComms
      Consulting</organization>
      <address>
        <postal>
          <street>6310 Watercrest Way Unit 203</street>
          <city>Lakewood Ranch</city>
          <region>FL</region>
          <code>34202-5211</code>
          <country>United States of America</country>
        </postal>
        <phone>+1 732 832 9723</phone>
        <email>mar42@cornell.edu</email>
        <uri>http://ramalho.webhop.info/</uri>
      </address>
    </author>

    <author fullname="Sergio Mena" initials="S. " surname="Mena">
      <organization>Cisco Systems</organization>
      <address>
        <postal>
          <street>EPFL, Quartier de l'Innovation, Batiment E</street>
          <city>Ecublens</city>
          <region>Vaud</region>
          <code>1015</code>
          <country>Switzerland</country>
        </postal>
        <email>semena@cisco.com</email>
      </address>
    </author>

    <date month="February" year="2020"/>
    <area>TSV</area>
    <keyword>Multimedia</keyword>
    <keyword>Congestion Control</keyword>
    <abstract>
      <t>This document describes Network-Assisted Dynamic Adaptation (NADA), a
      novel congestion control scheme for interactive real-time media
      applications such as video conferencing. In the proposed scheme, the
      sender regulates its sending rate, based on either implicit or explicit
      congestion signaling, in a unified approach. The scheme can benefit from
      Explicit Congestion Notification (ECN) markings from network nodes. It
      also maintains consistent sender behavior in the absence of such
      markings by reacting to queuing delays and packet losses instead. </t>
    </abstract>
  </front>
  <middle>
    <section anchor="sec-intro" numbered="true" toc="default">
      <name>Introduction</name>
      <t>Interactive real-time media applications introduce a unique set of
      challenges for congestion control. Unlike TCP, the mechanism used for
      real-time media needs to adapt quickly to instantaneous bandwidth
      changes, accommodate fluctuations in the output of video encoder rate
      control, and cause low queuing delay over the network. An ideal scheme
      should also make effective use of all types of congestion signals,
      including packet loss, queuing delay, and explicit congestion
      notification (ECN) <xref target="RFC3168" format="default"/>
      markings. The requirements for the congestion control algorithm are
      outlined in <xref target="I-D.ietf-rmcat-cc-requirements"
      format="default"/>.

    The requirements highlight that the desired congestion control scheme
    should 1) avoid flow starvation and attain a reasonable fair share of
    bandwidth when competing against other flows, 2) adapt quickly, and 3)
    operate in a stable manner. </t>


      <t>This document describes an experimental congestion control scheme
    called Network-Assisted Dynamic Adaptation (NADA). The design of NADA
    benefits from explicit congestion control signals (e.g., ECN markings)
    from the network, yet also operates when only implicit congestion
    indicators (delay and/or loss) are available. Such a unified sender
    behavior distinguishes NADA from other congestion control schemes for
    real-time media. In addition, its core congestion control algorithm is
    designed to guarantee stability for path round-trip times (RTTs) below
    a prescribed bound (e.g., 250 ms with default parameter choices). It
    further supports weighted bandwidth sharing among competing video flows
    with different priorities. The signaling mechanism consists of standard
    Real-time Transport Protocol (RTP) timestamp <xref target="RFC3550"
    format="default"/> and Real-time
    Transport Control Protocol (RTCP) feedback reports.
    The definition of the desired RTCP feedback message is described in
    detail in <xref target="I-D.ietf-avtcore-cc-feedback-message"
    format="default"/>
    so as to support the successful operation of several congestion control
    schemes for real-time interactive media. </t>
    </section>

    <section anchor="sec-term" numbered="true" toc="default">
      <name>Terminology</name>

        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
    "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
    "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are
    to be interpreted as described in BCP&nbsp;14 <xref target="RFC2119"/>
    <xref target="RFC8174"/> when, and only when, they appear in all capitals,
    as shown here.
        </t>



    </section>
    <section anchor="sec-system-overview" numbered="true" toc="default">
      <name>System Overview</name>
      <t><xref target="fig-system-overview" format="default"/> shows the
      end-to-end
    system for real-time media transport that NADA operates in. Note that
    there also exist network nodes along the reverse (potentially uncongested)
    path that the RTCP feedback reports traverse. Those network nodes are not
    shown in the figure for the sake of brevity.</t>

      <figure anchor="fig-system-overview">
        <name>System Overview</name>
        <artwork name="" type="" align="left" alt=""><![CDATA[
  +---------+  r_vin  +--------+        +--------+     +----------+
  |  Media  |<--------|  RTP   |        |Network |     |   RTP    |
  | Encoder |========>| Sender |=======>|  Node  |====>| Receiver |  
  +---------+  r_vout +--------+ r_send +--------+     +----------+
                          /|\                                |
                           |                                 |
                           +---------------------------------+
                                 RTCP Feedback Report
]]></artwork>
      </figure>


<dl>

<dt>Media encoder with rate control capabilities:
</dt>
<dd>Encodes raw media (audio and video) frames into a compressed bitstream
that is later packetized into RTP packets. As discussed in <xref
target="RFC8593"/>, the
actual output rate from the encoder r_vout may fluctuate around the target
r_vin. Furthermore, it is possible that the encoder can only react to bit rate
changes at rather coarse time intervals, e.g., once every 0.5 seconds.
</dd>

<dt>RTP sender:
</dt>
<dd>Responsible for calculating the NADA reference rate based on network
congestion indicators (delay, loss, or ECN marking reports from the receiver),
for updating the video encoder with a new target rate r_vin and for
regulating the actual sending rate r_send accordingly. The RTP sender also
generates a sending timestamp for each outgoing packet.
</dd>

<dt>RTP receiver:
</dt>
<dd>Responsible for measuring and estimating end-to-end delay (based on sender
timestamp), packet loss (based on RTP sequence number), ECN marking ratios
(based on <xref target="RFC6679"/>), and receiving rate (r_recv) of the
flow. It calculates
the aggregated congestion signal (x_curr) that accounts for queuing delay, ECN
markings, and packet losses. The receiver also determines the mode for sender
rate adaptation (rmode) based on whether the flow has encountered any standing
non-zero congestion. The receiver sends periodic RTCP reports back to the
sender, containing values of x_curr, rmode, and r_recv.
</dd>

<dt>Network node with several modes of operation:
</dt>
<dd>The system can work with the default behavior of a simple drop-tail
queue. It can also benefit from advanced Active Queue Management (AQM)
features such as Proportional Integral Controller Enhanced <xref
target="RFC8033">(PIE)</xref>, Flow Queue Controlling Queue Delay <xref
target="RFC8290">(FQ-CoDel)</xref>, ECN
marking based on <xref target="RFC7567"> Random Early Detection (RED)</xref>,
and Pre-Congestion Notification (PCN) marking using a
token bucket algorithm <xref target="RFC6660"/>. Note that network node
operation is out of scope for the design of NADA.

</dd>


</dl>


    </section>
    <section anchor="sec-algorithm" numbered="true" toc="default">
      <name>Core Congestion Control Algorithm</name>
      <t>Like TCP-Friendly Rate Control (TFRC) <xref target="FLOYD-CCR00"
      format="default"/>
        <xref target="RFC5348" format="default"/>, NADA is a rate-based
	congestion
  control algorithm. In its simplest form, the sender reacts to the
  collection of network congestion indicators in the form of an
  aggregated congestion signal and operates in one of two modes: 

      </t>
<dl>

<dt>Accelerated ramp up:
</dt>
<dd>When the bottleneck is deemed to be underutilized, the rate increases
multiplicatively with respect to the rate of previously successful
transmissions.  The rate increase multiplier (gamma) is calculated based on
the observed round-trip time and target feedback interval, so as to limit
self-inflicted queuing delay.
</dd>

<dt>Gradual rate update:
</dt>
<dd>In the presence of a non-zero aggregate congestion signal, the sending
rate
is adjusted in reaction to both its value (x_curr) and its change in value
(x_diff).
</dd>



</dl>

      <t>This section introduces the list of mathematical notations and
  describes the core congestion control algorithm at the sender and
  receiver, respectively. Additional details on recommended practical
  implementations are described in Sections <xref target="sec-receiver"
  format="counter"/>
  and <xref target="sec-sender" format="counter"/>. </t>


      <section anchor="sec-notation" numbered="true" toc="default">
        <name>Mathematical Notations</name>

        <t>This section summarizes the list of variables and parameters used
        in the NADA algorithm. <xref target="tab-parameters"
        format="default"/> also includes the default values for choosing the
        algorithm parameters to represent either a typical setting in
        practical applications or a setting based on theoretical and
        simulation studies.  See <xref target="sec-discussion-c"
        format="default"/> for some of the discussions on the impact of
        parameter values. Additional studies in real-world settings suggested
        in <xref target="sec-experiments" format="default"/> could gather
        further insight on how to choose and adapt these parameter values in
        practical deployment.</t>



<table align="left" anchor="tab-variables">
  <name>List of Variables</name>
  <thead>
    <tr>
      <th align='left'>Notation</th>
      <th align='left'>Variable Name</th>
    </tr>
  </thead>

  <tbody>

    <tr>
      <td align="left">t_curr</td>
      <td align="left">Current timestamp</td>
    </tr>

    <tr>
      <td align="left">t_last</td>
      <td align="left">Last time sending/receiving a feedback message</td>
    </tr>

    <tr>
      <td align="left">delta</td>
      <td align="left">Observed interval between current and previous
      feedback reports: delta = t_curr-t_last</td>
    </tr>

    <tr>
      <td align="left">r_ref</td>
      <td align="left">Reference rate based on network congestion</td>
    </tr>

    <tr>
      <td align="left">r_send</td>
      <td align="left">Sending rate</td>
    </tr>

    <tr>
      <td align="left">r_recv</td>
      <td align="left">Receiving rate</td>
    </tr>

    <tr>
      <td align="left">r_vin</td>
      <td align="left">Target rate for video encoder</td>
    </tr>

    <tr>
      <td align="left">r_vout</td>
      <td align="left">Output rate from video encoder</td>
    </tr>

    <tr>
      <td align="left">d_base</td>
      <td align="left">Estimated baseline delay</td>
    </tr>

    <tr>
      <td align="left">d_fwd</td>
      <td align="left">Measured and filtered one-way delay</td>
    </tr>

    <tr>
      <td align="left">d_queue</td>
      <td align="left">Estimated queuing delay</td>
    </tr>

    <tr>
      <td align="left">d_tilde</td>
      <td align="left">Equivalent delay after non-linear warping</td>
    </tr>

    <tr>
      <td align="left">p_mark</td>
      <td align="left">Estimated packet ECN marking ratio</td>
    </tr>

    <tr>
      <td align="left">p_loss</td>
      <td align="left">Estimated packet loss ratio</td>
    </tr>

    <tr>
      <td align="left">x_curr</td>
      <td align="left">Aggregate congestion signal</td>
    </tr>

    <tr>
      <td align="left">x_prev</td>
      <td align="left">Previous value of aggregate congestion signal</td>
    </tr>

    <tr>
      <td align="left">x_diff</td>
      <td align="left">Change in aggregate congestion signal w.r.t. its
      previous value: x_diff = x_curr - x_prev</td>
    </tr>

    <tr>
      <td align="left">rmode</td>
      <td align="left">Rate update mode: (0 = accelerated ramp up; 1 =
      gradual update)</td>
    </tr>

    <tr>
      <td align="left">gamma</td>
      <td align="left">Rate increase multiplier in accelerated ramp-up
      mode</td>
    </tr>

    <tr>
      <td align="left">loss_int</td>
      <td align="left">Measured average loss interval in packet count</td>
    </tr>

    <tr>
      <td align="left">loss_exp</td>
      <td align="left">Threshold value for setting the last observed packet
      loss to expiration</td>
    </tr>

    <tr>
      <td align="left">rtt</td>
      <td align="left">Estimated round-trip time at sender</td>
    </tr>

    <tr>
      <td align="left">buffer_len</td>
      <td align="left">Rate-shaping buffer occupancy measured in bytes</td>
    </tr>

  </tbody>
</table>





<table align="left" anchor="tab-parameters">
  <name>List of Algorithm Parameters and Their Default Values</name>
  <thead>
    <tr>
      <th align='left'>Notation</th>
      <th align='left'>Parameter Name</th>
      <th align='left'>Default Value</th>
    </tr>
  </thead>

  <tbody>


    <tr>
      <td align="left">PRIO</td>
      <td align="left">Weight of priority of the flow</td>
      <td align="left">1.0</td>
    </tr>

    <tr>
      <td align="left">RMIN</td>
      <td align="left">Minimum rate of application supported by media
      encoder</td>
      <td align="left">150 Kbps</td>
    </tr>

    <tr>
      <td align="left">RMAX</td>
      <td align="left">Maximum rate of application supported by media
      encoder</td>
      <td align="left">1.5 Mbps</td>
    </tr>

    <tr>
      <td align="left">XREF</td>
      <td align="left">Reference congestion level</td>
      <td align="left">10 ms</td>
    </tr>

    <tr>
      <td align="left">KAPPA</td>
      <td align="left">Scaling parameter for gradual rate update
      calculation</td>
      <td align="left">0.5</td>
    </tr>

    <tr>
      <td align="left">ETA</td>
      <td align="left">Scaling parameter for gradual rate update
      calculation</td>
      <td align="left">2.0</td>
    </tr>

    <tr>
      <td align="left">TAU</td>
      <td align="left">Upper bound of RTT in gradual rate update
      calculation</td>
      <td align="left">500 ms</td>
    </tr>

    <tr>
      <td align="left">DELTA</td>
      <td align="left">Target feedback interval</td>
      <td align="left">100 ms</td>
    </tr>

 
    <tr>
      <td align="left">LOGWIN</td>  
      <td align="left">Observation window in time for calculating packet
      summary statistics at receiver</td>
      <td align="left">500 ms</td>
    </tr>

    <tr>
      <td align="left">QEPS</td>
      <td align="left">Threshold for determining queuing delay buildup at
      receiver</td>
      <td align="left">10 ms</td>
    </tr>

    <tr>
      <td align="left">DFILT</td>
      <td align="left">Bound on filtering delay</td>
      <td align="left">120 ms</td>
    </tr>

    <tr>
      <td align="left">GAMMA_MAX</td>
      <td align="left">Upper bound on rate increase ratio for accelerated ramp
      up</td>
      <td align="left">0.5</td>
    </tr>

    <tr>
      <td align="left">QBOUND</td>
      <td align="left">Upper bound on self-inflicted queuing delay during ramp
      up</td>
      <td align="left">50 ms</td>
    </tr>

    <tr>
      <td align="left">MULTILOSS</td>
      <td align="left">Multiplier for self-scaling the expiration threshold of
      the last observed loss (loss_exp) based on measured average loss
      interval (loss_int)</td>
      <td align="left">7.0</td>
    </tr>

    <tr>
      <td align="left">QTH</td>
      <td align="left">Delay threshold for invoking non-linear warping</td>
      <td align="left">50 ms</td>
    </tr>

    <tr>
      <td align="left">LAMBDA</td>
      <td align="left">Scaling parameter in the exponent of non-linear
      warping</td>
      <td align="left">0.5</td>
    </tr>


    <tr>
      <td align="left">PLRREF</td>
      <td align="left">Reference packet loss ratio</td>
      <td align="left">0.01</td>
    </tr>

    <tr>
      <td align="left">PMRREF</td>
      <td align="left">Reference packet marking ratio</td>
      <td align="left">0.01</td>
    </tr>

    <tr>
      <td align="left">DLOSS</td>
      <td align="left">Reference delay penalty for loss when packet loss ratio
      is at PLRREF</td>
      <td align="left">10 ms</td>
    </tr>

    <tr>
      <td align="left">DMARK</td>
      <td align="left">Reference delay penalty for ECN marking when packet
      marking is at PMRREF</td>
      <td align="left">2 ms</td>
    </tr>


    <tr>
      <td align="left">FPS</td>
      <td align="left">Frame rate of incoming video</td>
      <td align="left">30</td>
    </tr>

    <tr>
      <td align="left">BETA_S</td>
      <td align="left">Scaling parameter for modulating outgoing sending
      rate</td>
      <td align="left">0.1</td>
    </tr>

    <tr>
      <td align="left">BETA_V</td>
      <td align="left">Scaling parameter for modulating video encoder target
      rate</td>
      <td align="left">0.1</td>
    </tr>

    <tr>
      <td align="left">ALPHA</td>
      <td align="left">Smoothing factor in exponential smoothing of packet
      loss and marking ratios</td>
      <td align="left">0.1</td>
    </tr>


  </tbody>
</table>

</section>


      <section anchor="subsec-receiver-algorithm" numbered="true"
	       toc="default">
        <name>Receiver-Side Algorithm</name>
        <t>The receiver-side algorithm can be outlined as below:</t>

<ul empty="true">

<li>On initialization:</li>
<li>
<ul empty="true">
<li>set d_base = +INFINITY
</li>
<li>set p_loss = 0
</li>
<li>set p_mark = 0
</li>
<li>set r_recv = 0
</li>
<li>set both t_last and t_curr as current time in milliseconds
</li>
</ul>
</li>


<li>On receiving a media packet:
</li>
<li>
<ul empty="true">

<li>obtain current timestamp t_curr from system clock
</li>

<li>obtain from packet header sending time stamp t_sent
</li>

<li>obtain one-way delay measurement: d_fwd = t_curr - t_sent
</li>

<li>update baseline delay: d_base = min(d_base, d_fwd)
</li>

<li>update queuing delay:  d_queue = d_fwd - d_base
</li>

<li>update packet loss ratio estimate p_loss
</li>


<li>update packet marking ratio estimate p_mark
</li>

<li>update measurement of receiving rate r_recv
</li>

</ul>
</li>


<li>On time to send a new feedback report (t_curr - t_last > DELTA):
</li>
<li>
<ul empty="true">

<li>calculate non-linear warping of delay d_tilde if packet loss exists
</li>

<li>calculate current aggregate congestion signal x_curr
</li>

<li>determine mode of rate adaptation for sender: rmode
</li>

<li>send feedback containing values of: rmode, x_curr, and r_recv
</li>

<li>update t_last = t_curr
</li>

</ul>
</li>

</ul>

        <t>In order for a delay-based flow to hold its ground when competing
   against loss-based flows (e.g., loss-based TCP), it is important
   to distinguish between different levels of observed queuing delay.
   For instance, over wired connections, a moderate queuing delay value
   on the order of tens of milliseconds is likely self-inflicted or
   induced by other delay-based flows, whereas a high queuing delay
   value of several hundreds of milliseconds may indicate the presence
   of a loss-based flow that does not refrain from increased delay.</t>
        <t> If the last observed packet loss is within the expiration 
window of loss_exp (measured in terms of packet counts), the
estimated queuing delay follows a non-linear warping: </t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
           / d_queue,                   if d_queue < QTH
           |
d_tilde = <                                           (1)
           |                  (d_queue-QTH)  
           \ QTH exp(-LAMBDA ---------------) , otherwise
                                 QTH    ]]></artwork>



	<t>
In Equation (1), the queuing delay value is unchanged when it is below
the first threshold QTH; otherwise, it is scaled down following
a non-linear curve. This non-linear warping is inspired by
the delay-adaptive congestion window backoff policy in
<xref target="BUDZISZ-AIMD-CC" format="default"/> so as to "gradually nudge"
the controller to operate based on loss-induced congestion
signals when competing against loss-based flows. The exact form
of the non-linear function has been simplified with respect to
<xref target="BUDZISZ-AIMD-CC" format="default"/>. The value of the threshold
QTH should be carefully tuned for different operational environments
so as to avoid potential risks of prematurely discounting the congestion
signal level. Typically, a higher value of QTH is required in a
noisier environment (e.g., over wireless connections or where the
video stream encounters many time-varying background competing traffic)
so as to stay robust against occasional non-congestion-induced delay
spikes. Additional insights on how this value can be tuned or auto-tuned
should be gathered from carrying out experimental studies in different
real-world deployment scenarios. 
	</t>
        <t>The value of loss_exp is configured to self-scale with the average
  packet loss interval loss_int with a multiplier MULTILOSS: </t>

<artwork name="" type="" align="left" alt=""><![CDATA[ loss_exp = MULTILOSS *
loss_int.  ]]></artwork>

        <t>Estimation of the average loss interval loss_int, in turn, follows
	<xref target="RFC5348" sectionFormat ="of"
	      section="5.4">"TCP Friendly Rate Control
   (TFRC): Protocol Specification"</xref>. </t>
        <t>In practice, it is recommended to linearly interpolate between the
warped (d_tilde) and non-warped (d_queue) values of the queuing delay
during the transitional period lasting for the duration of loss_int. </t>
        <t>The aggregate congestion signal is:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
                         / p_mark \^2        / p_loss \^2 
x_curr = d_tilde + DMARK*|--------|  + DLOSS*|--------|   (2) 
                         \ PMRREF /          \ PLRREF /         ]]></artwork>

        <t>Here, DMARK is prescribed a reference delay penalty associated with
        ECN markings at the reference marking ratio of PMRREF; DLOSS is
        prescribed a reference delay penalty associated with packet losses at
        the reference packet loss ratio of PLRREF.  The value of DLOSS and
        DMARK does not depend on configurations at the network node. Since
        ECN-enabled active queue management schemes typically mark a packet
        before dropping it, the value of DLOSS <bcp14>SHOULD</bcp14> be higher
        than that of DMARK. Furthermore, the values of DLOSS and DMARK need to
        be set consistently across all NADA flows sharing the same bottleneck
        link so that they can compete fairly.</t>
        <t>In the absence of packet marking and losses, the value of x_curr
        reduces to the observed queuing delay d_queue. In that case, the NADA
        algorithm operates in the regime of delay-based adaptation. </t>
        <t>Given observed per-packet delay and loss information, the receiver
        is also in a good position to determine whether or not the network is
        underutilized and then recommend the corresponding rate adaptation
	mode for
        the sender. The criteria for operating in accelerated ramp-up mode
        are:</t>
        <ul spacing="normal">
          <li> No recent packet losses within the observation window LOGWIN;
          and</li> <li> No buildup of queuing delay: d_fwd-d_base &lt; QEPS
          for all previous delay samples within the observation window
          LOGWIN.</li>
        </ul>
        <t>Otherwise, the algorithm operates in graduate update mode. </t>
      </section>
      <section anchor="subsec-sender-algorithm" numbered="true" toc="default">
        <name>Sender-Side Algorithm</name>
        <t>The sender-side algorithm is outlined as follows:</t>



<ul empty="true">

<li>On initialization:</li>
<li>
<ul empty="true">
<li>set r_ref = RMIN
</li>
<li>set rtt = 0
</li>
<li>set x_prev = 0
</li>
<li>set t_last and t_curr as current system clock time
</li>
</ul>
</li>


<li>On receiving feedback report:
</li>
<li>
<ul empty="true">

<li>obtain current timestamp from system clock: t_curr
</li>

<li>obtain values of rmode, x_curr, and r_recv from feedback report
</li>

<li>update estimation of rtt
</li>

<li>measure feedback interval: delta = t_curr - t_last
</li>

<li>if rmode == 0:
</li>
<li>
<ul empty="true">
<li>update r_ref following accelerated ramp-up rules
</li>
</ul>
</li>

<li>else:
</li>
<li>
<ul empty="true">
<li>update r_ref following gradual update rules
</li>
</ul>
</li>


<li>clip rate r_ref within the range of minimum rate (RMIN) and maximum rate
(RMAX).
</li>
<li>set x_prev = x_curr
</li>
<li>set t_last = t_curr
</li>

</ul>
</li>

</ul>


        <t>In accelerated ramp-up mode, the rate r_ref is updated as
	follows:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
                                QBOUND
    gamma = min(GAMMA_MAX, ------------------)       (3)
                            rtt+DELTA+DFILT

			    r_ref = max(r_ref, (1+gamma) r_recv)
			    (4)    
]]></artwork>


        <t>The rate increase multiplier gamma is calculated as a function of
        the upper bound of self-inflicted queuing delay (QBOUND), round-trip
        time (rtt), and target feedback interval (DELTA); it is bound on the
        filtering delay for calculating d_queue (DFILT). It has a maximum
        value of GAMMA_MAX. The rationale behind Equations (3)-(4) is that the
        longer it takes for the sender to observe self-inflicted queuing delay
        buildup, the more conservative the sender should be in increasing its
        rate and, hence, the smaller the rate increase multiplier. </t>
        <t>In gradual update mode, the rate r_ref is updated as:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
    x_offset = x_curr - PRIO*XREF*RMAX/r_ref          (5)

    x_diff   = x_curr - x_prev                        (6) 

                           delta    x_offset
    r_ref = r_ref - KAPPA*-------*------------*r_ref
                            TAU       TAU

                                x_diff
                  - KAPPA*ETA*---------*r_ref         (7)
                                 TAU    
]]></artwork>
        <t>The rate changes in proportion to the previous rate decision.
It is affected by two terms: the offset of the aggregate congestion
signal from its value at equilibrium (x_offset) and its change
(x_diff). The calculation of x_offset depends on the maximum rate
of the flow (RMAX), its weight of priority (PRIO), as well
as a reference congestion signal (XREF). The value of
XREF is chosen so that the maximum rate of RMAX can be achieved
when the observed congestion signal level is below PRIO*XREF. </t>
        <t>
At equilibrium, the aggregated congestion signal stabilizes at
x_curr = PRIO*XREF*RMAX/r_ref. This ensures that when multiple
flows share the same bottleneck and observe a common value of
x_curr, their rates at equilibrium will be proportional to their
respective priority levels (PRIO) and the range between minimum
and maximum rate. Values of the minimum rate (RMIN) and 
maximum rate (RMAX) will be provided by the media codec,
for instance, as outlined by <xref
target="I-D.ietf-rmcat-cc-codec-interactions" format="default">
</xref>. In the absence of such information, the NADA sender will
choose a default value of 0 for RMIN and 3 Mbps for RMAX. </t>
        <t> As mentioned in the sender-side algorithm, the final rate
is always clipped within the dynamic range specified by the
application: </t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
    r_ref = min(r_ref, RMAX)                         (8)

    r_ref = max(r_ref, RMIN)                         (9)
]]></artwork>
        <t>The above operations ignore many practical issues such as clock
synchronization between sender and receiver, the filtering of noise in
delay measurements, and base delay expiration. These will be addressed
in <xref target="sec-practical-nada" format="default"/>.</t>
</section>
</section>
    <section anchor="sec-practical-nada" numbered="true" toc="default">
      <name>Practical Implementation of NADA</name>
      <section anchor="sec-receiver" numbered="true" toc="default">
        <name>Receiver-Side Operation</name>
        <t>The receiver continuously monitors end-to-end per-packet
statistics in terms of delay, loss, and/or ECN marking ratios.
It then aggregates all forms of congestion indicators into the
form of an equivalent delay and periodically reports this back
to the sender. In addition, the receiver tracks the receiving
rate of the flow and includes that in the feedback message.</t>
        <section anchor="sec-receiver-a" numbered="true" toc="default">
          <name>Estimation of One-Way Delay and Queuing Delay</name>
          <t>
The delay estimation process in NADA follows an approach similar to that of
earlier
delay-based congestion control schemes, such as Low Extra Delay Background
Transport (LEDBAT) <xref target="RFC6817" format="default"></xref>. For
experimental implementations, instead of relying on RTP timestamps and the
transmission time offset RTP header extension <xref target="RFC5450"
format="default"/>, the NADA sender can generate its own timestamp based on
the local system clock and embed that information in the transport packet
header. The NADA receiver estimates the forward delay as having a constant
base delay component plus a time-varying queuing delay component. The base
delay is estimated as the minimum value of one-way delay observed over a
relatively long period (e.g., tens of minutes), whereas the individual
queuing delay value is taken to be the difference between one-way delay and
base delay. By re-estimating the base delay periodically, one can avoid the
potential issue of base delay expiration, whereby an earlier measured base
delay value is no longer valid due to underlying route changes or a cumulative
timing difference introduced by the clock-rate skew between sender and
receiver. All delay estimations are based on sender timestamps with a
recommended granularity of 100 microseconds or finer. </t>
          <t>
The individual sample values of queuing delay should be further
filtered against various non-congestion-induced noise, such as
spikes due to a processing "hiccup" at the network nodes. Therefore,
in addition to calculating the value of queuing delay using
d_queue = d_fwd - d_base, as expressed in <xref target="sec-receiver"
format="default"/>, 
the current implementation further employs a minimum filter with
a window size of 15 samples over per-packet queuing delay values.
          </t>
        </section>
        <section anchor="sec-receiver-b" numbered="true" toc="default">
          <name>Estimation of Packet Loss/Marking Ratio</name>
          <t>The receiver detects packet losses via gaps in the
RTP sequence numbers of received packets. For interactive
real-time media applications with stringent latency
constraints (e.g., video conferencing), the receiver avoids
the packet reordering delay by treating out-of-order packets
as losses. The instantaneous packet loss ratio p_inst is estimated
as the ratio between the number of missing packets over
the number of total transmitted packets within the
recent observation window LOGWIN. The packet loss ratio
p_loss is obtained after exponential smoothing: </t>
          <artwork name="" type="" align="left" alt=""><![CDATA[    
            p_loss = ALPHA*p_inst + (1-ALPHA)*p_loss        (10)
	    ]]></artwork>
          <t>The filtered result is reported back to the sender as
the observed packet loss ratio p_loss. </t>
          <t>
The estimation of the packet marking ratio p_mark follows the same procedure
as above.  It is assumed that ECN marking information at the IP header
can be passed to the receiving endpoint, e.g., by following the mechanism
described in <xref target="RFC6679" format="default"/>.</t>
        </section>
        <section anchor="sec-receiver-c" numbered="true" toc="default">
          <name>Estimation of Receiving Rate</name>
          <t>
It is fairly straightforward to estimate the receiving rate r_recv. NADA
maintains a recent observation window with a time span of LOGWIN and simply
divides the total size of packets arriving during that window over the time
span. The receiving rate (r_recv) can be either calculated at the sender side
based on the per-packet feedback from the receiver or included as part of the
feedback report.</t>
        </section>
      </section>
      <section anchor="sec-sender" numbered="true" toc="default">
        <name>Sender-Side Operation</name>
        <t>
<xref target="fig-nada-sender" format="default"/> provides a detailed
view of the NADA sender. Upon receipt of an RTCP feedback
report from the receiver, the NADA sender calculates the
reference rate r_ref as specified in
<xref target="subsec-sender-algorithm" format="default"/>.
It further adjusts both the target rate for the live video
encoder r_vin and the sending rate r_send over the network
based on the updated value of r_ref and rate-shaping buffer
occupancy buffer_len.
	</t>
        <t>
The NADA sender behavior stays the same in the presence
of all types of congestion indicators: delay, loss, and
ECN marking. This unified approach allows a graceful
transition of the scheme as the network shifts dynamically
between light and heavy congestion levels.
	</t>
        <figure anchor="fig-nada-sender">
          <name>NADA Sender Structure</name>
          <artwork name="" type="" align="left" alt=""><![CDATA[
                   +----------------+             
                   |  Calculate     | <---- RTCP report
                   | Reference Rate | 
                   -----------------+
                           | r_ref
              +------------+-------------+
              |                          |
             \|/                        \|/
      +-----------------+           +---------------+
      | Calculate Video |           |   Calculate   |
      |  Target Rate    |           | Sending Rate  |
      +-----------------+           +---------------+
          |        /|\                 /|\      |   
    r_vin |         |                   |       |
         \|/        +-------------------+       |       
      +----------+          | buffer_len        |  r_send
      |  Video   | r_vout  -----------+        \|/
      |  Encoder |-------->   |||||||||=================>  
      +----------+         -----------+    RTP packets     
      Rate-Shaping Buffer         
]]></artwork>
        </figure>
        <section anchor="sec-sender-c" numbered="true" toc="default">
          <name>Rate-Shaping Buffer</name>
          <t>
The operation of the live video encoder is out of the scope
of the design for the congestion control scheme in NADA.
Instead, its behavior is treated as a black box. 
	  </t>
          <t>
A rate-shaping buffer is employed to absorb any instantaneous
mismatch between the encoder rate output r_vout and the regulated sending
rate r_send. Its current level of occupancy is measured in bytes
and is denoted as buffer_len.  
	  </t>
          <t>A large rate-shaping buffer contributes to higher
end-to-end delay, which may harm the performance of
real-time media communications. Therefore, the sender
has a strong incentive to prevent the rate-shaping
buffer from building up. The mechanisms adopted are:
	  </t>
          <ul spacing="normal">
            <li>To deplete the rate-shaping buffer faster by
	    increasing the sending rate r_send; and </li>
            <li>To limit incoming packets of the rate-shaping
	    buffer by reducing the video encoder target rate
	    r_vin. </li>
          </ul>
        </section>
        <section anchor="sec-sender-d" numbered="true" toc="default">
          <name>Adjusting Video Target Rate and Sending Rate</name>
          <t>
If the level of occupancy in the rate-shaping buffer is accessible
at the sender, such information can be leveraged to further adjust
the target rate of the live video encoder r_vin as well as the
actual sending rate r_send. The purpose of such adjustments is to
mitigate the additional latencies introduced by the rate-shaping
buffer. The amount of rate adjustment can be calculated as follows:  
	  </t>
          <artwork name="" type="" align="left" alt=""><![CDATA[
    r_diff_v = min(0.05*r_ref, BETA_V*8*buffer_len*FPS)     (11) 
    r_diff_s = min(0.05*r_ref, BETA_S*8*buffer_len*FPS)     (12) 
    r_vin  = max(RMIN, r_ref - r_diff_v)                    (13) 
    r_send = min(RMAX, r_ref + r_diff_s)                    (14)
]]></artwork>

<t> In Equations (11) and (12), the amount of adjustment is calculated
as proportional to the size of the rate-shaping buffer but is
bounded by 5% of the reference rate r_ref calculated from network
congestion feedback alone. This ensures that the adjustment
introduced by the rate-shaping buffer will not counteract with the core
congestion control process. Equations (13) and (14) indicate
the influence of the rate-shaping buffer. A large
rate-shaping buffer nudges the encoder target rate slightly
below (and the sending rate slightly above) the reference
rate r_ref. The final video target rate (r_vin) and sending
rate (r_send) are further bounded within the original range of
[RMIN, RMAX]. </t>

          <t>
Intuitively, the amount of extra rate offset needed to completely
drain the rate-shaping buffer within the duration of a single
video frame is given by 8*buffer_len*FPS, where FPS stands
for the reference frame rate of the video. The scaling parameters
BETA_V and BETA_S can be tuned to balance between the competing
goals of maintaining a small rate-shaping buffer and deviating
from the reference rate point. Empirical observations show that
the rate-shaping buffer for a responsive live video encoder typically
stays empty and only occasionally holds a large frame (e.g., when
an intra-frame is produced) in transit. Therefore, the rate adjustment
introduced by this mechanism is expected to be minor. For instance,
a rate-shaping buffer of 2000 bytes will lead to a rate adjustment
of 48 Kbps given the recommended scaling parameters of BETA_V = 0.1
and BETA_S = 0.1, and the reference frame rate of FPS = 30. 
	  </t>
        </section>
      </section>
      <section anchor="sec-feedback" numbered="true" toc="default">
        <name>Feedback Message Requirements</name>
        <t>The following list of information is required for
NADA congestion control to function properly: </t>


<dl newline="false" spacing="normal">
<dt>Recommended rate adaptation mode (rmode):
</dt>
<dd>A 1-bit flag indicating whether the sender should operate in accelerated
ramp-up mode (rmode=0) or gradual update mode (rmode=1).
</dd>

<dt>Aggregated congestion signal (x_curr):
</dt>
<dd>The most recently updated value, calculated by the receiver according to
<xref target="subsec-receiver-algorithm" format="default"/>. This information
can be expressed with a unit of 100 microseconds (i.e., 1/10 of a millisecond)
in 15 bits. This allows a maximum value of x_curr at approximately 3.27
seconds.
</dd>

<dt>Receiving rate (r_recv):
</dt>
<dd>The most recently measured receiving rate according to <xref
target="sec-receiver-c" format="default"> </xref>. This information is
expressed with a unit of bits per second (bps) in 32 bits (unsigned int). This
allows a maximum rate of approximately 4.3 Gbps, approximately 1000 times the
streaming rate of a typical high-definition (HD) video conferencing session
today. This field can be expanded further by a few more bytes if an even
higher rate needs to be specified.
</dd>
</dl>


        <t>
  The above list of information can be accommodated by 48 bits,
  or 6 bytes, in total. They can be either included in the
  feedback report from the receiver or, in the case where all
  receiver-side calculations are moved to the sender, derived
  from per-packet information from the feedback message as defined
  in <xref target="I-D.ietf-avtcore-cc-feedback-message" format="default"/>. 
  Choosing the feedback message interval DELTA is discussed in
  <xref target="sec-discussion-c" format="default"/>. A target feedback
  interval
  of DELTA = 100 ms is recommended. 
        </t>

      </section>
    </section>


    <section anchor="sec-discussions" numbered="true" toc="default">
      <name>Discussions and Further Investigations</name>
      <t>This section discusses the various design choices
made by NADA, potential alternative variants of its
implementation, and guidelines on how the key algorithm
parameters can be chosen. <xref target="sec-experiments" format="default"/>
recommends additional experimental setups to 
further explore these topics. </t>
      <section anchor="sec-discussion-a" numbered="true" toc="default">
        <name>Choice of Delay Metrics</name>
     

   <t>
The current design works with relative one-way delay (OWD) as the main
indication of congestion. The value of the relative OWD is obtained by
maintaining the minimum value of observed OWD over a relatively long time
horizon and subtracting that out from the observed absolute OWD value. Such an
approach cancels out the fixed difference between the sender and receiver
clocks.  It has been widely adopted by other delay-based congestion control
approaches such as <xref target="RFC6817" format="default"/>.  As discussed in
<xref target="RFC6817" format="default"/>, the time horizon for tracking the
minimum OWD needs to be chosen with care; it must be long enough for an
opportunity to observe the minimum OWD with zero standing queue along the
path,
and it must be sufficiently short enough to timely reflect "true" changes in
minimum OWD introduced by route changes and other rare events and
to mitigate the cumulative impact of clock rate skew over time.
   </t>
        <t>
The potential drawback in relying on relative OWD as the congestion
signal is that when multiple flows share the same bottleneck, the
flow arriving late at the network experiencing a non-empty queue may
mistakenly consider the standing queuing delay as part of the fixed
path propagation delay. This will lead to slightly unfair bandwidth
sharing among the flows. 
	</t>
        <t>Alternatively, one could move the per-packet statistical handling
to the sender instead and use relative round-trip time (RTT) in lieu
of relative OWD, assuming that per-packet acknowledgments are available.
The main drawback of an RTT-based approach is the noise in the measured delay
in the reverse direction.
	</t>
        <t>
Note that the choice of either delay metric (relative OWD vs. RTT) involves no
change in the proposed rate adaptation algorithm.  Therefore, comparing the
pros and cons regarding which delay metric to adopt can be kept as an
orthogonal direction of investigation.
	</t>
      </section>
      <section anchor="sec-discussion-b" numbered="true" toc="default">
        <name>Method for Delay, Loss, and Marking Ratio Estimation</name>
        <t>Like other delay-based congestion control schemes, performance of
        NADA depends on the accuracy of its delay measurement and estimation
        module. <xref target= "RFC6817" format="default" section="A"/>
        provides an extensive discussion on this aspect.
	</t>


        <t>The current recommended practice of applying minimum filter with a
        window size of 15 samples suffices in guarding against processing
        delay outliers observed in wired connections. For wireless connections
        with a higher packet delay variation (PDV), more sophisticated
        techniques on denoising, outlier rejection, and trend analysis may be
        needed. </t>
        <t>
More sophisticated methods in packet loss ratio calculation,
such as that adopted by <xref target="FLOYD-CCR00" format="default"/>,
will likely be beneficial. These alternatives are part of
the experiments this document proposes.</t>
      </section>


      <section anchor="sec-discussion-c" numbered="true" toc="default">
        <name>Impact of Parameter Values</name>
        <t>In the gradual rate update mode, the parameter TAU indicates the
        upper bound of round-trip time (RTT) in the feedback control loop.
        Typically, the observed feedback interval delta is close to the target
        feedback interval DELTA, and the relative ratio of delta/TAU versus
        ETA dictates the relative strength of influence from the aggregate
        congestion signal offset term (x_offset) versus its recent change
        (x_diff), respectively. These two terms are analogous to the integral
        and proportional terms in a proportional-integral (PI) controller. The
        recommended choice of TAU = 500 ms, DELTA = 100 ms, and ETA = 2.0
	corresponds
        to a relative ratio of 1:10 between the gains of the integral and
        proportional terms. Consequently, the rate adaptation is mostly driven
        by the change in the congestion signal with a long-term shift towards
        its equilibrium value driven by the offset term. Finally, the scaling
        parameter KAPPA determines the overall speed of the adaptation and
        needs to strike a balance between responsiveness and stability. </t>

        <t>                                         
The choice of the target feedback interval DELTA needs to strike the right
balance between timely feedback and low RTCP feedback message counts. A target
feedback interval of DELTA = 100 ms is recommended, corresponding to a
feedback
bandwidth of 16 Kbps with 200 bytes per feedback message -- approximately 1.6%
overhead for a 1 Mbps flow. Furthermore, both simulation studies and
frequency-domain analysis in <xref target="IETF-95" format="default"/> have
established that a feedback interval below 250 ms (i.e., more frequently than
4
feedback messages per second) will not break up the feedback control loop of
NADA congestion control. </t>

        <t>In calculating the non-linear warping of delay in Equation (1), 
the current design uses fixed values of QTH for determining
whether to perform the non-linear warping. Its value should be
carefully tuned for different operational environments (e.g.,
over wired vs. wireless connections) so as to avoid the potential
risk of prematurely discounting the congestion signal level.
It is possible to adapt its value based on past observed patterns
of queuing delay in the presence of packet losses. It needs to be
noted that the non-linear warping mechanism may lead to multiple
NADA streams stuck in loss-based mode when competing against
each other. </t>

        <t>In calculating the aggregate congestion signal x_curr, the
choice of DMARK and DLOSS influence the steady-state packet
loss/marking ratio experienced by the flow at a given
available bandwidth. Higher values of DMARK and DLOSS result
in lower steady-state loss/marking ratios but are more 
susceptible to the impact of individual packet loss/marking
events.  While the value of DMARK and DLOSS are fixed and
predetermined in the current design, this document also encourages
further explorations of a scheme for automatically
tuning these values based on desired bandwidth sharing behavior
in the presence of other competing loss-based flows (e.g.,
loss-based TCP).</t>
      </section>

      <section anchor="sec-discussion-d" numbered="true" toc="default">
        <name>Sender-Based vs. Receiver-Based Calculation</name>
        <t>In the current design, the aggregated congestion
signal x_curr is calculated at the receiver, keeping
the sender operation completely independent of the
form of actual network congestion indications (delay, 
loss, or marking) in use. </t>
        <t>Alternatively, one can shift receiver-side calculations
to the sender, whereby the receiver simply reports on per-packet
information via periodic feedback messages as defined in
<xref target="I-D.ietf-avtcore-cc-feedback-message" format="default"/>. 
Such an approach enables interoperability amongst senders operating
on different congestion control schemes but requires slightly
higher overhead in the feedback messages. See additional discussions
in <xref target="I-D.ietf-avtcore-cc-feedback-message" format="default"/>
regarding the desired format of the feedback messages and the
recommended feedback intervals. </t>
      </section>
      <section anchor="sec-discussion-e" numbered="true" toc="default">
        <name>Incremental Deployment</name>
        <t>
One nice property of NADA is the consistent video endpoint
behavior irrespective of network node variations. This facilitates
gradual, incremental adoption of the scheme. 
	</t>
        <t>
Initially, the proposed congestion control mechanism can
be implemented without any explicit support from the network and
relies solely on observed relative one-way delay measurements
and packet loss ratios as implicit congestion signals. 
	</t>
        <t>
When ECN is enabled at the network nodes with RED-based marking,
the receiver can fold its observations of ECN markings into the
calculation of the equivalent delay. The sender can react to these
explicit congestion signals without any modification.
	</t>


        <t>
Ultimately, networks equipped with proactive marking based on the level of
token bucket metering can reap the additional benefits of
zero standing queues and lower end-to-end delay and work
seamlessly with existing senders and receivers. 
	</t>
      </section>
    </section>
    <section anchor="sec-implementations" numbered="true" toc="default">
      <name>Reference Implementations</name>
      <t>
The NADA scheme has been implemented in both ns-2 <xref target="NS-2"
format="default"/>
and ns-3 <xref target="NS-3" format="default"/> simulation platforms.  The
implementation
in ns-2 hosts the calculations as described in
<xref target="subsec-receiver-algorithm" format="default"/> at the receiver
side,
whereas the implementation in ns-3 hosts these receiver-side calculations
at the sender for the sake of interoperability. Extensive ns-2 simulation
evaluations of an earlier draft version of this document are recorded in
<xref target="ZHU-PV13" format="default"/>. 
An open-source implementation of NADA as part of an ns-3 module is
available at <xref target="NS3-RMCAT" format="default"/>.
Evaluation results of this document based on ns-3 are presented
in <xref target="IETF-90" format="default"/> and <xref target="IETF-91"
format="default"/>
for wired test cases as documented in <xref target="I-D.ietf-rmcat-eval-test"
format="default"/>.
Evaluation results of NADA over Wi-Fi-based test cases as defined in
<xref target="I-D.ietf-rmcat-wireless-tests" format="default"/> are
presented in <xref target="IETF-93" format="default"/>. These simulation-based
evaluations have shown that NADA flows can obtain their fair share of
bandwidth when competing against each other. They typically adapt fast
in reaction to the arrival and departure of other flows and can sustain
a reasonable throughput when competing against loss-based TCP flows. </t>
      <t> 
<xref target="IETF-90" format="default"/> describes the  implementation and
evaluation of NADA in a lab setting. Preliminary evaluation
results of NADA in single-flow and multi-flow test scenarios
are presented in <xref target="IETF-91" format="default"/>. </t>
      <t>
A reference implementation of NADA has been carried out by
modifying the WebRTC module embedded in the Mozilla open-source
browser. Presentations from <xref target="IETF-103" format="default"/>
and <xref target="IETF-105" format="default"/> document real-world evaluations
of the modified browser driven by NADA. The experimental setting
involves remote connections with endpoints over either home or enterprise
wireless networks. These evaluations validate the effectiveness of
NADA flows in recovering quickly from throughput drops caused by
intermittent delay spikes over the last-hop wireless connections. </t>
    </section>
    <section anchor="sec-experiments" numbered="true" toc="default">
      <name>Suggested Experiments</name>
      <t>
NADA has been extensively evaluated under various test scenarios, including
the collection of test cases specified by <xref
target="I-D.ietf-rmcat-eval-test" format="default"/> and the subset of
Wi-Fi-based test cases in <xref target="I-D.ietf-rmcat-wireless-tests"
format="default"/>.  Additional evaluations have been carried out to
characterize how NADA interacts with various AQM
schemes such as RED, Controlling Queue Delay (CoDel), and Proportional
Integral Controller Enhanced (PIE). Most of these evaluations have been
carried out in simulators. A few key test cases have been evaluated in lab
environments with implementations embedded in video conferencing clients. It
is strongly recommended to carry out implementation and experimentation of
NADA in real-world settings. Such exercises will provide insights on how to
choose or automatically adapt the values of the key algorithm parameters (see
list in <xref target="tab-parameters" format="default"/>) as discussed in
<xref target="sec-discussions" format="default"/>. </t>
      <t>Additional experiments are suggested for the following scenarios,
      preferably over real-world networks: </t>
      <ul spacing="normal">
        <li>Experiments reflecting the setup of a typical WAN
	connection. </li>
        <li>Experiments with ECN marking capability turned on at the network
  for existing test cases.</li>
        <li>Experiments with multiple NADA streams bearing different
  user-specified priorities.</li>
        <li>Experiments with additional access technologies, especially
over cellular networks such as 3G/LTE.</li>
        <li>Experiments with various media source contents, including audio
	only,
  audio and video, and application content sharing (e.g., slideshows). </li>
      </ul>
    </section>
    <section anchor="sec-iana" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>This document has no IANA actions.</t>
    </section>
    <section anchor="sec-security" numbered="true" toc="default">
      <name>Security Considerations</name>
      <t>The rate adaptation mechanism in NADA relies on feedback from the
      receiver. As such, it is vulnerable to attacks where feedback messages
      are hijacked, replaced, or intentionally injected with misleading
      information resulting in denial of service, similar to those that can
      affect TCP. Therefore, it is <bcp14>RECOMMENDED</bcp14> that the RTCP
      feedback message is at least integrity checked. In addition, <xref
      target="I-D.ietf-avtcore-cc-feedback-message" format="default"/>
      discusses the potential risk of a receiver providing misleading
      congestion feedback information and the mechanisms for mitigating such
      risks.</t>


      <t>The modification of the sending rate based on the sender-side
      rate-shaping
      buffer may lead to temporary excessive congestion over the network in
      the presence of an unresponsive video encoder. However, this effect can
      be mitigated by limiting the amount of rate modification introduced by
      the rate-shaping buffer, bounding the size of the rate-shaping buffer at
      the sender, and maintaining a maximum allowed sending rate by NADA.
      </t>
    </section>


  </middle>


  <back>

    <displayreference target="I-D.ietf-rmcat-cc-requirements" to="RMCAT-CC"/>
    <displayreference target="I-D.ietf-rmcat-cc-codec-interactions"
		      to="RMCAT-CC-RTP"/>
    <displayreference target="I-D.ietf-rmcat-eval-test" to="RMCAT-EVAL-TEST"/>
    <displayreference target="I-D.ietf-rmcat-wireless-tests"
		      to="WIRELESS-TESTS"/>
    <displayreference target="I-D.ietf-avtcore-cc-feedback-message"
		      to="RTCP-FEEDBACK"/>


    <references>
      <name>References</name>
      <references>
        <name>Normative References</name>
 <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
       
 <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3168.xml"/>
       
 <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3550.xml"/>
       
 <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5348.xml"/>
       
 <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6679.xml"/>
       
 <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
       
      </references>
      <references>
        <name>Informative References</name>

 <xi:include  href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5450.xml"/>
 <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6660.xml"/>
       
 <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6817.xml"/>

 <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7567.xml"/>

       
 <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8033.xml"/>

 <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8290.xml"/>
       
 <xi:include href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8593.xml"/>

        
 <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-rmcat-cc-requirements.xml"/>
 <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-rmcat-cc-codec-interactions.xml"/>
 <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-rmcat-eval-test.xml"/>
 <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-rmcat-wireless-tests.xml"/>
 <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-avtcore-cc-feedback-message.xml"/>

        <reference anchor="FLOYD-CCR00" target="">
          <front>
            <title>
             Equation-based congestion control for unicast applications
            </title>
            <seriesInfo name="DOI" value="10.1145/347057.347397"/> 
            <author fullname="Sally Floyd" initials="S." surname="Floyd">
              <organization/>
            </author>
            <author fullname="Mark Handley" initials="M." surname="Handley">
              <organization/>
            </author>
            <author fullname="Jitendra Padhye" initials="J." surname="Padhye">
              <organization/>
            </author>
            <author fullname="Jrg Widmer" initials="J." surname="Widmer">
              <organization/>
            </author>
            <date month="October" year="2000"/>
          </front>
          <refcontent>ACM SIGCOMM Computer Communications Review, vol. 30,
	    no. 4, pp. 43-56 
          </refcontent>
        </reference>

        <reference anchor="BUDZISZ-AIMD-CC" target="">
          <front>
            <title>
            On the Fair Coexistence of Loss- and Delay-Based TCP
            </title>
            <seriesInfo name="DOI" value="10.1109/TNET.2011.2159736"/>
            <author fullname="Lukasz Budzisz" initials="L." surname="Budzisz">
              <organization/>
            </author>
            <author fullname="Rade Stanojevic" initials="R."
		    surname="Stanojevic">
              <organization/>
            </author>
            <author fullname="Arieh Schlote" initials="A." surname="Schlote">
              <organization/>
            </author>
            <author fullname="Fred Baker" initials="F." surname="Baker">
              <organization/>
            </author>
            <author fullname="Robert Shorten" initials="R." surname="Shorten">
              <organization/>
            </author>
            <date month="December" year="2011"/>
          </front>
          <refcontent>IEEE/ACM Transactions on Networking, vol. 19, no. 6,
	  pp. 1811-1824
          </refcontent>
        </reference>


        <reference anchor="ZHU-PV13" target="">
          <front>
            <title>
	      NADA: A Unified Congestion Control Scheme for Low-Latency
	      Interactive Video
            </title>
            <seriesInfo name="DOI" value=" 10.1109/PV.2013.6691448"/>
            <author fullname="Xiaoqing Zhu" initials="X." surname="Zhu">
              <organization/>
            </author>
            <author fullname="Rong Pan" initials="R." surname="Pan">
              <organization/>
            </author>
            <date month="December" year="2013"/>
          </front>
          <refcontent>Proc. IEEE International Packet Video Workshop, San
	  Jose, CA, USA
          </refcontent>
        </reference>


        <reference anchor="NS-2"
		      target="http://nsnam.sourceforge.net/wiki/index.php/Main_Page">
          <front>
            <title>ns-2</title>
            <author>
              <organization/>
            </author>
            <date month="December" year="2014"/>
          </front>
        </reference>


        <reference anchor="NS-3" target="https://www.nsnam.org/">
          <front>
            <title>ns-3 Network Simulator</title>
            <author>
              <organization/>
            </author>
          </front>
        </reference>


        <reference anchor="IETF-90"
		   target="https://tools.ietf.org/agenda/90/slides/slides-90-rmcat-6.pdf">
          <front>
            <title>NADA Update: Algorithm, Implementation, and Test Case
	    Evaluation Results</title>
            <author fullname="Xiaoqing Zhu" initials="X." surname="Zhu">
              <organization/>
            </author>
            <author fullname="Michael Ramalho" initials="M."
		    surname="Ramalho">
              <organization/>
            </author>
            <author fullname="Charles Ganzhorn" initials="C."
		    surname="Ganzhorn">
              <organization/>
            </author>
            <author fullname="Paul E. Jones" initials="P." surname="Jones">
              <organization/>
            </author>
            <author fullname="Rong Pan" initials="R." surname="Pan">
              <organization/>
            </author>
            <date month="July" year="2014"/>
          </front>
          <refcontent>IETF 90
          </refcontent>
        </reference>


        <reference anchor="IETF-91"
		   target="https://www.ietf.org/proceedings/interim/2014/11/09/rmcat/slides/slides-interim-2014-rmcat-1-2.pdf">
          <front>
            <title>NADA Algorithm Update and Test Case Evaluations</title>
            <author fullname="Xiaoqing Zhu" initials="X." surname="Zhu">
              <organization/>
            </author>
            <author fullname="Rong Pan" initials="R." surname="Pan">
              <organization/>
            </author>
            <author fullname="Michael Ramalho" initials="M."
		    surname="Ramalho">
              <organization/>
            </author>
            <author fullname="Sergio Mena" initials="S." surname="Mena">
              <organization/>
            </author>
            <author fullname="Charles Ganzhorn" initials="C."
		    surname="Ganzhorn">
              <organization/>
            </author>
            <author fullname="Paul E. Jones" initials="P." surname="Jones">
              <organization/>
            </author>
            <author fullname="Stefano D'Aronco" initials="S."
		    surname="D'Aronco">
              <organization/>
            </author>
            <date month="November" year="2014"/>
          </front>
          <refcontent>IETF 91
          </refcontent>
        </reference>


        <reference anchor="IETF-93"
		   target="https://www.ietf.org/proceedings/93/slides/slides-93-rmcat-0.pdf">
          <front>
            <title>Updates on NADA</title>
            <author fullname="Xiaoqing Zhu" initials="X." surname="Zhu">
              <organization/>
            </author>
            <author fullname="Rong Pan" initials="R." surname="Pan">
              <organization/>
            </author>
            <author fullname="Michael Ramalho" initials="M."
		    surname="Ramalho">
              <organization/>
            </author>
            <author fullname="Sergio Mena" initials="S." surname="Mena">
              <organization/>
            </author>
            <author fullname="Charles Ganzhorn" initials="C."
		    surname="Ganzhorn">
              <organization/>
            </author>
            <author fullname="Paul E. Jones" initials="P." surname="Jones">
              <organization/>
            </author>
            <author fullname="Stefano D'Aronco" initials="S."
		    surname="D'Aronco">
              <organization/>
            </author>
            <author fullname="Jiantao Fu" initials="J." surname="Fu">
              <organization/>
            </author>
            <date month="July" year="2015"/>
          </front>
          <refcontent>IETF 93
          </refcontent>
        </reference>


        <reference anchor="IETF-95"
		   target="https://www.ietf.org/proceedings/95/slides/slides-95-rmcat-5.pdf">
          <front>
            <title>Updates on NADA: Stability Analysis and Impact of Feedback
	    Intervals</title>
            <author fullname="Xiaoqing Zhu" initials="X." surname="Zhu">
              <organization/>
            </author>
            <author fullname="Rong Pan" initials="R." surname="Pan">
              <organization/>
            </author>
            <author fullname="Michael Ramalho" initials="M."
		    surname="Ramalho">
              <organization/>
            </author>
            <author fullname="Sergio Mena" initials="S." surname="Mena">
              <organization/>
            </author>
            <author fullname="Paul E. Jones" initials="P." surname="Jones">
              <organization/>
            </author>
            <author fullname="Jiantao Fu" initials="J." surname="Fu">
              <organization/>
            </author>
            <author fullname="Stefano D'Aronco" initials="S."
		    surname="D'Aronco">
              <organization/>
            </author>
            <author fullname="Charles Ganzhorn" initials="C."
		    surname="Ganzhorn">
              <organization/>
            </author>
            <date month="April" year="2016"/>
          </front>
          <refcontent>IETF 95
          </refcontent>
        </reference>


        <reference anchor="IETF-103"
		   target="https://datatracker.ietf.org/meeting/103/materials/slides-103-rmcat-nada-implementation-in-mozilla-browser-00">
          <front>
            <title>NADA Implementation in Mozilla Browser</title>
            <author fullname="Xiaoqing Zhu" initials="X." surname="Zhu">
              <organization/>
            </author>
            <author fullname="Rong Pan" initials="R." surname="Pan">
              <organization/>
            </author>
            <author fullname="Michael Ramalho" initials="M."
		    surname="Ramalho">
              <organization/>
            </author>
            <author fullname="Sergio Mena" initials="S." surname="Mena">
              <organization/>
            </author>
            <author fullname="Paul E. Jones" initials="P." surname="Jones">
              <organization/>
            </author>
            <author fullname="Jiantao Fu" initials="J." surname="Fu">
              <organization/>
            </author>
            <author fullname="Stefano D'Aronco" initials="S."
		    surname="D'Aronco">
              <organization/>
            </author>
            <date month="November" year="2018"/>
          </front>
          <refcontent>IETF 103
          </refcontent>
        </reference>


        <reference anchor="IETF-105"
		   target="https://datatracker.ietf.org/meeting/105/materials/slides-105-rmcat-nada-update-02.pdf">
          <front>
            <title>NADA Implementation in Mozilla Browser and Draft
	    Update</title>
            <author fullname="Xiaoqing Zhu" initials="X." surname="Zhu">
              <organization/>
            </author>
            <author fullname="Rong Pan" initials="R." surname="Pan">
              <organization/>
            </author>
            <author fullname="Michael Ramalho" initials="M."
		    surname="Ramalho">
              <organization/>
            </author>
            <author fullname="Sergio Mena" initials="S." surname="Mena">
              <organization/>
            </author>
            <author fullname="Paul E. Jones" initials="P." surname="Jones">
              <organization/>
            </author>
            <author fullname="Jiantao Fu" initials="J." surname="Fu">
              <organization/>
            </author>
            <author fullname="Stefano D'Aronco" initials="S."
		    surname="D'Aronco">
              <organization/>
            </author>
            <date month="July" year="2019"/>
          </front>
          <refcontent>IETF 105
          </refcontent>
        </reference>


        <reference anchor="NS3-RMCAT"
		   target="https://github.com/cisco/ns3-rmcat">
          <front>
            <title>Simulator of IETF RMCAT congestion control
	    protocols</title>
            <author fullname="Jiantao Fu" initials="J." surname="Fu">
              <organization/>
            </author>
            <author fullname="Sergio Mena" initials="S." surname="Mena">
              <organization/>
            </author>
            <author fullname="Xiaoqing Zhu" initials="X." surname="Zhu">
              <organization/>
            </author>
            <date month="November" year="2017"/>
          </front>
        </reference>

      </references>


    </references>
    <section anchor="sec-network-nodes" numbered="true" toc="default">
      <name>Network Node Operations</name>
      <t>NADA can work with different network queue management
schemes and does not assume any specific network node operation.
As an example, this appendix describes three variants of queue
management behavior at the network node, leading to either
implicit or explicit congestion signals. It needs to be
acknowledged that NADA has not yet been tested with non-probabilistic
ECN marking behaviors.  
      </t>
      <t>
In all three flavors described below, the network queue
operates with the simple First In, First Out (FIFO) principle.
There is no need to maintain per-flow state. The system
can scale easily with a large number of video flows and
at high link capacity.
      </t>
      <section anchor="sec-network-droptail" numbered="true" toc="default">
        <name>Default Behavior of Drop-Tail Queues</name>
        <t>
In a conventional network with drop-tail or RED queues,
congestion is inferred from the estimation of end-to-end
delay and/or packet loss. Packet drops at the queue are
detected at the receiver and contribute to the calculation
of the aggregated congestion signal x_curr. No special
action is required at the network node.
	</t>
      </section>
      <section anchor="sec-network-ecn" numbered="true" toc="default">
        <name>RED-Based ECN Marking</name>
        <t>In this mode, the network node randomly marks
the ECN field in the IP packet header following
the <xref target="RFC7567" format="default">Random Early Detection
(RED) algorithm</xref>. Calculation of the marking
probability involves the following steps on packet arrival:</t>


<ol spacing="normal" type="1">

<li><t>update smoothed queue size q_avg as:</t>
<artwork name="" type="" align="left" alt=""><![CDATA[
   q_avg = w*q + (1-w)*q_avg
]]></artwork>
</li>

<li><t>calculate marking probability p as:</t>
<artwork name="" type="" align="left" alt=""><![CDATA[
        / 0,                    if q < q_lo
        |
        |        q_avg - q_lo
    p= <  p_max*--------------, if q_lo <= q < q_hi
        |         q_hi - q_lo
        |
        \ p = 1,                if q >= q_hi
]]></artwork>
</li>
</ol>

        <t>
Here, q_lo and q_hi correspond to the low
and high thresholds of queue occupancy.
The maximum marking probability is p_max. 
	</t>
        <t>
The ECN marking events will contribute
to the calculation of an equivalent delay
x_curr at the receiver. No changes are required
at the sender. 
	</t>
      </section>
      <section anchor="sec-network-pcn" numbered="true" toc="default">
        <name>Random Early Marking with Virtual Queues</name>
        <t>
Advanced network nodes may support random early marking
based on a token bucket algorithm originally designed for
<xref target="RFC6660" format="default">Pre-Congestion Notification
(PCN)</xref>. 
The early congestion notification (ECN) bit in the
IP header of packets is marked randomly.
The marking probability is calculated based on a
token bucket algorithm originally designed for
<xref target="RFC6660" format="default">PCN</xref>.
The target link utilization is set as 90%; the marking
probability is designed to grow linearly with the token
bucket size when it varies between 1/3 and 2/3 of the
full token bucket limit.</t>
        <t>Calculation of the marking probability involves
the following steps upon packet arrival:</t>

<ol spacing="normal" type="1">

<li><t>meter packet against token bucket (r,b)</t></li>

<li><t>update token level b_tk</t></li>

<li><t>calculate the marking probability as:</t>
        <artwork name="" type="" align="left" alt=""><![CDATA[
         / 0,                     if b-b_tk < b_lo 
         |
         |          b-b_tk-b_lo
    p = <  p_max* --------------, if b_lo <= b-b_tk < b_hi
         |           b_hi-b_lo
         |
         \ 1,                     if b-b_tk >= b_hi 
]]></artwork>
</li>
</ol>
        <t>
Here, the token bucket lower and upper limits are denoted by
b_lo and b_hi, respectively. The parameter b indicates the size
of the token bucket. The parameter r is chosen to be below
capacity, resulting in slight underutilization of the link.
The maximum marking probability is p_max. 
	</t>

        <t>The ECN marking events will contribute to the calculation
of an equivalent delay x_curr at the receiver. No changes are
required at the sender. The virtual queuing mechanism from
the PCN-based marking algorithm will lead to additional
benefits such as zero standing queues. 
	</t>
      </section>
</section>


    <section anchor="sec-acknowledgments" numbered="false" toc="default">
    <name>Acknowledgments</name>
   
<t>
The authors would like to thank <contact fullname="Randell Jesup"/>, <contact
fullname="Luca De Cicco"/>, <contact fullname="Piers O'Hanlon"/>, <contact
fullname="Ingemar Johansson"/>, <contact fullname="Stefan Holmer"/>, <contact
fullname="Cesar Ilharco Magalhaes"/>, <contact fullname="Safiqul Islam"/>,
<contact fullname="Michael Welzl"/>, <contact fullname="Mirja Khlewind"/>,
<contact fullname="Karen Elisabeth Egede Nielsen"/>, <contact fullname="Julius
Flohr"/>, <contact fullname="Roland Bless"/>, <contact fullname="Andreas
Smas"/>, and <contact fullname="Martin Stiemerling"/> for their valuable
review comments and helpful input to this specification. </t>

    </section>


<section anchor="sec-contributors" numbered="false" toc="default">
      
      <name>Contributors</name>
      
      <t>The following individuals contributed to the implementation
  and evaluation of the proposed scheme and, therefore, helped
  to validate and substantially improve this specification.</t>

        <t><contact fullname="Paul E.&nbsp;Jones"/>
	&lt;paulej@packetizer.com&gt; of Cisco Systems implemented
    an early version of the NADA congestion control scheme and helped with its
    lab-based testbed evaluations. </t>
        <t><contact fullname="Jiantao Fu"/> &lt;jianfu@cisco.com&gt; of Cisco
	Systems helped with the
  implementation and extensive evaluation of NADA both in Mozilla web browsers
  and in earlier simulation-based evaluation efforts. 
	</t>
        <t><contact fullname="Stefano D'Aronco"/>
	&lt;stefano.daronco@geod.baug.ethz.ch&gt; of ETH Zurich
  (previously at Ecole Polytechnique Federale de Lausanne when contributing
   to this work) helped with the implementation and evaluation of an early
   version
   of NADA in <xref target="NS-3" format="default"/>. </t>
        <t><contact fullname="Charles Ganzhorn"/>
	&lt;charles.ganzhorn@gmail.com&gt; contributed to the
    testbed-based evaluation of NADA during an early stage of its development.
	</t>

</section>

</back>
</rfc>
