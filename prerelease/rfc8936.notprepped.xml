<?xml version='1.0' encoding='utf-8'?>

<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">

<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="std"
     docName="draft-ietf-secevent-http-poll-12" ipr="trust200902" obsoletes=""
     updates="" submissionType="IETF" xml:lang="en" tocInclude="true"
     tocDepth="3" symRefs="true" sortRefs="true" consensus="yes" number="8936"
     version="3">

  <front>
    <title abbrev="Poll-Based SET Delivery Using HTTP">Poll-Based Security Event Token (SET) Delivery Using HTTP</title>
    <seriesInfo name="RFC" value="8936"/>
    <author fullname="Annabelle Backman" initials="A." surname="Backman" role="editor">
      <organization>Amazon</organization>
      <address>
        <email>richanna@amazon.com</email>
      </address>
    </author>
    <author fullname="Michael B. Jones" initials="M." surname="Jones" role="editor">
      <organization>Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
        <uri>https://self-issued.info/</uri>
      </address>
    </author>
    <author fullname="Marius Scurtescu" initials="M." surname="Scurtescu">
      <organization>Coinbase</organization>
      <address>
        <email>marius.scurtescu@coinbase.com</email>
      </address>
    </author>
    <author fullname="Morteza Ansari" initials="M." surname="Ansari">
      <organization>Independent</organization>
      <address>
        <email>morteza@sharppics.com</email>
      </address>
    </author>
    <author fullname="Anthony Nadalin" initials="A." surname="Nadalin">
      <organization>Independent</organization>
      <address>
        <email>nadalin@prodigy.net</email>
      </address>
    </author>
    <date year="2020" month="November"/>
    <area>Security</area>
    <workgroup>Security Events Working Group</workgroup>

<keyword>JSON Web Token</keyword>
<keyword>JWT</keyword>
<keyword>Security Event Token</keyword>
<keyword>SET</keyword>
<keyword>Delivery</keyword>
<keyword>JavaScript Object Notation</keyword>
<keyword>JSON</keyword>

    <abstract>
      <t>
	This specification defines how a series of Security Event Tokens
        (SETs) can be delivered to an intended recipient
        using HTTP POST over TLS initiated as a poll by the recipient. The
        specification also defines how delivery can be assured, subject to
        the SET Recipient's need for assurance.
      </t>
    </abstract>
  </front>
  <middle>


    <section anchor="intro" toc="default" numbered="true">
      <name>Introduction and Overview</name>
      <t>
        This specification defines how a stream of
	Security Event Tokens (SETs) <xref target="RFC8417" format="default"/>
        can be transmitted to an intended
        SET Recipient using HTTP <xref target="RFC7231" format="default"/>
        over TLS. The specification defines a method to poll for SETs
        using HTTP POST.
	This is an alternative SET delivery method to the one defined in
	<xref target="RFC8935" format="default"/>.
      </t>
      <t>
	Poll-based SET delivery is intended for scenarios where all of
	the following apply:
      </t>
      <ul spacing="normal">
        <li>The recipient of the SET is capable of making outbound HTTP requests.</li>
        <li>
	    The transmitter is capable of hosting a TLS-enabled HTTP endpoint that is accessible
	    to the recipient.
	  </li>
        <li>
	    The transmitter and recipient are willing to exchange data with one another.
	  </li>
      </ul>
      <t>
	In some scenarios, either push-based or poll-based delivery could be used,
	and in others, only one of them would be applicable.
      </t>
      <t>
	A mechanism for exchanging configuration metadata such as endpoint URLs,
	cryptographic keys,
	and possible implementation constraints such as buffer size limitations
	between the transmitter and recipient is
        out of scope for this specification.  How SETs are defined and the process
        by which security events are identified for SET Recipients are specified in
	<xref target="RFC8417" format="default"/>.
      </t>
      <section anchor="notat" toc="default" numbered="true">
        <name>Notational Conventions</name>
        <t>
    The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
    "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
    NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
    "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
    "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are
    to be interpreted as described in BCP&nbsp;14 <xref target="RFC2119"/>
    <xref target="RFC8174"/> when, and only when, they appear in all capitals,
    as shown here.
        </t>
        <t>
	  Throughout this document, all figures may contain spaces and extra
	  line wrapping for readability and due to space limitations.
        </t>
      </section>
      <section anchor="defs" toc="default" numbered="true">
        <name>Definitions</name>
        <t>
            This specification utilizes terminology defined in <xref target="RFC8417" format="default"/>
            and <xref target="RFC8935" format="default"/>.
        </t>
      </section>
    </section>
    <section anchor="Delivery" numbered="true" toc="default">
      <name>SET Delivery</name>
      <t>
	When a SET is available for a SET Recipient, the SET Transmitter
	queues the SET in a buffer so that
	a SET Recipient can poll for SETs using HTTP POST.
      </t>
      <t>
	In poll-based SET delivery using HTTP over TLS, zero or more SETs are
        delivered in a JSON <xref target="RFC8259" format="default"/> document
        to a SET Recipient in response to an HTTP POST request to the
        SET Transmitter. Then in a following request, the SET Recipient
        acknowledges received SETs and can poll for more.  All requests and
        responses are JSON documents and use a
        <tt>Content-Type</tt> of
        <tt>application/json</tt>, as described in
        <xref target="pollReq" format="default"/>.
      </t>

      <t>After successful (acknowledged) SET delivery, SET
      Transmitters are not required to retain or record SETs for
      retransmission. Once a SET is acknowledged, the SET Recipient <bcp14>SHALL</bcp14> be
      responsible for retention, if needed.
      Transmitters may also discard undelivered SETs under deployment-specific conditions,
      such as if they have not been polled for over too long a period of time
      or if an excessive amount of storage is needed to retain them.
      </t>
      <t>
	Upon receiving a SET, the SET Recipient reads the SET and validates
	it in the manner described in <xref
	target="RFC8935" sectionFormat="of" section="2"/>.
	The SET Recipient <bcp14>MUST</bcp14> acknowledge receipt to the SET Transmitter,
	and <bcp14>SHOULD</bcp14> do so in a timely fashion, as described in <xref target="pollRequest" format="default"/>.
	The SET Recipient <bcp14>SHALL NOT</bcp14> use the event acknowledgement mechanism
        to report event errors other than those relating to the parsing and
        validation of the SET.
      </t>
      <section anchor="httpPoll" numbered="true" toc="default">
        <name>Polling Delivery using HTTP</name>
        <t>This method allows a SET Recipient to use HTTP POST
	(<xref target="RFC7231" sectionFormat="of" section="4.3.3"/>) to acknowledge
	SETs and to check for and receive zero or more SETs. Requests
	<bcp14>MAY</bcp14> be made at a periodic interval (short polling) or requests
	<bcp14>MAY</bcp14> wait, pending availability of new SETs using long polling,
	per <xref target="RFC6202" sectionFormat="of" section="2"/>.
	Note that short polling will result in retrieving zero or more SETs
	whereas long polling will typically result in retrieving one or more SETs
	unless a timeout occurs.
        </t>
        <t>The delivery of SETs in this method is facilitated by HTTP
	POST requests initiated by the SET Recipient in which:</t>
        <ul spacing="normal">
          <li>The SET Recipient makes a request for available SETs
        using an HTTP POST to a pre-arranged endpoint provided by the SET
        Transmitter, or</li>
          <li>after validating previously received SETs, the SET Recipient
        initiates another poll request using HTTP POST that includes
        acknowledgement of previous SETs and requests the next batch
        of SETs.</li>
        </ul>
        <t>The purpose of the acknowledgement is to inform the
	SET Transmitter that delivery has succeeded and
	redelivery is no longer required.
	Before acknowledgement, SET Recipients validate the received SETs
	and retain them in a manner appropriate to the recipient's
	requirements. The level and method of retention of SETs
	by SET Recipients is out of scope of this specification.</t>
      </section>
      <section anchor="pollReq" numbered="true" toc="default">
        <name>Polling HTTP Request</name>
        <t>When initiating a poll request, the SET Recipient constructs
	a JSON document that consists of polling request parameters
	and SET acknowledgement parameters in the form of JSON objects.
        </t>
        <t>When making a request, the HTTP <tt>Content-Type</tt> header field
	is set to <tt>application/json</tt>.</t>
        <t>The following JSON object members are used in a polling request:
        </t>
        <dl newline="true" spacing="normal">
          <dt>Request Processing Parameters</dt>
          <dd>
            <dl newline="true" spacing="normal">
              <dt>maxEvents</dt>
              <dd>An <bcp14>OPTIONAL</bcp14> integer value
	    indicating the maximum number of unacknowledged SETs to be returned.
	    The SET Transmitter <bcp14>SHOULD NOT</bcp14> send more SETs than the specified maximum.
	    If more than the maximum number of SETs
	    are available, the SET Transmitter determines which to return first;
	    the oldest SETs available <bcp14>MAY</bcp14> be returned first,
	    or another selection algorithm <bcp14>MAY</bcp14> be used,
	    such as prioritizing SETs in some manner that makes sense for the use case.
	    A value of <tt>0</tt> <bcp14>MAY</bcp14> be used by
	    SET Recipients that would like to perform an acknowledge-only
	    request. This enables the Recipient to use separate HTTP requests
	    for acknowledgement and reception of SETs.
	    If this parameter is omitted, no limit is placed on
	    the number of SETs to be returned.
	    </dd>
              <dt>returnImmediately</dt>
              <dd>An <bcp14>OPTIONAL</bcp14> JSON
	    boolean value that indicates the SET Transmitter <bcp14>SHOULD</bcp14> return
	    an immediate response even if no results are available
	    (short polling). The default value is <tt>false</tt>,
	    which indicates the request is to be treated as an HTTP long poll,
	    per <xref target="RFC6202" sectionFormat="of" section="2"/>. The timeout for the
	    request is part of the configuration between the participants, which is out of
	    scope of this specification.</dd>
            </dl>
	</dd> </dl>
<dl newline="true" spacing="normal">
<dt>SET Acknowledgment Parameters</dt><dd>
            <dl newline="true" spacing="normal">
              <dt>ack</dt>
              <dd>
	     A JSON array of strings whose values are the <tt>jti</tt> <xref
	     target="RFC7519" format="default"/> values of successfully
	     received SETs that are being acknowledged.  If there are no
	     outstanding SETs to acknowledge, this member is omitted or
	     contains an empty array.  Once a SET has been acknowledged, the
	     SET Transmitter is released from any obligation to retain the
	     SET.
	   </dd>
              <dt>setErrs</dt>
              <dd>
	     A JSON object with one or more members whose keys
	     are the <tt>jti</tt> values of
	     invalid SETs received.
	     The values of these objects are themselves JSON objects that
	     describe the errors detected using the
	     <tt>err</tt> and
	     <tt>description</tt> values
	     specified in <xref target="errorResponse" format="default"/>.
	     If there are no outstanding SETs with errors to report, this member is omitted
	     or contains an empty JSON object.
	   </dd>
            </dl>
	</dd>	  </dl>
        </section>
      <section anchor="pollResp" numbered="true" toc="default">
        <name>Polling HTTP Response</name>
        <t>In response to a poll request, the SET Transmitter checks for
	available SETs and responds with a JSON document containing
	the following JSON object members:
        </t>
        <dl newline="true" spacing="normal">
          <dt>sets</dt>
          <dd>A JSON object containing zero or more SETs being returned.
	  Each member name
	  is the <tt>jti</tt> of a SET to
	  be delivered, and its value is a JSON string representing the
	  corresponding SET. If there are no
	  outstanding SETs to be transmitted, the JSON object <bcp14>SHALL</bcp14> be
	  empty.
	  Note that both SETs being transmitted for the first time and
	  SETs that are being retransmitted after not having been acknowledged
	  are communicated here.
	  </dd>
          <dt>moreAvailable</dt>
          <dd>A JSON boolean value that
	  indicates if more unacknowledged SETs are available to be returned.
	  This member <bcp14>MAY</bcp14> be omitted, with the meaning being the same as
	  including it with the boolean value <tt>false</tt>.
	  </dd>
        </dl>
        <t>When making a response, the HTTP <tt>Content-Type</tt> header field
	is set to <tt>application/json</tt>.</t>
      </section>
      <section anchor="pollRequest" numbered="true" toc="default">
        <name>Poll Request</name>
        <t>The SET Recipient performs an HTTP POST (see
	<xref target="RFC7231" sectionFormat="of" section="4.3.4"/>) to a pre-arranged
	polling endpoint URI to check for SETs that are available.
	Because the SET Recipient has no prior SETs to
	acknowledge, the <tt>ack</tt> and
	<tt>setErrs</tt> request parameters are omitted.</t>
        <t>
	  After a period of time configured in an out-of-band manner between the SET
	Transmitter and Recipient, a SET Transmitter <bcp14>MAY</bcp14> redeliver SETs
	it has previously delivered. The SET Recipient <bcp14>SHOULD</bcp14> accept
	repeat SETs and acknowledge the SETs regardless of whether the
	Recipient believes it has already acknowledged the SETs previously.
	A SET Transmitter <bcp14>MAY</bcp14> limit the number of times it attempts to
	deliver a SET.
        </t>
        <t>If the SET Recipient has received SETs from the
        SET Transmitter, the SET Recipient parses and validates that
        received SETs meet its own requirements and <bcp14>SHOULD</bcp14> acknowledge
        receipt in a timely fashion (e.g., seconds or minutes) so that the SET
        Transmitter can mark the SETs as received. SET Recipients <bcp14>SHOULD</bcp14>
        acknowledge receipt before taking any local actions based on
        the SETs to avoid unnecessary delay in acknowledgement, where
        possible.</t>
        <dl newline="true"><dt>Poll requests have three variations:</dt>

	<dd>
          <dl newline="true" spacing="normal">

          <dt>Poll-Only</dt>
          <dd>In this scenario, a SET Recipient
          asks for the next set of events where no previous SET deliveries
          are acknowledged (such as in the initial poll request).</dd>
          <dt>Acknowledge-Only</dt>
          <dd>In this scenario, a SET
          Recipient sets the <tt>maxEvents</tt>
          value to <tt>0</tt> along with
          <tt>ack</tt> and
          <tt>setErrs</tt> members indicating the
          SET Recipient is acknowledging previously received SETs and
          does not want to receive any new SETs in response to the
          request. </dd>
          <dt>Combined Acknowledge and Poll</dt>
          <dd>In this scenario, a SET Recipient is both acknowledging previously
          received SETs using the <tt>ack</tt> and <tt>setErrs</tt> members
          and will wait for the next group of SETs in the SET Transmitters
          response.</dd>
        </dl></dd></dl>
        <section anchor="PollOnlyRequest" numbered="true" toc="default">
          <name>Poll-Only Request</name>
          <t>In the case where no SETs were received in a previous poll (see
	  <xref target="emptyPollResponse" format="default"/>), the SET Recipient simply
	  polls without acknowledgement parameters (<tt>ack</tt>
	  and <tt>setErrs</tt>).</t>
          <t keepWithNext="true">
	      The following is a non-normative example request made by a SET Recipient
	      that has no outstanding SETs to acknowledge and is polling
	      for available SETs at the endpoint
	      <tt>https://notify.idp.example.com/Events</tt>:
          </t>
          <figure anchor="pollInitRequest">
            <name>Example Initial Poll Request</name>


            <sourcecode type="http-message" name=""><![CDATA[
  POST /Events HTTP/1.1
  Host: notify.idp.example.com
  Content-Type: application/json

  {
   "returnImmediately": true
  }
]]></sourcecode>
          </figure>
          <t>A SET Recipient can poll using default parameter values by passing
	  an empty JSON object.</t>
          <t keepWithNext="true">The following is a non-normative example default poll request to the
	    endpoint <tt>https://notify.idp.example.com/Events</tt>:</t>
          <figure anchor="pollDefaultRequest">
            <name>Example Default Poll Request</name>
            <sourcecode name="" type="http-message"><![CDATA[
  POST /Events HTTP/1.1
  Host: notify.idp.example.com
  Content-Type: application/json

  {}
]]></sourcecode>
          </figure>
        </section>
        <section anchor="AckOnlyRequest" numbered="true" toc="default">
          <name>Acknowledge-Only Request</name>
          <t>In this variation, the SET Recipient acknowledges previously
	  received SETs and indicates it does not want to receive SETs in
	  response by setting the <tt>maxEvents</tt>
	  value to <tt>0</tt>.
	  This variation might be used, for instance, when a SET Recipient needs to
	  acknowledge received SETs independently (e.g., on separate threads)
	  from the process of receiving SETs.
          </t>
          <t>
	    If the poll needs to return immediately, then <tt>returnImmediately</tt>
	    <bcp14>MUST</bcp14> also be present with the value <tt>true</tt>.
	    If it is <tt>false</tt>, then a long poll will still occur
	    until an event is ready to be returned, even though no events will be returned.
          </t>
          <t keepWithNext="true">The following is a non-normative example poll request with acknowledgement
	    of SETs received (for example, as shown in
	    <xref target="pollResponse" format="default"/>):</t>
          <figure anchor="pollAckOnly">
            <name>Example Acknowledge-Only Request</name>
            <sourcecode name="" type="http-message"><![CDATA[
  POST /Events HTTP/1.1
  Host: notify.idp.example.com
  Content-Type: application/json

  {
    "ack": [
      "4d3559ec67504aaba65d40b0363faad8",
      "3d0c3cf797584bd193bd0fb1bd4e7d30"
    ],
    "maxEvents": 0,
    "returnImmediately": true
  }
]]></sourcecode>
          </figure>
        </section>
        <section anchor="pollAck" numbered="true" toc="default">
          <name>Poll with Acknowledgement</name>
          <t>This variation allows a recipient thread to simultaneously
	  acknowledge previously received SETs and wait for the next
	  group of SETs in a single request.</t>
          <t keepWithNext="true">The following is a non-normative example poll with acknowledgement
	    of the SETs received in <xref target="pollResponse" format="default"/>:</t>
          <figure anchor="pollGoodResponse">
            <name>Example Poll with Acknowledgement and No Errors</name>
            <sourcecode name="" type="http-message"><![CDATA[
  POST /Events HTTP/1.1
  Host: notify.idp.example.com
  Content-Type: application/json

  {
    "ack": [
      "4d3559ec67504aaba65d40b0363faad8",
      "3d0c3cf797584bd193bd0fb1bd4e7d30"
    ],
    "returnImmediately": false
  }
]]></sourcecode>
          </figure>
          <t>In the above acknowledgement, the SET Recipient has acknowledged
	  receipt of two SETs and has indicated it wants to wait until
	  the next SET is available.</t>
        </section>
        <section anchor="pollAckErr" numbered="true" toc="default">
          <name>Poll with Acknowledgement and Errors</name>
          <t>In the case where errors were detected in previously
	  delivered SETs, the SET Recipient <bcp14>MAY</bcp14> use the
	  <tt>setErrs</tt> member to communicate the errors
	  in the following poll request.
          </t>
          <t keepWithNext="true">The following is a non-normative example of a response
	    acknowledging one successfully received SET and one SET with an error
	    from the two SETs received in <xref target="pollResponse" format="default"/>:</t>
          <figure anchor="pollErrorResponse">
            <name>Example Poll Acknowledgement with Error</name>
            <sourcecode name="" type="http-message"><![CDATA[
  POST /Events HTTP/1.1
  Host: notify.idp.example.com
  Content-Language: en-US
  Content-Type: application/json

  {
    "ack": ["3d0c3cf797584bd193bd0fb1bd4e7d30"],
    "setErrs": {
      "4d3559ec67504aaba65d40b0363faad8": {
        "err": "authentication_failed",
        "description": "The SET could not be authenticated"
      }
    },
    "returnImmediately": true
  }
  ]]></sourcecode>
          </figure>
        </section>
      </section>
      <section anchor="pollGetAck" numbered="true" toc="default">
        <name>Poll Response</name>
        <t>In response to a valid poll request, the service provider <bcp14>MAY</bcp14>
	respond immediately if SETs are available to be delivered.
	If no SETs are available at the time of the request, the
	SET Transmitter <bcp14>SHALL</bcp14> delay responding until a SET is
	available or the timeout interval has elapsed unless the poll request parameter
	<tt>returnImmediately</tt> is present with the value <tt>true</tt>.
        </t>
        <t>As described in <xref target="pollResp" format="default"/>, a JSON document
	is returned containing members including
	<tt>sets</tt>, which <bcp14>SHALL</bcp14> contain zero or more
	SETs.</t>
        <t keepWithNext="true">The following is a non-normative example response to
	  the request shown in <xref target="pollRequest" format="default"/>. This example
	  shows two SETs being returned:</t>
        <figure anchor="pollResponse">
          <name>Example Poll Response</name>

          <sourcecode name="" type="http-message"><![CDATA[
HTTP/1.1 200 OK
Content-Type: application/json

{
 "sets":
  {
   "4d3559ec67504aaba65d40b0363faad8":
   "eyJhbGciOiJub25lIn0.
    eyJqdGkiOiI0ZDM1NTllYzY3NTA0YWFiYTY1ZDQwYjAzNjNmYWFkOCIsImlhdC
    I6MTQ1ODQ5NjQwNCwiaXNzIjoiaHR0cHM6Ly9zY2ltLmV4YW1wbGUuY29tIiwi
    YXVkIjpbImh0dHBzOi8vc2NpbS5leGFtcGxlLmNvbS9GZWVkcy85OGQ1MjQ2MW
    ZhNWJiYzg3OTU5M2I3NzU0IiwiaHR0cHM6Ly9zY2ltLmV4YW1wbGUuY29tL0Zl
    ZWRzLzVkNzYwNDUxNmIxZDA4NjQxZDc2NzZlZTciXSwiZXZlbnRzIjp7InVybj
    ppZXRmOnBhcmFtczpzY2ltOmV2ZW50OmNyZWF0ZSI6eyJyZWYiOiJodHRwczov
    L3NjaW0uZXhhbXBsZS5jb20vVXNlcnMvNDRmNjE0MmRmOTZiZDZhYjYxZTc1Mj
    FkOSIsImF0dHJpYnV0ZXMiOlsiaWQiLCJuYW1lIiwidXNlck5hbWUiLCJwYXNz
    d29yZCIsImVtYWlscyJdfX19.",
   "3d0c3cf797584bd193bd0fb1bd4e7d30":
   "eyJhbGciOiJub25lIn0.
    eyJqdGkiOiIzZDBjM2NmNzk3NTg0YmQxOTNiZDBmYjFiZDRlN2QzMCIsImlhdC
    I6MTQ1ODQ5NjAyNSwiaXNzIjoiaHR0cHM6Ly9zY2ltLmV4YW1wbGUuY29tIiwi
    YXVkIjpbImh0dHBzOi8vamh1Yi5leGFtcGxlLmNvbS9GZWVkcy85OGQ1MjQ2MW
    ZhNWJiYzg3OTU5M2I3NzU0IiwiaHR0cHM6Ly9qaHViLmV4YW1wbGUuY29tL0Zl
    ZWRzLzVkNzYwNDUxNmIxZDA4NjQxZDc2NzZlZTciXSwic3ViIjoiaHR0cHM6Ly
    9zY2ltLmV4YW1wbGUuY29tL1VzZXJzLzQ0ZjYxNDJkZjk2YmQ2YWI2MWU3NTIx
    ZDkiLCJldmVudHMiOnsidXJuOmlldGY6cGFyYW1zOnNjaW06ZXZlbnQ6cGFzc3
    dvcmRSZXNldCI6eyJpZCI6IjQ0ZjYxNDJkZjk2YmQ2YWI2MWU3NTIxZDkifSwi
    aHR0cHM6Ly9leGFtcGxlLmNvbS9zY2ltL2V2ZW50L3Bhc3N3b3JkUmVzZXRFeH
    QiOnsicmVzZXRBdHRlbXB0cyI6NX19fQ."
  }
}
]]></sourcecode>
        </figure>
        <t>In the above example, two SETs whose <tt>jti</tt> values
	are <tt>4d3559ec67504aaba65d40b0363faad8</tt>
	and <tt>3d0c3cf797584bd193bd0fb1bd4e7d30</tt>
	are delivered.</t>
        <t keepWithNext="true">The following is a non-normative example response to
	  the request shown in <xref target="PollOnlyRequest" format="default"/>, which indicates that no new
	  SETs or unacknowledged SETs are available:</t>
        <figure anchor="emptyPollResponse">
          <name>Example No SETs Poll Response</name>
          <sourcecode name="" type="http-message"><![CDATA[
  HTTP/1.1 200 OK
  Content-Type: application/json

  {
   "sets": {}
  }
]]></sourcecode>
        </figure>
        <t>Upon receiving the JSON document (e.g., as shown in <xref
        target="pollResponse" format="default"/>), the SET Recipient parses
        and verifies the received SETs and notifies the SET Transmitter of
        successfully received SETs and SETs with errors via the next poll
        request to the SET Transmitter, as described in Sections <xref
        target="pollAck" format="counter"/> and <xref target="pollAckErr"
        format="counter"/>.</t>
        <section anchor="PollErrorResponse" numbered="true" toc="default">
          <name>Poll Error Response</name>
          <t>In the event of a general HTTP error condition in the context of
                processing a poll request, the service provider responds with
                the applicable HTTP response status code, as defined in <xref target="RFC7231" sectionFormat="of" section="6"/>.</t>

          <t>Service providers <bcp14>MAY</bcp14> respond to any invalid poll request with an HTTP response
                status code of 400 (Bad Request) even when a more specific code might apply, for
                example, if the service provider deemed that a more specific code presented an
                information disclosure risk. When no more specific code might apply, the service
                provider <bcp14>SHALL</bcp14> respond to an invalid poll
	  request with an HTTP status code of 400.</t> 
          <t>
	      The response body for responses to invalid poll requests is left undefined,
	      and its contents <bcp14>SHOULD</bcp14> be ignored.
          </t>
          <t keepWithNext="true">
                    The following is a non-normative example of a response to an invalid poll request:
          </t>
          <figure>
            <name>Example Poll Error Response</name>
            <sourcecode name="" type="http-message"><![CDATA[
  HTTP/1.1 400 Bad Request
]]></sourcecode>
          </figure>
        </section>
      </section>
      <section anchor="errorResponse" numbered="true" toc="default">
        <name>Error Response Handling</name>
        <t>
	  If a SET is invalid,
	  error codes from the IANA "Security Event Token Error Codes"
	  registry established by <xref target="RFC8935" format="default"/>
	  are used in error responses.

	  As described in <xref target="RFC8935"
	  sectionFormat="of" section="2.3"/>, an error response is a JSON
	  object providing details about the error that includes the following
	  name/value pairs:
        </t>
        <dl newline="false" spacing="normal">
          <dt>err:</dt>
          <dd>
	      A value from the
	      IANA "Security Event Token Error Codes" registry
	      that identifies the error.
	    </dd>
          <dt>description:</dt>
          <dd>
	      A human-readable string that provides
	      additional diagnostic information.
	    </dd>
        </dl>
        <t>
	  When included as part of a batch of SETs, the above JSON is included
	  as part of the <tt>setErrs</tt> member, as
          defined in Sections <xref target="pollReq" format="counter"/> and
	  <xref target="pollAckErr" format="counter"/>. 
        </t>
        <t>
            When the SET Recipient includes one or more error responses in a request to
            the SET Transmitter, it must also include in the request a 
            <tt>Content-Language</tt> header field whose value indicates the
            language of the error descriptions included in the request.  The method of
            language selection in the case when the SET Recipient can provide error messages
            in multiple languages is out of scope for this specification.
        </t>
      </section>
    </section>
    <section anchor="aa" toc="default" numbered="true">
      <name>Authentication and Authorization</name>
      <t>The SET delivery method described in this specification is
      based upon HTTP over TLS <xref target="RFC2818" format="default"/> and standard
      HTTP authentication and authorization schemes, as per
      <xref target="RFC7235" format="default"/>.
      The TLS server certificate <bcp14>MUST</bcp14> be validated using DNS-ID <xref target="RFC6125" format="default"/>
      and/or DNS-Based Authentication of Named Entities (DANE) <xref target="RFC6698" format="default"/>.
      As per <xref target="RFC7235" sectionFormat="of" section="4.1"/>, a SET
      delivery endpoint <bcp14>SHALL</bcp14> indicate supported HTTP authentication
      schemes via the <tt>WWW-Authenticate</tt> header field
      when using HTTP authentication.
      </t>
      <t>
	Authorization for the eligibility to provide actionable SETs can be determined by
	using the identity of the SET Issuer,
	validating the identity of the SET Transmitter,
	or via other employed authentication methods.
	Likewise, the SET Transmitter may choose to validate the identity of the SET Recipient,
	perhaps using mutual TLS.
	Because SETs are
      not commands, SET Recipients are free to ignore SETs that
      are not of interest after acknowledging their receipt.</t>
    </section>
    <section anchor="Security" toc="default" numbered="true">
      <name>Security Considerations</name>
      <section anchor="payloadAuthentication" numbered="true" toc="default">
        <name>Authentication Using Signed SETs</name>
        <t>
	  JWS signed SETs can be
	  used (see <xref target="RFC7515" format="default"/> and <xref target="RFC8417" sectionFormat="of" section="5"/>)
	  to enable the SET Recipient
	  to validate that the SET Issuer is authorized to provide actionable SETs.
        </t>
      </section>

      <section anchor="HTTP" numbered="true" toc="default">
        <name>HTTP Considerations</name>
        <t>SET delivery depends on the use of the Hypertext Transfer Protocol and is thus
        subject to the security considerations of HTTP (<xref
	target="RFC7230" sectionFormat="of" section="9"/>) and its related specifications.</t>
      </section>
      <section anchor="Confidentiality" numbered="true" toc="default">
        <name>Confidentiality of SETs</name>
        <t>
	  SETs may contain sensitive information, including Personally
	  Identifiable Information (PII), or be distributed through third
	  parties.  In such cases, SET Transmitters and SET Recipients
	  <bcp14>MUST</bcp14> protect the confidentiality of the SET contents.
	  In some use cases, using TLS to secure the transmitted SETs will be
	  sufficient.  In other use cases, encrypting the SET as described in
	  JSON Web Encryption (JWE) <xref target="RFC7516" format="default"/> will also be required.
	  The Event delivery endpoint <bcp14>MUST</bcp14> support at least TLS
	  version 1.2 <xref target="RFC5246" format="default"/> and
	  <bcp14>SHOULD</bcp14> support the newest version of TLS that meets
	  its security requirements, which as of the time of this publication
	  is TLS 1.3 <xref target="RFC8446" format="default"/>.  The client
	  <bcp14>MUST</bcp14> perform a TLS/SSL server certificate check using
	  DNS-ID <xref target="RFC6125" format="default"/> and/or DANE <xref
	  target="RFC6698" format="default"/>.  How a SET Recipient determines
	  the expected service identity to match the SET Transmitter's server
	  certificate against is out of scope for this document.  The
	  implementation security considerations for TLS in "Recommendations
	  for Secure Use of Transport Layer Security (TLS) and Datagram
	  Transport Layer Security (DTLS)" <xref target="RFC7525"
	  format="default"/> <bcp14>MUST</bcp14> be followed.
        </t>
      </section>
      <section anchor="AT" numbered="true" toc="default">
        <name>Access Token Considerations</name>
        <t>
	  If HTTP Authentication is performed using OAuth access tokens <xref target="RFC6749" format="default"/>,
	  implementers <bcp14>MUST</bcp14> take into account the threats
        and countermeasures documented in <xref target="RFC7521"
	sectionFormat="of" section="8"/>.</t>
        <section anchor="bearerConsiderations" numbered="true" toc="default">
          <name>Bearer Token Considerations</name>

          <t>
	    Transmitting bearer tokens <xref target="RFC6750" format="default"/> using TLS helps prevent their interception.
          </t>
          <t>Bearer tokens <bcp14>SHOULD</bcp14> have a limited lifetime that can be determined
	  directly or indirectly (e.g., by checking with a validation service)
	  by the service provider. By expiring tokens, clients are forced to
	  obtain a new token (which usually involves re-authentication) for
	  continued authorized access. For example, in OAuth 2.0, a client <bcp14>MAY</bcp14> use
	  an OAuth refresh token to obtain a new bearer token after authenticating
	  to an authorization server, per <xref target="RFC6749" sectionFormat="of" section="6"/>.</t>
          <t>Implementations supporting OAuth bearer tokens need to factor in
	  security considerations of this authorization method <xref target="RFC7521" format="default"/>. Since security is only as good
	  as the weakest link, implementers also need to consider authentication
	  choices coupled with OAuth bearer tokens. The security considerations
	  of the default authentication method for OAuth bearer tokens, HTTP
	  Basic, are well documented in <xref target="RFC7617" format="default"/>; therefore, implementers
	  are encouraged to prefer stronger authentication methods.
          </t>
        </section>
      </section>
    </section>
    <section anchor="Privacy" numbered="true" toc="default">
      <name>Privacy Considerations</name>
      <t>SET Transmitters should attempt to deliver SETs that are
      targeted to the specific business and
      protocol needs of subscribers.</t>
      <t>When sharing personally identifiable information or information
      that is otherwise considered confidential to affected users, SET
      Transmitters and Recipients <bcp14>MUST</bcp14> have the appropriate legal agreements
      and user consent or terms of service in place.
      Furthermore, data that needs confidentiality protection <bcp14>MUST</bcp14> be encrypted,
      at least with TLS
      and sometimes also using JSON Web Encryption (JWE) <xref target="RFC7516" format="default"/>.
      </t>
      <t>
	In some cases, subject identifiers themselves may be considered sensitive
	information, such that their inclusion within a SET may be considered a violation
	of privacy.  SET Issuers and SET Transmitters should consider the ramifications of sharing a
	particular subject identifier with a SET Recipient (e.g., whether doing so could
	enable correlation and/or de-anonymization of data) and choose appropriate
	subject identifiers for their use cases.
      </t>
    </section>
    <section anchor="IANA" numbered="true" toc="default">
      <name>IANA Considerations</name>
      <t>
	This document has no IANA actions.
      </t>
    </section>
  </middle>
  <back>

    <references>
      <name>References</name>

      <references>


        <name>Normative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2818.xml"/>

      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.5246.xml"/>

      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6125.xml"/>

      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6698.xml"/>

      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7231.xml"/>


      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7515.xml"/>

      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7516.xml"/>

      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7519.xml"/>

      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7521.xml"/>


      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7525.xml"/>

      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>

      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8259.xml"/>

      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8417.xml"/>

      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.8446.xml"/>



<reference anchor="RFC8935" target="https://www.rfc-editor.org/info/rfc8935">
<front>
<title>Push-Based Security Event Token (SET) Delivery Using HTTP</title>

<author initials='A' surname='Backman' fullname='Annabelle Backman' role='editor'>
</author>

<author initials='M' surname='Jones' fullname='Michael Jones' role="editor">
</author>

<author initials='M' surname='Scurtescu' fullname='Marius Scurtescu'>
</author>

<author initials='M' surname='Ansari' fullname='Morteza Ansari'>
</author>

<author initials='A' surname='Nadalin' fullname='Anthony Nadalin'>
</author>

<date month='November' year='2020' />

</front>

<seriesInfo name="RFC" value="8935"/>
<seriesInfo name="DOI" value="10.17487/RFC8935"/>
</reference>

      </references>
      <references>
        <name>Informative References</name>
        <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6202.xml"/>


      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6749.xml"/>

      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.6750.xml"/>


      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7230.xml"/>

      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7235.xml"/>


      <xi:include href="https://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.7617.xml"/>


    </references>
    </references>
    <section anchor="Unencrypted" numbered="true" toc="default">
      <name>Unencrypted Transport Considerations</name>
      <t>
	Earlier versions of this specification made the use of TLS optional
	and described security and privacy considerations resulting from use
	of unencrypted HTTP as the underlying transport.
	When the working group decided to mandate usage of HTTP over TLS,
	it also decided to preserve the description of these considerations
	in a non-normative manner.
      </t>
      <t>
	The considerations for using unencrypted HTTP with this protocol
	are the same as those described in <xref
	target="RFC8935" sectionFormat="of"
	section="A"/>,
	and are therefore not repeated here.
      </t>
    </section>

    <section anchor="Acknowledgments" numbered="false" toc="default">
      <name>Acknowledgments</name>
      <t>
	The editors would like to thank the members of the SCIM Working Group,
	which began discussions of provisioning events starting with
	draft-hunt-scim-notify-00 in 2015.  We would like to thank <contact
	fullname="Phil Hunt"/> and the other authors of
	draft-ietf-secevent-delivery-02, upon which this specification is
	based.  We would like to thank the participants in the SecEvents
	Working Group for their contributions to this specification.
      </t>
      <t>
	Additionally, we would like to thank the following individuals for their reviews of this specification:
	<contact fullname="Roman Danyliw"/>,
	<contact fullname="Martin Duke"/>,
	<contact fullname="Benjamin Kaduk"/>,
	<contact fullname="Erik Kline"/>,
	<contact fullname="Murray Kucherawy"/>,
	<contact fullname="Warren Kumari"/>,
	<contact fullname="Barry Leiba"/>,
	<contact fullname="Mark Nottingham"/>,
	<contact fullname="Alvaro Retana"/>,
	<contact fullname="Yaron Sheffer"/>,
	<contact fullname="Valery Smyslov"/>,
	<contact fullname="Robert Sparks"/>,
	<contact fullname="Ã‰ric Vyncke"/>,
	and
	<contact fullname="Robert Wilton"/>.
      </t>
    </section>

  </back>
</rfc>
