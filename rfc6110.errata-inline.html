<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="robots" content="index,follow" />

        <link rel="icon" href="./css/images/rfc.png" type="image/png" />
        <link rel="shortcut icon" href="./css/images/rfc.png" type="image/png" />
        <title>rfc6110</title>
    
        <link rel="stylesheet" type="text/css" href="./css/errata-base.css"/>
        <link rel="stylesheet" type="text/css" href="./css/errata-color.css" title="Default: Basic Colors"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-monochrome.css" title="Monochrome"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-printer.css" title="Printer"/>

        <script src="./css/errata.js"></script>
    </head>
    <body>
        <div class='Verified-headnote-styling'>
<span style="font-weight: bold;">This is a purely informative rendering of an RFC that includes verified errata.  This rendering may not be used as a reference.</span>
<br/>
<br/>
The following 'Verified' errata have been incorporated in this document:
 <a href='#eid3362'>EID 3362</a>
</div>

        <pre>
Internet Engineering Task Force (IETF)                    L. Lhotka, Ed.
Request for Comments: 6110                                        CESNET
Category: Standards Track                                  February 2011
ISSN: 2070-1721


          Mapping YANG to Document Schema Definition Languages
                     and Validating NETCONF Content

Abstract

   This document specifies the mapping rules for translating YANG data
   models into Document Schema Definition Languages (DSDL), a
   coordinated set of XML schema languages standardized as ISO/IEC
   19757.  The following DSDL schema languages are addressed by the
   mapping: Regular Language for XML Next Generation (RELAX NG),
   Schematron, and Schematron and Document Schema Renaming Language
   (DSRL).  The mapping takes one or more YANG modules and produces a
   set of DSDL schemas for a selected target document type -- datastore
   content, Network Configuration Protocol (NETCONF) messages, etc.
   Procedures for schema-based validation of such documents are also
   discussed.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 5741.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc6110.

Copyright Notice

   Copyright (c) 2011 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1. Introduction ....................................................5
   2. Terminology and Notation ........................................6
      2.1. Glossary of New Terms ......................................9
   3. Objectives and Motivation ......................................10
   4. DSDL Schema Languages ..........................................11
      4.1. RELAX NG ..................................................11
      4.2. Schematron ................................................12
      4.3. Document Semantics Renaming Language (DSRL) ...............13
   5. Additional Annotations .........................................14
      5.1. Dublin Core Metadata Elements .............................14
      5.2. RELAX NG DTD Compatibility Annotations ....................14
      5.3. NETMOD-Specific Annotations ...............................15
   6. Overview of the Mapping ........................................16
   7. NETCONF Content Validation .....................................18
   8. Design Considerations ..........................................19
      8.1. Hybrid Schema .............................................19
      8.2. Modularity ................................................22
      8.3. Granularity ...............................................23
      8.4. Handling of XML Namespaces ................................24
   9. Mapping YANG Data Models to the Hybrid Schema ..................25
      9.1. Occurrence Rules for Data Nodes ...........................25
           9.1.1. Optional and Mandatory Nodes .......................26
           9.1.2. Implicit Nodes .....................................27
      9.2. Mapping YANG Groupings and Typedefs .......................28
           9.2.1. YANG Refinements and Augments ......................29
           9.2.2. Type Derivation Chains .............................32
      9.3. Translation of XPath Expressions ..........................35
      9.4. YANG Language Extensions ..................................36
   10. Mapping YANG Statements to the Hybrid Schema ..................37
      10.1. The &#x27;anyxml&#x27; Statement ...................................37
      10.2. The &#x27;argument&#x27; Statement .................................38

      10.3. The &#x27;augment&#x27; Statement ..................................39
      10.4. The &#x27;base&#x27; Statement .....................................39
      10.5. The &#x27;belongs-to&#x27; Statement ...............................39
      10.6. The &#x27;bit&#x27; Statement ......................................39
      10.7. The &#x27;case&#x27; Statement .....................................39
      10.8. The &#x27;choice&#x27; Statement ...................................39
      10.9. The &#x27;config&#x27; Statement ...................................40
      10.10. The &#x27;contact&#x27; Statement .................................40
      10.11. The &#x27;container&#x27; Statement ...............................40
      10.12. The &#x27;default&#x27; Statement .................................40
      10.13. The &#x27;description&#x27; Statement .............................42
      10.14. The &#x27;deviation&#x27; Statement ...............................42
      10.15. The &#x27;enum&#x27; Statement ....................................42
      10.16. The &#x27;error-app-tag&#x27; Statement ...........................42
      10.17. The &#x27;error-message&#x27; Statement ...........................42
      10.18. The &#x27;extension&#x27; Statement ...............................43
      10.19. The &#x27;feature&#x27; Statement .................................43
      10.20. The &#x27;grouping&#x27; Statement ................................43
      10.21. The &#x27;identity&#x27; Statement ................................43
      10.22. The &#x27;if-feature&#x27; Statement ..............................45
      10.23. The &#x27;import&#x27; Statement ..................................45
      10.24. The &#x27;include&#x27; Statement .................................45
      10.25. The &#x27;input&#x27; Statement ...................................46
      10.26. The &#x27;key&#x27; Statement .....................................46
      10.27. The &#x27;leaf&#x27; Statement ....................................46
      10.28. The &#x27;leaf-list&#x27; Statement ...............................46
      10.29. The &#x27;length&#x27; Statement ..................................47
      10.30. The &#x27;list&#x27; Statement ....................................47
      10.31. The &#x27;mandatory&#x27; Statement ...............................48
      10.32. The &#x27;max-elements&#x27; Statement ............................49
      10.33. The &#x27;min-elements&#x27; Statement ............................49
      10.34. The &#x27;module&#x27; Statement ..................................49
      10.35. The &#x27;must&#x27; Statement ....................................49
      10.36. The &#x27;namespace&#x27; Statement ...............................50
      10.37. The &#x27;notification&#x27; Statement ............................50
      10.38. The &#x27;ordered-by&#x27; Statement ..............................50
      10.39. The &#x27;organization&#x27; Statement ............................50
      10.40. The &#x27;output&#x27; Statement ..................................51
      10.41. The &#x27;path&#x27; Statement ....................................51
      10.42. The &#x27;pattern&#x27; Statement .................................51
      10.43. The &#x27;position&#x27; Statement ................................51
      10.44. The &#x27;prefix&#x27; Statement ..................................51
      10.45. The &#x27;presence&#x27; Statement ................................51
      10.46. The &#x27;range&#x27; Statement ...................................51
      10.47. The &#x27;reference&#x27; Statement ...............................51
      10.48. The &#x27;require-instance&#x27; Statement ........................51
      10.49. The &#x27;revision&#x27; Statement ................................52
      10.50. The &#x27;rpc&#x27; Statement .....................................52

      10.51. The &#x27;status&#x27; Statement ..................................52
      10.52. The &#x27;submodule&#x27; Statement ...............................52
      10.53. The &#x27;type&#x27; Statement ....................................53
           10.53.1. The &quot;empty&quot; Type .................................54
           10.53.2. The &quot;boolean&quot; Type ...............................54
           10.53.3. The &quot;binary&quot; Type ................................54
           10.53.4. The &quot;bits&quot; Type ..................................54
           10.53.5. The &quot;enumeration&quot; and &quot;union&quot; Types ..............54
           10.53.6. The &quot;identityref&quot; Type ...........................54
           10.53.7. The &quot;instance-identifier&quot; Type ...................55
           10.53.8. The &quot;leafref&quot; Type ...............................55
           10.53.9. The Numeric Types ................................55
           10.53.10. The &quot;string&quot; Type ...............................57
           10.53.11. Derived Types ...................................58
      10.54. The &#x27;typedef&#x27; Statement .................................59
      10.55. The &#x27;unique&#x27; Statement ..................................59
      10.56. The &#x27;units&#x27; Statement ...................................60
      10.57. The &#x27;uses&#x27; Statement ....................................60
      10.58. The &#x27;value&#x27; Statement ...................................60
      10.59. The &#x27;when&#x27; Statement ....................................60
      10.60. The &#x27;yang-version&#x27; Statement ............................60
      10.61. The &#x27;yin-element&#x27; Statement .............................61
   11. Mapping the Hybrid Schema to DSDL .............................61
      11.1. Generating RELAX NG Schemas for Various Document Types ...61
      11.2. Mapping Semantic Constraints to Schematron ...............62
           11.2.1. Constraints on Mandatory Choice ...................65
      11.3. Mapping Default Values to DSRL ...........................67
   12. Mapping NETMOD-Specific Annotations to DSDL Schema Languages ..71
      12.1. The @nma:config Annotation ...............................71
      12.2. The @nma:default Annotation ..............................71
      12.3. The &lt;nma:error-app-tag&gt; Annotation .......................71
      12.4. The &lt;nma:error-message&gt; Annotation .......................71
      12.5. The @if-feature Annotation ...............................71
      12.6. The @nma:implicit Annotation .............................72
      12.7. The &lt;nma:instance-identifier&gt; Annotation .................72
      12.8. The @nma:key Annotation ..................................72
      12.9. The @nma:leaf-list Annotation ............................72
      12.10. The @nma:leafref Annotation .............................73
      12.11. The @nma:min-elements Annotation ........................73
      12.12. The @nma:max-elements Annotation ........................73
      12.13. The &lt;nma:must&gt; Annotation ...............................73
      12.14. The &lt;nma:ordered-by&gt; Annotation .........................74
      12.15. The &lt;nma:status&gt; Annotation .............................74
      12.16. The @nma:unique Annotation ..............................74
      12.17. The @nma:when Annotation ................................74
   13. IANA Considerations ...........................................75
   14. Security Considerations .......................................75
   15. Contributors ..................................................75

   16. Acknowledgments ...............................................76
   17. References ....................................................76
      17.1. Normative References .....................................76
      17.2. Informative References ...................................77
   Appendix A. RELAX NG Schema for NETMOD-Specific Annotations .......79
   Appendix B. Schema-Independent Library ............................84
   Appendix C. Mapping DHCP Data Model - A Complete Example ..........85
      C.1. Input YANG Module .........................................85
      C.2. Hybrid Schema .............................................88
      C.3. Final DSDL Schemas  .......................................93
           C.3.1. Main RELAX NG Schema for &lt;nc:get&gt; Reply ............93
           C.3.2. RELAX NG Schema - Global Named Pattern
                  Definitions ........................................95
           C.3.3. Schematron Schema for &lt;nc:get&gt; Reply ...............98
           C.3.4. DSRL Schema for &lt;nc:get&gt; Reply .....................99

1.  Introduction

   The NETCONF Working Group has completed a base protocol used for
   configuration management [RFC4741].  This base specification defines
   protocol bindings and an XML container syntax for configuration and
   management operations, but does not include a data modeling language
   or accompanying rules for how to model configuration and state
   information carried by NETCONF.  The IETF Operations Area has a long
   tradition of defining data for Simple Network Management Protocol
   (SNMP) Management Information Bases (MIB) modules [RFC1157] using the
   Structure of Management Information (SMI) language [RFC2578] to model
   its data.  While this specific modeling approach has a number of
   well-understood problems, most of the data modeling features provided
   by SMI are still considered extremely important.  Simply modeling the
   valid syntax without the additional semantic relationships has caused
   significant interoperability problems in the past.

   The NETCONF community concluded that a data modeling framework is
   needed to support ongoing development of IETF and vendor-defined
   management information modules.  The NETMOD Working Group was
   chartered to design a modeling language defining the semantics of
   operational data, configuration data, event notifications, and
   operations, with focus on &quot;human-friendliness&quot;, i.e., readability and
   ease of use.  The result is the YANG data modeling language
   [RFC6020], which now serves for the normative description of NETCONF
   data models.

   Since NETCONF uses XML for encoding its messages, it is natural to
   express the constraints on NETCONF content using standard XML schema
   languages.  For this purpose, the NETMOD WG selected the Document
   Schema Definition Languages (DSDL) that is being standardized as
   ISO/IEC 19757 [DSDL].  The DSDL framework comprises a set of XML

   schema languages that address grammar rules, semantic constraints,
   and other data modeling aspects, but also, and more importantly, do
   it in a coordinated and consistent way.  While it is true that some
   DSDL parts have not been standardized yet and are still work in
   progress, the three parts that the YANG-to-DSDL mapping relies upon
   -- Regular Language for XML Next Generation (RELAX NG), Schematron
   and Document Schema Renaming Language (DSRL) -- already have the
   status of an ISO/ IEC International Standard and are supported in a
   number of software tools.

   This document contains a specification of a mapping that translates
   YANG data models to XML schemas utilizing a subset of the DSDL schema
   languages.  The mapping procedure is divided into two steps: In the
   first step, the structure of the data tree, signatures of remote
   procedure call (RPC) operations, and notifications are expressed as
   the so-called &quot;hybrid schema&quot; -- a single RELAX NG schema with
   annotations representing additional data model information (metadata,
   documentation, semantic constraints, default values, etc.).  The
   second step then generates a coordinated set of DSDL schemas that can
   be used for validating specific XML documents such as client
   requests, server responses or notifications, perhaps also taking into
   account additional context such as active capabilities or features.

2.  Terminology and Notation

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [RFC2119].

   The following terms are defined in [RFC4741]:

   o  client

   o  datastore

   o  message

   o  operation

   o  server

   The following terms are defined in [RFC6020]:

   o  augment

   o  base type

   o  built-in type

   o  configuration data

   o  container

   o  data model

   o  data node

   o  data tree

   o  derived type

   o  device deviation

   o  extension

   o  feature

   o  grouping

   o  instance identifier

   o  leaf-list

   o  list

   o  mandatory node

   o  module

   o  RPC

   o  RPC operation

   o  schema node

   o  schema tree

   o  state data

   o  submodule

   o  top-level data node

   o  uses

   The following terms are defined in [XML-INFOSET]:

   o  attribute

   o  document

   o  document element

   o  document type declaration (DTD)

   o  element

   o  information set

   o  namespace

   In the text, the following typographic conventions are used:

   o  YANG statement keywords are delimited by single quotes.

   o  XML element names are delimited by &quot;&lt;&quot; and &quot;&gt;&quot; characters.

   o  Names of XML attributes are prefixed by the &quot;@&quot; character.

   o  Other literal values are delimited by double quotes.

   XML element names are always written with explicit namespace prefixes
   corresponding to the following XML vocabularies:

   &quot;a&quot;  DTD compatibility annotations [RNG-DTD];

   &quot;dc&quot;  Dublin Core metadata elements [RFC5013];

   &quot;dsrl&quot;  Document Semantics Renaming Language [DSRL];

   &quot;en&quot;  NETCONF event notifications [RFC5277];

   &quot;nc&quot;  NETCONF protocol [RFC4741];

   &quot;nma&quot;  NETMOD-specific schema annotations (see Section 5.3);

   &quot;nmf&quot;  NETMOD-specific XML Path Language (XPath) extension functions
      (see Section 12.7);

   &quot;rng&quot;  RELAX NG [RNG];

   &quot;sch&quot;  ISO Schematron [Schematron];

   &quot;xsd&quot;  W3C XML Schema [XSD].

   The following table shows the mapping of these prefixes to namespace
   URIs.

     +--------+-----------------------------------------------------+
     | Prefix | Namespace URI                                       |
     +--------+-----------------------------------------------------+
     | a      | http://relaxng.org/ns/compatibility/annotations/1.0 |
     |        |                                                     |
     | dc     | http://purl.org/dc/terms                            |
     |        |                                                     |
     | dsrl   | http://purl.oclc.org/dsdl/dsrl                      |
     |        |                                                     |
     | en     | urn:ietf:params:xml:ns:netconf:notification:1.0     |
     |        |                                                     |
     | nc     | urn:ietf:params:xml:ns:netconf:base:1.0             |
     |        |                                                     |
     | nma    | urn:ietf:params:xml:ns:netmod:dsdl-annotations:1    |
     |        |                                                     |
     | nmf    | urn:ietf:params:xml:ns:netmod:xpath-extensions:1    |
     |        |                                                     |
     | rng    | http://relaxng.org/ns/structure/1.0                 |
     |        |                                                     |
     | sch    | http://purl.oclc.org/dsdl/schematron                |
     |        |                                                     |
     | xsd    | http://www.w3.org/2001/XMLSchema                    |
     +--------+-----------------------------------------------------+

          Table 1: Used namespace prefixes and corresponding URIs

2.1.  Glossary of New Terms

   o  ancestor data type: Any data type from which a given data type is
      (transitively) derived.

   o  ancestor built-in data type: The built-in data type that is at the
      start of the type derivation chain for a given data type.

   o  hybrid schema: A RELAX NG schema with annotations, which embodies
      the same information as the source YANG module(s).  See
      Section 8.1 for details.

   o  implicit node: A data node that, if it is not instantiated in a
      data tree, may be added to the information set of that data tree
      (configuration, RPC input or output, notification) without
      changing the semantics of the data tree.

3.  Objectives and Motivation

   The main objective of this work is to complement YANG as a data
   modeling language with validation capabilities of DSDL schema
   languages, namely RELAX NG, Schematron, and DSRL.  This document
   describes the correspondence between grammatical, semantic, and data
   type constraints expressed in YANG and equivalent DSDL patterns and
   rules.  The ultimate goal is to be able to capture all substantial
   information contained in YANG modules and express it in DSDL schemas.
   While the mapping from YANG to DSDL described in this document may in
   principle be invertible, the inverse mapping from DSDL to YANG is
   beyond the scope of this document.

   XML-based information models and XML-encoded data appear in several
   different forms in various phases of YANG data modeling and NETCONF
   workflow -- configuration datastore contents, RPC requests and
   replies, and notifications.  Moreover, RPC operations are
   characterized by an inherent diversity resulting from selective
   availability of capabilities and features.  YANG modules can also
   define new RPC operations.  The mapping should be able to accommodate
   this variability and generate schemas that are specifically tailored
   to a particular situation and thus considerably more effective for
   validation than generic all-encompassing schemas.

   In order to cope with this variability, we assume that the DSDL
   schemas will be generated on demand for a particular purpose from the
   available collection of YANG modules and their lifetime will be
   relatively short.  In other words, we don&#x27;t envision that any
   collection of DSDL schemas will be created and maintained over an
   extended period of time in parallel to YANG modules.

   The generated schemas are primarily intended as input to existing XML
   schema validators and other off-the-shelf tools.  However, the
   schemas may also be perused by developers and users as a formal
   representation of constraints on a particular XML-encoded data
   object.  Consequently, our secondary goal is to keep the schemas as
   readable as possible.  To this end, the complexity of the mapping is
   distributed into two steps:

   1.  The first step maps one or more YANG modules to the so-called
       hybrid schema, which is a single RELAX NG schema that describes
       grammatical constraints for the main data tree as well as for RPC
       operations and notifications.  Semantic constraints and other
       information appearing in the input YANG modules is recorded in
       the hybrid schema in the form of foreign namespace annotations.
       The output of the first step can thus be considered a virtually
       complete equivalent of the input YANG modules.  It cannot,
       however, be directly used for any validation.

   2.  In the second step, the hybrid schema from step 1 is transformed
       further to a coordinated set of fully conformant DSDL schemas
       containing constraints for a particular data object and a
       specific situation.  The DSDL schemas are intended mainly for
       machine validation using off-the-shelf tools.

4.  DSDL Schema Languages

   Document Schema Definition Languages (DSDL) is a framework of schema
   languages that is being developed as the International Standard ISO/
   IEC 19757 [DSDL].  Unlike other approaches to XML document
   validation, most notably W3C XML Schema Definition (XSD) [XSD], the
   DSDL framework adheres to the principle of &quot;small languages&quot;: each of
   the DSDL constituents is a stand-alone schema language with a
   relatively narrow purpose and focus.  Together, these schema
   languages may be used in a coordinated way to accomplish various
   validation tasks.

   The mapping described in this document uses three of the DSDL schema
   languages, namely RELAX NG [RNG], Schematron [Schematron], and DSRL
   [DSRL].

4.1.  RELAX NG

   RELAX NG (pronounced &quot;relaxing&quot;) is an XML schema language for
   grammar-based validation and Part 2 of the ISO/IEC DSDL family of
   standards [RNG].  Like XSD, it is able to describe constraints on the
   structure and contents of XML documents.  However, unlike the DTD
   [XML] and XSD schema languages, RELAX NG intentionally avoids any
   infoset augmentation such as defining default values.  In the DSDL
   architecture, the particular task of defining and applying default
   values is delegated to another schema language, DSRL (see
   Section 4.3).

   As its base data type library, RELAX NG uses the W3C XML Schema
   Datatypes [XSD-D]; but unlike XSD, other data type libraries may be
   used along with it or even replace it if necessary.

   RELAX NG is very liberal in accepting annotations from other
   namespaces.  With a few exceptions, such annotations may be placed
   anywhere in the schema and need no encapsulating elements such as
   &lt;xsd:annotation&gt; in XSD.

   RELAX NG schemas can be represented in two equivalent syntaxes: XML
   and compact.  The compact syntax is described in Annex C of the RELAX
   NG specification [RNG-CS], which was added to the standard in 2006
   (Amendment 1).  Automatic bidirectional conversions between the two
   syntaxes can be accomplished using several tools, for example, Trang
   [Trang].

   For its terseness and readability, the compact syntax is often the
   preferred form for publishing RELAX NG schemas, whereas validators
   and other software tools usually work with the XML syntax.  However,
   the compact syntax has two drawbacks:

   o  External annotations make the compact syntax schema considerably
      less readable.  While in the XML syntax the annotating elements
      and attributes are represented in a simple and uniform way (XML
      elements and attributes from foreign namespaces), the compact
      syntax uses as many as four different syntactic constructs:
      documentation, grammar, initial, and following annotations.
      Therefore, the impact of annotations on readability is often much
      stronger for the compact syntax than it is for the XML syntax.

   o  In a computer program, it is more difficult to generate the
      compact syntax than the XML syntax.  While a number of software
      libraries exist that make it easy to create an XML tree in the
      memory and then serialize it, no such aid is available for the
      compact syntax.

   For these reasons, the mapping specification in this document uses
   exclusively the XML syntax.  Where appropriate, though, the schemas
   resulting from the translation MAY be presented in the equivalent
   compact syntax.

   RELAX NG elements are qualified with the namespace URI
   &quot;http://relaxng.org/ns/structure/1.0&quot;.  The namespace of the XSD data
   type library is &quot;http://www.w3.org/2001/XMLSchema-datatypes&quot;.

4.2.  Schematron

   Schematron is Part 3 of DSDL that reached the status of a full ISO/
   IEC standard in 2006 [Schematron].  In contrast to the traditional
   schema languages such as DTD, XSD, or RELAX NG, which are based on
   the concept of a formal grammar, Schematron utilizes a rule-based
   approach.  Its rules may specify arbitrary conditions involving data
   from different parts of an XML document.  Each rule consists of three
   essential components:

   o  context - an XPath expression that defines the set of locations
      where the rule is to be applied;

   o  assert or report condition - another XPath expression that is
      evaluated relative to the location matched by the context
      expression;

   o  human-readable message that is displayed when the assert condition
      is false or report condition is true.

   The difference between the assert and report condition is that the
   former is positive in that it states a condition that a valid
   document has to satisfy, whereas the latter specifies an error
   condition.

   Schematron draws most of its expressive power from XPath [XPath] and
   Extensible Stylesheet Language Transformations (XSLT) [XSLT].  ISO
   Schematron allows for dynamic query language binding so that the
   following XML query languages can be used: STX, XSLT 1.0, XSLT 1.1,
   EXSLT, XSLT 2.0, XPath 1.0, XPath 2.0, and XQuery 1.0 (this list may
   be extended in the future).

   Human-readable error messages are another feature that sets
   Schematron apart from other common schema languages.  The messages
   may even contain XPath expressions that are evaluated in the actual
   context and thus refer to information items in the XML document being
   validated.

   Another feature of Schematron that is used by the mapping are
   abstract patterns.  These work essentially as macros and may also
   contain parameters which are supplied when the abstract pattern is
   used.

   Schematron elements are qualified with namespace URI
   &quot;http://purl.oclc.org/dsdl/schematron&quot;.

4.3.  Document Semantics Renaming Language (DSRL)

   DSRL (pronounced &quot;disrule&quot;) is Part 8 of DSDL that reached the status
   of a full ISO/IEC standard in 2008 [DSRL].  Unlike RELAX NG and
   Schematron, DSRL is allowed to modify XML information set of the
   validated document.  While DSRL is primarily intended for renaming
   XML elements and attributes, it can also define default values for
   XML attributes and default contents for XML elements or subtrees so
   that the default contents are inserted if they are missing in the
   validated documents.  The latter feature is used by the YANG-to-DSDL
   mapping for representing YANG default contents consisting of leaf
   nodes with default values and their ancestor non-presence containers.

   DSRL elements are qualified with namespace URI
   &quot;http://purl.oclc.org/dsdl/dsrl&quot;.

5.  Additional Annotations

   Besides the DSDL schema languages, the mapping also uses three sets
   of annotations that are added as foreign-namespace attributes and
   elements to RELAX NG schemas.

   Two of the annotation sets -- Dublin Core elements and DTD
   compatibility annotations -- are standard vocabularies for
   representing metadata and documentation, respectively.  Although
   these data model items are not used for formal validation, they quite
   often carry important information for data model implementers.
   Therefore, they SHOULD be included in the hybrid schema and MAY also
   appear in the final validation schemas.

   The third set are NETMOD-specific annotations.  They are specifically
   designed for the hybrid schema and convey semantic constraints and
   other information that cannot be expressed directly in RELAX NG.  In
   the second mapping step, these annotations are converted to
   Schematron and DSRL rules.

5.1.  Dublin Core Metadata Elements

   Dublin Core is a system of metadata elements that was originally
   created for describing metadata of World Wide Web resources in order
   to facilitate their automated lookup.  Later it was accepted as a
   standard for describing metadata of arbitrary resources.  This
   specification uses the definition from [RFC5013].

   Dublin Core elements are qualified with namespace URI
   &quot;http://purl.org/dc/terms&quot;.

5.2.  RELAX NG DTD Compatibility Annotations

   DTD compatibility annotations are a part of the RELAX NG DTD
   Compatibility specification [RNG-DTD].  YANG-to-DSDL mapping uses
   only the &lt;a:documentation&gt; annotation for representing YANG
   &#x27;description&#x27; and &#x27;reference&#x27; texts.

   Note that there is no intention to make the resulting schemas DTD-
   compatible, the main reason for using these annotations is technical:
   they are well supported and adequately formatted by several RELAX NG
   tools.

   DTD compatibility annotations are qualified with namespace URI
   &quot;http://relaxng.org/ns/compatibility/annotations/1.0&quot;.

5.3.  NETMOD-Specific Annotations

   NETMOD-specific annotations are XML elements and attributes that are
   qualified with the namespace URI
   &quot;urn:ietf:params:xml:ns:netmod:dsdl-annotations:1&quot; and that appear in
   various locations of the hybrid schema.  YANG statements are mapped
   to these annotations in a straightforward way.  In most cases, the
   annotation attributes and elements have the same name as the
   corresponding YANG statement.

   Table 2 lists, alphabetically, the names of NETMOD-specific
   annotation attributes (prefixed with &quot;@&quot;) and elements (in angle
   brackets) along with a reference to the section where their use is
   described.  Appendix A contains a RELAX NG schema for this annotation
   vocabulary.

         +---------------------------+--------------------+------+
         | annotation                | section            | note |
         +---------------------------+--------------------+------+
         | @nma:config               | 10.9               |      |
         |                           |                    |      |
         | &lt;nma:data&gt;                | 8.1                | 4    |
         |                           |                    |      |
         | @nma:default              | 10.12              |      |
         |                           |                    |      |
         | &lt;nma:error-app-tag&gt;       | 10.16              | 1    |
         |                           |                    |      |
         | &lt;nma:error-message&gt;       | 10.17              | 1    |
         |                           |                    |      |
         | @nma:if-feature           | 10.22              |      |
         |                           |                    |      |
         | @nma:implicit             | 10.11, 10.7, 10.12 |      |
         |                           |                    |      |
         | &lt;nma:input&gt;               | 8.1                | 4    |
         |                           |                    |      |
         | &lt;nma:instance-identifier&gt; | 10.53.7            | 2    |
         |                           |                    |      |
         | @nma:key                  | 10.26              |      |
         |                           |                    |      |
         | @nma:leaf-list            | 10.28              |      |
         |                           |                    |      |
         | @nma:leafref              | 10.53.8            |      |
         |                           |                    |      |
         | @nma:mandatory            | 10.8               |      |
         |                           |                    |      |
         | @nma:max-elements         | 10.28              |      |
         |                           |                    |      |
         | @nma:min-elements         | 10.28              |      |

         |                           |                    |      |
         | @nma:module               | 10.34              |      |
         |                           |                    |      |
         | &lt;nma:must&gt;                | 10.35              | 3    |
         |                           |                    |      |
         | &lt;nma:notification&gt;        | 8.1                | 4    |
         |                           |                    |      |
         | &lt;nma:notifications&gt;       | 8.1                | 4    |
         |                           |                    |      |
         | @nma:ordered-by           | 10.38              |      |
         | &lt;nma:output&gt;              | 8.1                | 4    |
         |                           |                    |      |
         | &lt;nma:rpc&gt;                 | 8.1                | 4    |
         |                           |                    |      |
         | &lt;nma:rpcs&gt;                | 8.1                | 4    |
         |                           |                    |      |
         | @nma:status               | 10.51              |      |
         |                           |                    |      |
         | @nma:unique               | 10.55              |      |
         |                           |                    |      |
         | @nma:units                | 10.56              |      |
         |                           |                    |      |
         | @nma:when                 | 10.59              |      |
         +---------------------------+--------------------+------+

                   Table 2: NETMOD-specific annotations

   Notes:

   1.  Appears only as a subelement of &lt;nma:must&gt;.

   2.  Has an optional attribute @require-instance.

   3.  Has a mandatory attribute @assert and two optional subelements
       &lt;nma:error-app-tag&gt; and &lt;nma:error-message&gt;.

   4.  Marker element in the hybrid schema.

6.  Overview of the Mapping

   This section gives an overview of the YANG-to-DSDL mapping, its
   inputs and outputs.  Figure 1 presents an overall structure of the
   mapping:

                    +----------------+
                    | YANG module(s) |
                    +----------------+
                            |
                            |T
                            |
          +------------------------------------+
          |           hybrid schema            |
          +------------------------------------+
               /       |           |       \
              /        |           |        \
           Tg/       Tr|           |Tn       \
            /          |           |          \
      +---------+   +-----+    +-------+    +------+
      |get reply|   | rpc |    | notif |    | .... |
      +---------+   +-----+    +-------+    +------+

                    Figure 1: Structure of the mapping

   The mapping procedure is divided into two steps:

   1.  Transformation T in the first step maps one or more YANG modules
       to the hybrid schema (see Section 8.1).  Constraints that cannot
       be expressed directly in RELAX NG (list key definitions, &#x27;must&#x27;
       statements, etc.) and various documentation texts are recorded in
       the schema as foreign-namespace annotations.

   2.  In the second step, the hybrid schema may be transformed in
       multiple ways to a coordinated set of DSDL schemas that can be
       used for validating a particular data object in a specific
       context.  Figure 1 shows three simple possibilities as examples.
       In the process, appropriate parts of the hybrid schema are
       extracted and specific annotations transformed to equivalent, but
       usually more complex, Schematron patterns, DSRL element maps,
       etc.

   An implementation of the mapping algorithm MUST accept one or more
   valid YANG modules as its input.  It is important to be able to
   process multiple YANG modules together since multiple modules may be
   negotiated for a NETCONF session and the contents of the
   configuration datastore is then obtained as the union of data trees
   specified by the individual modules, which may also lead to multiple
   root nodes of the datastore hierarchy.  In addition, the input
   modules may be further coupled by the &#x27;augment&#x27; statement in which
   one module augments the data tree of another module.

   It is also assumed that the algorithm has access, perhaps on demand,
   to all YANG modules that the input modules import (directly or
   transitively).

   Other information contained in input YANG modules, such as semantic
   constraints and default values, is recorded in the hybrid schema as
   annotations -- XML attributes or elements qualified with the
   namespace URI &quot;urn:ietf:params:xml:ns:netmod:dsdl-annotations:1&quot;.
   Metadata describing the YANG modules are mapped to Dublin Core
   annotations elements (Section 5.1).  Finally, documentation strings
   are mapped to &lt;a:documentation&gt; elements belonging to the DTD
   compatibility vocabulary (Section 5.2).

   The output of the second step is a coordinated set of three DSDL
   schemas corresponding to a specific data object and context:

   o  RELAX NG schema describing the grammatical and data type
      constraints;

   o  Schematron schema expressing other constraints such as uniqueness
      of list keys or user-specified semantic rules;

   o  DSRL schema containing the specification of default contents.

7.  NETCONF Content Validation

   This section describes how the schemas generated by the YANG-to-DSDL
   mapping are supposed to be applied for validating XML instance
   documents such as the contents of a datastore or various NETCONF
   messages.

   The validation proceeds in the following steps, which are also
   illustrated in Figure 2:

   1.  The XML instance document is checked for grammatical and data
       type validity using the RELAX NG schema.

   2.  Default values for leaf nodes have to be applied and their
       ancestor containers added where necessary.  It is important to
       add the implicit nodes before the next validation step because
       YANG specification [RFC6020] requires that the data tree against
       which XPath expressions are evaluated already has all defaults
       filled-in.  Note that this step modifies the information set of
       the validated XML document.

   3.  The semantic constraints are checked using the Schematron schema.

         +----------+                        +----------+
         |          |                        |   XML    |
         |   XML    |                        | document |
         | document |-----------o-----------&gt;|   with   |
         |          |           ^            | defaults |
         |          |           |            |          |
         +----------+           |            +----------+
              ^                 | filling in       ^
              | grammar,        | defaults         | semantic
              | data types       |                  | constraints
              |                 |                  |
         +----------+       +--------+       +------------+
         | RELAX NG |       |  DSRL  |       | Schematron |
         |  schema  |       | schema |       |   schema   |
         +----------+       +--------+       +------------+

               Figure 2: Outline of the validation procedure

8.  Design Considerations

   YANG data models could, in principle, be mapped to the DSDL schemas
   in a number of ways.  The mapping procedure described in this
   document uses several specific design decisions that are discussed in
   the following subsections.

8.1.  Hybrid Schema

   As was explained in Section 6, the first step of the mapping produces
   an intermediate document -- the hybrid schema, which specifies all
   constraints for the entire data model using the RELAX NG syntax and
   additional annotations.  In cannot be directly used for validation --
   as a matter of fact, it is not even a valid RELAX NG schema because
   it contains multiple schemas demarcated by special annotation
   elements.

   Every input YANG module corresponds to exactly one embedded grammar
   in the hybrid schema.  This separation of input YANG modules allows
   each embedded grammar to include named pattern definitions into its
   own namespace, which is important for mapping YANG groupings (see
   Section 9.2 for additional details).

   In addition to grammatical and data type constraints, YANG modules
   provide other important information that cannot be expressed in a
   RELAX NG schema: semantic constraints, default values, metadata,
   documentation, and so on.  Such information items are represented in

   the hybrid schema as XML attributes and elements belonging to the
   namespace with the following URI:
   &quot;urn:ietf:params:xml:ns:netmod:dsdl-annotations:1&quot;.  A complete list
   of these annotations is given in Section 5.3, detailed rules about
   their use are then contained in the following sections.

   YANG modules define data models not only for configuration and state
   data but also for (multiple) RPC operations [RFC4741] and/or event
   notifications [RFC5277].  In order to be able to capture all three
   types of data models in one schema document, the hybrid schema uses
   special markers that enclose sub-schemas for configuration and state
   data, individual RPC operations (both input and output part) and
   individual notifications.

   The markers are the following XML elements in the namespace of
   NETMOD-specific annotations (URI
   urn:ietf:params:xml:ns:netmod:dsdl-annotations:1):

       +-------------------+---------------------------------------+
       | Element name      | Role                                  |
       +-------------------+---------------------------------------+
       | nma:data          | encloses configuration and state data |
       |                   |                                       |
       | nma:rpcs          | encloses all RPC operations           |
       |                   |                                       |
       | nma:rpc           | encloses an individual RPC operation  |
       |                   |                                       |
       | nma:input         | encloses an RPC request               |
       |                   |                                       |
       | nma:output        | encloses an RPC reply                 |
       |                   |                                       |
       | nma:notifications | encloses all notifications            |
       |                   |                                       |
       | nma:notification  | encloses an individual notification   |
       +-------------------+---------------------------------------+

               Table 3: Marker elements in the hybrid schema

   For example, consider a data model formed by two YANG modules
   &quot;example-a&quot; and &quot;example-b&quot; that define nodes in the namespaces
   &quot;http://example.com/ns/example-a&quot; and
   &quot;http://example.com/ns/example-b&quot;.  Module &quot;example-a&quot; defines
   configuration/state data, RPC methods and notifications, whereas
   &quot;example-b&quot; defines only configuration/state data.  The hybrid schema
   can then be schematically represented as follows:

  &lt;grammar xmlns=&quot;http://relaxng.org/ns/structure/1.0&quot;
           xmlns:nma=&quot;urn:ietf:params:xml:ns:netmod:dsdl-annotations:1&quot;
           xmlns:exa=&quot;http://example.com/ns/example-a&quot;
           xmlns:exb=&quot;http://example.com/ns/example-b&quot;
           datatypeLibrary=&quot;http://www.w3.org/2001/XMLSchema-datatypes&quot;&gt;
    &lt;start&gt;
      &lt;grammar nma:module=&quot;example-a&quot;
               ns=&quot;http://example.com/ns/example-a&quot;&gt;
        &lt;start&gt;
          &lt;nma:data&gt;
            ...configuration and state data defined in &quot;example-a&quot;...
          &lt;/nma:data&gt;
          &lt;nma:rpcs&gt;
            &lt;nma:rpc&gt;
              &lt;nma:input&gt;
                &lt;element name=&quot;exa:myrpc&quot;&gt;
                  ...
                &lt;/element&gt;
              &lt;/nma:input&gt;
              &lt;nma:output&gt;
                ...
              &lt;/nma:output&gt;
            &lt;/nma:rpc&gt;
            ...
          &lt;/nma:rpcs&gt;
          &lt;nma:notifications&gt;
            &lt;nma:notification&gt;
              &lt;element name=&quot;exa:mynotif&quot;&gt;
                ...
              &lt;/element&gt;
            &lt;/nma:notification&gt;
            ...
          &lt;/nma:notifications&gt;
        &lt;/start&gt;
        ...local named pattern definitions of example-a...
      &lt;/grammar&gt;
      &lt;grammar nma:module=&quot;example-b&quot;
               ns=&quot;http://example.com/ns/example-a&quot;&gt;
        &lt;start&gt;
          &lt;nma:data&gt;
            ...configuration and state data defined in &quot;example-b&quot;...
          &lt;/nma:data&gt;
          &lt;nma:rpcs/&gt;
          &lt;nma:notifications/&gt;
        &lt;/start&gt;
        ...local named pattern definitions of example-b...
      &lt;/grammar&gt;
    &lt;/start&gt;

    ...global named pattern definitions...
  &lt;/grammar&gt;

   A complete hybrid schema for the data model of a DHCP server is given
   in Appendix C.2.

8.2.  Modularity

   Both YANG and RELAX NG offer means for modularity, i.e., for
   splitting the contents of a full schema into separate modules and
   combining or reusing them in various ways.  However, the approaches
   taken by YANG and RELAX NG differ.  Modularity in RELAX NG is
   suitable for ad hoc combinations of a small number of schemas whereas
   YANG assumes a large set of modules similar to SNMP MIB modules.  The
   following differences are important:

   o  In YANG, whenever module A imports module B, it gets access to the
      definitions (groupings and typedefs) appearing at the top level of
      module B.  However, no part of data tree from module B is imported
      along with it.  In contrast, the &lt;rng:include&gt; pattern in RELAX NG
      imports both definitions of named patterns and the entire schema
      tree from the included schema.

   o  The names of imported YANG groupings and typedefs are qualified
      with the namespace of the imported module.  On the other hand, the
      names of data nodes contained inside the imported groupings, when
      used within the importing module, become part of the importing
      module&#x27;s namespace.  In RELAX NG, the names of patterns are
      unqualified and so named patterns defined in both the importing
      and imported module share the same flat namespace.  The contents
      of RELAX NG named patterns may either keep the namespace of the
      schema where they are defined or inherit the namespace of the
      importing module, analogically to YANG.  However, in order to
      achieve the latter behavior, the definitions of named patterns
      must be included from an external schema, which has to be prepared
      in a special way (see [Vli04], Chapter 11).

   In order to map, as much as possible, the modularity of YANG to RELAX
   NG, a validating RELAX NG schema (the result of the second mapping
   step) has to be split into two files, one of them containing all
   global definitions that are mapped from top-level YANG groupings
   appearing in all input YANG module.  This RELAX NG schema MUST NOT
   define any namespace via the @ns attribute.

   The other RELAX NG schema file then defines actual data trees mapped
   from input YANG modules, each of them enclosed in an own embedded
   grammar.  Those embedded grammars, in which at least one of the
   global definitions is used, MUST include the first schema with

   definitions and also MUST define the local namespace using the @ns
   attribute.  This way, the global definitions can be used inside
   different embedded grammar, each time accepting a different local
   namespace.

   Named pattern definitions that are mapped from non-top-level YANG
   groupings MUST be placed inside the embedded grammar corresponding to
   the YANG module where the grouping is defined.

   In the hybrid schema, we need to distinguish the global and non-
   global named pattern definitions while still keeping the hybrid
   schema in one file.  This is accomplished in the following way:

   o  Every global definition MUST be placed as a child of the outer
      &lt;rng:grammar&gt; element (the document root of the hybrid schema).

   o  Every non-global definitions MUST be placed as a child of the
      corresponding embedded &lt;rng:grammar&gt; element.

   YANG also allows for splitting a module into a number of submodules.
   However, as submodules have no impact on the scope of identifiers and
   namespaces, the modularity based on submodules is not mapped in any
   way.  The contents of submodules is therefore handled as if the
   submodule text appeared directly in the main module.

8.3.  Granularity

   RELAX NG supports different styles of schema structuring: one
   extreme, often called &quot;Russian Doll&quot;, specifies the structure of an
   XML instance document in a single hierarchy.  The other extreme, the
   flat style, uses a similar approach as the Data Type Definition (DTD)
   schema language -- every XML element corresponds to a named pattern
   definition.  In practice, some compromise between the two extremes is
   usually chosen.

   YANG supports both styles in principle, too, but in most cases the
   modules are organized in a way closer to the &quot;Russian Doll&quot; style,
   which provides a better insight into the structure of the
   configuration data.  Groupings are usually defined only for contents
   that are prepared for reuse in multiple places via the &#x27;uses&#x27;
   statement.  In contrast, RELAX NG schemas tend to be much flatter,
   because finer granularity is also needed in RELAX NG for
   extensibility of the schemas -- it is only possible to replace or
   modify schema fragments that are factored out as named patterns.  For
   YANG, this is not an issue since its &#x27;augment&#x27; and &#x27;refine&#x27;
   statements can delve, by using path expressions, into arbitrary
   depths of existing structures.

   In general, it is not feasible to map YANG&#x27;s powerful extension
   mechanisms to those available in RELAX NG.  For this reason, the
   mapping essentially keeps the granularity of the original YANG data
   model: YANG groupings and definitions of derived types usually have
   direct counterparts in definitions of named patterns in the resulting
   RELAX NG schema.

8.4.  Handling of XML Namespaces

   Most modern XML schema languages, including RELAX NG, Schematron, and
   DSRL, support schemas for so-called compound XML documents that
   contain elements from multiple namespaces.  This is useful for our
   purpose since the YANG-to-DSDL mapping allows for multiple input YANG
   modules, which naturally leads to compound document schemas.

   RELAX NG offers two alternatives for defining the target namespaces
   in the schema:

   1.  First possibility is the traditional XML way via the @xmlns:xxx
       attribute.

   2.  One of the target namespace URIs may be declared using the @ns
       attribute.

   In both the hybrid schema and validation RELAX NG schemas generated
   in the second step, the namespaces MUST be declared as follows:

   1.  The root &lt;rng:grammar&gt; MUST have @xmlns:xxx attributes declaring
       prefixes of all namespaces that are used in the data model.  The
       prefixes SHOULD be identical to those defined in the &#x27;prefix&#x27;
       statements.  An implementation of the mapping MUST resolve all
       collisions in the prefixes defined by different input modules, if
       there are any.

   2.  Each embedded &lt;rng:grammar&gt; element MUST declare the namespace of
       the corresponding module using the @ns attribute.  This way, the
       names of nodes defined by global named patterns are able to adopt
       the local namespace of each embedded grammar, as explained in
       Section 8.2.

   This setup is illustrated by the example at the end of Section 8.1.

   DSRL schemas may declare any number of target namespaces via the
   standard XML attributes xmlns:xxx.

   In contrast, Schematron requires all used namespaces to be defined in
   the &lt;sch:ns&gt; subelements of the document element &lt;sch:schema&gt;.

9.  Mapping YANG Data Models to the Hybrid Schema

   This section explains the main principles governing the first step of
   the mapping.  Its result is the hybrid schema that is described in
   Section 8.1.

   A detailed specification of the mapping of individual YANG statements
   is contained in Section 10.

9.1.  Occurrence Rules for Data Nodes

   In DSDL schema languages, occurrence constraints for a node are
   always localized together with that node.  In a RELAX NG schema, for
   example, the &lt;rng:optional&gt; pattern appears as the parent element of
   the pattern defining a leaf or non-leaf element.  Similarly, DSRL
   specifies default contents separately for every single node, be it a
   leaf or non-leaf element.

   For leaf nodes in YANG modules, the occurrence constraints are also
   easily inferred from the substatements of &#x27;leaf&#x27;.  On the other hand,
   for a YANG container, it is often necessary to examine its entire
   subtree in order to determine the container&#x27;s occurrence constraints.

   Therefore, one of the goals of the first mapping step is to infer the
   occurrence constraints for all data nodes and mark, accordingly, the
   corresponding &lt;rng:element&gt; patterns in the hybrid schema so that any
   transformation procedure in the second mapping step can simply use
   this information and need not examine the subtree again.

   First, it has to be decided whether a given data node must always be
   present in a valid configuration.  If so, such a node is called
   mandatory, otherwise it is called optional.  This constraint is
   closely related to the notion of mandatory nodes in Section 3.1 in
   [RFC6020].  The only difference is that this document also considers
   list keys to be mandatory.

   The other occurrence constraint has to do with the semantics of the
   &#x27;default&#x27; statement and the possibility of removing empty non-
   presence containers.  As a result, the information set of a valid
   configuration may be modified by adding or removing certain leaf or
   container elements without changing the meaning of the configuration.
   In this document, such elements are called implicit.  In the hybrid
   schema, they can be identified as RELAX NG patterns having either the
   @nma:default or the @nma:implicit attribute.

   Note that both occurrence constraints apply to containers at the top
   level of the data tree, and then also to other containers under the
   additional condition that their parent node exists in the instance
   document.  For example, consider the following YANG fragment:

       container outer {
           presence &#x27;Presence of &quot;outer&quot; means something.&#x27;;
           container c1 {
               leaf foo {
                   type uint8;
                   default 1;
               }
           }
           container c2 {
               leaf-list bar {
                   type uint8;
                   min-elements 0;
               }
           }
           container c3 {
               leaf baz {
                   type uint8;
                   mandatory true;
               }
           }
       }

   Here, container &quot;outer&quot; has the &#x27;presence&#x27; substatement, which means
   that it is optional and not implicit.  If &quot;outer&quot; is not present in a
   configuration, its child containers are not present as well.
   However, if &quot;outer&quot; does exist, it makes sense to ask which of its
   child containers are optional and which are implicit.  In this case,
   &quot;c1&quot; is optional and implicit, &quot;c2&quot; is optional but not implicit, and
   &quot;c3&quot; is mandatory (and therefore not implicit).

   The following subsections give precise rules for determining whether
   a container is optional or mandatory and whether it is implicit.  In
   order to simplify the recursive definition of these occurrence
   characteristics, it is useful to define them also for other types of
   YANG schema nodes, i.e., leaf, list, leaf-list, anyxml, and choice.

9.1.1.  Optional and Mandatory Nodes

   The decision whether a given node is mandatory or optional is
   governed by the following rules:

   o  Leaf, anyxml, and choice nodes are mandatory if they contain the
      substatement &quot;mandatory true;&quot;.  For a choice node, this means
      that at least one node from exactly one case branch must exist.

   o  In addition, a leaf node is mandatory if it is declared as a list
      key.

   o  A list or leaf-list node is mandatory if it contains the &#x27;min-
      elements&#x27; substatement with an argument value greater than zero.

   o  A container node is mandatory if its definition does not contain
      the &#x27;presence&#x27; substatement and at least one of its child nodes is
      mandatory.

   A node that is not mandatory is said to be optional.

   In RELAX NG, definitions of nodes that are optional must be
   explicitly wrapped in the &lt;rng:optional&gt; element.  The mapping MUST
   use the above rules to determine whether a YANG node is optional, and
   if so, insert the &lt;rng:optional&gt; element in the hybrid schema.

   However, alternatives in &lt;rng:choice&gt; MUST NOT be defined as optional
   in the hybrid schema.  If a choice in YANG is not mandatory, &lt;rng:
   optional&gt; MUST be used to wrap the entire &lt;rng:choice&gt; pattern.

9.1.2.  Implicit Nodes

   The following rules are used to determine whether a given data node
   is implicit:

   o  List, leaf-list, and anyxml nodes are never implicit.

   o  A leaf node is implicit if and only if it has a default value,
      defined either directly or via its data type.

   o  A container node is implicit if and only if it does not have the
      &#x27;presence&#x27; substatement, none of its children are mandatory, and
      at least one child is implicit.

   In the hybrid schema, all implicit containers, as well as leafs that
   obtain their default value from a typedef and don&#x27;t have the @nma:
   default attribute, MUST be marked with @nma:implicit attribute having
   the value of &quot;true&quot;.

   Note that Section 7.9.3 in [RFC6020] specifies other rules that must
   be taken into account when deciding whether or not a given container
   or leaf appearing inside a case of a choice is ultimately implicit.
   Specifically, a leaf or container under a case can be implicit only

   if the case appears in the argument of the choice&#x27;s &#x27;default&#x27;
   statement.  However, this is not sufficient by itself but also
   depends on the particular instance XML document, namely on the
   presence or absence of nodes from other (non-default) cases.  The
   details are explained in Section 11.3.

9.2.  Mapping YANG Groupings and Typedefs

   YANG groupings and typedefs are generally mapped to RELAX NG named
   patterns.  There are, however, several caveats that the mapping has
   to take into account.

   First of all, YANG typedefs and groupings may appear at all levels of
   the module hierarchy and are subject to lexical scoping, see Section
   5.5 in [RFC6020].  Second, top-level symbols from external modules
   may be imported as qualified names represented using the external
   module namespace prefix and the name of the symbol.  In contrast,
   named patterns in RELAX NG (both local and imported via the &lt;rng:
   include&gt; pattern) share the same namespace and within a grammar they
   are always global -- their definitions may only appear at the top
   level as children of the &lt;rng:grammar&gt; element.  Consequently,
   whenever YANG groupings and typedefs are mapped to RELAX NG named
   pattern definitions, their names MUST be disambiguated in order to
   avoid naming conflicts.  The mapping uses the following procedure for
   mangling the names of groupings and type definitions:

   o  Names of groupings and typedefs appearing at the top level of the
      YANG module hierarchy are prefixed with the module name and two
      underscore characters (&quot;__&quot;).

   o  Names of other groupings and typedefs, i.e., those that do not
      appear at the top level of a YANG module, are prefixed with the
      module name, double underscore, and then the names of all ancestor
      data nodes separated by double underscore.

   o  Finally, since the names of groupings and typedefs in YANG have
      different namespaces, an additional underscore character is added
      to the beginning of the mangled names of all groupings.

   An additional complication is caused by the YANG rules for subelement
   ordering (see, e.g., Section 7.5.7 in [RFC6020]): in RPC input and
   output parameters, subelements must follow the order specified in the
   data model; otherwise, the order is arbitrary.  Consequently, if a
   grouping is used both in RPC input/output parameters and elsewhere,
   it MUST be mapped to two different named pattern definitions -- one
   with fixed order and the other with arbitrary order.  To distinguish
   them, the &quot;__rpc&quot; suffix MUST be appended to the version with fixed
   order.

   EXAMPLE.  Consider the following YANG module that imports the
   standard module &quot;ietf-inet-types&quot; [RFC6021]:

   module example1 {
       namespace &quot;http://example.com/ns/example1&quot;;
       prefix ex1;
       typedef vowels {
           type string {
               pattern &quot;[aeiouy]*&quot;;
           }
       }
       grouping &quot;grp1&quot; {
           leaf &quot;void&quot; {
               type &quot;empty&quot;;
           }
       }
       container &quot;cont&quot; {
           leaf foo {
               type vowels;
           }
           uses &quot;grp1&quot;;
       }
   }

   The hybrid schema generated by the first mapping step will then
   contain the following two (global) named pattern definitions:

   &lt;rng:define name=&quot;example1__vowels&quot;&gt;
     &lt;rng:data type=&quot;string&quot;&gt;
       &lt;rng:param name=&quot;pattern&quot;&gt;[aeiouy]*&lt;/rng:param&gt;
     &lt;/rng:data&gt;
   &lt;/rng:define&gt;

   &lt;rng:define name=&quot;_example1__grp1&quot;&gt;
     &lt;rng:optional&gt;
       &lt;rng:element name=&quot;void&quot;&gt;
         &lt;rng:empty/&gt;
       &lt;/rng:element&gt;
     &lt;/rng:optional&gt;
   &lt;/rng:define&gt;

9.2.1.  YANG Refinements and Augments

   YANG groupings represent a similar concept as named pattern
   definitions in RELAX NG, and both languages also offer mechanisms for
   their subsequent modification.  However, in RELAX NG, the definitions
   themselves are modified, whereas YANG provides two substatements of
   &#x27;uses&#x27;, which modify expansions of groupings:

   o  The &#x27;refine&#x27; statement allows for changing parameters of a schema
      node inside the grouping referenced by the parent &#x27;uses&#x27;
      statement;

   o  The &#x27;augment&#x27; statement can be used for adding new schema nodes to
      the grouping contents.

   Both &#x27;refine&#x27; and &#x27;augment&#x27; statements are quite powerful in that
   they can address, using XPath-like expressions as their arguments,
   schema nodes that are arbitrarily deep inside the grouping contents.
   In contrast, modifications of named pattern definitions in RELAX NG
   are applied exclusively at the topmost level of the named pattern
   contents.  In order to achieve a modifiability of named patterns
   comparable to YANG, a RELAX NG schema would have to be extremely flat
   (cf. Section 8.3) and very difficult to read.

   Since the goal of the mapping described in this document is to
   generate ad hoc DSDL schemas, we decided to avoid these complications
   and instead expand the grouping and refine and/or augment it &quot;in
   place&quot;.  In other words, every &#x27;uses&#x27; statement that has &#x27;refine&#x27;
   and/or &#x27;augment&#x27; substatements is replaced by the contents of the
   corresponding grouping, the changes specified in the &#x27;refine&#x27; and
   &#x27;augment&#x27; statements are applied, and the resulting YANG schema
   fragment is mapped as if the &#x27;uses&#x27;/&#x27;grouping&#x27; indirection wasn&#x27;t
   there.

   If there are further &#x27;uses&#x27; statements inside the grouping contents,
   they may require expansion, too: it is necessary if the contained
   &#x27;uses&#x27;/&#x27;grouping&#x27; pair lies on the &quot;modification path&quot; specified in
   the argument of a &#x27;refine&#x27; or &#x27;augment&#x27; statement.

   EXAMPLE.  Consider the following YANG module:

   module example2 {
       namespace &quot;http://example.com/ns/example2&quot;;
       prefix ex2;
       grouping leaves {
           uses fr;
           uses es;
       }
       grouping fr {
           leaf feuille {
               type string;
           }
       }
       grouping es {
           leaf hoja {
               type string;
           }
       }
       uses leaves;
   }

   The resulting hybrid schema contains three global named pattern
   definitions corresponding to the three groupings, namely:

   &lt;rng:define name=&quot;_example2__leaves&quot;&gt;
     &lt;rng:interleave&gt;
       &lt;rng:ref name=&quot;_example2__fr&quot;/&gt;
       &lt;rng:ref name=&quot;_example2__es&quot;/&gt;
     &lt;/rng:interleave&gt;
   &lt;/rng:define&gt;

   &lt;rng:define name=&quot;_example2__fr&quot;&gt;
     &lt;rng:optional&gt;
       &lt;rng:element name=&quot;feuille&quot;&gt;
         &lt;rng:data type=&quot;string&quot;/&gt;
       &lt;/rng:element&gt;
     &lt;/rng:optional&gt;
   &lt;/rng:define&gt;

   &lt;rng:define name=&quot;_example2__es&quot;&gt;
     &lt;rng:optional&gt;
       &lt;rng:element name=&quot;hoja&quot;&gt;
         &lt;rng:data type=&quot;string&quot;/&gt;
       &lt;/rng:element&gt;
     &lt;/rng:optional&gt;
   &lt;/rng:define&gt;

   and the configuration data part of the hybrid schema is a single
   named pattern reference:

   &lt;nma:data&gt;
     &lt;rng:ref name=&quot;_example2__leaves&quot;/&gt;
   &lt;/nma:data&gt;

   Now assume that the &quot;uses leaves&quot; statement contains a &#x27;refine&#x27;
   substatement, for example:

   uses leaves {
       refine &quot;hoja&quot; {
           default &quot;alamo&quot;;
       }
   }

   The resulting hybrid schema now contains just one named pattern
   definition - &quot;_example2__fr&quot;.  The other two groupings &quot;leaves&quot; and
   &quot;es&quot; have to be expanded because they both lie on the &quot;modification
   path&quot;, i.e., contain the leaf &quot;hoja&quot; that is being refined.  The
   configuration data part of the hybrid schema now looks like this:

   &lt;nma:data&gt;
     &lt;rng:interleave&gt;
       &lt;rng:ref name=&quot;_example2__fr&quot;/&gt;
       &lt;rng:optional&gt;
         &lt;rng:element name=&quot;ex2:hoja&quot; nma:default=&quot;alamo&quot;&gt;
           &lt;rng:data type=&quot;string&quot;/&gt;
         &lt;/rng:element&gt;
       &lt;/rng:optional&gt;
     &lt;/rng:interleave&gt;
   &lt;/nma:data&gt;

9.2.2.  Type Derivation Chains

   RELAX NG has no equivalent of the type derivation mechanism in YANG
   that allows one to restrict a built-in type (perhaps in multiple
   steps) by adding new constraints.  Whenever a derived YANG type is
   used without restrictions -- as a substatement of either &#x27;leaf&#x27; or
   another &#x27;typedef&#x27; -- then the &#x27;type&#x27; statement is mapped simply to a
   named pattern reference &lt;rng:ref&gt;, and the type definition is mapped
   to a RELAX NG named pattern definition &lt;rng:define&gt;.  However, if any
   restrictions are specified as substatements of the &#x27;type&#x27; statement,
   the type definition MUST be expanded at that point so that only the
   ancestor built-in type appears in the hybrid schema, restricted with
   facets that correspond to the combination of all restrictions found
   along the type derivation chain and also in the &#x27;type&#x27; statement.

   EXAMPLE.  Consider this YANG module:

   module example3 {
       namespace &quot;http://example.com/ns/example3&quot;;
       prefix ex3;
       typedef dozen {
           type uint8 {
               range 1..12;
           }
       }
       leaf month {
           type dozen;
       }
   }

   The &#x27;type&#x27; statement in &quot;leaf month&quot; has no restrictions and is
   therefore mapped simply to the reference &lt;rng:ref
   name=&quot;example3__dozen&quot;/&gt; and the corresponding named pattern is
   defined as follows:

   &lt;rng:define name=&quot;example3__dozen&quot;&gt;
     &lt;rng:data type=&quot;unsignedByte&quot;&gt;
       &lt;rng:param name=&quot;minInclusive&quot;&gt;1&lt;/rng:param&gt;
       &lt;rng:param name=&quot;maxInclusive&quot;&gt;12&lt;/rng:param&gt;
     &lt;/rng:data&gt;
   &lt;/rng:define&gt;

   Assume now that the definition of leaf &quot;month&quot; is changed to:

   leaf month {
       type dozen {
           range 7..max;
       }
   }

   The output RELAX NG schema then will not contain any named pattern
   definition and the leaf &quot;month&quot; will be mapped directly to:

   &lt;rng:element name=&quot;ex3:month&quot;&gt;
     &lt;rng:data type=&quot;unsignedByte&quot;&gt;
       &lt;rng:param name=&quot;minInclusive&quot;&gt;7&lt;/rng:param&gt;
       &lt;rng:param name=&quot;maxInclusive&quot;&gt;12&lt;/rng:param&gt;
     &lt;/rng:data&gt;
   &lt;/rng:element&gt;

   The mapping of type derivation chains may be further complicated by
   the presence of the &#x27;default&#x27; statement in type definitions.  In the
   simple case, when a type definition containing the &#x27;default&#x27;

   statement is used without restrictions, the &#x27;default&#x27; statement is
   mapped to the @nma:default attribute attached to the &lt;rng:define&gt;
   element.

   However, if that type definition has to be expanded due to
   restrictions, the @nma:default attribute arising from the expanded
   type or ancestor types in the type derivation chain MUST be attached
   to the pattern where the expansion occurs.  If there are multiple
   &#x27;default&#x27; statements in consecutive steps of the type derivation,
   only the &#x27;default&#x27; statement that is closest to the expanded type is
   used.

   EXAMPLE.  Consider this variation of the last example:

   module example3bis {
       namespace &quot;http://example.com/ns/example3bis&quot;;
       prefix ex3bis;
       typedef dozen {
           type uint8 {
               range 1..12;
           }
           default 7;
       }
       leaf month {
           type dozen;
       }
   }

   The &#x27;typedef&#x27; statement in this module is mapped to the following
   named pattern definition:

   &lt;rng:define name=&quot;example3bis__dozen&quot; @nma:default=&quot;7&quot;&gt;
     &lt;rng:data type=&quot;unsignedByte&quot;&gt;
       &lt;rng:param name=&quot;minInclusive&quot;&gt;1&lt;/rng:param&gt;
       &lt;rng:param name=&quot;maxInclusive&quot;&gt;12&lt;/rng:param&gt;
     &lt;/rng:data&gt;
   &lt;/rng:define&gt;

   If the &quot;dozen&quot; type is restricted when used in the leaf &quot;month&quot;
   definition, as in the previous example, the &quot;dozen&quot; type has to be
   expanded and @nma:default becomes an attribute of the &lt;ex3bis:month&gt;
   element definition:

   &lt;rng:element name=&quot;ex3bis:month&quot; @nma:default=&quot;7&quot;&gt;
     &lt;rng:data type=&quot;unsignedByte&quot;&gt;
       &lt;rng:param name=&quot;minInclusive&quot;&gt;7&lt;/rng:param&gt;
       &lt;rng:param name=&quot;maxInclusive&quot;&gt;12&lt;/rng:param&gt;
     &lt;/rng:data&gt;
   &lt;/rng:element&gt;

   However, if the definition of the leaf &quot;month&quot; itself contained the
   &#x27;default&#x27; substatement, the default specified for the &quot;dozen&quot; type
   would be ignored.

9.3.  Translation of XPath Expressions

   YANG uses full XPath 1.0 syntax [XPath] for the arguments of &#x27;must&#x27;,
   &#x27;when&#x27;, and &#x27;path&#x27; statements.  As the names of data nodes defined in
   a YANG module always belong to the namespace of that YANG module,
   YANG adopted a simplification similar to the concept of default
   namespace in XPath 2.0: node names in XPath expressions needn&#x27;t carry
   a namespace prefix inside the module where they are defined and the
   local module&#x27;s namespace is assumed.

   Consequently, all XPath expressions MUST be translated into a fully
   conformant XPath 1.0 expression: every unprefixed node name MUST be
   prepended with the local module&#x27;s namespace prefix as declared by the
   &#x27;prefix&#x27; statement.

   XPath expressions appearing inside top-level groupings require
   special attention because all unprefixed node names contained in them
   must adopt the namespace of each module where the grouping is used
   (cf. Section 8.2).  In order to achieve this, the local prefix MUST
   be represented using the variable &quot;$pref&quot; in the hybrid schema.  A
   Schematron schema which encounters such an XPath expression then
   supplies an appropriate value for this variable via a parameter to an
   abstract pattern to which the YANG grouping is mapped (see
   Section 11.2).

   For example, XPath expression &quot;/dhcp/max-lease-time&quot; appearing in a
   YANG module with the &quot;dhcp&quot; prefix will be translated to:

   o  &quot;$pref:dhcp/$pref:max-lease-time&quot;, if the expression is inside a
      top-level grouping;

   o  &quot;dhcp:dhcp/dhcp:max-lease-time&quot;, otherwise.

   YANG also uses other XPath-like expressions, namely key identifiers
   and &quot;descendant schema node identifiers&quot; (see the ABNF production for
   and &quot;descendant-schema-nodeid&quot; in Section 12 of [RFC6020]).  These
   expressions MUST be translated by adding local module prefixes as
   well.

9.4.  YANG Language Extensions

   YANG allows for extending its own language in-line by adding new
   statements with keywords from special namespaces.  Such extensions
   first have to be declared using the &#x27;extension&#x27; statement, and then
   they can be used as the standard YANG statements, from which they are
   distinguished by a namespace prefix qualifying the extension keyword.
   RELAX NG has a similar extension mechanism -- XML elements and
   attributes with names from foreign namespaces may be inserted at
   almost any place of a RELAX NG schema.

   YANG language extensions may or may not have a meaning in the context
   of DSDL schemas.  Therefore, an implementation MAY ignore any or all
   of the extensions.  However, an extension that is not ignored MUST be
   mapped to XML element(s) and/or attribute(s) that exactly match the
   YIN form of the extension, see Section 11.1 in [RFC6020].

   EXAMPLE.  Consider the following extension defined by the &quot;acme&quot;
   module:

   extension documentation-flag {
       argument number;
   }

   This extension can then be used in the same or another module, for
   instance like this:

   leaf folio {
       acme:documentation-flag 42;
       type string;
   }

   If this extension is honored by the mapping, it will be mapped to:

   &lt;rng:element name=&quot;acme:folio&quot;&gt;
      &lt;acme:documentation-flag number=&quot;42&quot;/&gt;
      &lt;rng:data type=&quot;string&quot;/&gt;
   &lt;/rng:element&gt;

   Note that the &#x27;extension&#x27; statement itself is not mapped in any way.

10.  Mapping YANG Statements to the Hybrid Schema

   Each subsection in this section is devoted to one YANG statement and
   provides the specification of how the statement is mapped to the
   hybrid schema.  The subsections are sorted alphabetically by the
   statement keyword.

   Each YANG statement is mapped to an XML fragment, typically a single
   element or attribute, but it may also be a larger structure.  The
   mapping procedure is inherently recursive, which means that after
   finishing a statement the mapping continues with its substatements,
   if there are any, and a certain element of the resulting fragment
   becomes the parent of other fragments resulting from the mapping of
   substatements.  Any changes to this default recursive procedure are
   explicitly specified.

   YANG XML encoding rules translate to the following rules for ordering
   multiple subelements:

   1.  Within the &lt;nma:rpcs&gt; subtree (i.e., for input and output
       parameters of an RPC operation) the order of subelements is fixed
       and their definitions in the hybrid schema MUST follow the order
       specified in the source YANG module.

   2.  When mapping the &#x27;list&#x27; statement, all keys MUST come before any
       other subelements and in the same order as they are declared in
       the &#x27;key&#x27; statement.  The order of the remaining (non-key)
       subelements is not specified, so their definitions in the hybrid
       schema MUST be enclosed in the &lt;rng:interleave&gt; element.

   3.  Otherwise, the order of subelements is arbitrary and,
       consequently, all definitions of subelements in the hybrid schema
       MUST be enclosed in the &lt;rng:interleave&gt; element.

   The following conventions are used in this section:

   o  The argument of the statement being mapped is denoted by ARGUMENT.

   o  The element in the RELAX NG schema that becomes the parent of the
      resulting XML fragment is denoted by PARENT.

10.1.  The &#x27;anyxml&#x27; Statement

   This statement is mapped to the &lt;rng:element&gt; element and ARGUMENT
   with prepended local namespace prefix becomes the value of its @name
   attribute.  The contents of &lt;rng:element&gt; are:

   &lt;rng:ref name=&quot;__anyxml__&quot;/&gt;

   Substatements of the &#x27;anyxml&#x27; statement, if any, MAY be mapped to
   additional children of the &lt;rng:element&gt; element.

   If at least one &#x27;anyxml&#x27; statement occurs in any of the input YANG
   modules, the following pattern definition MUST be added exactly once
   to the RELAX NG schema as a child of the root &lt;rng:grammar&gt; element
   (cf. [Vli04], p. 172):

   &lt;rng:define name=&quot;__anyxml__&quot;&gt;
     &lt;rng:zeroOrMore&gt;
       &lt;rng:choice&gt;
         &lt;rng:attribute&gt;
           &lt;rng:anyName/&gt;
         &lt;/rng:attribute&gt;
         &lt;rng:element&gt;
           &lt;rng:anyName/&gt;
           &lt;rng:ref name=&quot;__anyxml__&quot;/&gt;
         &lt;/rng:element&gt;
         &lt;rng:text/&gt;
       &lt;/rng:choice&gt;
     &lt;/rng:zeroOrMore&gt;
   &lt;/rng:define&gt;

   EXAMPLE: YANG statement in a module with namespace prefix &quot;yam&quot;

   anyxml data {
       description &quot;Any XML content allowed here.&quot;;
   }

   is mapped to the following fragment:

   &lt;rng:element name=&quot;yam:data&quot;&gt;
       &lt;a:documentation&gt;Any XML content allowed here&lt;/a:documentation&gt;
       &lt;rng:ref name=&quot;__anyxml__&quot;/&gt;
   &lt;/rng:element&gt;

   An anyxml node is optional if there is no &quot;mandatory true;&quot;
   substatement.  The &lt;rng:element&gt; element then MUST be wrapped in
   &lt;rng:optional&gt;, except when the &#x27;anyxml&#x27; statement is a child of the
   &#x27;choice&#x27; statement and thus forms a shorthand case for that choice
   (see Section 9.1.1 for details).

10.2.  The &#x27;argument&#x27; Statement

   This statement is not mapped to the output schema, but see the rules
   for handling extensions in Section 9.4.

10.3.  The &#x27;augment&#x27; Statement

   As a substatement of &#x27;uses&#x27;, this statement is handled as a part of
   &#x27;uses&#x27; mapping, see Section 10.57.

   At the top level of a module or submodule, the &#x27;augment&#x27; statement is
   used for augmenting the schema tree of another YANG module.  If the
   augmented module is not processed within the same mapping session,
   the top-level &#x27;augment&#x27; statement MUST be ignored.  Otherwise, the
   contents of the statement are added to the foreign module with the
   namespace of the module where the &#x27;augment&#x27; statement appears.

10.4.  The &#x27;base&#x27; Statement

   This statement is ignored as a substatement of &#x27;identity&#x27; and handled
   within the &#x27;identityref&#x27; type if it appears as a substatement of that
   type definition, see Section 10.53.6.

10.5.  The &#x27;belongs-to&#x27; Statement

   This statement is not used since the processing of submodules is
   always initiated from the main module, see Section 10.24.

10.6.  The &#x27;bit&#x27; Statement

   This statement is handled within the &quot;bits&quot; type, see
   Section 10.53.4.

10.7.  The &#x27;case&#x27; Statement

   This statement is mapped to the &lt;rng:group&gt; or &lt;rng:interleave&gt;
   element, depending on whether or not the statement belongs to an
   definition of an RPC operation.  If the argument of a sibling
   &#x27;default&#x27; statement equals to ARGUMENT, the @nma:implicit attribute
   with the value of &quot;true&quot; MUST be added to that &lt;rng:group&gt; or &lt;rng:
   interleave&gt; element.  The @nma:implicit attribute MUST NOT be used
   for nodes at the top-level of a non-default case (see Section 7.9.3
   in [RFC6020]).

10.8.  The &#x27;choice&#x27; Statement

   This statement is mapped to the &lt;rng:choice&gt; element.

   If &#x27;choice&#x27; has the &#x27;mandatory&#x27; substatement with the value of
   &quot;true&quot;, the attribute @nma:mandatory MUST be added to the &lt;rng:
   choice&gt; element with the value of ARGUMENT.  This case may require

   additional handling, see Section 11.2.1.  Otherwise, if &quot;mandatory
   true;&quot; is not present, the &lt;rng:choice&gt; element MUST be wrapped in
   &lt;rng:optional&gt;.

   The alternatives in &lt;rng:choice&gt; -- mapped from either the &#x27;case&#x27;
   statement or a shorthand case -- MUST NOT be defined as optional.

10.9.  The &#x27;config&#x27; Statement

   This statement is mapped to the @nma:config attribute, and ARGUMENT
   becomes its value.

10.10.  The &#x27;contact&#x27; Statement

   This statement SHOULD NOT be used by the mapping since the hybrid
   schema may be mapped from multiple YANG modules created by different
   authors.  The hybrid schema contains references to all input modules
   in the Dublin Core elements &lt;dc:source&gt;, see Section 10.34.  The
   original YANG modules are the authoritative sources of the authorship
   information.

10.11.  The &#x27;container&#x27; Statement

   Using the rules specified in Section 9.1.1, the mapping algorithm
   MUST determine whether the statement defines an optional container,
   and if so, insert the &lt;rng:optional&gt; element and make it the new
   PARENT.

   The container defined by this statement is then mapped to the &lt;rng:
   element&gt; element, which becomes a child of PARENT and uses ARGUMENT
   with prepended local namespace prefix as the value of its @name
   attribute.

   Finally, using the rules specified in Section 9.1.2, the mapping
   algorithm MUST determine whether the container is implicit, and if
   so, add the attribute @nma:implicit with the value of &quot;true&quot; to the
   &lt;rng:element&gt; element.

10.12.  The &#x27;default&#x27; Statement

   If this statement is a substatement of &#x27;leaf&#x27;, it is mapped to the
   @nma:default attribute of PARENT and ARGUMENT becomes its value.

   As a substatement of &#x27;typedef&#x27;, the &#x27;default&#x27; statement is also
   mapped to the @nma:default attribute with the value of ARGUMENT.  The
   placement of this attribute depends on whether or not the type
   definition has to be expanded when it is used:

   o  If the type definition is not expanded, @nma:default becomes an
      attribute of the &lt;rng:define&gt; pattern resulting from the parent
      &#x27;typedef&#x27; mapping.

   o  Otherwise, @nma:default becomes an attribute of the ancestor RELAX
      NG pattern inside which the expansion takes place.

   Details and an example are given in Section 9.2.2.

   Finally, as a substatement of &#x27;choice&#x27;, the &#x27;default&#x27; statement
   identifies the default case and is handled within the &#x27;case&#x27;
   statement, see Section 10.7.  If the default case uses the shorthand
   notation where the &#x27;case&#x27; statement is omitted, the @nma:implicit
   attribute with the value of &quot;true&quot; is either attached to the node
   representing the default case in the shorthand notation or,
   alternatively, an extra &lt;rng:group&gt; element MAY be inserted and the
   @nma:implicit attribute attached to it.  In the latter case, the net
   result is the same as if the &#x27;case&#x27; statement wasn&#x27;t omitted for the
   default case.

   EXAMPLE.  The following &#x27;choice&#x27; statement in a module with namespace
   prefix &quot;yam&quot;

   choice leaves {
       default feuille;
       leaf feuille { type empty; }
       leaf hoja { type empty; }
   }

   is either mapped directly to:

   &lt;rng:choice&gt;
     &lt;rng:element name=&quot;yam:feuille&quot; nma:implicit=&quot;true&quot;&gt;
       &lt;rng:empty/&gt;
     &lt;/rng:element&gt;
     &lt;rng:element name=&quot;yam:hoja&quot;&gt;
       &lt;rng:empty/&gt;
     &lt;/rng:element/&gt;
   &lt;/rng:choice&gt;

   or the default case may be wrapped in an extra &lt;rng:group&gt;:

   &lt;rng:choice&gt;
     &lt;rng:group nma:implicit=&quot;true&quot;&gt;
       &lt;rng:element name=&quot;yam:feuille&quot;&gt;
         &lt;rng:empty/&gt;
       &lt;/rng:element&gt;
     &lt;/rng:group&gt;
     &lt;rng:element name=&quot;yam:hoja&quot;&gt;
       &lt;rng:empty/&gt;
     &lt;/rng:element/&gt;
   &lt;/rng:choice&gt;

10.13.  The &#x27;description&#x27; Statement

   This statement is mapped to the DTD compatibility element
   &lt;a:documentation&gt; and ARGUMENT becomes its text.

   In order to get properly formatted in the RELAX NG compact syntax,
   this element SHOULD be inserted as the first child of PARENT.

10.14.  The &#x27;deviation&#x27; Statement

   This statement is ignored.  However, it is assumed that all
   deviations are known beforehand and the corresponding changes have
   already been applied to the input YANG modules.

10.15.  The &#x27;enum&#x27; Statement

   This statement is mapped to the &lt;rng:value&gt; element, and ARGUMENT
   becomes its text.  All substatements except &#x27;status&#x27; are ignored
   because the &lt;rng:value&gt; element cannot contain annotation elements,
   see [RNG], Section 6.

10.16.  The &#x27;error-app-tag&#x27; Statement

   This statement is ignored unless it is a substatement of &#x27;must&#x27;.  In
   the latter case, it is mapped to the &lt;nma:error-app-tag&gt; element.
   See also Section 10.35.

10.17.  The &#x27;error-message&#x27; Statement

   This statement is ignored unless it is a substatement of &#x27;must&#x27;.  In
   the latter case, it is mapped to the &lt;nma:error-message&gt; element.
   See also Section 10.35.

10.18.  The &#x27;extension&#x27; Statement

   This statement is ignored.  However, extensions to the YANG language
   MAY be mapped as described in Section 9.4.

10.19.  The &#x27;feature&#x27; Statement

   This statement is ignored.

10.20.  The &#x27;grouping&#x27; Statement

   This statement is mapped to a RELAX NG named pattern definition &lt;rng:
   define&gt;, but only if the grouping defined by this statement is used
   without refinements and augments in at least one of the input
   modules.  In this case, the named pattern definition becomes a child
   of the &lt;rng:grammar&gt; element and its name is ARGUMENT mangled
   according to the rules specified in Section 9.2.

   As explained in Section 8.2, a named pattern definition MUST be
   placed:

   o  as a child of the root &lt;rng:grammar&gt; element if the corresponding
      grouping is defined at the top level of an input YANG module;

   o  otherwise as a child of the embedded &lt;rng:grammar&gt; element
      corresponding to the module in which the grouping is defined.

   Whenever a grouping is used with refinements and/or augments, it is
   expanded so that the refinements and augments may be applied in place
   to the prescribed schema nodes.  See Section 9.2.1 for further
   details and an example.

   An implementation MAY offer the option of mapping all &#x27;grouping&#x27;
   statements as named pattern definitions in the output RELAX NG schema
   even if they are not referenced.  This is useful for mapping YANG
   &quot;library&quot; modules that typically contain only &#x27;typedef&#x27; and/or
   &#x27;grouping&#x27; statements.

10.21.  The &#x27;identity&#x27; Statement

   This statement is mapped to the following named pattern definition
   which is placed as a child of the root &lt;rng:grammar&gt; element:

   &lt;rng:define name=&quot;__PREFIX_ARGUMENT&quot;&gt;
     &lt;rng:choice&gt;
       &lt;rng:value type=&quot;QName&quot;&gt;PREFIX:ARGUMENT&lt;/rng:value&gt;
       &lt;rng:ref name=&quot;IDENTITY1&quot;/&gt;
       ...
     &lt;/rng:choice&gt;
   &lt;/rng:define&gt;

   where:

      PREFIX is the prefix used in the hybrid schema for the namespace
      of the module where the current identity is defined.

      IDENTITY1 is the name of the named pattern corresponding to an
      identity that is derived from the current identity.  Exactly one
      &lt;rng:ref&gt; element MUST be present for every such identity.

   EXAMPLE ([RFC6020], Section 7.16.3).  Consider the following
   identities defined in two input YANG modules:

   module crypto-base {
     namespace &quot;http://example.com/crypto-base&quot;;
     prefix &quot;crypto&quot;;
     identity crypto-alg {
       description
         &quot;Base identity from which all crypto algorithms
          are derived.&quot;;
       }
   }

   module des {
     namespace &quot;http://example.com/des&quot;;
     prefix &quot;des&quot;;
     import &quot;crypto-base&quot; {
       prefix &quot;crypto&quot;;
     }
     identity des {
       base &quot;crypto:crypto-alg&quot;;
       description &quot;DES crypto algorithm&quot;;
     }
     identity des3 {
       base &quot;crypto:crypto-alg&quot;;
       description &quot;Triple DES crypto algorithm&quot;;
     }
   }

   The identities will be mapped to the following named pattern
   definitions:

   &lt;define name=&quot;__crypto_crypto-alg&quot;&gt;
     &lt;choice&gt;
       &lt;value type=&quot;QName&quot;&gt;crypto:crypto-alg&lt;/value&gt;
       &lt;ref name=&quot;__des_des&quot;/&gt;
       &lt;ref name=&quot;__des_des3&quot;/&gt;
     &lt;/choice&gt;
   &lt;/define&gt;
   &lt;define name=&quot;__des_des&quot;&gt;
     &lt;value type=&quot;QName&quot;&gt;des:des&lt;/value&gt;
   &lt;/define&gt;
   &lt;define name=&quot;__des_des3&quot;&gt;
     &lt;value type=&quot;QName&quot;&gt;des:des3&lt;/value&gt;
   &lt;/define&gt;

10.22.  The &#x27;if-feature&#x27; Statement

   ARGUMENT together with arguments of all sibling &#x27;if-feature&#x27;
   statements (with added prefixes, if missing) MUST be collected in a
   space-separated list that becomes the value of the @nma:if-feature
   attribute.  This attribute is attached to PARENT.

10.23.  The &#x27;import&#x27; Statement

   This statement is not specifically mapped.  The module whose name is
   in ARGUMENT has to be parsed so that the importing module is able to
   use its top-level groupings, typedefs and identities, and also
   augment the data tree of the imported module.

   If the &#x27;import&#x27; statement has the &#x27;revision&#x27; substatement, the
   corresponding revision of the imported module MUST be used.  The
   mechanism for finding a given module revision is outside the scope of
   this document.

10.24.  The &#x27;include&#x27; Statement

   This statement is not specifically mapped.  The submodule whose name
   is in ARGUMENT has to be parsed and its contents mapped exactly as if
   the submodule text appeared directly in the main module text.

   If the &#x27;include&#x27; statement has the &#x27;revision&#x27; substatement, the
   corresponding revision of the submodule MUST be used.  The mechanism
   for finding a given submodule revision is outside the scope of this
   document.

10.25.  The &#x27;input&#x27; Statement

   This statement is handled within &#x27;rpc&#x27; statement, see Section 10.50.

10.26.  The &#x27;key&#x27; Statement

   This statement is mapped to @nma:key attribute.  ARGUMENT MUST be
   translated so that every key is prefixed with the namespace prefix of
   the local module.  The result of this translation then becomes the
   value of the @nma:key attribute.

10.27.  The &#x27;leaf&#x27; Statement

   This statement is mapped to the &lt;rng:element&gt; element and ARGUMENT
   with prepended local namespace prefix becomes the value of its @name
   attribute.

   If the leaf is optional, i.e., if there is no &quot;mandatory true;&quot;
   substatement and the leaf is not declared among the keys of an
   enclosing list, then the &lt;rng:element&gt; element MUST be enclosed in
   &lt;rng:optional&gt;, except when the &#x27;leaf&#x27; statement is a child of the
   &#x27;choice&#x27; statement and thus represents a shorthand case for that
   choice (see Section 9.1.1 for details).

10.28.  The &#x27;leaf-list&#x27; Statement

   This statement is mapped to a block enclosed by either the &lt;rng:
   zeroOrMore&gt; or the &lt;rng:oneOrMore&gt; element depending on whether the
   argument of &#x27;min-elements&#x27; substatement is &quot;0&quot; or positive,
   respectively (it is zero by default).  This &lt;rng:zeroOrMore&gt; or &lt;rng:
   oneOrMore&gt; element becomes the PARENT.

   &lt;rng:element&gt; is then added as a child element of PARENT and ARGUMENT
   with prepended local namespace prefix becomes the value of its @name
   attribute.  Another attribute, @nma:leaf-list, MUST also be added to
   this &lt;rng:element&gt; element with the value of &quot;true&quot;.  If the &#x27;leaf-
   list&#x27; statement has the &#x27;min-elements&#x27; substatement and its argument
   is greater than one, additional attribute @nma:min-elements is
   attached to &lt;rng:element&gt; and the argument of &#x27;min-elements&#x27; becomes
   the value of this attribute.  Similarly, if there is the &#x27;max-
   elements&#x27; substatement and its argument value is not &quot;unbounded&quot;,
   attribute @nma:max-elements is attached to this element and the
   argument of &#x27;max-elements&#x27; becomes the value of this attribute.

   EXAMPLE.  Consider the following &#x27;leaf-list&#x27; appearing in a module
   with the namespace prefix &quot;yam&quot;:

   leaf-list foliage {
       min-elements 3;
       max-elements 6378;
       ordered-by user;
       type string;
   }

   It is mapped to the following RELAX NG fragment:

   &lt;rng:oneOrMore&gt;
     &lt;rng:element name=&quot;yam:foliage&quot; nma:leaf-list=&quot;true&quot;
                  nma:ordered-by=&quot;user&quot;
                  nma:min-elements=&quot;3&quot; nma:max-elements=&quot;6378&quot;&gt;
       &lt;rng:data type=&quot;string&quot;/&gt;
     &lt;/rng:element&gt;
   &lt;/rng:oneOrMore&gt;

10.29.  The &#x27;length&#x27; Statement

   This statement is handled within the &quot;string&quot; type, see
   Section 10.53.10.

10.30.  The &#x27;list&#x27; Statement

   This statement is mapped exactly as the &#x27;leaf-list&#x27; statement, see
   Section 10.28.  The only difference is that the @nma:leaf-list
   annotation either MUST NOT be present or MUST have the value of
   &quot;false&quot;.

   When mapping the substatements of &#x27;list&#x27;, the order of children of
   the list element MUST be specified so that list keys, if there are
   any, always appear in the same order as they are defined in the &#x27;key&#x27;
   substatement and before other children, see [RFC6020], Section 7.8.5.
   In particular, if a list key is defined in a grouping but the list
   node itself is not a part of the same grouping, and the position of
   the &#x27;uses&#x27; statement would violate the above ordering requirement,
   the grouping MUST be expanded, i.e., the &#x27;uses&#x27; statement replaced by
   the grouping contents.

   For example, consider the following YANG fragment of a module with
   the prefix &quot;yam&quot;:

   grouping keygrp {
     leaf clef {
       type uint8;
     }
   }
   list foo {
     key clef;
     leaf bar {
       type string;
     }
     leaf baz {
       type string;
     }
     uses keygrp;
   }

   It is mapped to the following RELAX NG fragment:

   &lt;rng:zeroOrMore&gt;
     &lt;rng:element name=&quot;yam:foo&quot; nma:key=&quot;yam:clef&quot;&gt;
       &lt;rng:element name=&quot;yam:clef&quot;&gt;
         &lt;rng:data type=&quot;unsignedByte&quot;/&gt;
       &lt;/rng:element&gt;
       &lt;rng:interleave&gt;
         &lt;rng:element name=&quot;yam:bar&quot;&gt;
           &lt;rng:data type=&quot;string&quot;/&gt;
         &lt;/rng:element&gt;
         &lt;rng:element name=&quot;yam:baz&quot;&gt;
           &lt;rng:data type=&quot;string&quot;/&gt;
         &lt;/rng:element&gt;
       &lt;/rng:interleave&gt;
     &lt;/rng:element&gt;
   &lt;/rng:zeroOrMore&gt;

   Note that the &quot;keygrp&quot; grouping is expanded and the definition of
   &quot;yam:clef&quot; is moved before the &lt;rng:interleave&gt; pattern.

10.31.  The &#x27;mandatory&#x27; Statement

   This statement may appear as a substatement of &#x27;leaf&#x27;, &#x27;choice&#x27;, or
   &#x27;anyxml&#x27; statement.  If ARGUMENT is &quot;true&quot;, the parent data node is
   mapped as mandatory, see Section 9.1.1.

   As a substatement of &#x27;choice&#x27;, this statement is also mapped to the
   @nma:mandatory attribute, which is added to PARENT.  The value of
   this attribute is the argument of the parent &#x27;choice&#x27; statement.

10.32.  The &#x27;max-elements&#x27; Statement

   This statement is handled within &#x27;leaf-list&#x27; or &#x27;list&#x27; statements,
   see Section 10.28.

10.33.  The &#x27;min-elements&#x27; Statement

   This statement is handled within &#x27;leaf-list&#x27; or &#x27;list&#x27; statements,
   see Section 10.28.

10.34.  The &#x27;module&#x27; Statement

   This statement is mapped to an embedded &lt;rng:grammar&gt; pattern having
   the @nma:module attribute with the value of ARGUMENT.  In addition, a
   &lt;dc:source&gt; element SHOULD be created as a child of this &lt;rng:
   grammar&gt; element and contain ARGUMENT as a metadata reference to the
   input YANG module.  See also Section 10.49.

   Substatements of the &#x27;module&#x27; statement MUST be mapped so that:

   o  statements representing configuration/state data are mapped to
      descendants of the &lt;nma:data&gt; element;

   o  statements representing the contents of RPC requests or replies
      are mapped to descendants of the &lt;nma:rpcs&gt; element;

   o  statements representing the contents of event notifications are
      mapped to descendants of the &lt;nma:notifications&gt; element.

10.35.  The &#x27;must&#x27; Statement

   This statement is mapped to the &lt;nma:must&gt; element.  It has one
   mandatory attribute @assert (with no namespace) that contains
   ARGUMENT transformed into a valid XPath expression (see Section 9.3).
   The &lt;nma:must&gt; element may have other subelements resulting from
   mapping the &#x27;error-app-tag&#x27; and &#x27;error-message&#x27; substatements.  Other
   substatements of &#x27;must&#x27;, i.e., &#x27;description&#x27; and &#x27;reference&#x27;, are
   ignored.

   EXAMPLE.  YANG statement in the &quot;dhcp&quot; module

   must &#x27;current() &lt;= ../max-lease-time&#x27; {
       error-message
           &quot;The default-lease-time must be less than max-lease-time&quot;;
   }

   is mapped to:

   &lt;nma:must assert=&quot;current()&amp;lt;=../dhcp:max-lease-time&quot;&gt;
     &lt;nma:error-message&gt;
       The default-lease-time must be less than max-lease-time
     &lt;/nma:error-message&gt;
   &lt;/nma:must&gt;

10.36.  The &#x27;namespace&#x27; Statement

   This statement is mapped simultaneously in two ways:

   1.  to the @xmlns:PREFIX attribute of the root &lt;rng:grammar&gt; element
       where PREFIX is the namespace prefix specified by the sibling
       &#x27;prefix&#x27; statement.  ARGUMENT becomes the value of this
       attribute;

   2.  to the @ns attribute of PARENT, which is an embedded &lt;rng:
       grammar&gt; pattern.  ARGUMENT becomes the value of this attribute.

10.37.  The &#x27;notification&#x27; Statement

   This statement is mapped to the following subtree of the &lt;nma:
   notifications&gt; element in the hybrid schema (where PREFIX is the
   prefix of the local YANG module):

   &lt;nma:notification&gt;
     &lt;rng:element name=&quot;PREFIX:ARGUMENT&quot;&gt;
       ...
     &lt;/rng:element&gt;
   &lt;/nma:notification&gt;

   Substatements of &#x27;notification&#x27; are mapped under &lt;rng:element
   name=&quot;PREFIX:ARGUMENT&quot;&gt;.

10.38.  The &#x27;ordered-by&#x27; Statement

   This statement is mapped to @nma:ordered-by attribute and ARGUMENT
   becomes the value of this attribute.  See Section 10.28 for an
   example.

10.39.  The &#x27;organization&#x27; Statement

   This statement is ignored by the mapping because the hybrid schema
   may be mapped from multiple YANG modules authored by different
   parties.  The hybrid schema SHOULD contain references to all input
   modules in the Dublin Core &lt;dc:source&gt; elements, see Section 10.34.

   The original YANG modules are the authoritative sources of the
   authorship information.

10.40.  The &#x27;output&#x27; Statement

   This statement is handled within the &#x27;rpc&#x27; statement, see
   Section 10.50.

10.41.  The &#x27;path&#x27; Statement

   This statement is handled within the &quot;leafref&quot; type, see
   Section 10.53.8.

10.42.  The &#x27;pattern&#x27; Statement

   This statement is handled within the &quot;string&quot; type, see
   Section 10.53.10.

10.43.  The &#x27;position&#x27; Statement

   This statement is ignored.

10.44.  The &#x27;prefix&#x27; Statement

   This statement is handled within the sibling &#x27;namespace&#x27; statement,
   see Section 10.36, or within the parent &#x27;import&#x27; statement, see
   Section 10.23.  As a substatement of &#x27;belongs-to&#x27; (in submodules),
   the &#x27;prefix&#x27; statement is ignored.

10.45.  The &#x27;presence&#x27; Statement

   This statement influences the mapping of the parent container
   (Section 10.11): the parent container definition MUST be wrapped in
   &lt;rng:optional&gt;, regardless of its contents.  See also Section 9.1.1.

10.46.  The &#x27;range&#x27; Statement

   This statement is handled within numeric types, see Section 10.53.9.

10.47.  The &#x27;reference&#x27; Statement

   This statement is mapped to &lt;a:documentation&gt; element and its text is
   set to ARGUMENT prefixed with &quot;See: &quot;.

10.48.  The &#x27;require-instance&#x27; Statement

   This statement is handled within &quot;instance-identifier&quot; type
   (Section 10.53.7).

10.49.  The &#x27;revision&#x27; Statement

   The mapping uses only the most recent instance of the &#x27;revision&#x27;
   statement, i.e., one with the latest date in ARGUMENT, which
   specifies the current revision of the input YANG module [RFC6020].
   This date SHOULD be recorded, together with the name of the YANG
   module, in the corresponding Dublin Core &lt;dc:source&gt; element (see
   Section 10.34), for example in this form:

   &lt;dc:source&gt;YANG module &#x27;foo&#x27;, revision 2010-03-02&lt;/dc:source&gt;

   The &#x27;description&#x27; substatement of &#x27;revision&#x27; is ignored.

10.50.  The &#x27;rpc&#x27; Statement

   This statement is mapped to the following subtree in the RELAX NG
   schema (where PREFIX is the prefix of the local YANG module):

   &lt;nma:rpc&gt;
     &lt;nma:input&gt;
       &lt;rng:element name=&quot;PREFIX:ARGUMENT&quot;&gt;
         ... mapped contents of &#x27;input&#x27; ...
       &lt;/rng:element&gt;
     &lt;/nma:input&gt;
     &lt;nma:output&quot;&gt;
       ... mapped contents of &#x27;output&#x27; ...
     &lt;/nma:output&gt;
   &lt;/nma:rpc&gt;

   As indicated in the schema fragment, contents of the &#x27;input&#x27;
   substatement (if any) are mapped under &lt;rng:element name=&quot;PREFIX:
   ARGUMENT&quot;&gt;.  Similarly, contents of the &#x27;output&#x27; substatement are
   mapped under &lt;nma:output&gt;.  If there is no &#x27;output&#x27; substatement, the
   &lt;nma:output&gt; element MUST NOT be present.

   The &lt;nma:rpc&gt; element is a child of &lt;nma:rpcs&gt;.

10.51.  The &#x27;status&#x27; Statement

   This statement MAY be ignored.  Otherwise, it is mapped to @nma:
   status attribute and ARGUMENT becomes its value.

10.52.  The &#x27;submodule&#x27; Statement

   This statement is not specifically mapped.  Its substatements are
   mapped as if they appeared directly in the module to which the
   submodule belongs.

10.53.  The &#x27;type&#x27; Statement

   Most YANG built-in data types have an equivalent in the XSD data type
   library [XSD-D] as shown in Table 4.

      +-----------+---------------+--------------------------------+
      | YANG type | XSD type      | Meaning                        |
      +-----------+---------------+--------------------------------+
      | int8      | byte          | 8-bit integer value            |
      |           |               |                                |
      | int16     | short         | 16-bit integer value           |
      |           |               |                                |
      | int32     | int           | 32-bit integer value           |
      |           |               |                                |
      | int64     | long          | 64-bit integer value           |
      |           |               |                                |
      | uint8     | unsignedByte  | 8-bit unsigned integer value   |
      |           |               |                                |
      | uint16    | unsignedShort | 16-bit unsigned integer value  |
      |           |               |                                |
      | uint32    | unsignedInt   | 32-bit unsigned integer value  |
      |           |               |                                |
      | uint64    | unsignedLong  | 64-bit unsigned integer value  |
      |           |               |                                |
      | string    | string        | character string               |
      |           |               |                                |
      | binary    | base64Binary  | binary data in base64 encoding |
      +-----------+---------------+--------------------------------+

     Table 4: YANG built-in data types with equivalents in the W3C XML
                            Schema Type Library

   Two important data types of the XSD data type library -- &quot;dateTime&quot;
   and &quot;anyURI&quot; -- are not built-in types in YANG but instead are
   defined as derived types in the standard modules [RFC6021]: &quot;date-
   and-time&quot; in the &quot;ietf-yang-types&quot; module and &quot;uri&quot; in the &quot;ietf-
   inet-types&quot; module.  However, the formal restrictions in the YANG
   type definitions are rather weak.  Therefore, implementations of the
   YANG-to-DSDL mapping SHOULD detect these derived types in source YANG
   modules and map them to &quot;dateType&quot; and &quot;anyURI&quot;, respectively.

   Details about the mapping of individual YANG built-in types are given
   in the following subsections.

10.53.1.  The &quot;empty&quot; Type

   This type is mapped to &lt;rng:empty/&gt;.

10.53.2.  The &quot;boolean&quot; Type

   This built-in type does not allow any restrictions and is mapped to
   the following XML fragment:

   &lt;rng:choice&gt;
     &lt;rng:value&gt;true&lt;/rng:value&gt;
     &lt;rng:value&gt;false&lt;/rng:value&gt;
   &lt;/rng:choice&gt;

   Note that the XSD &quot;boolean&quot; type cannot be used here because it
   allows, unlike YANG, an alternative numeric representation of boolean
   values: 0 for &quot;false&quot; and 1 for &quot;true&quot;.

10.53.3.  The &quot;binary&quot; Type

   This built-in type does not allow any restrictions and is mapped
   simply by inserting an &lt;rng:data&gt; element whose @type attribute value
   is set to &quot;base64Binary&quot; (see also Table 4).

10.53.4.  The &quot;bits&quot; Type

   This type is mapped to the &lt;rng:list&gt; and for each &#x27;bit&#x27; substatement
   the following XML fragment is inserted as a child of &lt;rng:list&gt;:

   &lt;rng:optional&gt;
     &lt;rng:value&gt;bit_name&lt;/rng:value&gt;
   &lt;/rng:optional&gt;

   where bit_name is the name of the bit as found in the argument of a
   &#x27;bit&#x27; substatement.

10.53.5.  The &quot;enumeration&quot; and &quot;union&quot; Types

   These types are mapped to the &lt;rng:choice&gt; element.

10.53.6.  The &quot;identityref&quot; Type

   This type is mapped to the following named pattern reference:

   &lt;rng:ref name=&quot;__PREFIX_BASE&quot;/&gt;

   where PREFIX:BASE is the qualified name of the identity appearing in
   the argument of the &#x27;base&#x27; substatement.

   For example, assume that module &quot;des&quot; in Section 10.21 contains the
   following leaf definition:

   leaf foo {
     type identityref {
       base crypto:crypto-alg;
     }
   }

   This leaf would then be mapped to the following element pattern:

   &lt;element name=&quot;des:foo&quot;&gt;
     &lt;ref name=&quot;__crypto_crypto-alg&quot;/&gt;
   &lt;/element&gt;

10.53.7.  The &quot;instance-identifier&quot; Type

   This type is mapped to &lt;rng:data&gt; element with @type attribute set to
   &quot;string&quot;.  In addition, an empty &lt;nma:instance-identifier&gt; element
   MUST be inserted as a child of PARENT.

   The argument of the &#x27;require-instance&#x27; substatement, if it exists,
   becomes the value of the @require-instance attribute of the &lt;nma:
   instance-identifier&gt; element.

10.53.8.  The &quot;leafref&quot; Type

   This type is mapped exactly as the type of the leaf given in the
   argument of &#x27;path&#x27; substatement.  However, if the type of the
   referred leaf defines a default value, this default value MUST be
   ignored by the mapping.

   In addition, @nma:leafref attribute MUST be added to PARENT.  The
   argument of the &#x27;path&#x27; substatement, translated according to
   Section 9.3, is set as the value of this attribute.

10.53.9.  The Numeric Types

   YANG built-in numeric types are &quot;int8&quot;, &quot;int16&quot;, &quot;int32&quot;, &quot;int64&quot;,
   &quot;uint8&quot;, &quot;uint16&quot;, &quot;uint32&quot;, &quot;uint64&quot;, and &quot;decimal64&quot;.  They are
   mapped to the &lt;rng:data&gt; element with the @type attribute set to
   ARGUMENT translated according to Table 4 above.

   An exception is the &quot;decimal64&quot; type, which is mapped to the
   &quot;decimal&quot; type of the XSD data type library.  Its precision and
   number of fractional digits are controlled with the following facets,
   which MUST always be present:

   o  &quot;totalDigits&quot; facet set to the value of 19.

   o  &quot;fractionDigits&quot; facet set to the argument of the &#x27;fraction-
      digits&#x27; substatement.

   The fixed value of &quot;totalDigits&quot; corresponds to the maximum of 19
   decimal digits for 64-bit integers.

   For example, the statement:

   type decimal64 {
       fraction-digits 2;
   }

   is mapped to the following RELAX NG data type:

   &lt;rng:data type=&quot;decimal&quot;&gt;
     &lt;rng:param name=&quot;totalDigits&quot;&gt;19&lt;/rng:param&gt;
     &lt;rng:param name=&quot;fractionDigits&quot;&gt;2&lt;/rng:param&gt;
   &lt;/rng:data&gt;

   All numeric types support the &#x27;range&#x27; restriction, which is mapped as
   follows:

   If the range expression consists of just a single range LO..HI, then
   it is mapped to a pair of data type facets:

         &lt;rng:param name=&quot;minInclusive&quot;&gt;LO&lt;/rng:param&gt;

   and

          &lt;rng:param name=&quot;maxInclusive&quot;&gt;HI&lt;/rng:param&gt;

   If the range consists of a single number, the values of both facets
   are set to this value.  If LO is equal to the string &quot;min&quot;, the
   &quot;minInclusive&quot; facet is omitted.  If HI is equal to the string &quot;max&quot;,
   the &quot;maxInclusive&quot; facet is omitted.

   If the range expression has multiple parts separated by &quot;|&quot;, then the
   parent &lt;rng:data&gt; element must be repeated once for every range part
   and all such &lt;rng:data&gt; elements are wrapped in &lt;rng:choice&gt; element.
   Each &lt;rng:data&gt; element contains the &quot;minInclusive&quot; and
   &quot;maxInclusive&quot; facets for one part of the range expression as
   described in the previous paragraph.

   For the &quot;decimal64&quot; type, the &quot;totalDigits&quot; and &quot;fractionDigits&quot; must
   be repeated inside each of the &lt;rng:data&gt; elements.

   For example,

   type int32 {
       range &quot;-6378..0|42|100..max&quot;;
   }

   is mapped to the following RELAX NG fragment:

   &lt;rng:choice&gt;
     &lt;rng:data type=&quot;int&quot;&gt;
       &lt;rng:param name=&quot;minInclusive&quot;&gt;-6378&lt;/rng:param&gt;
       &lt;rng:param name=&quot;maxInclusive&quot;&gt;0&lt;/rng:param&gt;
     &lt;/rng:data&gt;
     &lt;rng:data type=&quot;int&quot;&gt;
       &lt;rng:param name=&quot;minInclusive&quot;&gt;42&lt;/rng:param&gt;
       &lt;rng:param name=&quot;maxInclusive&quot;&gt;42&lt;/rng:param&gt;
     &lt;/rng:data&gt;
     &lt;rng:data type=&quot;int&quot;&gt;
       &lt;rng:param name=&quot;minInclusive&quot;&gt;100&lt;/rng:param&gt;
     &lt;/rng:data&gt;
   &lt;/rng:choice&gt;

   See Section 9.2.2 for further details on mapping the restrictions.

10.53.10.  The &quot;string&quot; Type

   This type is mapped to the &lt;rng:data&gt; element with the @type
   attribute set to &quot;string&quot;.

   The &#x27;length&#x27; restriction is handled analogically to the &#x27;range&#x27;
   restriction for the numeric types (Section 10.53.9):

   If the length expression has just a single range:

   o  and if the length range consists of a single number LENGTH, the
      following data type facet is inserted:

         &lt;rng:param name=&quot;length&quot;&gt;LENGTH&lt;/rng:param&gt;.

   o  if the length range is of the form LO..HI, i.e., it consists of
      both the lower and upper bound.  The following two data type
      facets are then inserted:

         &lt;rng:param name=&quot;minLength&quot;&gt;LO&lt;/rng:param&gt;

   and

         &lt;rng:param name=&quot;maxLength&quot;&gt;HI&lt;/rng:param&gt;

   If LO is equal to the string &quot;min&quot;, the &quot;minLength&quot; facet is omitted.
   If HI is equal to the string &quot;max&quot;, the &quot;maxLength&quot; facet is omitted.

   If the length expression has of multiple parts separated by &quot;|&quot;, then
   the parent &lt;rng:data&gt; element must be repeated once for every range
   part and all such &lt;rng:data&gt; elements are wrapped in &lt;rng:choice&gt;
   element.  Each &lt;rng:data&gt; element contains the &quot;length&quot; or
   &quot;minLength&quot; and &quot;maxLength&quot; facets for one part of the length
   expression as described in the previous paragraph.

   Every &#x27;pattern&#x27; restriction of the &quot;string&quot; data type is mapped to
   the &quot;pattern&quot; facet:

   &lt;rng:param name=&quot;pattern&quot;&gt;...&lt;/rng:param&gt;

   with text equal to the argument of the &#x27;pattern&#x27; statement.  All such
   &quot;pattern&quot; facets must be repeated inside each copy of the &lt;rng:data&gt;
   element, i.e., once for each length range.

   For example,

   type string {
       length &quot;1|3..8&quot;;
       pattern &quot;[A-Z][a-z]*&quot;;
   }

   is mapped to the following RELAX NG fragment:

   &lt;rng:choice&gt;
     &lt;rng:data type=&quot;string&quot;&gt;
       &lt;rng:param name=&quot;length&quot;&gt;1&lt;/rng:param&gt;
       &lt;rng:param name=&quot;pattern&quot;&gt;[A-Z][a-z]*&lt;/rng:param&gt;
     &lt;/rng:data&gt;
     &lt;rng:data type=&quot;string&quot;&gt;
       &lt;rng:param name=&quot;minLength&quot;&gt;3&lt;/rng:param&gt;
       &lt;rng:param name=&quot;maxLength&quot;&gt;8&lt;/rng:param&gt;
       &lt;rng:param name=&quot;pattern&quot;&gt;[A-Z][a-z]*&lt;/rng:param&gt;
     &lt;/rng:data&gt;
   &lt;/rng:choice&gt;

10.53.11.  Derived Types

   If the &#x27;type&#x27; statement refers to a derived type, it is mapped in one
   of the following ways depending on whether it contains any
   restrictions as its substatements:

   1.  Without restrictions, the &#x27;type&#x27; statement is mapped simply to
       the &lt;rng:ref&gt; element, i.e., a reference to a named pattern.  If
       the RELAX NG definition of this named pattern has not been added
       to the hybrid schema yet, the corresponding type definition MUST
       be found and its mapping installed as a subelement of either the
       root or an embedded &lt;rng:grammar&gt; element, see Section 10.54.
       Even if a given derived type is used more than once in the input
       YANG modules, the mapping of the corresponding &#x27;typedef&#x27; MUST be
       installed only once.

   2.  If any restrictions are present, the ancestor built-in type for
       the given derived type must be determined and the mapping of this
       base type MUST be used.  Restrictions appearing at all stages of
       the type derivation chain MUST be taken into account and their
       conjunction added to the &lt;rng:data&gt; element that defines the
       basic type.

   See Section 9.2.2 for more details and an example.

10.54.  The &#x27;typedef&#x27; Statement

   This statement is mapped to a RELAX NG named pattern definition &lt;rng:
   define&gt;, but only if the type defined by this statement is used
   without restrictions in at least one of the input modules.  In this
   case, the named pattern definition becomes a child of either the root
   or an embedded &lt;rng:grammar&gt; element, depending on whether or not the
   &#x27;typedef&#x27; statement appears at the top level of a YANG module.  The
   name of this named pattern definition is set to ARGUMENT mangled
   according to the rules specified in Section 9.2.

   Whenever a derived type is used with additional restrictions, the
   ancestor built-in type for the derived type is used instead with
   restrictions (facets) that are a combination of all restrictions
   specified along the type derivation chain.  See Section 10.53.11 for
   further details and an example.

   An implementation MAY offer the option of recording all &#x27;typedef&#x27;
   statements as named patterns in the output RELAX NG schema even if
   they are not referenced.  This is useful for mapping YANG &quot;library&quot;
   modules containing only &#x27;typedef&#x27; and/or &#x27;grouping&#x27; statements.

10.55.  The &#x27;unique&#x27; Statement

   This statement is mapped to the @nma:unique attribute.  ARGUMENT MUST
   be translated so that every node identifier in each of its components
   is prefixed with the namespace prefix of the local module, unless the
   prefix is already present.  The result of this translation then
   becomes the value of the @nma:unique attribute.

   For example, assuming that the local module prefix is &quot;ex&quot;,

   unique &quot;foo ex:bar/baz&quot;

   is mapped to the following attribute/value pair:

   nma:unique=&quot;ex:foo ex:bar/ex:baz&quot;

10.56.  The &#x27;units&#x27; Statement

   This statement is mapped to the @nma:units attribute and ARGUMENT
   becomes its value.

10.57.  The &#x27;uses&#x27; Statement

   If this statement has neither &#x27;refine&#x27; nor &#x27;augment&#x27; substatements,
   it is mapped to the &lt;rng:ref&gt; element, i.e., a reference to a named
   pattern, and the value of its @name attribute is set to ARGUMENT
   mangled according to Section 9.2.  If the RELAX NG definition of the
   referenced named pattern has not been added to the hybrid schema yet,
   the corresponding grouping MUST be found and its mapping installed as
   a subelement of &lt;rng:grammar&gt;, see Section 10.20.

   Otherwise, if the &#x27;uses&#x27; statement has any &#x27;refine&#x27; or &#x27;augment&#x27;
   substatements, the corresponding grouping must be looked up and its
   contents inserted under PARENT.  See Section 9.2.1 for further
   details and an example.

10.58.  The &#x27;value&#x27; Statement

   This statement is ignored.

10.59.  The &#x27;when&#x27; Statement

   This statement is mapped to the @nma:when attribute and ARGUMENT,
   translated according to Section 9.3, becomes it value.

10.60.  The &#x27;yang-version&#x27; Statement

   This statement is not mapped to the output schema.  However, an
   implementation SHOULD check that it is compatible with the YANG
   version declared by the statement (currently version 1).  In the case
   of a mismatch, the implementation SHOULD report an error and
   terminate.

10.61.  The &#x27;yin-element&#x27; Statement

   This statement is not mapped to the output schema, but see the rules
   for extension handling in Section 9.4.

11.  Mapping the Hybrid Schema to DSDL

   As explained in Section 6, the second step of the YANG-to-DSDL
   mapping takes the hybrid schema and transforms it to various DSDL
   schemas capable of validating instance XML documents.  As an input
   parameter, this step takes, in the simplest case, just a
   specification of the NETCONF XML document type that is to be
   validated.  These document types can be, for example, the contents of
   a datastore, a reply to &lt;nc:get&gt; or &lt;nc:get-config&gt;, contents of
   other RPC requests/replies and event notifications, and so on.

   The second mapping step has to accomplish the following three general
   tasks:

   1.  Extract the parts of the hybrid schema that are appropriate for
       the requested document type.  For example, if a &lt;nc:get&gt; reply is
       to be validated, the subtree under &lt;nma:data&gt; has to be selected.

   2.  The schema must be adapted to the specific encapsulating XML
       elements mandated by the RPC layer.  These are, for example, &lt;nc:
       rpc&gt; and &lt;nc:data&gt; elements in the case of a &lt;nc:get&gt; reply or
       &lt;en:notification&gt; for a notification.

   3.  Finally, NETMOD-specific annotations that are relevant for the
       schema language of the generated schema must be mapped to the
       corresponding patterns or rules.

   These three tasks are together much simpler than the first mapping
   step and can be effectively implemented using XSL transformations
   [XSLT].

   The following subsections describe the details of the second mapping
   step for the individual DSDL schema languages.  Section 12 then
   contains a detailed specification for the mapping of all NETMOD-
   specific annotations.

11.1.  Generating RELAX NG Schemas for Various Document Types

   With one minor exception, obtaining a validating RELAX NG schema from
   the hybrid schema only means taking appropriate parts of the hybrid
   schema and assembling them in a new RELAX NG grammar, perhaps after
   removing all unwanted annotations.

   The structure of the resulting RELAX NG schema is similar to that of
   the hybrid schema: the root grammar contains embedded grammars, one
   for each input YANG module.  However, as explained in Section 8.2,
   global named pattern definitions (children of the root &lt;rng:grammar&gt;
   element) MUST be moved to a separate schema file.

   Depending on the XML document type that is the target for validation,
   such as &lt;nc:get&gt; or &lt;nc:get-config&gt; reply, RPC operations or
   notifications, patterns defining corresponding top-level information
   items MUST be added, such as &lt;nc:rpc-reply&gt; with the @message-id
   attribute and so on.

   In order to avoid copying common named pattern definitions for common
   NETCONF elements and attributes to every single output RELAX NG file,
   such schema-independent definitions SHOULD be collected in a library
   file that is then included by the validating RELAX NG schemas.
   Appendix B has the listing of such a library file.

   The minor exception mentioned above is the annotation @nma:config,
   which must be observed if the target document type is a reply to &lt;nc:
   get-config&gt;.  In this case, each element definition that has this
   attribute with the value of &quot;false&quot; MUST be removed from the schema
   together with its descendants.  See Section 12.1 for more details.

11.2.  Mapping Semantic Constraints to Schematron

   Schematron schemas tend to be much flatter and more uniform compared
   to RELAX NG.  They have exactly four levels of XML hierarchy: &lt;sch:
   schema&gt;, &lt;sch:pattern&gt;, &lt;sch:rule&gt;, and &lt;sch:assert&gt; or &lt;sch:report&gt;.

   In a Schematron schema generated by the second mapping step, the
   basic unit of organization is a rule represented by the &lt;sch:rule&gt;
   element.  The following NETMOD-specific annotations from the hybrid
   schema (henceforth called &quot;semantic annotations&quot;) are mapped to
   corresponding Schematron rules: &lt;nma:must&gt;, @nma:key, @nma:unique,
   @nma:max-elements, @nma:min-elements, @nma:when, @nma:leafref, @nma:
   leaf-list, and also @nma:mandatory appearing as an attribute of &lt;rng:
   choice&gt; (see Section 11.2.1).

   Each input YANG module is mapped to a Schematron pattern whose @id
   attribute is set to the module name.  Every &lt;rng:element&gt; pattern
   containing at least one of the above-mentioned semantic annotations
   is then mapped to a Schematron rule:

   &lt;sch:rule context=&quot;XELEM&quot;&gt;
     ...
   &lt;/sch:rule&gt;

   The value of the mandatory @context attribute of &lt;sch:rule&gt; (denoted
   as XELEM) MUST be set to the absolute path of the context element in
   the data tree.  The &lt;sch:rule&gt; element contains the mappings of all
   contained semantic annotations in the form of Schematron asserts or
   reports.

   Semantic annotations appearing inside a named pattern definition
   (i.e., having &lt;rng:define&gt; among its ancestors) require special
   treatment because they may be potentially used in different contexts.
   This is accomplished by using Schematron abstract patterns that use
   the &quot;$pref&quot; variable in place of the local namespace prefix.  The
   value of the @id attribute of such an abstract pattern MUST be set to
   the name of the named pattern definition that is being mapped (i.e.,
   the mangled name of the original YANG grouping).

   When the abstract pattern is instantiated, the values of the
   following two parameters MUST be provided:

   o  pref: the actual namespace prefix,

   o  start: XPath expression defining the context in which the grouping
      is used.

   EXAMPLE.  Consider the following YANG module:

   module example4 {
     namespace &quot;http://example.com/ns/example4&quot;;
     prefix ex4;
     uses sorted-leaf-list;
     grouping sorted-leaf-list {
       leaf-list sorted-entry {
         must &quot;not(preceding-sibling::sorted-entry &gt; .)&quot; {
           error-message &quot;Entries must appear in ascending order.&quot;;
         }
         type uint8;
       }
     }
   }

   The resulting Schematron schema for a reply to &lt;nc:get&gt; is then as
   follows:

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
   &lt;sch:schema xmlns:sch=&quot;http://purl.oclc.org/dsdl/schematron&quot;&gt;
     &lt;sch:ns uri=&quot;http://example.com/ns/example4&quot; prefix=&quot;ex4&quot;/&gt;
     &lt;sch:ns uri=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
             prefix=&quot;nc&quot;/&gt;
     &lt;sch:pattern abstract=&quot;true&quot;
                  id=&quot;_example4__sorted-leaf-list&quot;&gt;
       &lt;sch:rule context=&quot;$start/$pref:sorted-entry&quot;&gt;
         &lt;sch:report
             test=&quot;. = preceding-sibling::$pref:sorted-entry&quot;&gt;
           Duplicate leaf-list entry &quot;&lt;sch:value-of select=&quot;.&quot;/&gt;&quot;.
         &lt;/sch:report&gt;
         &lt;sch:assert
             test=&quot;not(preceding-sibling::$pref:sorted-entry &amp;gt; .)&quot;&gt;
           Entries must appear in ascending order.
         &lt;/sch:assert&gt;
       &lt;/sch:rule&gt;
     &lt;/sch:pattern&gt;
     &lt;sch:pattern id=&quot;example4&quot;/&gt;
     &lt;sch:pattern id=&quot;id2573371&quot; is-a=&quot;_example4__sorted-leaf-list&quot;&gt;
       &lt;sch:param name=&quot;start&quot; value=&quot;/nc:rpc-reply/nc:data&quot;/&gt;
       &lt;sch:param name=&quot;pref&quot; value=&quot;ex4&quot;/&gt;
     &lt;/sch:pattern&gt;
   &lt;/sch:schema&gt;

   The &quot;sorted-leaf-list&quot; grouping from the input module is mapped to an
   abstract pattern with an @id value of &quot;_example4__sorted-leaf-list&quot;
   in which the &#x27;must&#x27; statement corresponds to the &lt;sch:assert&gt;
   element.  The abstract pattern is the instantiated by the pattern
   with an @id value of &quot;id2573371&quot;, which sets the &quot;start&quot; and &quot;pref&quot;
   parameters to appropriate values.

   Note that another Schematron element, &lt;sch:report&gt;, was automatically
   added, checking for duplicate leaf-list entries.

   The mapping from the hybrid schema to Schematron proceeds in the
   following steps:

   1.  First, the active subtree(s) of the hybrid schema must be
       selected depending on the requested target document type.  This
       procedure is identical to the RELAX NG case, including the
       handling of @nma:config if the target document type is &lt;nc:get-
       config&gt; reply.

   2.  Namespaces of all input YANG modules, together with the
       namespaces of base NETCONF (&quot;nc&quot; prefix) or notifications (&quot;en&quot;
       prefix) MUST be declared using the &lt;sch:ns&gt; element, for example:

   &lt;sch:ns uri=&quot;http://example.com/ns/example4&quot; prefix=&quot;ex4&quot;/&gt;

   3.  One pattern is created for every input module.  In addition, an
       abstract pattern is created for every named pattern definition
       containing one or more semantic annotations.

   4.  A &lt;sch:rule&gt; element is created for each element pattern
       containing semantic annotations.

   5.  Every such annotation is then mapped to an &lt;sch:assert&gt; or &lt;sch:
       report&gt; element, which is installed as a child of the &lt;sch:rule&gt;
       element.

11.2.1.  Constraints on Mandatory Choice

   In order to fully represent the semantics of YANG&#x27;s &#x27;choice&#x27;
   statement with the &quot;mandatory true;&quot; substatement, the RELAX NG
   grammar has to be combined with a special Schematron rule.

   EXAMPLE.  Consider the following module:

   module example5 {
       namespace &quot;http://example.com/ns/example5&quot;;
       prefix ex5;
       choice foobar {
           mandatory true;
           case foo {
               leaf foo1 {
                   type uint8;
               }
               leaf foo2 {
                   type uint8;
               }
           }
           leaf bar {
               type uint8;
           }
       }
   }

   In this module, all three leaf nodes in both case branches are
   optional but because of the &quot;mandatory true;&quot; statement, at least one
   of them must be present in a valid configuration.  The &#x27;choice&#x27;
   statement from this module is mapped to the following fragment of the
   RELAX NG schema:

   &lt;rng:choice&gt;
     &lt;rng:interleave&gt;
       &lt;rng:optional&gt;
         &lt;rng:element name=&quot;ex5:foo1&quot;&gt;
           &lt;rng:data type=&quot;unsignedByte&quot;/&gt;
         &lt;/rng:element&gt;
       &lt;/rng:optional&gt;
       &lt;rng:optional&gt;
         &lt;rng:element name=&quot;ex5:foo2&quot;&gt;
           &lt;rng:data type=&quot;unsignedByte&quot;/&gt;
         &lt;/rng:element&gt;
       &lt;/rng:optional&gt;
     &lt;/rng:interleave&gt;
     &lt;rng:element name=&quot;ex5:bar&quot;&gt;
       &lt;rng:data type=&quot;unsignedByte&quot;/&gt;
     &lt;/rng:element&gt;
   &lt;/rng:choice&gt;

   In the second case branch, the &quot;ex5:bar&quot; element is defined as
   mandatory so that this element must be present in a valid
   configuration if this branch is selected.  However, the two elements
   in the first branch &quot;foo&quot; cannot be both declared as mandatory since
   each of them alone suffices for a valid configuration.  As a result,
   the above RELAX NG fragment would successfully validate
   configurations where none of the three leaf elements are present.

   Therefore, mandatory choices, which can be recognized in the hybrid
   schema as &lt;rng:choice&gt; elements with the @nma:mandatory annotation,
   have to be handled in a special way: for each mandatory choice where
   at least one of the cases contains more than one node, a Schematron
   rule MUST be added enforcing the presence of at least one element
   from any of the cases.  (RELAX NG schema guarantees that elements
   from different cases cannot be mixed together, that all mandatory
   nodes are present, etc.).

   For the example module above, the Schematron rule will be as follows:

   &lt;sch:rule context=&quot;/nc:rpc-reply/nc:data&quot;&gt;
     &lt;sch:assert test=&quot;ex5:foo1 or ex5:foo2 or ex5:bar&quot;&gt;
       Node(s) from at least one case of choice &quot;foobar&quot; must exist.
     &lt;/sch:assert&gt;
   &lt;/sch:rule&gt;

11.3.  Mapping Default Values to DSRL

   DSRL is the only component of DSDL that is allowed to change the
   information set of the validated XML document.  While DSRL also has
   other functions, YANG-to-DSDL mapping uses it only for specifying and
   applying default contents.  For XML instance documents based on YANG
   data models, insertion of default contents may potentially take place
   for all implicit nodes identified by the rules in Section 9.1.2.

   In DSRL, the default contents of an element are specified using the
   &lt;dsrl:default-content&gt; element, which is a child of &lt;dsrl:element-
   map&gt;.  Two sibling elements of &lt;dsrl:default-content&gt; determine the
   context for the application of the default contents, see [DSRL]:

   o  the &lt;dsrl:parent&gt; element contains an XSLT pattern specifying the
      parent element; the default contents are applied only if the
      parent element exists in the instance document;

   o  the &lt;dsrl:name&gt; contains the XML name of the element that, if
      missing or empty, is inserted together with the contents of &lt;dsrl:
      default-content&gt;.

   The &lt;dsrl:parent&gt; element is optional in a general DSRL schema but,
   for the purpose of the YANG-to-DSDL mapping, this element MUST be
   always present, in order to guarantee a proper application of default
   contents.

   DSRL mapping only deals with &lt;rng:element&gt; patterns in the hybrid
   schema that define implicit nodes (see Section 9.1.2).  Such element
   patterns are distinguished by having NETMOD-specific annotation
   attributes @nma:default or @nma:implicit, i.e., either:

   &lt;rng:element name=&quot;ELEM&quot; nma:default=&quot;DEFVALUE&quot;&gt;
     ...
   &lt;/rng:element&gt;

   or

   &lt;rng:element name=&quot;ELEM&quot; nma:implicit=&quot;true&quot;&gt;
     ...
   &lt;/rng:element&gt;

   The former case applies to leaf nodes having the &#x27;default&#x27;
   substatement, but also to leaf nodes that obtain their default value
   from a typedef, if this typedef is expanded according to the rules in
   Section 9.2.2 so that the @nma:default annotation is attached
   directly to the leaf&#x27;s element pattern.

   The latter case is used for all implicit containers (see Section 9.1)
   and for leafs that obtain the default value from a typedef and don&#x27;t
   have the @nma:default annotation.

   In the simplest case, both element patterns are mapped to the
   following DSRL element map:

   &lt;dsrl:element-map&gt;
     &lt;dsrl:parent&gt;XPARENT&lt;/dsrl:parent&gt;
     &lt;dsrl:name&gt;ELEM&lt;/dsrl:name&gt;
     &lt;dsrl:default-content&gt;DEFCONT&lt;/dsrl:default-content&gt;
   &lt;/dsrl:element-map&gt;

   where XPARENT is the absolute XPath of ELEM&#x27;s parent element in the
   data tree and DEFCONT is constructed as follows:

   o  If the implicit node ELEM is a leaf and has the @nma:default
      attribute, DEFCONT is set to the value of this attribute (denoted
      above as DEFVALUE).

   o  If the implicit node ELEM is a leaf and has the @nma:implicit
      attribute with the value of &quot;true&quot;, the default value has to be
      determined from the @nma:default attribute of the definition of
      ELEM&#x27;s type (perhaps recursively) and used in place of DEFCONT in
      the above DSRL element map.  See also Section 9.2.2.

   o  Otherwise, the implicit node ELEM is a container and DEFCONT is
      constructed as an XML fragment containing all descendant elements
      of ELEM that have either the @nma:implicit or the @nma:default
      attribute.

   In addition, when mapping the default case of a choice, it has to be
   guaranteed that the default contents are not applied if any node from
   any non-default case is present.  This is accomplished by setting
   &lt;dsrl:parent&gt; in a special way:

   &lt;dsrl:parent&gt;XPARENT[not (ELEM1|ELEM2|...|ELEMn)]&lt;/dsrl:parent&gt;

   where ELEM1, ELEM2, ...  ELEMn are the names of all top-level nodes
   from all non-default cases.  The rest of the element map is exactly
   as before.

   EXAMPLE.  Consider the following YANG module:

   module example6 {
     namespace &quot;http://example.com/ns/example6&quot;;
     prefix ex6;
     container outer {
       leaf leaf1 {
         type uint8;
         default 1;
       }
       choice one-or-two {
         default &quot;one&quot;;
         container one {
           leaf leaf2 {
             type uint8;
             default 2;
           }
         }
         leaf leaf3 {
           type uint8;
           default 3;
         }
       }
     }
   }

   The DSRL schema generated for the &quot;get-reply&quot; target document type
   will be:

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
   &lt;dsrl:maps xmlns:dsrl=&quot;http://purl.oclc.org/dsdl/dsrl&quot;
              xmlns:ex6=&quot;http://example.com/ns/example6&quot;
              xmlns:nc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
     &lt;dsrl:element-map&gt;
       &lt;dsrl:parent&gt;/nc:rpc-reply/nc:data&lt;/dsrl:parent&gt;
       &lt;dsrl:name&gt;ex6:outer&lt;/dsrl:name&gt;
       &lt;dsrl:default-content&gt;
         &lt;ex6:leaf1&gt;1&lt;/ex6:leaf1&gt;
         &lt;ex6:one&gt;
           &lt;ex6:leaf2&gt;2&lt;/ex6:leaf2&gt;
         &lt;/ex6:one&gt;
       &lt;/dsrl:default-content&gt;
     &lt;/dsrl:element-map&gt;
     &lt;dsrl:element-map&gt;
       &lt;dsrl:parent&gt;/nc:rpc-reply/nc:data/ex6:outer&lt;/dsrl:parent&gt;
       &lt;dsrl:name&gt;ex6:leaf1&lt;/dsrl:name&gt;
       &lt;dsrl:default-content&gt;1&lt;/dsrl:default-content&gt;
     &lt;/dsrl:element-map&gt;
     &lt;dsrl:element-map&gt;
       &lt;dsrl:parent&gt;
         /nc:rpc-reply/nc:data/ex6:outer[not(ex6:leaf3)]
       &lt;/dsrl:parent&gt;
       &lt;dsrl:name&gt;ex6:one&lt;/dsrl:name&gt;
       &lt;dsrl:default-content&gt;
         &lt;ex6:leaf2&gt;2&lt;/ex6:leaf2&gt;
       &lt;/dsrl:default-content&gt;
     &lt;/dsrl:element-map&gt;
     &lt;dsrl:element-map&gt;
       &lt;dsrl:parent&gt;
         /nc:rpc-reply/nc:data/ex6:outer/ex6:one
       &lt;/dsrl:parent&gt;
       &lt;dsrl:name&gt;ex6:leaf2&lt;/dsrl:name&gt;
       &lt;dsrl:default-content&gt;2&lt;/dsrl:default-content&gt;
     &lt;/dsrl:element-map&gt;
   &lt;/dsrl:maps&gt;

   Note that the default value for &quot;leaf3&quot; defined in the YANG module is
   ignored because &quot;leaf3&quot; represents a non-default alternative of a
   choice and as such never becomes an implicit element.

12.  Mapping NETMOD-Specific Annotations to DSDL Schema Languages

   This section contains the mapping specification for the individual
   NETMOD-specific annotations.  In each case, the result of the mapping
   must be inserted into an appropriate context of the target DSDL
   schema as described in Section 11.  The context is determined by the
   element pattern in the hybrid schema to which the annotation is
   attached.  In the rest of this section, CONTELEM will denote the name
   of this context element properly qualified with its namespace prefix.

12.1.  The @nma:config Annotation

   If this annotation is present with the value of &quot;false&quot;, the
   following rules MUST be observed for DSDL schemas of &lt;nc:get-config&gt;
   reply:

   o  When generating RELAX NG, the contents of the CONTELEM definition
      MUST be changed to &lt;rng:notAllowed&gt;.

   o  When generating Schematron or DSRL, the CONTELEM definition and
      all its descendants in the hybrid schema MUST be ignored.

12.2.  The @nma:default Annotation

   This annotation is used for generating the DSRL schema as described
   in Section 11.3.

12.3.  The &lt;nma:error-app-tag&gt; Annotation

   This annotation currently has no mapping defined.

12.4.  The &lt;nma:error-message&gt; Annotation

   This annotation is handled within &lt;nma:must&gt;, see Section 12.13.

12.5.  The @if-feature Annotation

   The information about available features MAY be supplied as an input
   parameter to an implementation.  In this case, the following changes
   MUST be performed for all features that are considered unavailable:

   o  When generating RELAX NG, the contents of the CONTELEM definition
      MUST be changed to &lt;rng:notAllowed&gt;.

   o  When generating Schematron or DSRL, the CONTELEM definition and
      all its descendants in the hybrid schema MUST be ignored.

12.6.  The @nma:implicit Annotation

   This annotation is used for generating the DSRL schema as described
   in Section 11.3.

12.7.  The &lt;nma:instance-identifier&gt; Annotation

   If this annotation element has the @require-instance attribute with
   the value of &quot;false&quot;, it is ignored.  Otherwise, it is mapped to the
   following Schematron assert:

   &lt;sch:assert test=&quot;nmf:evaluate(.)&quot;&gt;
     The element pointed to by &quot;CONTELEM&quot; must exist.
   &lt;/sch:assert&gt;

   The nmf:evaluate() function is an XSLT extension function (see
   Extension Functions in [XSLT]) that evaluates an XPath expression at
   run time.  Such an extension function is available in Extended XSLT
   (EXSLT) or provided as a proprietary extension by some XSLT
   processors, for example Saxon.

12.8.  The @nma:key Annotation

   Assume this annotation attribute contains &quot;k_1 k_2 ... k_n&quot;, i.e.,
   specifies n children of CONTELEM as list keys.  The annotation is
   then mapped to the following Schematron report:

   &lt;sch:report test=&quot;CONDITION&quot;&gt;
     Duplicate key of list &quot;CONTELEM&quot;
   &lt;/sch:report&gt;

   where CONDITION has this form:
   preceding-sibling::CONTELEM[C_1 and C_2 and ... and C_n]

   Each sub-expression C_i, for i=1,2,...,n, specifies the condition for
   violated uniqueness of the key k_i, namely

   k_i=current()/k_i

12.9.  The @nma:leaf-list Annotation

   This annotation is mapped to the following Schematron rule, which
   detects duplicate entries of a leaf-list:

   &lt;sch:report
       test=&quot;. = preceding-sibling::PREFIX:sorted-entry&quot;&gt;
     Duplicate leaf-list entry &quot;&lt;sch:value-of select=&quot;.&quot;/&gt;&quot;.
   &lt;/sch:report&gt;

   See Section 11.2 for a complete example.

12.10.  The @nma:leafref Annotation

   This annotation is mapped to the following assert:

   &lt;sch:assert test=&quot;PATH=.&quot;&gt;
     Leaf &quot;PATH&quot; does not exist for leafref value &quot;VALUE&quot;
   &lt;/sch:assert&gt;

   where PATH is the value of @nma:leafref and VALUE is the value of the
   context element in the instance document for which the referred leaf
   doesn&#x27;t exist.

12.11.  The @nma:min-elements Annotation

   This annotation is mapped to the following Schematron assert:

   &lt;sch:assert test=&quot;count(../CONTELEM)&amp;gt;=MIN&quot;&gt;
     List &quot;CONTELEM&quot; - item count must be at least MIN
   &lt;/sch:assert&gt;

   where MIN is the value of @nma:min-elements.

12.12.  The @nma:max-elements Annotation

   This annotation is mapped to the following Schematron assert:

&lt;sch:assert
    test=&quot;count(../CONTELEM)&amp;lt;=MAX or preceding-sibling::../CONTELEM&quot;&gt;
  Number of list items must be at most MAX
&lt;/sch:assert&gt;

   where MAX is the value of @nma:min-elements.

12.13.  The &lt;nma:must&gt; Annotation

   This annotation is mapped to the following Schematron assert:

   &lt;sch:assert test=&quot;EXPRESSION&quot;&gt;
     MESSAGE
   &lt;/sch:assert&gt;

   where EXPRESSION is the value of the mandatory @assert attribute of
   &lt;nma:must&gt;.  If the &lt;nma:error-message&gt; subelement exists, MESSAGE is
   set to its contents; otherwise, it is set to the default message
   &quot;Condition EXPRESSION must be true&quot;.

12.14.  The &lt;nma:ordered-by&gt; Annotation

   This annotation currently has no mapping defined.

12.15.  The &lt;nma:status&gt; Annotation

   This annotation currently has no mapping defined.

12.16.  The @nma:unique Annotation

   The mapping of this annotation is almost identical as for @nma:key,
   see Section 12.8, with two small differences:

   o  The value of @nma:unique is a list of descendant schema node
      identifiers rather than simple leaf names.  However, the XPath
      expressions specified in Section 12.8 work without any
      modifications if the descendant schema node identifiers are
      substituted for k_1, k_2, ..., k_n.

   o  The message appearing as the text of &lt;sch:report&gt; is different:
      &quot;Violated uniqueness for list CONTELEM&quot;.

12.17.  The @nma:when Annotation

   This annotation is mapped to the following Schematron assert:

   &lt;sch:assert test=&quot;EXPRESSION&quot;&gt;
     Node &quot;CONTELEM&quot; is only valid when &quot;EXPRESSION&quot; is true.
   &lt;/sch:assert&gt;

   where EXPRESSION is the value of @nma:when.

13.  IANA Considerations

   This document requests the following two registrations of namespace
   URIs in the IETF XML registry [RFC3688]:

   -----------------------------------------------------
   URI: urn:ietf:params:xml:ns:netmod:dsdl-annotations:1

   Registrant Contact: The IESG.

   XML: N/A, the requested URI is an XML namespace.
   -----------------------------------------------------

   -----------------------------------------------------
   URI: urn:ietf:params:xml:ns:netmod:xpath-extensions:1

   Registrant Contact: The IESG.

   XML: N/A, the requested URI is an XML namespace.
   -----------------------------------------------------

14.  Security Considerations

   This document defines a procedure that maps data models expressed in
   the YANG language to a coordinated set of DSDL schemas.  The
   procedure itself has no security impact on the Internet.

   DSDL schemas obtained by the mapping procedure may be used for
   validating the contents of NETCONF messages or entire datastores, and
   thus they provide additional validity checks above those performed by
   NETCONF server and client implementations supporting YANG data
   models.  The strictness of this validation is directly derived from
   the source YANG modules that the validated XML data adhere to.

15.  Contributors

   The following people contributed significantly to the initial version
   of this document:

   o  Rohan Mahy

   o  Sharon Chisholm (Ciena)

16.  Acknowledgments

   The editor wishes to thank the following individuals who provided
   helpful suggestions and/or comments on various versions of this
   document: Andy Bierman, Martin Bjorklund, Jirka Kosek, Juergen
   Schoenwaelder, and Phil Shafer.

17.  References

17.1.  Normative References

   [DSDL]         ISO/IEC, &quot;Document Schema Definition Languages (DSDL)
                  - Part 1: Overview&quot;, ISO/IEC 19757-1, November 2004.

   [DSRL]         ISO/IEC, &quot;Information Technology - Document Schema
                  Definition Languages (DSDL) - Part 8: Document
                  Semantics Renaming Language - DSRL&quot;, ISO/
                  IEC 19757-8:2008(E), December 2008.

   [RFC2119]      Bradner, S., &quot;Key words for use in RFCs to Indicate
                  Requirement Levels&quot;, BCP 14, RFC 2119, March 1997.

   [RFC3688]      Mealling, M., &quot;The IETF XML Registry&quot;, BCP 81,
                  RFC 3688, January 2004.

   [RFC4741]      Enns, R., &quot;NETCONF Configuration Protocol&quot;, RFC 4741,
                  December 2006.

   [RFC6020]      Bjorklund, M., Ed., &quot;YANG - A Data Modeling Language
                  for Network Configuration Protocol (NETCONF)&quot;,
                  RFC 6020, October 2010.

   [RFC6021]      Schoenwaelder, J., Ed., &quot;Common YANG Data Types&quot;,
                  RFC 6021, October 2010.

   [RNG]          ISO/IEC, &quot;Information Technology - Document Schema
                  Definition Languages (DSDL) - Part 2: Regular-Grammar-
                  Based Validation - RELAX NG. Second Edition.&quot;, ISO/
                  IEC 19757-2:2008(E), December 2008.

   [RNG-CS]       ISO/IEC, &quot;Information Technology - Document Schema
                  Definition Languages (DSDL) - Part 2: Regular-Grammar-
                  Based Validation - RELAX NG. AMENDMENT 1: Compact
                  Syntax&quot;, ISO/IEC 19757-2:2003/Amd. 1:2006(E),
                  January 2006.

   [RNG-DTD]      Clark, J., Ed. and M. Murata, Ed., &quot;RELAX NG DTD
                  Compatibility&quot;, OASIS Committee Specification, 3
                  December 2001.

   [Schematron]   ISO/IEC, &quot;Information Technology - Document Schema
                  Definition Languages (DSDL) - Part 3: Rule-Based
                  Validation - Schematron&quot;, ISO/IEC 19757-3:2006(E),
                  June 2006.

   [XML]          Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E.,
                  and F. Yergeau, &quot;Extensible Markup Language (XML) 1.0
                  (Fifth Edition)&quot;, World Wide Web Consortium
                  Recommendation REC-xml-20081126, November 2008,
                  &lt;http://www.w3.org/TR/2006/REC-xml-20060816&gt;.

   [XML-INFOSET]  Tobin, R. and J. Cowan, &quot;XML Information Set (Second
                  Edition)&quot;, World Wide Web Consortium
                  Recommendation REC-xml-infoset-20040204,
                  February 2004,
                  &lt;http://www.w3.org/TR/2004/REC-xml-infoset-20040204&gt;.

   [XPath]        Clark, J. and S. DeRose, &quot;XML Path Language (XPath)
                  Version 1.0&quot;, World Wide Web Consortium
                  Recommendation REC-xpath-19991116, November 1999,
                  &lt;http://www.w3.org/TR/1999/REC-xpath-19991116&gt;.

   [XSD-D]        Biron, P. and A. Malhotra, &quot;XML Schema Part 2:
                  Datatypes Second Edition&quot;, World Wide Web Consortium
                  Recommendation REC-xmlschema-2-20041028, October 2004,
                  &lt;http://www.w3.org/TR/2004/REC-xmlschema-2-20041028&gt;.

   [XSLT]         Clark, J., &quot;XSL Transformations (XSLT) Version 1.0&quot;,
                  World Wide Web Consortium Recommendation REC-xslt-
                  19991116, November 1999.

17.2.  Informative References

   [DHCPtut]      Bjorklund, M., &quot;DHCP Tutorial&quot;, November 2007, &lt;http:/
                  /www.yang-central.org/twiki/bin/view/Main/
                  DhcpTutorial&gt;.

   [RFC1157]      Case, J., Fedor, M., Schoffstall, M., and J. Davin,
                  &quot;Simple Network Management Protocol (SNMP)&quot;, RFC 1157,
                  May 1990.

   [RFC2578]      McCloghrie, K., Ed., Perkins, D., Ed., and J.
                  Schoenwaelder, Ed., &quot;Structure of Management
                  Information Version 2 (SMIv2)&quot;, STD 58, RFC 2578,
                  April 1999.

   [RFC5013]      Kunze, J., &quot;The Dublin Core Metadata Element Set&quot;,
                  RFC 5013, August 2007.

   [RFC5277]      Chisholm, S. and H. Trevino, &quot;NETCONF Event
                  Notifications&quot;, RFC 5277, July 2008.

   [Trang]        Clark, J., &quot;Trang: Multiformat schema converter based
                  on RELAX NG&quot;, 2008,
                  &lt;http://www.thaiopensource.com/relaxng/trang.html&gt;.

   [Vli04]        van der Vlist, E., &quot;RELAX NG&quot;, O&#x27;Reilly, 2004.

   [XSD]          Thompson, H., Beech, D., Maloney, M., and N.
                  Mendelsohn, &quot;XML Schema Part 1: Structures Second
                  Edition&quot;, World Wide Web Consortium
                  Recommendation REC-xmlschema-1-20041028, October 2004,
                  &lt;http://www.w3.org/TR/2004/REC-xmlschema-1-20041028&gt;.

   [pyang]        Bjorklund, M. and L. Lhotka, &quot;pyang: An extensible
                  YANG validator and converter in Python&quot;, 2010,
                  &lt;http://code.google.com/p/pyang/&gt;.

Appendix A.  RELAX NG Schema for NETMOD-Specific Annotations

   This appendix defines the content model for all NETMOD-specific
   annotations in the form of RELAX NG named pattern definitions.

  &lt;CODE BEGINS&gt; file &quot;nmannot.rng&quot;

  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
  &lt;grammar xmlns=&quot;http://relaxng.org/ns/structure/1.0&quot;
           xmlns:nma=&quot;urn:ietf:params:xml:ns:netmod:dsdl-annotations:1&quot;
           datatypeLibrary=&quot;http://www.w3.org/2001/XMLSchema-datatypes&quot;&gt;

  &lt;define name=&quot;config-attribute&quot;&gt;
    &lt;attribute name=&quot;nma:config&quot;&gt;
      &lt;data type=&quot;boolean&quot;/&gt;
    &lt;/attribute&gt;
  &lt;/define&gt;

  &lt;define name=&quot;data-element&quot;&gt;
    &lt;element name=&quot;nma:data&quot;&gt;
      &lt;ref name=&quot;__anyxml__&quot;/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name=&quot;default-attribute&quot;&gt;
    &lt;attribute name=&quot;nma:default&quot;&gt;
      &lt;data type=&quot;string&quot;/&gt;
    &lt;/attribute&gt;
  &lt;/define&gt;

  &lt;define name=&quot;error-app-tag-element&quot;&gt;
    &lt;element name=&quot;nma:error-app-tag&quot;&gt;
      &lt;text/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name=&quot;error-message-element&quot;&gt;
    &lt;element name=&quot;nma:error-message&quot;&gt;
      &lt;text/&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name=&quot;if-feature-attribute&quot;&gt;
    &lt;attribute name=&quot;nma:if-feature&quot;&gt;
      &lt;list&gt;
        &lt;data type=&quot;QName&quot;/&gt;
      &lt;/list&gt;
    &lt;/attribute&gt;
  &lt;/define&gt;

  &lt;define name=&quot;implicit-attribute&quot;&gt;
    &lt;attribute name=&quot;nma:implicit&quot;&gt;
      &lt;data type=&quot;boolean&quot;/&gt;
    &lt;/attribute&gt;
  &lt;/define&gt;

  &lt;define name=&quot;instance-identifier-element&quot;&gt;
    &lt;element name=&quot;nma:instance-identifier&quot;&gt;
      &lt;optional&gt;
        &lt;attribute name=&quot;nma:require-instance&quot;&gt;
          &lt;data type=&quot;boolean&quot;/&gt;
        &lt;/attribute&gt;
      &lt;/optional&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name=&quot;key-attribute&quot;&gt;
    &lt;attribute name=&quot;nma:key&quot;&gt;
      &lt;list&gt;
        &lt;data type=&quot;QName&quot;/&gt;
      &lt;/list&gt;
    &lt;/attribute&gt;
  &lt;/define&gt;

  &lt;define name=&quot;leaf-list-attribute&quot;&gt;
    &lt;attribute name=&quot;nma:leaf-list&quot;&gt;
      &lt;data type=&quot;boolean&quot;/&gt;
    &lt;/attribute&gt;
  &lt;/define&gt;

  &lt;define name=&quot;leafref-attribute&quot;&gt;
    &lt;attribute name=&quot;nma:leafref&quot;&gt;
      &lt;data type=&quot;string&quot;/&gt;
    &lt;/attribute&gt;
  &lt;/define&gt;

  &lt;define name=&quot;mandatory-attribute&quot;&gt;
    &lt;attribute name=&quot;nma:mandatory&quot;&gt;
      &lt;data type=&quot;Name&quot;/&gt;
    &lt;/attribute&gt;
  &lt;/define&gt;

  &lt;define name=&quot;max-elements-attribute&quot;&gt;
    &lt;attribute name=&quot;nma:max-elements&quot;&gt;
      &lt;data type=&quot;nonNegativeInteger&quot;/&gt;
    &lt;/attribute&gt;
  &lt;/define&gt;

  &lt;define name=&quot;min-elements-attribute&quot;&gt;
    &lt;attribute name=&quot;nma:min-elements&quot;&gt;
      &lt;data type=&quot;nonNegativeInteger&quot;/&gt;
    &lt;/attribute&gt;
  &lt;/define&gt;

  &lt;define name=&quot;module-attribute&quot;&gt;
    &lt;attribute name=&quot;nma:module&quot;&gt;
      &lt;data type=&quot;Name&quot;/&gt;
    &lt;/attribute&gt;
  &lt;/define&gt;

  &lt;define name=&quot;must-element&quot;&gt;
    &lt;element name=&quot;nma:must&quot;&gt;
      &lt;attribute name=&quot;assert&quot;&gt;
        &lt;data type=&quot;string&quot;/&gt;
      &lt;/attribute&gt;
      &lt;interleave&gt;
        &lt;optional&gt;
          &lt;ref name=&quot;error-app-tag-element&quot;/&gt;
        &lt;/optional&gt;
        &lt;optional&gt;
          &lt;ref name=&quot;error-message-element&quot;/&gt;
        &lt;/optional&gt;
      &lt;/interleave&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name=&quot;notifications-element&quot;&gt;
    &lt;element name=&quot;nma:notifications&quot;&gt;
      &lt;zeroOrMore&gt;
        &lt;element name=&quot;nma:notification&quot;&gt;
          &lt;ref name=&quot;__anyxml__&quot;/&gt;
        &lt;/element&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name=&quot;rpcs-element&quot;&gt;
    &lt;element name=&quot;nma:rpcs&quot;&gt;
      &lt;zeroOrMore&gt;
        &lt;element name=&quot;nma:rpc&quot;&gt;
          &lt;interleave&gt;
            &lt;element name=&quot;nma:input&quot;&gt;
              &lt;ref name=&quot;__anyxml__&quot;/&gt;
            &lt;/element&gt;
            &lt;optional&gt;
              &lt;element name=&quot;nma:output&quot;&gt;
                &lt;ref name=&quot;__anyxml__&quot;/&gt;
              &lt;/element&gt;
            &lt;/optional&gt;
          &lt;/interleave&gt;
        &lt;/element&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name=&quot;ordered-by-attribute&quot;&gt;
    &lt;attribute name=&quot;nma:ordered-by&quot;&gt;
      &lt;choice&gt;
        &lt;value&gt;user&lt;/value&gt;
        &lt;value&gt;system&lt;/value&gt;
      &lt;/choice&gt;
    &lt;/attribute&gt;
  &lt;/define&gt;

  &lt;define name=&quot;status-attribute&quot;&gt;
    &lt;optional&gt;
      &lt;attribute name=&quot;nma:status&quot;&gt;
        &lt;choice&gt;
          &lt;value&gt;current&lt;/value&gt;
          &lt;value&gt;deprecated&lt;/value&gt;
          &lt;value&gt;obsolete&lt;/value&gt;
        &lt;/choice&gt;
      &lt;/attribute&gt;
    &lt;/optional&gt;
  &lt;/define&gt;

  &lt;define name=&quot;unique-attribute&quot;&gt;
    &lt;optional&gt;
      &lt;attribute name=&quot;nma:unique&quot;&gt;
        &lt;list&gt;
          &lt;data type=&quot;token&quot;/&gt;
        &lt;/list&gt;
      &lt;/attribute&gt;
    &lt;/optional&gt;
  &lt;/define&gt;

  &lt;define name=&quot;units-attribute&quot;&gt;
    &lt;optional&gt;
      &lt;attribute name=&quot;nma:units&quot;&gt;
        &lt;data type=&quot;string&quot;/&gt;
      &lt;/attribute&gt;
    &lt;/optional&gt;
  &lt;/define&gt;

  &lt;define name=&quot;when-attribute&quot;&gt;
    &lt;optional&gt;
      &lt;attribute name=&quot;nma:when&quot;&gt;
        &lt;data type=&quot;string&quot;/&gt;
      &lt;/attribute&gt;
    &lt;/optional&gt;
  &lt;/define&gt;

  &lt;define name=&quot;__anyxml__&quot;&gt;
    &lt;zeroOrMore&gt;
      &lt;choice&gt;
        &lt;attribute&gt;
          &lt;anyName/&gt;
        &lt;/attribute&gt;
        &lt;element&gt;
          &lt;anyName/&gt;
          &lt;ref name=&quot;__anyxml__&quot;/&gt;
        &lt;/element&gt;
        &lt;text/&gt;
      &lt;/choice&gt;
    &lt;/zeroOrMore&gt;
  &lt;/define&gt;

  &lt;/grammar&gt;

  &lt;CODE ENDS&gt;

Appendix B.  Schema-Independent Library

   In order to avoid copying the common named pattern definitions to
   every RELAX NG schema generated in the second mapping step, the
   definitions are collected in a library file -- schema-independent
   library -- which is included by the validating schemas under the file
   name &quot;relaxng-lib.rng&quot; (XML syntax) and &quot;relaxng-lib.rnc&quot; (compact
   syntax).  The included definitions cover patterns for common elements
   from base NETCONF [RFC4741] and event notifications [RFC5277].

  &lt;CODE BEGINS&gt; file &quot;relaxng-lib.rng&quot;

  &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

  &lt;grammar xmlns=&quot;http://relaxng.org/ns/structure/1.0&quot;
           xmlns:nc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
           xmlns:en=&quot;urn:ietf:params:xml:ns:netconf:notification:1.0&quot;
           datatypeLibrary=&quot;http://www.w3.org/2001/XMLSchema-datatypes&quot;&gt;

    &lt;define name=&quot;message-id-attribute&quot;&gt;
      &lt;attribute name=&quot;message-id&quot;&gt;
        &lt;data type=&quot;string&quot;&gt;
          &lt;param name=&quot;maxLength&quot;&gt;4095&lt;/param&gt;
        &lt;/data&gt;
      &lt;/attribute&gt;
    &lt;/define&gt;

    &lt;define name=&quot;ok-element&quot;&gt;
      &lt;element name=&quot;nc:ok&quot;&gt;
        &lt;empty/&gt;
      &lt;/element&gt;
    &lt;/define&gt;

    &lt;define name=&quot;eventTime-element&quot;&gt;
      &lt;element name=&quot;en:eventTime&quot;&gt;
        &lt;data type=&quot;dateTime&quot;/&gt;
      &lt;/element&gt;
    &lt;/define&gt;
  &lt;/grammar&gt;

  &lt;CODE ENDS&gt;

Appendix C.  Mapping DHCP Data Model - A Complete Example

   This appendix demonstrates both steps of the YANG-to-DSDL mapping
   applied to the &quot;canonical&quot; DHCP tutorial [DHCPtut] data model.  The
   input YANG module is shown in Appendix C.1 and the output schemas in
   the following two subsections.

   The hybrid schema was obtained by the &quot;dsdl&quot; plugin of the pyang tool
   [pyang] and the validating DSDL schemas were obtained by XSLT
   stylesheets that are also part of pyang distribution.

   Due to the limit of 72 characters per line, a few long strings
   required manual editing, in particular the regular expression
   patterns for IP addresses, etc.  These were replaced by the
   placeholder string &quot;... regex pattern ...&quot;.  Also, line breaks were
   added to several documentation strings and Schematron messages.

   Other than that, the results of the automatic translations were not
   changed.

C.1.  Input YANG Module

   module dhcp {
     namespace &quot;http://example.com/ns/dhcp&quot;;
     prefix dhcp;

     import ietf-yang-types { prefix yang; }
     import ietf-inet-types { prefix inet; }

     organization
       &quot;yang-central.org&quot;;
     description
       &quot;Partial data model for DHCP, based on the config of
        the ISC DHCP reference implementation.&quot;;

     container dhcp {
       description
         &quot;configuration and operational parameters for a DHCP server.&quot;;

       leaf max-lease-time {
         type uint32;
         units seconds;
         default 7200;
       }

       leaf default-lease-time {
         type uint32;
         units seconds;
         must &#x27;. &lt;= ../max-lease-time&#x27; {
           error-message
             &quot;The default-lease-time must be less than max-lease-time&quot;;
         }
         default 600;
       }

       uses subnet-list;

       container shared-networks {
         list shared-network {
           key name;

           leaf name {
             type string;
           }
           uses subnet-list;
         }
       }

       container status {
         config false;
         list leases {
           key address;

           leaf address {
             type inet:ip-address;
           }
           leaf starts {
             type yang:date-and-time;
           }
           leaf ends {
             type yang:date-and-time;
           }
           container hardware {
             leaf type {
               type enumeration {
                 enum &quot;ethernet&quot;;
                 enum &quot;token-ring&quot;;
                 enum &quot;fddi&quot;;
               }
             }
             leaf address {
               type yang:phys-address;
             }
           }
         }
       }
     }

     grouping subnet-list {
       description &quot;A reusable list of subnets&quot;;
       list subnet {
         key net;
         leaf net {
           type inet:ip-prefix;
         }
         container range {
           presence &quot;enables dynamic address assignment&quot;;
           leaf dynamic-bootp {
             type empty;
             description
               &quot;Allows BOOTP clients to get addresses in this range&quot;;
           }

           leaf low {
             type inet:ip-address;
             mandatory true;
           }
           leaf high {
             type inet:ip-address;
             mandatory true;
           }
         }

         container dhcp-options {
           description &quot;Options in the DHCP protocol&quot;;
           leaf-list router {
             type inet:host;
             ordered-by user;
             reference &quot;RFC 2132, sec. 3.8&quot;;
           }
           leaf domain-name {
             type inet:domain-name;
             reference &quot;RFC 2132, sec. 3.17&quot;;
           }
         }

         leaf max-lease-time {
           type uint32;
           units seconds;
           default 7200;
         }
       }
     }
   }

C.2.  Hybrid Schema

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;grammar
       xmlns=&quot;http://relaxng.org/ns/structure/1.0&quot;
       xmlns:nma=&quot;urn:ietf:params:xml:ns:netmod:dsdl-annotations:1&quot;
       xmlns:dc=&quot;http://purl.org/dc/terms&quot;
       xmlns:a=&quot;http://relaxng.org/ns/compatibility/annotations/1.0&quot;
       xmlns:dhcp=&quot;http://example.com/ns/dhcp&quot;
       datatypeLibrary=&quot;http://www.w3.org/2001/XMLSchema-datatypes&quot;&gt;
    &lt;dc:creator&gt;Pyang 1.0a, DSDL plugin&lt;/dc:creator&gt;
    &lt;dc:date&gt;2010-06-17&lt;/dc:date&gt;
    &lt;start&gt;
     &lt;grammar nma:module=&quot;dhcp&quot; ns=&quot;http://example.com/ns/dhcp&quot;&gt;
      &lt;dc:source&gt;YANG module &#x27;dhcp&#x27;&lt;/dc:source&gt;
      &lt;start&gt;

       &lt;nma:data&gt;
        &lt;optional&gt;
         &lt;element nma:implicit=&quot;true&quot; name=&quot;dhcp:dhcp&quot;&gt;
          &lt;interleave&gt;
           &lt;a:documentation&gt;
            configuration and operational parameters for a DHCP server.
           &lt;/a:documentation&gt;
           &lt;optional&gt;
            &lt;element nma:default=&quot;7200&quot;
                     name=&quot;dhcp:max-lease-time&quot;
                     nma:units=&quot;seconds&quot;&gt;
             &lt;data type=&quot;unsignedInt&quot;/&gt;
            &lt;/element&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
            &lt;element nma:default=&quot;600&quot;
                     name=&quot;dhcp:default-lease-time&quot;
                     nma:units=&quot;seconds&quot;&gt;
             &lt;data type=&quot;unsignedInt&quot;/&gt;
             &lt;nma:must assert=&quot;. &amp;lt;= ../dhcp:max-lease-time&quot;&gt;
              &lt;nma:error-message&gt;
               The default-lease-time must be less than max-lease-time
              &lt;/nma:error-message&gt;
             &lt;/nma:must&gt;
            &lt;/element&gt;
           &lt;/optional&gt;
           &lt;ref name=&quot;_dhcp__subnet-list&quot;/&gt;
           &lt;optional&gt;
            &lt;element name=&quot;dhcp:shared-networks&quot;&gt;
             &lt;zeroOrMore&gt;
              &lt;element nma:key=&quot;dhcp:name&quot;
                       name=&quot;dhcp:shared-network&quot;&gt;
               &lt;element name=&quot;dhcp:name&quot;&gt;
                &lt;data type=&quot;string&quot;/&gt;
               &lt;/element&gt;
               &lt;ref name=&quot;_dhcp__subnet-list&quot;/&gt;
              &lt;/element&gt;
             &lt;/zeroOrMore&gt;
            &lt;/element&gt;
           &lt;/optional&gt;
           &lt;optional&gt;
            &lt;element name=&quot;dhcp:status&quot; nma:config=&quot;false&quot;&gt;
             &lt;zeroOrMore&gt;
              &lt;element nma:key=&quot;dhcp:address&quot;
                       name=&quot;dhcp:leases&quot;&gt;
               &lt;element name=&quot;dhcp:address&quot;&gt;
                &lt;ref name=&quot;ietf-inet-types__ip-address&quot;/&gt;
               &lt;/element&gt;

               &lt;interleave&gt;
                &lt;optional&gt;
                 &lt;element name=&quot;dhcp:starts&quot;&gt;
                  &lt;ref name=&quot;ietf-yang-types__date-and-time&quot;/&gt;
                 &lt;/element&gt;
                &lt;/optional&gt;
                &lt;optional&gt;
                 &lt;element name=&quot;dhcp:ends&quot;&gt;
                  &lt;ref name=&quot;ietf-yang-types__date-and-time&quot;/&gt;
                 &lt;/element&gt;
                &lt;/optional&gt;
                &lt;optional&gt;
                 &lt;element name=&quot;dhcp:hardware&quot;&gt;
                  &lt;interleave&gt;
                   &lt;optional&gt;
                    &lt;element name=&quot;dhcp:type&quot;&gt;
                     &lt;choice&gt;
                      &lt;value&gt;ethernet&lt;/value&gt;
                      &lt;value&gt;token-ring&lt;/value&gt;
                      &lt;value&gt;fddi&lt;/value&gt;
                     &lt;/choice&gt;
                    &lt;/element&gt;
                   &lt;/optional&gt;
                   &lt;optional&gt;
                    &lt;element name=&quot;dhcp:address&quot;&gt;
                     &lt;ref name=&quot;ietf-yang-types__phys-address&quot;/&gt;
                    &lt;/element&gt;
                   &lt;/optional&gt;
                  &lt;/interleave&gt;
                 &lt;/element&gt;
                &lt;/optional&gt;
               &lt;/interleave&gt;
              &lt;/element&gt;
             &lt;/zeroOrMore&gt;
            &lt;/element&gt;
           &lt;/optional&gt;
          &lt;/interleave&gt;
         &lt;/element&gt;
        &lt;/optional&gt;
       &lt;/nma:data&gt;
       &lt;nma:rpcs/&gt;
       &lt;nma:notifications/&gt;
      &lt;/start&gt;
     &lt;/grammar&gt;
    &lt;/start&gt;
    &lt;define name=&quot;ietf-yang-types__phys-address&quot;&gt;
     &lt;data type=&quot;string&quot;&gt;
      &lt;param name=&quot;pattern&quot;&gt;([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?&lt;/param&gt;

     &lt;/data&gt;
    &lt;/define&gt;
    &lt;define name=&quot;ietf-inet-types__ipv6-address&quot;&gt;
     &lt;data type=&quot;string&quot;&gt;
      &lt;param name=&quot;pattern&quot;&gt;... regex pattern ...&lt;/param&gt;
      &lt;param name=&quot;pattern&quot;&gt;... regex pattern ...&lt;/param&gt;
     &lt;/data&gt;
    &lt;/define&gt;
    &lt;define name=&quot;ietf-inet-types__ip-prefix&quot;&gt;
     &lt;choice&gt;
      &lt;ref name=&quot;ietf-inet-types__ipv4-prefix&quot;/&gt;
      &lt;ref name=&quot;ietf-inet-types__ipv6-prefix&quot;/&gt;
     &lt;/choice&gt;
    &lt;/define&gt;
    &lt;define name=&quot;ietf-inet-types__host&quot;&gt;
     &lt;choice&gt;
      &lt;ref name=&quot;ietf-inet-types__ip-address&quot;/&gt;
      &lt;ref name=&quot;ietf-inet-types__domain-name&quot;/&gt;
     &lt;/choice&gt;
    &lt;/define&gt;
    &lt;define name=&quot;ietf-yang-types__date-and-time&quot;&gt;
     &lt;data type=&quot;string&quot;&gt;
      &lt;param name=&quot;pattern&quot;&gt;... regex pattern ...&lt;/param&gt;
     &lt;/data&gt;
    &lt;/define&gt;
    &lt;define name=&quot;_dhcp__subnet-list&quot;&gt;
     &lt;a:documentation&gt;A reusable list of subnets&lt;/a:documentation&gt;
     &lt;zeroOrMore&gt;
      &lt;element nma:key=&quot;net&quot; name=&quot;subnet&quot;&gt;
       &lt;element name=&quot;net&quot;&gt;
        &lt;ref name=&quot;ietf-inet-types__ip-prefix&quot;/&gt;
       &lt;/element&gt;
       &lt;interleave&gt;
        &lt;optional&gt;
         &lt;element name=&quot;range&quot;&gt;
          &lt;interleave&gt;
           &lt;optional&gt;
            &lt;element name=&quot;dynamic-bootp&quot;&gt;
             &lt;a:documentation&gt;
              Allows BOOTP clients to get addresses in this range
             &lt;/a:documentation&gt;
             &lt;empty/&gt;
            &lt;/element&gt;
           &lt;/optional&gt;
           &lt;element name=&quot;low&quot;&gt;
            &lt;ref name=&quot;ietf-inet-types__ip-address&quot;/&gt;
           &lt;/element&gt;
           &lt;element name=&quot;high&quot;&gt;

            &lt;ref name=&quot;ietf-inet-types__ip-address&quot;/&gt;
           &lt;/element&gt;
          &lt;/interleave&gt;
         &lt;/element&gt;
        &lt;/optional&gt;
        &lt;optional&gt;
         &lt;element name=&quot;dhcp-options&quot;&gt;
          &lt;interleave&gt;
           &lt;a:documentation&gt;
            Options in the DHCP protocol
           &lt;/a:documentation&gt;
           &lt;zeroOrMore&gt;
            &lt;element nma:leaf-list=&quot;true&quot; name=&quot;router&quot;
                     nma:ordered-by=&quot;user&quot;&gt;
             &lt;a:documentation&gt;
              See: RFC 2132, sec. 3.8
             &lt;/a:documentation&gt;
             &lt;ref name=&quot;ietf-inet-types__host&quot;/&gt;
            &lt;/element&gt;
           &lt;/zeroOrMore&gt;
           &lt;optional&gt;
            &lt;element name=&quot;domain-name&quot;&gt;
             &lt;a:documentation&gt;
              See: RFC 2132, sec. 3.17
             &lt;/a:documentation&gt;
             &lt;ref name=&quot;ietf-inet-types__domain-name&quot;/&gt;
            &lt;/element&gt;
           &lt;/optional&gt;
          &lt;/interleave&gt;
         &lt;/element&gt;
        &lt;/optional&gt;
        &lt;optional&gt;
         &lt;element nma:default=&quot;7200&quot; name=&quot;max-lease-time&quot;
                  nma:units=&quot;seconds&quot;&gt;
          &lt;data type=&quot;unsignedInt&quot;/&gt;
         &lt;/element&gt;
        &lt;/optional&gt;
       &lt;/interleave&gt;
      &lt;/element&gt;
     &lt;/zeroOrMore&gt;
    &lt;/define&gt;
    &lt;define name=&quot;ietf-inet-types__domain-name&quot;&gt;
     &lt;data type=&quot;string&quot;&gt;
      &lt;param name=&quot;pattern&quot;&gt;... regex pattern ...&lt;/param&gt;
      &lt;param name=&quot;minLength&quot;&gt;1&lt;/param&gt;
      &lt;param name=&quot;maxLength&quot;&gt;253&lt;/param&gt;
     &lt;/data&gt;
    &lt;/define&gt;

    &lt;define name=&quot;ietf-inet-types__ipv4-prefix&quot;&gt;
     &lt;data type=&quot;string&quot;&gt;
      &lt;param name=&quot;pattern&quot;&gt;... regex pattern ...&lt;/param&gt;
     &lt;/data&gt;
    &lt;/define&gt;
    &lt;define name=&quot;ietf-inet-types__ipv4-address&quot;&gt;
     &lt;data type=&quot;string&quot;&gt;
      &lt;param name=&quot;pattern&quot;&gt;... regex pattern ...&lt;/param&gt;
     &lt;/data&gt;
    &lt;/define&gt;
    &lt;define name=&quot;ietf-inet-types__ipv6-prefix&quot;&gt;
     &lt;data type=&quot;string&quot;&gt;
      &lt;param name=&quot;pattern&quot;&gt;... regex pattern ...&lt;/param&gt;
      &lt;param name=&quot;pattern&quot;&gt;... regex pattern ...&lt;/param&gt;
     &lt;/data&gt;
    &lt;/define&gt;
    &lt;define name=&quot;ietf-inet-types__ip-address&quot;&gt;
     &lt;choice&gt;
      &lt;ref name=&quot;ietf-inet-types__ipv4-address&quot;/&gt;
      &lt;ref name=&quot;ietf-inet-types__ipv6-address&quot;/&gt;
     &lt;/choice&gt;
    &lt;/define&gt;
   &lt;/grammar&gt;

C.3.  Final DSDL Schemas

   This appendix contains DSDL schemas that were obtained from the
   hybrid schema in Appendix C.2 by XSL transformations.  These schemas
   can be directly used for validating a reply to unfiltered &lt;nc:get&gt;
   with the contents corresponding to the DHCP data model.

   The RELAX NG schema (in two parts, as explained in Section 8.2) also
   includes the schema-independent library from Appendix B.

C.3.1.  Main RELAX NG Schema for &lt;nc:get&gt; Reply

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
   &lt;grammar
       xmlns=&quot;http://relaxng.org/ns/structure/1.0&quot;
       xmlns:nma=&quot;urn:ietf:params:xml:ns:netmod:dsdl-annotations:1&quot;
       xmlns:dhcp=&quot;http://example.com/ns/dhcp&quot;
       datatypeLibrary=&quot;http://www.w3.org/2001/XMLSchema-datatypes&quot;
       ns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
    &lt;include href=&quot;relaxng-lib.rng&quot;/&gt;
    &lt;start&gt;
     &lt;element name=&quot;rpc-reply&quot;&gt;
      &lt;ref name=&quot;message-id-attribute&quot;/&gt;
      &lt;element name=&quot;data&quot;&gt;

       &lt;interleave&gt;
        &lt;grammar ns=&quot;http://example.com/ns/dhcp&quot;&gt;
         &lt;include href=&quot;dhcp-gdefs.rng&quot;/&gt;
         &lt;start&gt;
          &lt;optional&gt;
           &lt;element name=&quot;dhcp:dhcp&quot;&gt;
            &lt;interleave&gt;
             &lt;optional&gt;
              &lt;element name=&quot;dhcp:max-lease-time&quot;&gt;
               &lt;data type=&quot;unsignedInt&quot;/&gt;
              &lt;/element&gt;
             &lt;/optional&gt;
             &lt;optional&gt;
              &lt;element name=&quot;dhcp:default-lease-time&quot;&gt;
               &lt;data type=&quot;unsignedInt&quot;/&gt;
              &lt;/element&gt;
             &lt;/optional&gt;
             &lt;ref name=&quot;_dhcp__subnet-list&quot;/&gt;
             &lt;optional&gt;
              &lt;element name=&quot;dhcp:shared-networks&quot;&gt;
               &lt;zeroOrMore&gt;
                &lt;element name=&quot;dhcp:shared-network&quot;&gt;
                 &lt;element name=&quot;dhcp:name&quot;&gt;
                  &lt;data type=&quot;string&quot;/&gt;
                 &lt;/element&gt;
                 &lt;ref name=&quot;_dhcp__subnet-list&quot;/&gt;
                &lt;/element&gt;
               &lt;/zeroOrMore&gt;
              &lt;/element&gt;
             &lt;/optional&gt;
             &lt;optional&gt;
              &lt;element name=&quot;dhcp:status&quot;&gt;
               &lt;zeroOrMore&gt;
                &lt;element name=&quot;dhcp:leases&quot;&gt;
                 &lt;element name=&quot;dhcp:address&quot;&gt;
                  &lt;ref name=&quot;ietf-inet-types__ip-address&quot;/&gt;
                 &lt;/element&gt;
                 &lt;interleave&gt;
                  &lt;optional&gt;
                   &lt;element name=&quot;dhcp:starts&quot;&gt;
                    &lt;ref name=&quot;ietf-yang-types__date-and-time&quot;/&gt;
                   &lt;/element&gt;
                  &lt;/optional&gt;
                  &lt;optional&gt;
                   &lt;element name=&quot;dhcp:ends&quot;&gt;
                    &lt;ref name=&quot;ietf-yang-types__date-and-time&quot;/&gt;
                   &lt;/element&gt;
                  &lt;/optional&gt;

                  &lt;optional&gt;
                   &lt;element name=&quot;dhcp:hardware&quot;&gt;
                    &lt;interleave&gt;
                     &lt;optional&gt;
                      &lt;element name=&quot;dhcp:type&quot;&gt;
                       &lt;choice&gt;
                        &lt;value&gt;ethernet&lt;/value&gt;
                        &lt;value&gt;token-ring&lt;/value&gt;
                        &lt;value&gt;fddi&lt;/value&gt;
                       &lt;/choice&gt;
                      &lt;/element&gt;
                     &lt;/optional&gt;
                     &lt;optional&gt;
                      &lt;element name=&quot;dhcp:address&quot;&gt;
                       &lt;ref name=&quot;ietf-yang-types__phys-address&quot;/&gt;
                      &lt;/element&gt;
                     &lt;/optional&gt;
                    &lt;/interleave&gt;
                   &lt;/element&gt;
                  &lt;/optional&gt;
                 &lt;/interleave&gt;
                &lt;/element&gt;
               &lt;/zeroOrMore&gt;
              &lt;/element&gt;
             &lt;/optional&gt;
            &lt;/interleave&gt;
           &lt;/element&gt;
          &lt;/optional&gt;
         &lt;/start&gt;
        &lt;/grammar&gt;
       &lt;/interleave&gt;
      &lt;/element&gt;
     &lt;/element&gt;
    &lt;/start&gt;
   &lt;/grammar&gt;

C.3.2.  RELAX NG Schema - Global Named Pattern Definitions

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
   &lt;grammar
       xmlns=&quot;http://relaxng.org/ns/structure/1.0&quot;
       xmlns:nma=&quot;urn:ietf:params:xml:ns:netmod:dsdl-annotations:1&quot;
       xmlns:dhcp=&quot;http://example.com/ns/dhcp&quot;
       datatypeLibrary=&quot;http://www.w3.org/2001/XMLSchema-datatypes&quot;&gt;
    &lt;define name=&quot;ietf-yang-types__phys-address&quot;&gt;
     &lt;data type=&quot;string&quot;&gt;
      &lt;param name=&quot;pattern&quot;&gt;
       ([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?

      &lt;/param&gt;
     &lt;/data&gt;
    &lt;/define&gt;
    &lt;define name=&quot;ietf-inet-types__ipv6-address&quot;&gt;
     &lt;data type=&quot;string&quot;&gt;
      &lt;param name=&quot;pattern&quot;&gt;... regex pattern ...&lt;/param&gt;
     &lt;/data&gt;
    &lt;/define&gt;
    &lt;define name=&quot;ietf-inet-types__ip-prefix&quot;&gt;
     &lt;choice&gt;
      &lt;ref name=&quot;ietf-inet-types__ipv4-prefix&quot;/&gt;
      &lt;ref name=&quot;ietf-inet-types__ipv6-prefix&quot;/&gt;
     &lt;/choice&gt;
    &lt;/define&gt;
    &lt;define name=&quot;ietf-inet-types__host&quot;&gt;
     &lt;choice&gt;
      &lt;ref name=&quot;ietf-inet-types__ip-address&quot;/&gt;
      &lt;ref name=&quot;ietf-inet-types__domain-name&quot;/&gt;
     &lt;/choice&gt;
    &lt;/define&gt;
    &lt;define name=&quot;ietf-yang-types__date-and-time&quot;&gt;
     &lt;data type=&quot;string&quot;&gt;
      &lt;param name=&quot;pattern&quot;&gt;... regex pattern ...&lt;/param&gt;
     &lt;/data&gt;
    &lt;/define&gt;
    &lt;define name=&quot;_dhcp__subnet-list&quot;&gt;
     &lt;zeroOrMore&gt;
      &lt;element name=&quot;subnet&quot;&gt;
       &lt;element name=&quot;net&quot;&gt;
        &lt;ref name=&quot;ietf-inet-types__ip-prefix&quot;/&gt;
       &lt;/element&gt;
       &lt;interleave&gt;
        &lt;optional&gt;
         &lt;element name=&quot;range&quot;&gt;
          &lt;interleave&gt;
           &lt;optional&gt;
            &lt;element name=&quot;dynamic-bootp&quot;&gt;
             &lt;empty/&gt;
            &lt;/element&gt;
           &lt;/optional&gt;
           &lt;element name=&quot;low&quot;&gt;
            &lt;ref name=&quot;ietf-inet-types__ip-address&quot;/&gt;
           &lt;/element&gt;
           &lt;element name=&quot;high&quot;&gt;
            &lt;ref name=&quot;ietf-inet-types__ip-address&quot;/&gt;
           &lt;/element&gt;
          &lt;/interleave&gt;
         &lt;/element&gt;

        &lt;/optional&gt;
        &lt;optional&gt;
         &lt;element name=&quot;dhcp-options&quot;&gt;
          &lt;interleave&gt;
           &lt;zeroOrMore&gt;
            &lt;element name=&quot;router&quot;&gt;
             &lt;ref name=&quot;ietf-inet-types__host&quot;/&gt;
            &lt;/element&gt;
           &lt;/zeroOrMore&gt;
           &lt;optional&gt;
            &lt;element name=&quot;domain-name&quot;&gt;
             &lt;ref name=&quot;ietf-inet-types__domain-name&quot;/&gt;
            &lt;/element&gt;
           &lt;/optional&gt;
          &lt;/interleave&gt;
         &lt;/element&gt;
        &lt;/optional&gt;
        &lt;optional&gt;
         &lt;element name=&quot;max-lease-time&quot;&gt;
          &lt;data type=&quot;unsignedInt&quot;/&gt;
         &lt;/element&gt;
        &lt;/optional&gt;
       &lt;/interleave&gt;
      &lt;/element&gt;
     &lt;/zeroOrMore&gt;
    &lt;/define&gt;
    &lt;define name=&quot;ietf-inet-types__domain-name&quot;&gt;
     &lt;data type=&quot;string&quot;&gt;
      &lt;param name=&quot;pattern&quot;&gt;... regex pattern ...&lt;/param&gt;
      &lt;param name=&quot;minLength&quot;&gt;1&lt;/param&gt;
      &lt;param name=&quot;maxLength&quot;&gt;253&lt;/param&gt;
     &lt;/data&gt;
    &lt;/define&gt;
    &lt;define name=&quot;ietf-inet-types__ipv4-prefix&quot;&gt;
     &lt;data type=&quot;string&quot;&gt;
      &lt;param name=&quot;pattern&quot;&gt;... regex pattern ...&lt;/param&gt;
     &lt;/data&gt;
    &lt;/define&gt;
    &lt;define name=&quot;ietf-inet-types__ipv4-address&quot;&gt;
     &lt;data type=&quot;string&quot;&gt;
      &lt;param name=&quot;pattern&quot;&gt;... regex pattern ...&lt;/param&gt;
     &lt;/data&gt;
    &lt;/define&gt;
    &lt;define name=&quot;ietf-inet-types__ipv6-prefix&quot;&gt;
     &lt;data type=&quot;string&quot;&gt;
      &lt;param name=&quot;pattern&quot;&gt;... regex pattern ...&lt;/param&gt;
      &lt;param name=&quot;pattern&quot;&gt;... regex pattern ...&lt;/param&gt;
     &lt;/data&gt;

    &lt;/define&gt;
    &lt;define name=&quot;ietf-inet-types__ip-address&quot;&gt;
     &lt;choice&gt;
      &lt;ref name=&quot;ietf-inet-types__ipv4-address&quot;/&gt;
      &lt;ref name=&quot;ietf-inet-types__ipv6-address&quot;/&gt;
     &lt;/choice&gt;
    &lt;/define&gt;
   &lt;/grammar&gt;

C.3.3.  Schematron Schema for &lt;nc:get&gt; Reply

  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
  &lt;sch:schema xmlns:sch=&quot;http://purl.oclc.org/dsdl/schematron&quot;&gt;
   &lt;sch:ns uri=&quot;http://example.com/ns/dhcp&quot; prefix=&quot;dhcp&quot;/&gt;
   &lt;sch:ns uri=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot; prefix=&quot;nc&quot;/&gt;
   &lt;sch:pattern abstract=&quot;true&quot; id=&quot;_dhcp__subnet-list&quot;&gt;
    &lt;sch:rule context=&quot;$start/$pref:subnet&quot;&gt;
     &lt;sch:report test=&quot;preceding-sibling::$pref:subnet
                       [$pref:net=current()/$pref:net]&quot;&gt;
      Duplicate key &quot;net&quot;
     &lt;/sch:report&gt;
    &lt;/sch:rule&gt;
    &lt;sch:rule
      context=&quot;$start/$pref:subnet/$pref:dhcp-options/$pref:router&quot;&gt;
     &lt;sch:report test=&quot;.=preceding-sibling::router&quot;&gt;
      Duplicate leaf-list value &quot;&lt;sch:value-of select=&quot;.&quot;/&gt;&quot;
     &lt;/sch:report&gt;
    &lt;/sch:rule&gt;
   &lt;/sch:pattern&gt;
   &lt;sch:pattern id=&quot;dhcp&quot;&gt;
    &lt;sch:rule
      context=&quot;/nc:rpc-reply/nc:data/dhcp:dhcp/dhcp:default-lease-time&quot;&gt;
     &lt;sch:assert test=&quot;. &amp;lt;= ../dhcp:max-lease-time&quot;&gt;
      The default-lease-time must be less than max-lease-time
     &lt;/sch:assert&gt;
    &lt;/sch:rule&gt;
    &lt;sch:rule context=&quot;/nc:rpc-reply/nc:data/dhcp:dhcp/
                       dhcp:shared-networks/dhcp:shared-network&quot;&gt;
     &lt;sch:report test=&quot;preceding-sibling::dhcp:shared-network
                       [dhcp:name=current()/dhcp:name]&quot;&gt;
      Duplicate key &quot;dhcp:name&quot;
     &lt;/sch:report&gt;
    &lt;/sch:rule&gt;
    &lt;sch:rule context=&quot;/nc:rpc-reply/nc:data/dhcp:dhcp/
                       dhcp:status/dhcp:leases&quot;&gt;
     &lt;sch:report test=&quot;preceding-sibling::dhcp:leases
                       [dhcp:address=current()/dhcp:address]&quot;&gt;
      Duplicate key &quot;dhcp:address&quot;

     &lt;/sch:report&gt;
    &lt;/sch:rule&gt;
   &lt;/sch:pattern&gt;
   &lt;sch:pattern id=&quot;id2768196&quot; is-a=&quot;_dhcp__subnet-list&quot;&gt;
    &lt;sch:param name=&quot;start&quot; value=&quot;/nc:rpc-reply/nc:data/dhcp:dhcp&quot;/&gt;
    &lt;sch:param name=&quot;pref&quot; value=&quot;dhcp&quot;/&gt;
   &lt;/sch:pattern&gt;
   &lt;sch:pattern id=&quot;id2768215&quot; is-a=&quot;_dhcp__subnet-list&quot;&gt;
    &lt;sch:param name=&quot;start&quot;
               value=&quot;/nc:rpc-reply/nc:data/dhcp:dhcp/
                      dhcp:shared-networks/dhcp:shared-network&quot;/&gt;
    &lt;sch:param name=&quot;pref&quot; value=&quot;dhcp&quot;/&gt;
   &lt;/sch:pattern&gt;
  &lt;/sch:schema&gt;

C.3.4.  DSRL Schema for &lt;nc:get&gt; Reply

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
   &lt;dsrl:maps
       xmlns:dsrl=&quot;http://purl.oclc.org/dsdl/dsrl&quot;
       xmlns:dhcp=&quot;http://example.com/ns/dhcp&quot;
       xmlns:nc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
    &lt;dsrl:element-map&gt;
     &lt;dsrl:parent&gt;/nc:rpc-reply/nc:data&lt;/dsrl:parent&gt;
     &lt;dsrl:name&gt;dhcp:dhcp&lt;/dsrl:name&gt;
     &lt;dsrl:default-content&gt;
      &lt;dhcp:max-lease-time&gt;7200&lt;/dhcp:max-lease-time&gt;
      &lt;dhcp:default-lease-time&gt;600&lt;/dhcp:default-lease-time&gt;
     &lt;/dsrl:default-content&gt;
    &lt;/dsrl:element-map&gt;
    &lt;dsrl:element-map&gt;
     &lt;dsrl:parent&gt;/nc:rpc-reply/nc:data/dhcp:dhcp&lt;/dsrl:parent&gt;
     &lt;dsrl:name&gt;dhcp:max-lease-time&lt;/dsrl:name&gt;
     &lt;dsrl:default-content&gt;7200&lt;/dsrl:default-content&gt;
    &lt;/dsrl:element-map&gt;
    &lt;dsrl:element-map&gt;
     &lt;dsrl:parent&gt;/nc:rpc-reply/nc:data/dhcp:dhcp&lt;/dsrl:parent&gt;
     &lt;dsrl:name&gt;dhcp:default-lease-time&lt;/dsrl:name&gt;
     &lt;dsrl:default-content&gt;600&lt;/dsrl:default-content&gt;
    &lt;/dsrl:element-map&gt;
    &lt;dsrl:element-map&gt;
     &lt;dsrl:parent&gt;
      /nc:rpc-reply/nc:data/dhcp:dhcp/dhcp:subnet
     &lt;/dsrl:parent&gt;
     &lt;dsrl:name&gt;dhcp:max-lease-time&lt;/dsrl:name&gt;
     &lt;dsrl:default-content&gt;7200&lt;/dsrl:default-content&gt;
    &lt;/dsrl:element-map&gt;
    &lt;dsrl:element-map&gt;

     &lt;dsrl:parent&gt;
      /nc:rpc-reply/nc:data/dhcp:dhcp/dhcp:shared-networks/
      dhcp:shared-network/dhcp:subnet
     &lt;/dsrl:parent&gt;
     &lt;dsrl:name&gt;dhcp:max-lease-time&lt;/dsrl:name&gt;
     &lt;dsrl:default-content&gt;7200&lt;/dsrl:default-content&gt;
    &lt;/dsrl:element-map&gt;
   &lt;/dsrl:maps&gt;

Author&#x27;s Address

   Ladislav Lhotka (editor)
   CESNET

   EMail: lhotka@cesnet.cz


        </re>
        <div class='Verified-endnote-styling' id='eid3362'>
<pre>
<b><i><a href='https://www.rfc-editor.org/errata/eid3362'>EID 3362</a> (Verified) is as follows:</i></b>

<b>Section:</b> GLOBAL

<b>Original Text:</b>

Table of Contents
-----------------
OLD
      12.16. The @nma:unique Annotation ..............................74


Sec. 5.3, entry in Table 2:
---------------------------
OLD
        | @nma:unique               | 10.55              |      |

Sec. 10.55:
-----------
OLD

   This statement is mapped to the @nma:unique attribute.  ARGUMENT MUST
   be translated so that every node identifier in each of its components
   is prefixed with the namespace prefix of the local module, unless the
   prefix is already present.  The result of this translation then
   becomes the value of the @nma:unique attribute.

   For example, assuming that the local module prefix is &quot;ex&quot;,

   unique &quot;foo ex:bar/baz&quot;

   is mapped to the following attribute/value pair:

   nma:unique=&quot;ex:foo ex:bar/ex:baz&quot;

Sec. 11.2, second paragraph:
----------------------------
OLD

   In a Schematron schema generated by the second mapping step, the
   basic unit of organization is a rule represented by the &lt;sch:rule&gt;
   element.  The following NETMOD-specific annotations from the hybrid
   schema (henceforth called &quot;semantic annotations&quot;) are mapped to
   corresponding Schematron rules: &lt;nma:must&gt;, @nma:key, @nma:unique,
   @nma:max-elements, @nma:min-elements, @nma:when, @nma:leafref, @nma:
   leaf-list, and also @nma:mandatory appearing as an attribute of &lt;rng:
   choice&gt; (see Section 11.2.1).

Sec. 12.16 (including its title):
---------------------------------
OLD

12.16.  The @nma:unique Annotation

   The mapping of this annotation is almost identical as for @nma:key,
   see Section 12.8, with two small differences:

   o  The value of @nma:unique is a list of descendant schema node
      identifiers rather than simple leaf names.  However, the XPath
      expressions specified in Section 12.8 work without any
      modifications if the descendant schema node identifiers are
      substituted for k_1, k_2, ..., k_n.

   o  The message appearing as the text of &lt;sch:report&gt; is different:
      &quot;Violated uniqueness for list CONTELEM&quot;.

Appendix A:
-----------
OLD

  &lt;define name=&quot;unique-attribute&quot;&gt;
    &lt;optional&gt;
      &lt;attribute name=&quot;nma:unique&quot;&gt;
        &lt;list&gt;
          &lt;data type=&quot;token&quot;/&gt;
        &lt;/list&gt;
      &lt;/attribute&gt;
    &lt;/optional&gt;
  &lt;/define&gt;



<b>Corrected Text:</b>

Table of Contents
-----------------
NEW
      12.16. The &lt;nma:unique&gt; Annotation ..............................74

Sec. 5.3, entry in Table 2:
---------------------------
NEW
        | &lt;nma:unique&gt;              | 10.55              |      |

Sec. 10.55:
-----------

NEW

   This statement is mapped to the &lt;nma:unique&gt; element.  ARGUMENT MUST
   be translated so that every node identifier in each of its components
   is prefixed with the namespace prefix of the local module, unless the
   prefix is already present.  The result of this translation then
   becomes the value of the @tag attribute which is attached to the
   &lt;nma:unique&gt; element.

   For example, assuming that the local module prefix is &quot;ex&quot;,

   unique &quot;foo ex:bar/baz&quot;

   is mapped to the following annotation element:

   &lt;nma:unique tag=&quot;ex:foo ex:bar/ex:baz&quot;/&gt;

Sec. 11.2, second paragraph:
----------------------------
NEW

   In a Schematron schema generated by the second mapping step, the
   basic unit of organization is a rule represented by the &lt;sch:rule&gt;
   element.  The following NETMOD-specific annotations from the hybrid
   schema (henceforth called &quot;semantic annotations&quot;) are mapped to
   corresponding Schematron rules: &lt;nma:must&gt;, &lt;nma:unique&gt;, @nma:key,
   @nma:max-elements, @nma:min-elements, @nma:when, @nma:leafref, @nma:
   leaf-list, and also @nma:mandatory appearing as an attribute of &lt;rng:
   choice&gt; (see Section 11.2.1).

Sec. 12.16 (including its title):
---------------------------------
12.16.  The &lt;nma:unique&gt; Annotation

   The mapping of this annotation is similar to @nma:key,
   see Section 12.8, with two small differences:

   o  The value of the @tag attribute of &lt;nma:unique&gt; is a list of
      descendant schema node identifiers rather than simple leaf names.
      However, the XPath expressions specified in Section 12.8 work
      without any modifications if the descendant schema node
      identifiers are substituted for k_1, k_2, ..., k_n.

   o  The message appearing as the text of &lt;sch:report&gt; is different:
      &quot;Violated uniqueness of NODES&quot;, where NODES is the value of the
      @tag attribute.

Appendix A:
-----------
NEW

  &lt;define name=&quot;unique-element&quot;&gt;
    &lt;element name=&quot;nma:unique&quot;&gt;
      &lt;attribute name=&quot;tag&quot;&gt;
        &lt;list&gt;
          &lt;data type=&quot;token&quot;/&gt;
        &lt;/list&gt;
      &lt;/attribute&gt;
    &lt;/element&gt;
  &lt;/define&gt;
</pre>
<b>Notes:</b><br/>
The &#x27;unique&#x27; YANG statement, which is a substatement of &#x27;list&#x27;, has the cardinality of &quot;0..n&quot;. Multiple sibling &#x27;unique&#x27; statements cannot be mapped to a single @nma:unique attribute in the hybrid schema. Therefore, an XML element, &lt;nma:unique&gt;, has to be used for mapping the &#x27;unique&#x27; statement instead of the attribute, much like the it is done for the &#x27;must&#x27; statement.<br/><br/>This change to the mapping of the &#x27;unique&#x27; statement is realized by changing the text of Section 10.55. Several other sections are also affected by this change.
<br/>
</div>

    </body>
</html>
