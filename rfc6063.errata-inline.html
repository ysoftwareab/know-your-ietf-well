<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="robots" content="index,follow" />

        <link rel="icon" href="./css/images/rfc.png" type="image/png" />
        <link rel="shortcut icon" href="./css/images/rfc.png" type="image/png" />
        <title>rfc6063</title>
    
        <link rel="stylesheet" type="text/css" href="./css/errata-base.css"/>
        <link rel="stylesheet" type="text/css" href="./css/errata-color.css" title="Default: Basic Colors"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-monochrome.css" title="Monochrome"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-printer.css" title="Printer"/>

        <script src="./css/errata.js"></script>
    </head>
    <body>
        <div class='Verified-headnote-styling'>
<span style="font-weight: bold;">This is a purely informative rendering of an RFC that includes verified errata.  This rendering may not be used as a reference.</span>
<br/>
<br/>
The following 'Verified' errata have been incorporated in this document:
 <a href='#btn_2948'>EID 2948</a>,  <a href='#btn_2999'>EID 2999</a>
</div>

        <pre>
Internet Engineering Task Force (IETF)                        A. Doherty
Request for Comments: 6063             RSA, The Security Division of EMC
Category: Standards Track                                         M. Pei
ISSN: 2070-1721                                           VeriSign, Inc.
                                                              S. Machani
                                                        Diversinet Corp.
                                                              M. Nystrom
                                                         Microsoft Corp.
                                                           December 2010


          Dynamic Symmetric Key Provisioning Protocol (DSKPP)

Abstract

   The Dynamic Symmetric Key Provisioning Protocol (DSKPP) is a client-
   server protocol for initialization (and configuration) of symmetric
   keys to locally and remotely accessible cryptographic modules.  The
   protocol can be run with or without private key capabilities in the
   cryptographic modules and with or without an established public key
   infrastructure.

   Two variations of the protocol support multiple usage scenarios.
   With the four-pass variant, keys are mutually generated by the
   provisioning server and cryptographic module; provisioned keys are
   not transferred over-the-wire or over-the-air.  The two-pass variant
   enables secure and efficient download and installation of pre-
   generated symmetric keys to a cryptographic module.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 5741.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc6063.

Copyright Notice

   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   1. Introduction ....................................................6
      1.1. Key Words ..................................................6
      1.2. Version Support ............................................6
      1.3. Namespace Identifiers ......................................7
           1.3.1. Defined Identifiers .................................7
           1.3.2. Identifiers Defined in Related Specifications .......7
           1.3.3. Referenced Identifiers ..............................8
   2. Terminology .....................................................8
      2.1. Definitions ................................................8
      2.2. Notation ..................................................10
      2.3. Abbreviations .............................................11
   3. DSKPP Overview .................................................11
      3.1. Protocol Entities .........................................12
      3.2. Basic DSKPP Exchange ......................................12
           3.2.1. User Authentication ................................12
           3.2.2. Protocol Initiated by the DSKPP Client .............14
           3.2.3. Protocol Triggered by the DSKPP Server .............16
           3.2.4. Variants ...........................................17
                  3.2.4.1. Criteria for Using the Four-Pass Variant ..17
                  3.2.4.2. Criteria for Using the Two-Pass Variant ...18
      3.3. Status Codes ..............................................18
      3.4. Basic Constructs ..........................................20
           3.4.1. User Authentication Data (AD) ......................20
                  3.4.1.1. Authentication Code Format ................20
                  3.4.1.2. User Authentication Data Calculation ......23
           3.4.2. The DSKPP One-Way Pseudorandom Function,
                  DSKPP-PRF ..........................................24
           3.4.3. The DSKPP Message Hash Algorithm ...................24
   4. Four-Pass Protocol Usage .......................................25
      4.1. The Key Agreement Mechanism ...............................25
           4.1.1. Data Flow ..........................................25
           4.1.2. Computation ........................................27
      4.2. Message Flow ..............................................28
           4.2.1. KeyProvTrigger .....................................28
           4.2.2. KeyProvClientHello .................................29
           4.2.3. KeyProvServerHello .................................30
           4.2.4. KeyProvClientNonce .................................32
           4.2.5. KeyProvServerFinished ..............................34
   5. Two-Pass Protocol Usage ........................................35
      5.1. Key Protection Methods ....................................36
           5.1.1. Key Transport ......................................36
           5.1.2. Key Wrap ...........................................37
           5.1.3. Passphrase-Based Key Wrap ..........................37
      5.2. Message Flow ..............................................38
           5.2.1. KeyProvTrigger .....................................38
           5.2.2. KeyProvClientHello .................................39

           5.2.3. KeyProvServerFinished ..............................43
   6. Protocol Extensions ............................................44
      6.1. The ClientInfoType Extension ..............................45
      6.2. The ServerInfoType Extension ..............................45
   7. Protocol Bindings ..............................................45
      7.1. General Requirements ......................................45
      7.2. HTTP/1.1 Binding for DSKPP ................................46
           7.2.1. Identification of DSKPP Messages ...................46
           7.2.2. HTTP Headers .......................................46
           7.2.3. HTTP Operations ....................................47
           7.2.4. HTTP Status Codes ..................................47
           7.2.5. HTTP Authentication ................................47
           7.2.6. Initialization of DSKPP ............................47
           7.2.7. Example Messages ...................................48
   8. DSKPP XML Schema ...............................................49
      8.1. General Processing Requirements ...........................49
      8.2. Schema ....................................................49
   9. Conformance Requirements .......................................58
   10. Security Considerations .......................................59
      10.1. General ..................................................59
      10.2. Active Attacks ...........................................60
           10.2.1. Introduction ......................................60
           10.2.2. Message Modifications .............................60
           10.2.3. Message Deletion ..................................61
           10.2.4. Message Insertion .................................62
           10.2.5. Message Replay ....................................62
           10.2.6. Message Reordering ................................62
           10.2.7. Man in the Middle .................................63
      10.3. Passive Attacks ..........................................63
      10.4. Cryptographic Attacks ....................................63
      10.5. Attacks on the Interaction between DSKPP and User
            Authentication ...........................................64
      10.6. Miscellaneous Considerations .............................65
           10.6.1. Client Contributions to K_TOKEN Entropy ...........65
           10.6.2. Key Confirmation ..................................65
           10.6.3. Server Authentication .............................65
           10.6.4. User Authentication ...............................66
           10.6.5. Key Protection in Two-Pass DSKPP ..................66
           10.6.6. Algorithm Agility .................................67
   11. Internationalization Considerations ...........................68
   12. IANA Considerations ...........................................68
      12.1. URN Sub-Namespace Registration ...........................68
      12.2. XML Schema Registration ..................................69
      12.3. MIME Media Type Registration .............................69
      12.4. Status Code Registration .................................70
      12.5. DSKPP Version Registration ...............................70
      12.6. PRF Algorithm ID Sub-Registry ............................70
           12.6.1. DSKPP-PRF-AES .....................................71

           12.6.2. DSKPP-PRF-SHA256 ..................................71
      12.7. Key Container Registration ...............................72
   13. Intellectual Property Considerations ..........................73
   14. Contributors ..................................................73
   15. Acknowledgements ..............................................73
   16. References ....................................................74
      16.1. Normative References .....................................74
      16.2. Informative References ...................................76
   Appendix A.  Usage Scenarios ......................................78
     A.1.  Single Key Request ........................................78
     A.2.  Multiple Key Requests .....................................78
     A.3.  User Authentication .......................................78
     A.4.  Provisioning Time-Out Policy ............................78
     A.5.  Key Renewal ...............................................79
     A.6.  Pre-Loaded Key Replacement ..............................79
     A.7.  Pre-Shared Manufacturing Key ............................79
     A.8.  End-to-End Protection of Key Material ...................80
   Appendix B.  Examples .............................................80
     B.1.  Trigger Message ...........................................80
     B.2.  Four-Pass Protocol ......................................81
       B.2.1.  &lt;KeyProvClientHello&gt; without a Preceding Trigger ......81
       B.2.2.  &lt;KeyProvClientHello&gt; Assuming a Preceding Trigger .....82
       B.2.3.  &lt;KeyProvServerHello&gt; Without a Preceding Trigger ......83
       B.2.4.  &lt;KeyProvServerHello&gt; Assuming Key Renewal .............84
       B.2.5.  &lt;KeyProvClientNonce&gt; Using Default Encryption .........85
       B.2.6.  &lt;KeyProvServerFinished&gt; Using Default Encryption ......85
     B.3.  Two-Pass Protocol .......................................86
       B.3.1.  Example Using the Key Transport Method ................86
       B.3.2.  Example Using the Key Wrap Method .....................90
       B.3.3.  Example Using the Passphrase-Based Key Wrap Method ..94
   Appendix C.  Integration with PKCS #11 ............................98
     C.1.  The Four-Pass Variant ...................................98
     C.2.  The Two-Pass Variant ....................................98
   Appendix D.  Example of DSKPP-PRF Realizations .................101
     D.1.  Introduction .............................................101
     D.2.  DSKPP-PRF-AES ..........................................101
       D.2.1.  Identification .......................................101
       D.2.2.  Definition ...........................................101
       D.2.3.  Example ..............................................102
     D.3.  DSKPP-PRF-SHA256 .......................................103
       D.3.1.  Identification .......................................103
       D.3.2.  Definition ...........................................103
       D.3.3.  Example ..............................................104

1.  Introduction

   Symmetric-key-based cryptographic systems (e.g., those providing
   authentication mechanisms such as one-time passwords and challenge-
   response) offer performance and operational advantages over public
   key schemes.  Such use requires a mechanism for the provisioning of
   symmetric keys providing equivalent functionality to mechanisms such
   as the Certificate Management Protocol (CMP) [RFC4210] and
   Certificate Management over CMS (CMC) [RFC5272] in a Public Key
   Infrastructure.

   Traditionally, cryptographic modules have been provisioned with keys
   during device manufacturing, and the keys have been imported to the
   cryptographic server using, e.g., a CD-ROM disc shipped with the
   devices.  Some vendors also have proprietary provisioning protocols,
   which often have not been publicly documented (the Cryptographic
   Token Key Initialization Protocol (CT-KIP) is one exception
   [RFC4758]).

   This document describes the Dynamic Symmetric Key Provisioning
   Protocol (DSKPP), a client-server protocol for provisioning symmetric
   keys between a cryptographic module (corresponding to DSKPP Client)
   and a key provisioning server (corresponding to DSKPP Server).

   DSKPP provides an open and interoperable mechanism for initializing
   and configuring symmetric keys to cryptographic modules that are
   accessible over the Internet.  The description is based on the
   information contained in [RFC4758], and contains specific
   enhancements, such as user authentication and support for the
   [RFC6030] format for transmission of keying material.

   DSKPP has two principal protocol variants.  The four-pass protocol
   variant permits a symmetric key to be established that includes
   randomness contributed by both the client and the server.  The two-
   pass protocol requires only one round trip instead of two and permits
   a server specified key to be established.

1.1.  Key Words

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [RFC2119].

1.2.  Version Support

   There is a provision made in the syntax for an explicit version
   number.  Only version &quot;1.0&quot; is currently specified.

   The purpose for versioning the protocol is to provide a mechanism by
   which changes to required cryptographic algorithms (e.g., SHA-256)
   and attributes (e.g., key size) can be deployed without disrupting
   existing implementations; likewise, outdated implementations can be
   de-commissioned without disrupting operations involving newer
   protocol versions.

   The numbering scheme for DSKPP versions is &quot;&lt;major&gt;.&lt;minor&gt;&quot;.  The
   major and minor numbers MUST be treated as separate integers and each
   number MAY be incremented higher than a single digit.  Thus, &quot;DSKPP
   2.4&quot; would be a lower version than &quot;DSKPP 2.13&quot;, which in turn would
   be lower than &quot;DSKPP 12.3&quot;.  Leading zeros (e.g., &quot;DSKPP 6.01&quot;) MUST
   be ignored by recipients and MUST NOT be sent.

   The major version number should be incremented only if the data
   formats or security algorithms have changed so dramatically that an
   older version implementation would not be able to interoperate with a
   newer version (e.g., removing support for a previously mandatory-to-
   implement algorithm now found to be insecure).  The minor version
   number indicates new capabilities (e.g., introducing a new algorithm
   option) and MUST be ignored by an entity with a smaller minor version
   number but be used for informational purposes by the entity with the
   larger minor version number.

1.3.  Namespace Identifiers

   This document uses Uniform Resource Identifiers (URIs) [RFC3986] to
   identify resources, algorithms, and semantics.

1.3.1.  Defined Identifiers

   The XML namespace [XMLNS] URI for Version 1.0 of DSKPP is:

   &quot;urn:ietf:params:xml:ns:keyprov:dskpp&quot;

   References to qualified elements in the DSKPP schema defined herein
   use the prefix &quot;dskpp&quot;, but any prefix is allowed.

1.3.2.  Identifiers Defined in Related Specifications

   This document relies on qualified elements already defined in the
   Portable Symmetric Key Container [RFC6030] namespace, which is
   represented by the prefix &quot;pskc&quot; and declared as:

   xmlns:pskc=&quot;urn:ietf:params:xml:ns:keyprov:pskc&quot;

1.3.3.  Referenced Identifiers

   Finally, the DSKPP syntax presented in this document relies on
   algorithm identifiers defined in the XML Signature [XMLDSIG]
   namespace:

   xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;

   References to algorithm identifiers in the XML Signature namespace
   are represented by the prefix &quot;ds&quot;.

2.  Terminology

2.1.  Definitions

   Terms are defined below as they are used in this document.  The same
   terms may be defined differently in other documents.

   Authentication Code (AC):  User Authentication Code comprised of a
      string of hexadecimal characters known to the device and the
      server and containing at a minimum a client identifier and a
      password.  This ClientID/password combination is used only once
      and may have a time limit, and then discarded.

   Authentication Data (AD):  User Authentication Data that is derived
      from the Authentication Code (AC)

   Client ID:  An identifier that the DSKPP Server uses to locate the
      real username or account identifier on the server.  It can be a
      short random identifier that is unrelated to any real usernames.

   Cryptographic Module:  A component of an application, which enables
      symmetric key cryptographic functionality

   Device:  A physical piece of hardware, or a software framework, that
      hosts symmetric key cryptographic modules

   Device ID (DeviceID):  A unique identifier for the device that houses
      the cryptographic module, e.g., a mobile phone

   DSKPP Client:  Manages communication between the symmetric key
      cryptographic module and the DSKPP Server

   DSKPP Server:  The symmetric key provisioning server that
      participates in the DSKPP run

   DSKPP Server ID (ServerID):  The unique identifier of a DSKPP Server

   Key Agreement:  A key establishment protocol whereby two or more
      parties can agree on a key in such a way that both influence the
      outcome

   Key Confirmation:  The assurance of the rightful participants in a
      key-establishment protocol that the intended recipient of the
      shared key actually possesses the shared key

   Key Issuer:  An organization that issues symmetric keys to end-users

   Key Package (KP):  An object that encapsulates a symmetric key and
      its configuration data

   Key ID (KeyID):  A unique identifier for the symmetric key

   Key Protection Method (KPM):  The key transport method used during
      two-pass DSKPP

   Key Protection Method List (KPML):  The list of key protection
      methods supported by a cryptographic module

   Key Provisioning Server:  A lifecycle management system that provides
      a key issuer with the ability to provision keys to cryptographic
      modules hosted on end-users&#x27; devices

   Key Transport:  A key establishment procedure whereby the DSKPP
      Server selects and encrypts the keying material and then sends the
      material to the DSKPP Client [NIST-SP800-57]

   Key Transport Key:  The private key that resides on the cryptographic
      module.  This key is paired with the DSKPP Client&#x27;s public key,
      which the DSKPP Server uses to encrypt keying material during key
      transport [NIST-SP800-57]

   Key Type:  The type of symmetric key cryptographic methods for which
      the key will be used (e.g., Open AUTHentication HMAC-Based One-
      Time Password (OATH HOTP) or RSA SecurID authentication, AES
      encryption, etc.)

   Key Wrapping:  A method of encrypting keys for key transport
      [NIST-SP800-57]

   Key Wrapping Key:  A symmetric key encrypting key used for key
      wrapping [NIST-SP800-57]

   Keying Material:  The data necessary (e.g., keys and key
      configuration data) necessary to establish and maintain
      cryptographic keying relationships [NIST-SP800-57]

   Manufacturer&#x27;s Key:  A unique master key pre-issued to a hardware
      device, e.g., a smart card, during the manufacturing process.  If
      present, this key may be used by a cryptographic module to derive
      secret keys

   Protocol Run:  Complete execution of the DSKPP that involves one
      exchange (two-pass) or two exchanges (four-pass)

   Security Attribute List (SAL):  A payload that contains the DSKPP
      version, DSKPP variant (four- or two-pass), key package formats,
      key types, and cryptographic algorithms that the cryptographic
      module is capable of supporting

2.2.  Notation

   ||                    String concatenation
   [x]                   Optional element x
   A ^ B                 Exclusive-OR operation on strings A and B
                         (where A and B are of equal length)
   &lt;XMLElement&gt;          A typographical convention used in the body of
                         the text
   DSKPP-PRF(k,s,dsLen)  A keyed pseudorandom function
   E(k,m)                Encryption of m with the key k
   K                     Key used to encrypt R_C (either K_SERVER or
                         K_SHARED), or in MAC or DSKPP_PRF computations
   K_AC                  Secret key that is derived from the
                         Authentication Code and used for user
                         authentication purposes
   K_MAC                 Secret key derived during a DSKPP exchange for
                         use with key confirmation
   K_MAC&#x27;                A second secret key used for server
                         authentication
   K_PROV                A provisioning master key from which two keys
                         are derived: K_TOKEN and K_MAC
   K_SERVER              Public key of the DSKPP Server; used for
                         encrypting R_C in the four-pass protocol
                         variant

   K_SHARED              Secret key that is pre-shared between the DSKPP
                         Client and the DSKPP Server; used for
                         encrypting R_C in the four-pass protocol
                         variant
   K_TOKEN               Secret key that is established in a
                         cryptographic module using DSKPP
   R                     Pseudorandom value chosen by the DSKPP Client
                         and used for MAC computations
   R_C                   Pseudorandom value chosen by the DSKPP Client
                         and used as input to the generation of K_TOKEN
   R_S                   Pseudorandom value chosen by the DSKPP Server
                         and used as input to the generation of K_TOKEN
   URL_S                 DSKPP Server address, as a URL

2.3.  Abbreviations

   AC      Authentication Code
   AD      Authentication Data
   DSKPP   Dynamic Symmetric Key Provisioning Protocol
   HTTP    Hypertext Transfer Protocol
   KP      Key Package
   KPM     Key Protection Method
   KPML    Key Protection Method List
   MAC     Message Authentication Code
   PC      Personal Computer
   PDU     Protocol Data Unit
   PKCS    Public Key Cryptography Standards
   PRF     Pseudorandom Function
   PSKC    Portable Symmetric Key Container
   SAL     Security Attribute List (see Section 2.1)
   TLS     Transport Layer Security
   URL     Uniform Resource Locator
   USB     Universal Serial Bus
   XML     eXtensible Markup Language

3.  DSKPP Overview

   The following sub-sections provide a high-level view of protocol
   internals and how they interact with external provisioning
   applications.  Usage scenarios are provided in Appendix A.

3.1.  Protocol Entities

   A DSKPP provisioning transaction has three entities:

   Server:   The DSKPP provisioning server.

   Cryptographic Module:  The cryptographic module to which the
      symmetric keys are to be provisioned, e.g., an authentication
      token.

   Client:  The DSKPP Client that manages communication between the
      cryptographic module and the key provisioning server.

   The principal syntax is XML [XML] and it is layered on a transport
   mechanism such as HTTP [RFC2616] and HTTP Over TLS [RFC2818].  While
   it is highly desirable for the entire communication between the DSKPP
   Client and server to be protected by means of a transport providing
   confidentiality and integrity protection such as HTTP over Transport
   Layer Security (TLS), such protection is not sufficient to protect
   the exchange of the symmetric key data between the server and the
   cryptographic module and DSKPP is designed to permit implementations
   that satisfy this requirement.

   The server only communicates to the client.  As far as the server is
   concerned, the client and cryptographic module may be considered to
   be a single entity.

   From a client-side security perspective, however, the client and the
   cryptographic module are separate logical entities and may in some
   implementations be separate physical entities as well.

   It is assumed that a device will host an application layered above
   the cryptographic module, and this application will manage
   communication between the DSKPP Client and cryptographic module.  The
   manner in which the communicating application will transfer DSKPP
   elements to and from the cryptographic module is transparent to the
   DSKPP Server.  One method for this transfer is described in
   [CT-KIP-P11].

3.2.  Basic DSKPP Exchange

3.2.1.  User Authentication

   In a DSKPP message flow, the user has obtained a new hardware or
   software device embedded with a cryptographic module.  The goal of
   DSKPP is to provision the same symmetric key and related information
   to the cryptographic module and the key management server, and

   associate the key with the correct username (or other account
   identifier) on the server.  To do this, the DSKPP Server MUST
   authenticate the user to be sure he is authorized for the new key.

   User authentication occurs within the protocol itself *after* the
   DSKPP Client initiates the first message.  In this case, the DSKPP
   Client MUST have access to the DSKPP Server URL.

   Alternatively, a DSKPP web service or other form of web application
   can authenticate a user *before* the first message is exchanged.  In
   this case, the DSKPP Server MUST trigger the DSKPP Client to initiate
   the first message in the protocol transaction.

3.2.2.  Protocol Initiated by the DSKPP Client

   In the following example, the DSKPP Client first initiates DSKPP, and
   then the user is authenticated using a Client ID and Authentication
   Code.

   Crypto       DSKPP                          DSKPP    Key Provisioning
   Module       Client                         Server        Server
    |             |                              |             |
    |             |                              |     +---------------+
    |             |                              |     |Server creates |
    |             |                              |     |and stores     |
    |             |                              |     |Client ID and  |
    |             |                              |     |Auth. Code and |
    |             |                              |     |delivers them  |
    |             |                              |     |to user out-of-|
    |             |                              |     |band.          |
    |             |                              |     +---------------+
    |             |                              |             |
    |  +----------------------+                  |             |
    |  |User enters Client ID,|                  |             |
    |  |Auth. Code, and URL   |                  |             |
    |  +----------------------+                  |             |
    |             |                              |             |
    |             |&lt;-- 1. TLS handshake with ---&gt;|             |
    |             |        server auth.          |             |
    |             |                              |             |
    |             | 2. &lt;KeyProvClientHello&gt; ----&gt;|     User --&gt;|
    |             |                              |     Auth.   |
    |             |&lt;-- [3. &lt;KeyProvServerHello&gt;] |             |
    |             |                              |             |
    |             | [4. &lt;KeyProvClientNonce&gt;] --&gt;|             |
    |             |                              |             |
    |             |&lt;- 5. &lt;KeyProvServerFinished&gt; |             |
    |             |                              |             |
    |             |                              |             |
    |&lt;-- Key      |                              |      Key --&gt;|
    |    Package  |                              |   Package   |

                      Figure 1: Basic DSKPP Exchange

   Before DSKPP begins:
   o  The Authentication Code is generated by the DSKPP Server, and
      delivered to the user via an out-of-band trustworthy channel
      (e.g., a paper slip delivered by IT department staff).
   o  The user typically enters the Client ID and Authentication Code
      manually, possibly on a device with only a numeric keypad.  Thus,
      they are often short numeric values (for example, 8 decimal
      digits).  However, the DSKPP Server is free to generate them in
      any way it wishes.
   o  The DSKPP Client needs the URL [RFC3986] of the DSKPP Server
      (which is not user specific or secret, and may be pre-configured
      somehow), and a set of trust anchors for verifying the server
      certificate.
   o  There must be an account for the user that has an identifier and
      long-term username (or other account identifier) to which the
      token will be associated.  The DSKPP Server will use the Client ID
      to find the corresponding Authentication Code for user
      authentication.

   In Step 1, the client establishes a TLS connection, authenticates the
   server (that is, validates the certificate, and compares the host
   name in the URL with the certificate) as described in Section 3.1 of
   [RFC2818].

   Next, the DSKPP Client and DSKPP Server exchange DSKPP messages
   (which are sent over HTTPS).  In these messages:
   o  The client and server negotiate which cryptographic algorithms
      they want to use, which algorithms are supported for protecting
      DSKPP messages, and other DSKPP details.
   o  The client sends the Client ID to the server, and proves that it
      knows the corresponding Authentication Code.
   o  The client and server agree on a secret key (token key or
      K_TOKEN); depending on the negotiated protocol variant, this is
      either a fresh key derived during the DSKPP run (called &quot;four-pass
      variant&quot;, since it involves four DSKPP messages) or is generated
      by (or pre-exists on) the server and transported to the client
      (called &quot;two-pass variant&quot; in the rest of this document, since it
      involves two DSKPP messages).
   o  The server sends a &quot;key package&quot; to the client.  The package only
      includes the key itself in the case of the &quot;two-pass variant&quot;;
      with either variant, the key package contains attributes that
      influence how the provisioned key will be later used by the
      cryptographic module and cryptographic server.  The exact contents
      depend on the cryptographic algorithm (e.g., for a one-time
      password algorithm that supports variable-length OTP values, the
      length of the OTP value would be one attribute in the key
      package).

   After the protocol run has been successfully completed, the
   cryptographic modules stores the contents of the key package.
   Likewise, the DSKPP provisioning server stores the contents of the
   key package with the cryptographic server, and associates these with
   the correct username.  The user can now use the their device to
   perform symmetric-key based operations.

   The exact division of work between the cryptographic module and the
   DSKPP Client -- and key Provisioning server and DSKPP Server -- are
   not specified in this document.  The figure above shows one possible
   case, but this is intended for illustrative purposes only.

3.2.3.  Protocol Triggered by the DSKPP Server

   In the first message flow (previous section), the Client ID and
   Authentication Code were delivered to the client by some out-of-band
   means (such as paper sent to the user).

   Web           DSKPP                          DSKPP            Web
   Browser       Client                         Server          Server
     |              |                              |               |
     |&lt;-------- HTTPS browsing + some kind of user auth. ---------&gt;|
     |              |                              |               |
     | some HTTP request -----------------------------------------&gt;|
     |              |                              |
     |              |                              |&lt;-------------&gt;|
     |              |                              |               |
     |&lt;----------------------- HTTP response with &lt;KeyProvTrigger&gt; |
     |              |                              |               |
     | Trigger ----&gt;|                              |               |
     |              |                              |               |
     |              |&lt;-- 1. TLS handshake with ---&gt;|               |
     |              |        server auth.          |               |
     |              |                              |               |
     |              |     ... continues...         |               |

          Figure 2: DSKPP Exchange with Web-Based Authentication

   In the second message flow, the user first authenticates to a web
   server (for example, an IT department&#x27;s &quot;self-service&quot; Intranet
   page), using an ordinary web browser and some existing credentials.

   The user then requests (by clicking a link or submitting a form)
   provisioning of a new key to the cryptographic module.  The web
   server will reply with a &lt;KeyProvTrigger&gt; message that contains the
   Client ID, Authentication Code, and URL of the DSKPP Server.  This
   information is also needed by the DSKPP Server; how the web server
   and DSKPP Server interact is beyond the scope of this document.

   The &lt;KeyProvTrigger&gt; message is sent in an HTTP response, and it is
   marked with MIME type &quot;application/dskpp+xml&quot;.  It is assumed the web
   browser has been configured to recognize this MIME type; the browser
   will start the DSKPP Client and provide it with the &lt;KeyProvTrigger&gt;
   message.

   The DSKPP Client then contacts the DSKPP Server and uses the Client
   ID and Authentication Code (from the &lt;KeyProvTrigger&gt; message) the
   same way as in the first message flow.

3.2.4.  Variants

   As noted in the previous section, once the protocol has started, the
   client and server MAY engage in either a two-pass or four-pass
   message exchange.  The four-pass and two-pass protocols are
   appropriate in different deployment scenarios.  The biggest
   differentiator between the two is that the two-pass protocol supports
   transport of an existing key to a cryptographic module, while the
   four-pass involves key generation on-the-fly via key agreement.  In
   either case, both protocol variants support algorithm agility through
   the negotiation of encryption mechanisms and key types at the
   beginning of each protocol run.

3.2.4.1.  Criteria for Using the Four-Pass Variant

   The four-pass protocol is needed under one or more of the following
   conditions:

   o  Policy requires that both parties engaged in the protocol jointly
      contribute entropy to the key.  Enforcing this policy mitigates
      the risk of exposing a key during the provisioning process as the
      key is generated through mutual agreement without being
      transferred over-the-air or over-the-wire.  It also mitigates risk
      of exposure after the key is provisioned, as the key will not be
      vulnerable to a single point of attack in the system.

   o  A cryptographic module does not have private key capabilities.

   o  The cryptographic module is hosted by a device that neither was
      pre-issued with a manufacturer&#x27;s key or other form of pre-shared
      key (as might be the case with a smart card or Subscriber Identity
      Module (SIM) card) nor has a keypad that can be used for entering
      a passphrase (such as present on a mobile phone).

3.2.4.2.  Criteria for Using the Two-Pass Variant

   The two-pass protocol is needed under one or more of the following
   conditions:

   o  Pre-existing (i.e., legacy) keys must be provisioned via transport
      to the cryptographic module.

   o  The cryptographic module is hosted on a device that was pre-issued
      with a manufacturer&#x27;s key (such as may exist on a smart card), or
      other form of pre-shared key (such as may exist on a SIM-card),
      and is capable of performing private key operations.

   o  The cryptographic module is hosted by a device that has a built-in
      keypad with which a user may enter a passphrase, useful for
      deriving a key wrapping key for distribution of keying material.

3.3.  Status Codes

   Upon transmission or receipt of a message for which the Status
   attribute&#x27;s value is not &quot;Success&quot; or &quot;Continue&quot;, the default
   behavior, unless explicitly stated otherwise below, is that both the
   DSKPP Server and the DSKPP Client MUST immediately terminate the
   DSKPP run.  DSKPP Servers and DSKPP Clients MUST delete any secret
   values generated as a result of failed runs of DSKPP.  Session
   identifiers MAY be retained from successful or failed protocol runs
   for replay detection purposes, but such retained identifiers MUST NOT
   be reused for subsequent runs of the protocol.

   When possible, the DSKPP Client SHOULD present an appropriate error
   message to the user.

   These status codes are valid in all DSKPP Response messages unless
   explicitly stated otherwise:

   Continue:  The DSKPP Server is ready for a subsequent request from
      the DSKPP Client.  It cannot be sent in the server&#x27;s final
      message.

   Success:  Successful completion of the DSKPP session.  It can only be
      sent in the server&#x27;s final message.

   Abort:  The DSKPP Server rejected the DSKPP Client&#x27;s request for
      unspecified reasons.

   AccessDenied:  The DSKPP Client is not authorized to contact this
      DSKPP Server.

   MalformedRequest:  The DSKPP Server failed to parse the DSKPP
      Client&#x27;s request.

   UnknownRequest:  The DSKPP Client made a request that is unknown to
      the DSKPP Server.

   UnknownCriticalExtension:  A DSKPP extension marked as &quot;Critical&quot;
      could not be interpreted by the receiving party.

   UnsupportedVersion:  The DSKPP Client used a DSKPP version not
      supported by the DSKPP Server.  This error is only valid in the
      DSKPP Server&#x27;s first response message.

   NoSupportedKeyTypes:  &quot;NoSupportedKeyTypes&quot; indicates that the DSKPP
      Client only suggested key types that are not supported by the
      DSKPP Server.  This error is only valid in the DSKPP Server&#x27;s
      first response message.

   NoSupportedEncryptionAlgorithms:  The DSKPP Client only suggested
      encryption algorithms that are not supported by the DSKPP Server.
      This error is only valid in the DSKPP Server&#x27;s first response
      message.

   NoSupportedMacAlgorithms:  The DSKPP Client only suggested MAC
      algorithms that are not supported by the DSKPP Server.  This error
      is only valid in the DSKPP Server&#x27;s first response message.

   NoProtocolVariants:  The DSKPP Client did not suggest a required
      protocol variant (either two-pass or four-pass).  This error is
      only valid in the DSKPP Server&#x27;s first response message.

   NoSupportedKeyPackages:  The DSKPP Client only suggested key package
      formats that are not supported by the DSKPP Server.  This error is
      only valid in the DSKPP Server&#x27;s first response message.

   AuthenticationDataMissing:  The DSKPP Client didn&#x27;t provide
      Authentication Data that the DSKPP Server required.

   AuthenticationDataInvalid:  The DSKPP Client supplied User
      Authentication Data that the DSKPP Server failed to validate.

   InitializationFailed:  The DSKPP Server could not generate a valid
      key given the provided data.  When this status code is received,
      the DSKPP Client SHOULD try to restart DSKPP, as it is possible
      that a new run will succeed.

   ProvisioningPeriodExpired:  The provisioning period set by the DSKPP
      Server has expired.  When the status code is received, the DSKPP
      Client SHOULD report the reason for key initialization failure to
      the user and the user MUST register with the DSKPP Server to
      initialize a new key.

3.4.  Basic Constructs

   The following calculations are used in both DSKPP variants.

3.4.1.  User Authentication Data (AD)

   User Authentication Data (AD) is derived from a Client ID and
   Authentication Code that the user enters before the first DSKPP
   message is sent.

   Note: The user will typically enter the Client ID and Authentication
   Code manually, possibly on a device with only numeric keypad.  Thus,
   they are often short numeric values (for example, 8 decimal digits).
   However, the DSKPP Server is free to generate them in any way it
   wishes.

3.4.1.1.  Authentication Code Format

   AC is encoded in Type-Length-Value (TLV) format.  The format consists
   of a minimum of two TLVs and a variable number of additional TLVs,
   depending on implementation.

   The TLV fields are defined as follows:

   Type (1 character)        A hexadecimal character identifying the
                             type of information contained in the Value
                             field.

   Length (2 characters)     Two hexadecimal characters indicating the
                             length of the Value field to follow.  The
                             field value MAY be up to 255 characters.
                             The Length value 00 MAY be used to specify
                             custom tags without any field values.

   Value (variable length)   A variable-length string of hexadecimal
                             characters containing the instance-specific
                             information for this TLV.

   The following table summarizes the TLVs defined in this document.
   Optional TLVs are allowed for vendor-specific extensions with the
   constraint that the high bit MUST be set to indicate a vendor-
   specific type.  Other TLVs are left for later revisions of this
   protocol.

   +------+------------+-------------------------------------------+
   | Type | TLV Name   | Conformance | Example Usage               |
   +------+------------+-------------------------------------------+
   |  1   | Client ID  | Mandatory   | { &quot;AC00000A&quot; }              |
   +------+------------+-------------+-----------------------------+
   |  2   | Password   | Mandatory   | { &quot;3582AF0C3E&quot; }            |
   +------+------------+-------------+-----------------------------+
   |  3   | Checksum   | Optional    | { &quot;4D5&quot; }                   |
   +------+------------+-------------+-----------------------------+

   The Client ID is a mandatory TLV that represents the requester&#x27;s
   identifier of maximum length 255.  The value is represented as a
   string of hexadecimal characters that identifies the key request.
   For example, suppose Client ID is set to &quot;AC00000A&quot;, the Client ID
   TLV in the AC will be represented as &quot;108AC00000A&quot;.

   The Password is a mandatory TLV the contains a one-time use shared
   secret known by the user and the Provisioning Server.  The Password
   value is unique and SHOULD be a random string to make AC more
   difficult to guess.  The string MUST contain hexadecimal characters
   only.  For example, suppose password is set to &quot;3582AF0C3E&quot;, then the
   Password TLV would be &quot;20A3582AF0C3E&quot;.

   The Checksum is an OPTIONAL TLV, which is generated by the issuing
   server and sent to the user as part of the AC.  If the TLV is
   provided, the checksum value MUST be computed using the CRC16
   algorithm [ISO3309].  When the user enters the AC, the typed AC
   string of characters is verified with the checksum to ensure it is
   correctly entered by the user.  For example, suppose the AC with
   combined Client ID tag and Password tag is set to
   &quot;108AC00000A20A3582AF0C3E&quot;, then the CRC16 calculation would generate
   a checksum of 0x356, resulting in a Checksum TLV of &quot;334D5&quot;.  The
   complete AC string in this example would be
   &quot;108AC00000A20A3582AF0C3E3034D5&quot;.

   Although this specification recommends using hexadecimal characters
   only for the AC at the application&#x27;s user interface layer and making
   the TLV triples non-transparent to the user as described in the
   example above; implementations MAY additionally choose to use other
   printable Unicode characters [UNICODE] at the application&#x27;s user
   interface layer in order to meet specific local, context or usability
   requirements.  When non-hexadecimal characters are desired at the

   user interface layer such as when other printable US-ASCII characters
   or international characters are used, SASLprep [RFC4013] MUST be used
   to normalize user input before converting it to a string of
   hexadecimal characters.  For example, if a given application allows
   the use of any printable US-ASCII characters and extended ASCII
   characters for Client ID and Password fields, and the Client ID is
   set to &quot;myclient!D&quot; and the associated Password is set to
   &quot;mYpas&amp;#rD&quot;, the user enters through the keyboard or other means a
   Client ID of &quot;myclient!D&quot; and a Password of &quot;mYpas&amp;#rD&quot; in separate
   form fields or as instructed by the provider.  The application&#x27;s
   layer processing user input MUST then convert the values entered by
   the user to the following string for use in the protocol:
   &quot;1146D79636C69656E7421442126D5970617326237244&quot; (note that in this
   example the Checksum TLV is not added).

   The example is explained further below in detail:

   Assume that the raw Client ID value or the value entered by the use
   is: myclient!ID

   The Client ID value as characters names is:

      U+006D LATIN SMALL LETTER M character
      U+0079 LATIN SMALL LETTER Y character
      U+0063 LATIN SMALL LETTER C character
      U+006C LATIN SMALL LETTER L character
      U+0069 LATIN SMALL LETTER I character
      U+0065 LATIN SMALL LETTER E character
      U+006E LATIN SMALL LETTER N character
      U+0074 LATIN SMALL LETTER T character
      U+0021 EXCLAMATION MARK character (!)
      U+0044 LATIN CAPITAL LETTER D character

   The UTF-8 conversion of the Client ID value is: 6D 79 63 6C 69 65 6E
   74 21 44

   The length of the Client ID value in hexadecimal characters is: 14

   The TLV presentation of the Client ID field is:
   1146D79636C69656E742144

   The raw Password value or the value entered by the user is: mYpas&amp;#rD

   The Password value as character names is:

      U+006D LATIN SMALL LETTER M character
      U+0059 LATIN LARGE LETTER Y character
      U+0070 LATIN SMALL LETTER P character

      U+0061 LATIN SMALL LETTER A character
      U+0073 LATIN SMALL LETTER S character
      U+0026 AMPERSAND character (&amp;)
      U+0023 POUND SIGN character (#)
      U+0072 LATIN SMALL LETTER R character
      U+0044 LATIN LARGE LETTER D character

   The UTF-8 conversion of the password value is: 6D 59 70 61 73 26 23
   72 44

   The length of the password value in hexadecimal characters is: 12

   The TLV presentation of the password field is: 2126D5970617326237244

   The combined Client ID and password fields value or the AC value is:
   1146D79636C69656E7421442126D5970617326237244

3.4.1.2.  User Authentication Data Calculation

   The Authentication Data consists of a Client ID (extracted from the
   AC) and a value, which is derived from AC as follows (refer to
   Section 3.4.2 for a description of DSKPP-PRF in general and
   Appendix D for a description of DSKPP-PRF-AES):

   MAC = DSKPP-PRF(K_AC, AC-&gt;ClientID||URL_S||R_C||[R_S], 16)

   In four-pass DSKPP, the cryptographic module uses R_C, R_S, and URL_S
   to calculate the MAC, where URL_S is the URL the DSKPP Client uses
   when contacting the DSKPP Server.  In two-pass DSKPP, the
   cryptographic module does not have access to R_S, therefore only R_C
   is used in combination with URL_S to produce the MAC.  In either
   case, K_AC MUST be derived from AC-&gt;password as follows [PKCS-5]:

   K_AC = PBKDF2(AC-&gt;password, R_C || K, iter_count, 16)

   One of the following values for K MUST be used:

   a.  In four-pass:
       *  The public key of the DSKPP Server (K_SERVER), or (in the pre-
          shared key variant) the pre-shared key between the client and
          the server (K_SHARED).
   b.  In two-pass:
       *  The public key of the DSKPP Client, or the public key of the
          device when a device certificate is available.
       *  The pre-shared key between the client and the server
          (K_SHARED).
       *  A passphrase-derived key.

   The iteration count, iter_count, MUST be set to at least 100,000
   except in the last two two-pass cases (where K is set to K_SHARED or
   a passphrase-derived key), in which case iter_count MUST be set to 1.

3.4.2.  The DSKPP One-Way Pseudorandom Function, DSKPP-PRF

   Regardless of the protocol variant employed, there is a requirement
   for a cryptographic primitive that provides a deterministic
   transformation of a secret key k and a varying length octet string s
   to a bit string of specified length dsLen.

   This primitive must meet the same requirements as for a keyed hash
   function: it MUST take an arbitrary length input and generate an
   output that is one way and collision free (for a definition of these
   terms, see, e.g., [FAQ]).  Further, its output MUST be unpredictable
   even if other outputs for the same key are known.

   From the point of view of this specification, DSKPP-PRF is a &quot;black-
   box&quot; function that, given the inputs, generates a pseudorandom value
   and MAY be realized by any appropriate and competent cryptographic
   technique.  Appendix D contains two example realizations of DSKPP-
   PRF.

   DSKPP-PRF(k, s, dsLen)

   Input:

   k     secret key in octet string format
   s     octet string of varying length consisting of variable data
         distinguishing the particular string being derived
   dsLen desired length of the output

   Output:

   DS    pseudorandom string, dsLen octets long

   For the purposes of this document, the secret key k MUST be at least
   16 octets long.

3.4.3.  The DSKPP Message Hash Algorithm

   When sending its last message in a protocol run, the DSKPP Server
   generates a MAC that is used by the client for key confirmation.
   Computation of the MAC MUST include a hash of all DSKPP messages sent
   by the client and server during the transaction.  To compute a
   message hash for the MAC given a sequence of DSKPP messages msg_1,
   ..., msg_n, the following operations MUST be carried out:

   a.  The sequence of messages contains all DSKPP Request and Response
       messages up to but not including this message.
   b.  Re-transmitted messages are removed from the sequence of
       messages.
       Note: The resulting sequence of messages MUST be an alternating
       sequence of DSKPP Request and DSKPP Response messages
   c.  The contents of each message is concatenated together.
   d.  The resultant string is hashed using SHA-256 in accordance with
       [FIPS180-SHA].

4.  Four-Pass Protocol Usage

   This section describes the methods and message flow that comprise the
   four-pass protocol variant.  Four-pass DSKPP depends on a client-
   server key agreement mechanism.

4.1.  The Key Agreement Mechanism

   With four-pass DSKPP, the symmetric key that is the target of
   provisioning, is generated on-the-fly without being transferred
   between the DSKPP Client and DSKPP Server.  The data flow and
   computation are described below.

4.1.1.  Data Flow

   A sample data flow showing key generation during the four-pass
   protocol is shown in Figure 3.

   +----------------------+                  +----------------------+
   |    +------------+    |                  |                      |
   |    | Server key |    |                  |                      |
   | +&lt;-|  Public    |------&gt;-------------&gt;-------------+---------+ |
   | |  |  Private   |    |                  |          |         | |
   | |  +------------+    |                  |          |         | |
   | |        |           |                  |          |         | |
   | V        V           |                  |          V         V |
   | |   +---------+      |                  |        +---------+ | |
   | |   | Decrypt |&lt;-------&lt;-------------&lt;-----------| Encrypt | | |
   | |   +---------+      |                  |        +---------+ | |
   | |      |  +--------+ |                  |            ^       | |
   | |      |  | Server | |                  |            |       | |
   | |      |  | Random |---&gt;-------------&gt;------+  +----------+  | |
   | |      |  +--------+ |                  |   |  | Client   |  | |
   | |      |      |      |                  |   |  | Random   |  | |
   | |      |      |      |                  |   |  +----------+  | |
   | |      |      |      |                  |   |        |       | |
   | |      V      V      |                  |   V        V       | |
   | |   +------------+   |                  | +------------+     | |
   | +--&gt;|  DSKPP PRF |   |                  | |  DSKPP PRF |&lt;----+ |
   |     +------------+   |                  | +------------+       |
   |           |          |                  |       |              |
   |           V          |                  |       V              |
   |       +-------+      |                  |   +-------+          |
   |       |  Key  |      |                  |   |  Key  |          |
   |       +-------+      |                  |   +-------+          |
   |       +-------+      |                  |   +-------+          |
   |       |Key Id |--------&gt;-------------&gt;------|Key Id |          |
   |       +-------+      |                  |   +-------+          |
   +----------------------+                  +----------------------+
         DSKPP Server                              DSKPP Client

    Figure 3: Principal Data Flow for DSKPP Key Generation Using Public
                                Server Key

   The inclusion of the two random nonces (R_S and R_C) in the key
   generation provides assurance to both sides (the cryptographic module
   and the DSKPP Server) that they have contributed to the key&#x27;s
   randomness and that the key is unique.  The inclusion of the
   encryption key (K) ensures that no man in the middle may be present,
   or else the cryptographic module will end up with a key different
   from the one stored by the legitimate DSKPP Server.

   Conceptually, although R_C is one pseudorandom string, it may be
   viewed as consisting of two components, R_C1 and R_C2, where R_C1 is
   generated during the protocol run, and R_C2 can be pre-generated and

   loaded on the cryptographic module before the device is issued to the
   user.  In that case, the latter string, R_C2, SHOULD be unique for
   each cryptographic module.

   A man in the middle (in the form of corrupt client software or a
   mistakenly contacted server) may present his own public key to the
   cryptographic module.  This will enable the attacker to learn the
   client&#x27;s version of K_TOKEN.  However, the attacker is not able to
   persuade the legitimate server to derive the same value for K_TOKEN,
   since K_TOKEN is a function of the public key involved, and the
   attacker&#x27;s public key must be different than the correct server&#x27;s (or
   else the attacker would not be able to decrypt the information
   received from the client).  Therefore, once the attacker is no longer
   &quot;in the middle,&quot; the client and server will detect that they are &quot;out
   of sync&quot; when they try to use their keys.  In the case of encrypting
   R_C with K_SERVER, it is therefore important to verify that K_SERVER
   really is the legitimate server&#x27;s key.  One way to do this is to
   independently validate a newly generated K_TOKEN against some
   validation service at the server (e.g., using a connection
   independent from the one used for the key generation).

4.1.2.  Computation

   In four-pass DSKPP, the client and server both generate K_TOKEN and
   K_MAC by deriving them from a provisioning key (K_PROV) using the
   DSKPP-PRF (refer to Section 3.4.2) as follows:

   K_PROV = DSKPP-PRF(k,s,dsLen), where

       k = R_C (i.e., the secret random value chosen by the DSKPP
       Client)
       s = &quot;Key generation&quot; || K || R_S (where K is the key used to
       encrypt R_C and R_S is the random value chosen by the DSKPP
       Server)
       dsLen = (desired length of K_PROV whose first half constitutes
       K_MAC and second half constitutes K_TOKEN)

   Then, K_TOKEN and K_MAC are derived from K_PROV, where

       K_PROV = K_MAC || K_TOKEN

   When computing K_PROV, the derived keys, K_MAC and K_TOKEN, MAY be
   subject to an algorithm-dependent transform before being adopted as a
   key of the selected type.  One example of this is the need for parity
   in DES keys.

   Note that this computation pertains to four-pass DSKPP only.

4.2.  Message Flow

   The four-pass protocol flow consists of two message exchanges:
   1:  Pass 1 = &lt;KeyProvClientHello&gt;, Pass 2 = &lt;KeyProvServerHello&gt;
   2:  Pass 3 = &lt;KeyProvClientNonce&gt;, Pass 4 = &lt;KeyProvServerFinished&gt;

   The first pair of messages negotiate cryptographic algorithms and
   exchange nonces.  The second pair of messages establishes a symmetric
   key using mutually authenticated key agreement.

   The purpose and content of each message are described below.  XML
   format and examples are in Section 8 and Appendix B.

4.2.1.  KeyProvTrigger

           DSKPP Client                         DSKPP Server
           ------------                         ------------
                                [&lt;---]       AD, [DeviceID],
                                            [KeyID], [URL_S]

   When this message is sent:
      The &quot;trigger&quot; message is optional.  The DSKPP Server sends this
      message after the following out-of-band steps are performed:
      1.  A user directed their browser to a key provisioning web
          application and signs in (i.e., authenticates).
      2.  The user requests a key.
      3.  The web application processes the request and returns an
          Authentication Code to the user, e.g., in response to an
          enrollment request via a secure web session.
      4.  The web application retrieves the Authentication Code from the
          user (possibly by asking the user to enter it using a web
          form, or alternatively by the user selecting a URL in which
          the Authentication Code is embedded).
      5.  The web application derives Authentication Data (AD) from the
          Authentication Code as described in Section 3.4.1.
      6.  The web application passes AD, and possibly a DeviceID
          (identifies a particular device to which the key is to be
          provisioned) and/or KeyID (identifies a key that will be
          replaced) to the DSKPP Server.

   Purpose of this message:
      To start a DSKPP session: The DSKPP Server uses this message to
      trigger a client-side application to send the first DSKPP message.
      To provide a way for the key provisioning system to get the DSKPP
      Server URL to the DSKPP Client.

      So the key provisioning system can point the DSKPP Client to a
      particular cryptographic module that was pre-configured in the
      DSKPP provisioning server.

      In the case of key renewal, to identify the key to be replaced.

   What is contained in this message:
      AD MUST be provided to allow the DSKPP Server to authenticate the
      user before completing the protocol run.

      A DeviceID MAY be included to allow a key provisioning application
      to bind the provisioned key to a specific device.

      A KeyID MAY be included to allow the key provisioning application
      to identify a key to be replaced, e.g., in the case of key
      renewal.

      The Server URL MAY be included to allow the key provisioning
      application to inform the DSKPP Client of which server to contact.

4.2.2.  KeyProvClientHello

           DSKPP Client                         DSKPP Server
           ------------                         ------------
           SAL, [AD],
           [DeviceID], [KeyID]     ---&gt;

   When this message is sent:
      When a DSKPP Client first connects to a DSKPP Server, it is
      required to send the &lt;KeyProvClientHello&gt; as its first message.
      The client can also send a &lt;KeyProvClientHello&gt; in response to a
      &lt;KeyProvTrigger&gt;.

   What is contained in this message:
      The Security Attribute List (SAL) included with
      &lt;KeyProvClientHello&gt; contains the combinations of DSKPP versions,
      variants, key package formats, key types, and cryptographic
      algorithms that the DSKPP Client supports in order of the client&#x27;s
      preference (favorite choice first).

      If &lt;KeyProvClientHello&gt; was preceded by a &lt;KeyProvTrigger&gt;, then
      this message MUST also include the Authentication Data (AD),
      DeviceID, and/or KeyID that was provided with the trigger.

      If &lt;KeyProvClientHello&gt; was not preceded by a &lt;KeyProvTrigger&gt;,
      then this message MAY contain a DeviceID that was pre-shared with
      the DSKPP Server, and a key ID associated with a key previously
      provisioned by the DSKPP provisioning server.

   Application note:
      If this message is preceded by trigger message &lt;KeyProvTrigger&gt;,
      then the application will already have AD available (see
      Section 4.2.1).  However, if this message was not preceded by
      &lt;KeyProvTrigger&gt;, then the application MUST retrieve the User
      Authentication Code, possibly by prompting the user to manually
      enter their Authentication Code, e.g., on a device with only a
      numeric keypad.

      The application MUST also derive Authentication Data (AD) from the
      Authentication Code, as described in Section 3.4.1, and save it
      for use in its next message, &lt;KeyProvClientNonce&gt;.

   How the DSKPP Server uses this message:
      The DSKPP Server will look for an acceptable combination of DSKPP
      version, variant (in this case, four-pass), key package format,
      key type, and cryptographic algorithms.  If the DSKPP Client&#x27;s SAL
      does not match the capabilities of the DSKPP Server, or does not
      comply with key provisioning policy, then the DSKPP Server will
      set the Status attribute to something other than &quot;Continue&quot;.
      Otherwise, the Status attribute will be set to &quot;Continue&quot;.

      If included in &lt;KeyProvClientHello&gt;, the DSKPP Server will
      validate the Authentication Data (AD), DeviceID, and KeyID.  The
      DSKPP Server MUST NOT accept the DeviceID unless the server sent
      the DeviceID in a preceding trigger message.  Note that it is also
      legitimate for a DSKPP Client to initiate the DSKPP run without
      having received a &lt;KeyProvTrigger&gt; message from a server, but in
      this case any provided DeviceID MUST NOT be accepted by the DSKPP
      Server unless the server has access to a unique key for the
      identified device and that key will be used in the protocol.

4.2.3.  KeyProvServerHello

           DSKPP Client                         DSKPP Server
           ------------                         ------------
                                 &lt;---    SAL, R_S, [K], [MAC]

   When this message is sent:
      The DSKPP Server will send this message in response to a
      &lt;KeyProvClientHello&gt; message after it looks for an acceptable
      combination of DSKPP version, variant (in this case, four-pass),
      key package format, key type, and set of cryptographic algorithms.
      If it could not find an acceptable combination, then it will still
      send the message, but with a failure status.

   Purpose of this message:
      With this message, the context for the protocol run is set.
      Furthermore, the DSKPP Server uses this message to transmit a
      random nonce, which is required for each side to agree upon the
      same symmetric key (K_TOKEN).

   What is contained in this message:
      A status attribute equivalent to the server&#x27;s return code to
      &lt;KeyProvClientHello&gt;.  If the server found an acceptable set of
      attributes from the client&#x27;s SAL, then it sets status to Continue
      and returns an SAL (selected from the SAL that it received in
      &lt;KeyProvClientHello&gt;).  The Server&#x27;s SAL specifies the DSKPP
      version and variant (in this case, four-pass), key type,
      cryptographic algorithms, and key package format that the DSKPP
      Client MUST use for the remainder of the protocol run.

      A random nonce (R_S) for use in generating a symmetric key through
      key agreement; the length of R_S may depend on the selected key
      type.

      A key (K) for the DSKPP Client to use for encrypting the client
      nonce included with &lt;KeyProvClientNonce&gt;.  K represents the
      server&#x27;s public key (K_SERVER) or a pre-shared secret key
      (K_SHARED).

      A MAC MUST be present if a key is being renewed so that the DSKPP
      Client can confirm that the replacement key came from a trusted
      server.  This MAC MUST be computed using DSKPP-PRF (see
      Section 3.4.2), where the input parameter k MUST be set to the
      existing MAC key K_MAC&#x27; (i.e., the value of the MAC key that
      existed before this protocol run; the implementation MAY specify
      K_MAC&#x27; to be the value of the K_TOKEN that is being replaced), and
      input parameter dsLen MUST be set to the length of R_S.

   How the DSKPP Client uses this message:
      When the Status attribute is not set to &quot;Continue&quot;, this indicates
      failure and the DSKPP Client MUST abort the protocol.

      If successful execution of the protocol will result in the
      replacement of an existing key with a newly generated one, the
      DSKPP Client MUST verify the MAC provided in &lt;KeyProvServerHello&gt;.
      The DSKPP Client MUST terminate the DSKPP session if the MAC does
      not verify, and MUST delete any nonces, keys, and/or secrets
      associated with the failed run.

      If the Status attribute is set to &quot;Continue&quot;, the cryptographic
      module generates a random nonce (R_C) using the cryptographic
      algorithm specified in the SAL.  The length of the nonce R_C will
      depend on the selected key type.

      Encrypt R_C using K and the encryption algorithm included in the
      SAL.

   The method the DSKPP Client MUST use to encrypt R_C:
      If K is equivalent to K_SERVER (i.e., the public key of the DSKPP
      Server), then an RSA encryption scheme from PKCS #1 [PKCS-1] MAY
      be used.  If K is equivalent to K_SERVER, then the cryptographic
      module SHOULD verify the server&#x27;s certificate before using it to
      encrypt R_C as described in [RFC2818], Section 3.1, and [RFC5280].

      If K is equivalent to K_SHARED, the DSKPP Client MAY use the
      DSKPP-PRF to avoid dependence on other algorithms.  In this case,
      the client uses K_SHARED as input parameter k (K_SHARED SHOULD be
      used solely for this purpose) as follows:

      dsLen = len(R_C), where &quot;len&quot; is the length of R_C
      DS = DSKPP-PRF(K_SHARED, &quot;Encryption&quot; || R_S, dsLen)

      This will produce a pseudorandom string DS of length equal to R_C.
      Encryption of R_C MAY then be achieved by XOR-ing DS with R_C:

      E(DS, R_C) = DS ^ R_C

      The DSKPP Server will then perform the reverse operation to
      extract R_C from E(DS, R_C).

4.2.4.  KeyProvClientNonce

           <span class="Verified-inline-styling" id='inline-2999'>           DSKPP Client                         DSKPP Server <button id="btn_2999" target="expand_2999" onclick='hideFunction("expand_2999")'>Expand</button>
           ------------                         ------------
           E(K,R_C), [AD]          ---&gt;

   When this message is sent:
      The DSKPP Client will send this message immediately following a
      &lt;KeyProvServerHello&gt; message whose status was set to &quot;Continue&quot;.
      The AD element MUST be sent unless it was already sent in the
      KeyProvClientHello message.</span id__locate=2999>
<div class="nodeCloseClass" id='expand_2999'><div class='Verified-endnote-styling' id='eid2999'>
<pre>
<b><i><a href='https://www.rfc-editor.org/errata/eid2999'>EID 2999</a> (Verified) is as follows:</i></b>

<b>Section:</b> 4.2.4

<b>Original Text:</b>

           DSKPP Client                         DSKPP Server
           ------------                         ------------
           E(K,R_C), AD          ---&gt;


   When this message is sent:
      The DSKPP Client will send this message immediately following a
      &lt;KeyProvServerHello&gt; message whose status was set to &quot;Continue&quot;.

<b>Corrected Text:</b>

           DSKPP Client                         DSKPP Server
           ------------                         ------------
           E(K,R_C), [AD]          ---&gt;

   When this message is sent:
      The DSKPP Client will send this message immediately following a
      &lt;KeyProvServerHello&gt; message whose status was set to &quot;Continue&quot;.
      The AD element MUST be sent unless it was already sent in the
      KeyProvClientHello message.
</pre>
<b>Notes:</b><br/>
The AD is carried in the &lt;KeyProvClientHello&gt; if sent as a result of a trigger and so is optional in the &lt;ekyProvClientNonce&gt;.
</div>
</div>
   Purpose of this message:
      With this message the DSKPP Client transmits User Authentication
      Data (AD) and a random nonce encrypted with the DSKPP Server&#x27;s key
      (K).  The client&#x27;s random nonce is required for each side to agree
      upon the same symmetric key (K_TOKEN).

   What is contained in this message:
      Authentication Data (AD) that was derived from an Authentication
      Code entered by the user before &lt;KeyProvClientHello&gt; was sent
      (refer to Section 3.2).

      The DSKPP Client&#x27;s random nonce (R_C), which was encrypted as
      described in Section 4.2.3.

   How the DSKPP Server uses this message:
      The DSKPP Server MUST use AD to authenticate the user.  If
      authentication fails, then the DSKPP Server MUST set the return
      code to a failure status.

      If user authentication passes, the DSKPP Server decrypts R_C using
      its key (K).  The decryption method is based on whether K that was
      transmitted to the client in &lt;KeyProvServerHello&gt; was equal to the
      server&#x27;s public key (K_SERVER) or a pre-shared key (K_SHARED)
      (refer to Section 4.2.3 for a description of how the DSKPP Client
      encrypts R_C).

      After extracting R_C, the DSKPP Server computes K_TOKEN using a
      combination of the two random nonces R_S and R_C and its
      encryption key, K, as described in Section 4.1.2.  The particular
      realization of DSKPP-PRF (e.g., those defined in Appendix D)
      depends on the MAC algorithm contained in the &lt;KeyProvServerHello&gt;
      message.  The DSKPP Server then generates a key package that
      contains key usage attributes such as expiry date and length.  The
      key package MUST NOT include K_TOKEN since in the four-pass
      variant K_TOKEN is never transmitted between the DSKPP Server and
      Client.  The server stores K_TOKEN and the key package with the
      user&#x27;s account on the cryptographic server.

      Finally, the server generates a key confirmation MAC that the
      client will use to avoid a false &quot;Commit&quot; message that would cause
      the cryptographic module to end up in state in which the server
      does not recognize the stored key.

   The MAC used for key confirmation MUST be calculated as follows:

      msg_hash = SHA-256(msg_1, ..., msg_n)

      dsLen = len(msg_hash)

      MAC = DSKPP-PRF (K_MAC, &quot;MAC 1 computation&quot; || msg_hash, dsLen)

      where

      MAC The DSKPP Pseudorandom Function defined in Section 3.4.2 is
          used to compute the MAC.  The particular realization of DSKPP-
          PRF (e.g., those defined in Appendix D) depends on the MAC
          algorithm contained in the &lt;KeyProvServerHello&gt; message.  The
          MAC MUST be computed using the existing MAC key (K_MAC), and a
          string that is formed by concatenating the (ASCII) string &quot;MAC
          1 computation&quot; and a msg_hash.

      K_MAC  The key derived from K_PROV, as described in Section 4.1.2.

      msg_hash  The message hash (defined in Section 3.4.3) of messages
                msg_1, ..., msg_n.

4.2.5.  KeyProvServerFinished

           DSKPP Client                         DSKPP Server
           ------------                         ------------
                                  &lt;---               KP, MAC

   When this message is sent:
      The DSKPP Server will send this message after authenticating the
      user and, if authentication passed, generating K_TOKEN and a key
      package, and associating them with the user&#x27;s account on the
      cryptographic server.

   Purpose of this message:
      With this message, the DSKPP Server confirms generation of the key
      (K_TOKEN) and transmits the associated identifier and application-
      specific attributes, but not the key itself, in a key package to
      the client for protocol completion.

   What is contained in this message:
      A status attribute equivalent to the server&#x27;s return code to
      &lt;KeyProvClientNonce&gt;.  If user authentication passed, and the
      server successfully computed K_TOKEN, generated a key package, and
      associated them with the user&#x27;s account on the cryptographic
      server, then it sets the Status attribute to &quot;Success&quot;.
      If the Status attribute is set to &quot;Success&quot;, then this message
      acts as a &quot;Commit&quot; message, instructing the cryptographic module
      to store the generated key (K_TOKEN) and associate the given key
      identifier with this key.  As such, a key package (KP) MUST be
      included in this message, which holds an identifier for the
      generated key (but not the key itself) and additional
      configuration, e.g., the identity of the DSKPP Server, key usage
      attributes, etc.  The default symmetric key package format MUST be

      based on the Portable Symmetric Key Container (PSKC) defined in
      [RFC6030].  Alternative formats MAY include [RFC6031], PKCS #12
      [PKCS-12], or PKCS #5 XML [PKCS-5-XML] format.

      With KP, the server includes a key confirmation MAC that the
      client uses to avoid a false &quot;Commit&quot; message.  The MAC algorithm
      is the same DSKPP-PRF that was sent in the &lt;KeyProvServerHello&gt;
      message.

   How the DSKPP Client uses this message:
      When the Status attribute is not set to &quot;Success&quot;, this indicates
      failure and the DSKPP Client MUST abort the protocol.

      After receiving a &lt;KeyProvServerFinished&gt; message with Status =
      &quot;Success&quot;, the DSKPP Client MUST verify the key confirmation MAC
      that was transmitted with this message.  The DSKPP Client MUST
      terminate the DSKPP session if the MAC does not verify, and MUST,
      in this case, also delete any nonces, keys, and/or secrets
      associated with the failed run of the protocol.

      If &lt;KeyProvServerFinished&gt; has Status = &quot;Success&quot;, and the MAC was
      verified, then the DSKPP Client MUST calculate K_TOKEN from the
      combination of the two random nonces R_S and R_C and the server&#x27;s
      encryption key, K, as described in Section 4.1.2.  The DSKPP-PRF
      is the same one used for MAC computation.  The DSKPP Client
      associates the key package contained in &lt;KeyProvServerFinished&gt;
      with the generated key, K_TOKEN, and stores this data permanently
      on the cryptographic module.

      After this operation, it MUST NOT be possible to overwrite the key
      unless knowledge of an authorizing key is proven through a MAC on
      a later &lt;KeyProvServerHello&gt; (and &lt;KeyProvServerFinished&gt;)
      message.

5.  Two-Pass Protocol Usage

   This section describes the methods and message flow that comprise the
   two-pass protocol variant.  Two-pass DSKPP is essentially a transport
   of keying material from the DSKPP Server to the DSKPP Client.  The
   DSKPP Server transmits keying material in a key package formatted in
   accordance with [RFC6030], [RFC6031], PKCS #12 [PKCS-12], or PKCS #5
   XML [PKCS-5-XML].

   The keying material includes a provisioning master key, K_PROV, from
   which the DSKPP Client derives two keys: the symmetric key to be
   established in the cryptographic module, K_TOKEN, and a key, K_MAC,
   used for key confirmation.  The keying material also includes key
   usage attributes, such as expiry date and length.

   The DSKPP Server encrypts K_PROV to ensure that it is not exposed to
   any other entity than the DSKPP Server and the cryptographic module
   itself.  The DSKPP Server uses any of three key protection methods to
   encrypt K_PROV: Key Transport, Key Wrap, and Passphrase-Based Key
   Wrap Key Protection methods.

   While the DSKPP Client and server may negotiate the key protection
   method to use, the actual key protection is carried out in the
   KeyPackage.  The format of a KeyPackage specifies how a key should be
   protected using the three key protection methods.  The following
   KeyPackage formats are defined for DSKPP:

   o  PSKC Key Container [RFC6030] at
      urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container

   o  SKPC Key Container [RFC6031] at
      urn:ietf:params:xml:ns:keyprov:dskpp:skpc-key-container

   o  PKCS12 Key Container [PKCS-12] at
      urn:ietf:params:xml:ns:keyprov:dskpp:pkcs12-key-container

   o  PKCS5-XML Key Container [PKCS-5-XML] at
      urn:ietf:params:xml:ns:keyprov:dskpp:pkcs5-xml-key-container

   Each of the key protection methods is described below.

5.1.  Key Protection Methods

   This section introduces three key protection methods for the two-pass
   variant.  Additional methods MAY be defined by external entities or
   through the IETF process.

5.1.1.  Key Transport

   Purpose of this method:
      This method is intended for PKI-capable devices.  The DSKPP Server
      encrypts keying material and transports it to the DSKPP Client.
      The server encrypts the keying material using the public key of
      the DSKPP Client, whose private key part resides in the
      cryptographic module.  The DSKPP Client decrypts the keying
      material and uses it to derive the symmetric key, K_TOKEN.

   This method is identified with the following URN:
      urn:ietf:params:xml:schema:keyprov:dskpp:transport

   The DSKPP Server and Client MUST support the following mechanism:
      http://www.w3.org/2001/04/xmlenc#rsa-1_5 encryption mechanism
      defined in [XMLENC].

5.1.2.  Key Wrap

   Purpose of this method:
      This method is ideal for pre-keyed devices, e.g., SIM cards.  The
      DSKPP Server encrypts keying material using a pre-shared key
      wrapping key and transports it to the DSKPP Client.  The DSKPP
      Client decrypts the keying material, and uses it to derive the
      symmetric key, K_TOKEN.

   This method is identified with the following URN:
      urn:ietf:params:xml:schema:keyprov:dskpp:wrap

   The DSKPP Server and Client MUST support all of the following key
   wrapping mechanisms:

   AES128 KeyWrap
      Refer to id-aes128-wrap in [RFC3394] and
      http://www.w3.org/2001/04/xmlenc#kw-aes128 in [XMLENC]

   AES128 KeyWrap with Padding
      Refer to id-aes128-wrap-pad in [RFC5649] and
      http://www.w3.org/2001/04/xmlenc#kw-aes128 in [XMLENC]

   AES-CBC-128
      Refer to [FIPS197-AES] and
      http://www.w3.org/2001/04/xmlenc#aes128-cbc in [XMLENC]

5.1.3.  Passphrase-Based Key Wrap

   Purpose of this method:
      This method is a variation of the Key Wrap Method that is
      applicable to constrained devices with keypads, e.g., mobile
      phones.  The DSKPP Server encrypts keying material using a
      wrapping key derived from a user-provided passphrase, and
      transports the encrypted material to the DSKPP Client.  The DSKPP
      Client decrypts the keying material, and uses it to derive the
      symmetric key, K_TOKEN.

      To preserve the property of not exposing K_TOKEN to any other
      entity than the DSKPP Server and the cryptographic module itself,
      the method SHOULD be employed only when the device contains
      facilities (e.g., a keypad) for direct entry of the passphrase.

   This method is identified with the following URN:
      urn:ietf:params:xml:schema:keyprov:dskpp:passphrase-wrap

   The DSKPP Server and Client MUST support the following:

      *  The PBES2 password-based encryption scheme defined in [PKCS-5]
         (and identified as
         http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2 in
         [PKCS-5-XML]).

      *  The PBKDF2 passphrase-based key derivation function also
         defined in [PKCS-5] (and identified as
         http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbkdf2
         in [PKCS-5-XML]).

      *  All of the following key wrapping mechanisms:

         AES128 KeyWrap
            Refer to id-aes128-wrap in [RFC3394] and
            http://www.w3.org/2001/04/xmlenc#kw-aes128 in [XMLENC]

         AES128 KeyWrap with Padding
            Refer to id-aes128-wrap-pad in [RFC5649] and
            http://www.w3.org/2001/04/xmlenc#kw-aes128 in [XMLENC]

         AES-CBC-128
            Refer to [FIPS197-AES] and
            http://www.w3.org/2001/04/xmlenc#aes128-cbc in [XMLENC]

5.2.  Message Flow

   The two-pass protocol flow consists of one exchange:
   1:  Pass 1 = &lt;KeyProvClientHello&gt;, Pass 2 = &lt;KeyProvServerFinished&gt;

   Although there is no exchange of the &lt;ServerHello&gt; message or the
   &lt;ClientNonce&gt; message, the DSKPP Client is still able to specify
   algorithm preferences and supported key types in the
   &lt;KeyProvClientHello&gt; message.

   The purpose and content of each message are described below.  XML
   format and examples are in Section 8 and Appendix B.

5.2.1.  KeyProvTrigger

   The trigger message is used in exactly the same way for the two-pass
   variant as for the four-pass variant; refer to Section 4.2.1.

5.2.2.  KeyProvClientHello

           DSKPP Client                         DSKPP Server
           ------------                         ------------
           SAL, AD, R_C,
           [DeviceID], [KeyID],
           KPML                   ---&gt;

   When this message is sent:
      When a DSKPP Client first connects to a DSKPP Server, it is
      required to send the &lt;KeyProvClientHello&gt; as its first message.
      The client can also send &lt;KeyProvClientHello&gt; in response to a
      &lt;KeyProvTrigger&gt; message.

   Purpose of this message:
      With this message, the DSKPP Client specifies its algorithm
      preferences and supported key types as well as which DSKPP
      versions, protocol variants (in this case &quot;two-pass&quot;), key package
      formats, and key protection methods that it supports.
      Furthermore, the DSKPP Client facilitates user authentication by
      transmitting the Authentication Data (AD) that was provided by the
      user before the first DSKPP message was sent.

   Application note:
      This message MUST send User Authentication Data (AD) to the DSKPP
      Server.  If this message is preceded by trigger message
      &lt;KeyProvTrigger&gt;, then the application will already have AD
      available (see Section 4.2.1).  However, if this message was not
      preceded by &lt;KeyProvTrigger&gt;, then the application MUST retrieve
      the User Authentication Code, possibly by prompting the user to
      manually enter their Authentication Code, e.g., on a device with
      only a numeric keypad.  The application MUST also derive
      Authentication Data (AD) from the Authentication Code, as
      described in Section 3.4.1, and save it for use in its next
      message, &lt;KeyProvClientNonce&gt;.

   What is contained in this message:
      The Security Attribute List (SAL) included with
      &lt;KeyProvClientHello&gt; contains the combinations of DSKPP versions,
      variants, key package formats, key types, and cryptographic
      algorithms that the DSKPP Client supports in order of the client&#x27;s
      preference (favorite choice first).

      Authentication Data (AD) that was either included with
      &lt;KeyProvTrigger&gt;, or generated as described in the &quot;Application
      Note&quot; above.

      The DSKPP Client&#x27;s random nonce (R_C), which was used by the
      client when generating AD.  By inserting R_C into the DSKPP
      session, the DSKPP Client is able to ensure the DSKPP Server is
      live before committing the key.

      If &lt;KeyProvClientHello&gt; was preceded by a &lt;KeyProvTrigger&gt;, then
      this message MUST also include the DeviceID and/or KeyID that was
      provided with the trigger.  Otherwise, if a trigger message did
      not precede &lt;KeyProvClientHello&gt;, then this message MAY include a
      DeviceID that was pre-shared with the DSKPP Server, and MAY
      contain a key ID associated with a key previously provisioned by
      the DSKPP provisioning server.

      The list of key protection methods (KPML) that the DSKPP Client
      supports.  Each item in the list MAY include an encryption key
      &quot;payload&quot; for the DSKPP Server to use to protect keying material
      that it sends back to the client.  The payload MUST be of type
      &lt;ds:KeyInfoType&gt; ([XMLDSIG]).  For each key protection method, the
      allowable choices for &lt;ds:KeyInfoType&gt; are:

      *  Key Transport
         Only those choices of &lt;ds:KeyInfoType&gt; that identify a public
         key (i.e., &lt;ds:KeyName&gt;, &lt;ds:KeyValue&gt;, &lt;ds:X509Data&gt;, or &lt;ds:
         PGPData&gt;).  The &lt;ds:X509Certificate&gt; option of the &lt;ds:
         X509Data&gt; alternative is RECOMMENDED when the public key
         corresponding to the private key on the cryptographic module
         has been certified.

      *  Key Wrap
         Only those choices of &lt;ds:KeyInfoType&gt; that identify a
         symmetric key (i.e., &lt;ds:KeyName&gt; and &lt;ds:KeyValue&gt;).  The &lt;ds:
         KeyName&gt; alternative is RECOMMENDED.

      *  Passphrase-Based Key Wrap
         The &lt;ds:KeyName&gt; option MUST be used and the key name MUST
         identify the passphrase that will be used by the server to
         generate the key wrapping key.  The identifier and passphrase
         components of &lt;ds:KeyName&gt; MUST be set to the Client ID and
         Authentication Code components of AD (same AD as contained in
         this message).

   How the DSKPP Server uses this message:
      The DSKPP Server will look for an acceptable combination of DSKPP
      version, variant (in this case, two-pass), key package format, key
      type, and cryptographic algorithms.  If the DSKPP Client&#x27;s SAL
      does not match the capabilities of the DSKPP Server, or does not

      comply with key provisioning policy, then the DSKPP Server will
      set the Status attribute to something other than &quot;Success&quot;.
      Otherwise, the Status attribute will be set to &quot;Success&quot;.

      The DSKPP Server will validate the DeviceID and KeyID if included
      in &lt;KeyProvClientHello&gt;.  The DSKPP Server MUST NOT accept the
      DeviceID unless the server sent the DeviceID in a preceding
      trigger message.  Note that it is also legitimate for a DSKPP
      Client to initiate the DSKPP run without having received a
      &lt;KeyProvTrigger&gt; message from a server, but in this case any
      provided DeviceID MUST NOT be accepted by the DSKPP Server unless
      the server has access to a unique key for the identified device
      and that key will be used in the protocol.

      The DSKPP Server MUST use AD to authenticate the user.  If
      authentication fails, then the DSKPP Server MUST set the return
      code to a failure status, and MUST, in this case, also delete any
      nonces, keys, and/or secrets associated with the failed run of the
      protocol.

      If user authentication passes, the DSKPP Server generates a key
      K_PROV.  In the two-pass case, wherein the client does not have
      access to R_S, K_PROV is randomly generated solely by the DSKPP
      Server wherein K_PROV MUST consist of two parts of equal length,
      i.e.,

         K_PROV = K_MAC || K_TOKEN

      The length of K_TOKEN (and hence also the length of K_MAC) is
      determined by the type of K_TOKEN, which MUST be one of the key
      types supported by the DSKPP Client.  In cases where the desired
      key length for K_TOKEN is different from the length of K_MAC for
      the underlying MAC algorithm, the greater length of the two MUST
      be chosen to generate K_PROV.  The actual MAC key is truncated
      from the resulting K_MAC when it is used in the MAC algorithm when
      K_MAC is longer than necessary in order to match the desired
      K_TOKEN length.  If K_TOKEN is longer than needed in order to
      match the K_MAC length, the provisioning server and the receiving
      client must determine the actual secret key length from the target
      key algorithm and store only the truncated portion of the K_TOKEN.
      The truncation MUST take the beginning bytes of the desired length
      from K_TOKEN or K_MAC for the actual key.  For example, when a
      provisioning server provisions an event based HOTP secret key with
      length 20 and MAC algorithm DSKPP-PRF-SHA256 (Appendix D), K_PROV
      length will be 64.  The derived K_TOKEN and K_MAC will each
      consist of 32 bytes.  The actual HOTP key should be the first 20
      bytes of the K_TOKEN.

      Once K_PROV is computed, the DSKPP Server selects one of the key
      protection methods from the DSKPP Client&#x27;s KPML, and uses that
      method and corresponding payload to encrypt K_PROV.  The DSKPP
      Server generates a key package to transport the key encryption
      method information and the encrypted provisioning key (K_PROV).
      The encrypted data format is subject to the choice supported by
      the selected key package.  The key package MUST specify and use
      the selected key protection method and the key information that
      was received in &lt;KeyProvClientHello&gt;.  The key package also
      includes key usage attributes such as expiry date and length.  The
      server stores the key package and K_TOKEN with a user account on
      the cryptographic server.

      The server generates a MAC for key confirmation, which the client
      will use to avoid a false &quot;Commit&quot; message that would cause the
      cryptographic module to end up in state in which the server does
      not recognize the stored key.

      In addition, if an existing key is being renewed, the server
      generates a second MAC that it will return to the client as server
      Authentication Data (AD) so that the DSKPP Client can confirm that
      the replacement key came from a trusted server.

   The method the DSKPP Server MUST use to calculate the key
   confirmation MAC:

      msg_hash = SHA-256(msg_1, ..., msg_n)

      dsLen = len(msg_hash)

      MAC = DSKPP-PRF (K_MAC, &quot;MAC 1 computation&quot; || msg_hash ||
      ServerID, dsLen)

      where

      MAC         The MAC MUST be calculated using the already
                  established MAC algorithm and MUST be computed on the
                  (ASCII) string &quot;MAC 1 computation&quot;, msg_hash, and
                  ServerID using the existing MAC key K_MAC.

      K_MAC       The key that is derived from K_PROV, which the DSKPP
                  Server MUST provide to the cryptographic module.

      msg_hash    The message hash, defined in Section 3.4.3, of
                  messages msg_1, ..., msg_n.

      ServerID    The identifier that the DSKPP Server MUST include in
                  the &lt;KeyPackage&gt; element of &lt;KeyProvServerFinished&gt;.

      If DSKPP-PRF (defined in Section 3.4.2) is used as the MAC
      algorithm, then the input parameter s MUST consist of the
      concatenation of the (ASCII) string &quot;MAC 1 computation&quot;, msg_hash,
      and ServerID, and the parameter dsLen MUST be set to the length of
      msg_hash.

   The method the DSKPP Server MUST use to calculate the server
   authentication MAC:

      The MAC MUST be computed on the (ASCII) string &quot;MAC 2
      computation&quot;, the server identifier ServerID, and R, using a pre-
      existing MAC key K_MAC&#x27; (the MAC key that existed before this
      protocol run).  Note that the implementation may specify K_MAC&#x27; to
      be the value of the K_TOKEN that is being replaced.

      If DSKPP-PRF is used as the MAC algorithm, then the input
      parameter s MUST consist of the concatenation of the (ASCII)
      string &quot;MAC 2 computation&quot; ServerID, and R.  The parameter dsLen
      MUST be set to at least 16 (i.e., the length of the MAC MUST be at
      least 16 octets):

      dsLen &gt;= 16

      MAC = DSKPP-PRF (K_MAC&#x27;, &quot;MAC 2 computation&quot; || ServerID || R,
      dsLen)

      The MAC algorithm MUST be the same as the algorithm used by the
      DSKPP Server to calculate the key confirmation MAC.

5.2.3.  KeyProvServerFinished

          DSKPP Client                         DSKPP Server
           ------------                         ------------
                                  &lt;---           KP, MAC, AD

   When this message is sent:
      The DSKPP Server will send this message after authenticating the
      user and, if authentication passed, generating K_TOKEN and a key
      package, and associating them with the user&#x27;s account on the
      cryptographic server.

   Purpose of this message:
      With this message, the DSKPP Server transports a key package
      containing the encrypted provisioning key (K_PROV) and key usage
      attributes.

   What is contained in this message:
      A Status attribute equivalent to the server&#x27;s return code to
      &lt;KeyProvClientHello&gt;.  If the server found an acceptable set of
      attributes from the client&#x27;s SAL, then it sets Status to
      &quot;Success&quot;.

      The confirmation message MUST include the Key Package (KP) that
      holds the DSKPP Server&#x27;s ID, key ID, key type, encrypted
      provisioning key (K_PROV), encryption method, and additional
      configuration information.  The default symmetric key package
      format MUST be based on the Portable Symmetric Key Container
      (PSKC) defined in [RFC6030].  Alternative formats MAY include
      [RFC6031], PKCS #12 [PKCS-12], or PKCS #5 XML [PKCS-5-XML].

      This message MUST include a MAC that the DSKPP Client will use for
      key confirmation.  This key confirmation MAC is calculated using
      the &quot;MAC 1 computation&quot; as described in the previous section.

      Finally, if an existing key is being replaced, then this message
      MUST also include a server authentication MAC (calculated using
      the &quot;MAC 2 computation&quot; as described in the previous section),
      which is passed as AD to the DSKPP Client.

   How the DSKPP Client uses this message:
      After receiving a &lt;KeyProvServerFinished&gt; message with Status =
      &quot;Success&quot;, the DSKPP Client MUST verify both MACs (MAC and AD).
      The DSKPP Client MUST terminate the DSKPP run if either MAC does
      not verify, and MUST, in this case, also delete any nonces, keys,
      and/or secrets associated with the failed run of the protocol.

      If &lt;KeyProvServerFinished&gt; has Status = &quot;Success&quot; and the MACs
      were verified, then the DSKPP Client MUST extract K_PROV from the
      provided key package, and derive K_TOKEN.  Finally, the DSKPP
      Client initializes the cryptographic module with K_TOKEN and the
      corresponding key usage attributes.  After this operation, it MUST
      NOT be possible to overwrite the key unless knowledge of an
      authorizing key is proven through a MAC on a later
      &lt;KeyProvServerFinished&gt; message.

6.  Protocol Extensions

   DSKPP has been designed to be extensible.  The sub-sections below
   define two extensions that are included with the DSKPP schema.  Since
   it is possible that the use of extensions will harm interoperability,
   protocol designers are advised to carefully consider the use of
   extensions.  For example, if a particular implementation relies on

   the presence of a proprietary extension, then it may not be able to
   interoperate with independent implementations that have no knowledge
   of this extension.

   Extensions may be sent with any DSKPP message using the
   ExtensionsType.  The ExtensionsType type is a list of Extensions
   containing type-value pairs that define optional features supported
   by a DSKPP Client or server.  Each extension MAY be marked as
   Critical by setting the Critical attribute of the Extension to
   &quot;true&quot;.  Unless an extension is marked as Critical, a receiving party
   need not be able to interpret it; a receiving party is always free to
   disregard any (non-critical) extensions.

6.1.  The ClientInfoType Extension

   The ClientInfoType extension MAY contain any client-specific data
   required of an application.  This extension MAY be present in a
   &lt;KeyProvClientHello&gt; or &lt;KeyProvClientNonce&gt; message.  When present,
   this extension MUST NOT be marked as Critical.

   DSKPP Servers MUST support this extension.  DSKPP Servers MUST NOT
   attempt to interpret the data it carries and, if received, MUST
   include it unmodified in the current protocol run&#x27;s next server
   response.  DSKPP Servers need not retain the ClientInfoType data.

6.2.  The ServerInfoType Extension

   The ServerInfoType extension MAY contain any server-specific data
   required of an application, e.g., state information.  This extension
   is only valid in &lt;KeyProvServerHello&gt; messages for which the Status
   attribute is set to &quot;Continue&quot;.  When present, this extension MUST
   NOT be marked as Critical.

   DSKPP Clients MUST support this extension.  DSKPP Clients MUST NOT
   attempt to interpret the data it carries and, if received, MUST
   include it unmodified in the current protocol run&#x27;s next client
   request (i.e., the &lt;KeyProvClientNonce&gt; message).  DSKPP Clients need
   not retain the ServerInfoType data.

7.  Protocol Bindings

7.1.  General Requirements

   DSKPP assumes a reliable transport.

7.2.  HTTP/1.1 Binding for DSKPP

   This section presents a binding of the previous messages to HTTP/1.1
   [RFC2616].  This HTTP binding is mandatory to implement, although
   newer versions of the specification might define additional bindings
   in the future.  Note that the HTTP client will normally be different
   from the DSKPP Client (i.e., the HTTP client will &quot;proxy&quot; DSKPP
   messages from the DSKPP Client to the DSKPP Server).  Likewise, on
   the HTTP server side, the DSKPP Server MAY receive DSKPP message from
   a &quot;front-end&quot; HTTP server.  The DSKPP Server will be identified by a
   specific URL, which may be pre-configured, or provided to the client
   during initialization.

7.2.1.  Identification of DSKPP Messages

   The MIME type for all DSKPP messages MUST be

   application/dskpp+xml

7.2.2.  HTTP Headers

   In order to avoid caching of responses carrying DSKPP messages by
   proxies, the following holds:

   o  When using HTTP/1.1, requesters SHOULD:
      *  Include a Cache-Control header field set to &quot;no-cache, no-
         store&quot;.
      *  Include a Pragma header field set to &quot;no-cache&quot;.

   o  When using HTTP/1.1, responders SHOULD:
      *  Include a Cache-Control header field set to &quot;no-cache, no-must-
         revalidate, private&quot;.
      *  Include a Pragma header field set to &quot;no-cache&quot;.
      *  NOT include a Validator, such as a Last-Modified or ETag
         header.

   To handle content negotiation, HTTP requests MAY include an HTTP
   Accept header field.  This header field SHOULD should be identified
   using the MIME type specified in Section 7.2.1.  The Accept header
   MAY include additional content types defined by future versions of
   this protocol.

   There are no other restrictions on HTTP headers, besides the
   requirement to set the Content-Type header value to the MIME type
   specified in Section 7.2.1.

7.2.3.  HTTP Operations

   Persistent connections as defined in HTTP/1.1 are OPTIONAL.  DSKPP
   requests are mapped to HTTP requests with the POST method.  DSKPP
   responses are mapped to HTTP responses.

   For the four-pass DSKPP, messages within the protocol run are bound
   together.  In particular, &lt;KeyProvServerHello&gt; is bound to the
   preceding &lt;KeyProvClientHello&gt; by being transmitted in the
   corresponding HTTP response. &lt;KeyProvServerHello&gt; MUST have a
   SessionID attribute, and the SessionID attribute of the subsequent
   &lt;KeyProvClientNonce&gt; message MUST be identical.
   &lt;KeyProvServerFinished&gt; is then once again bound to the rest through
   HTTP (and possibly through a SessionID).

7.2.4.  HTTP Status Codes

   A DSKPP HTTP responder that refuses to perform a message exchange
   with a DSKPP HTTP requester SHOULD return a 403 (Forbidden) response.
   In this case, the content of the HTTP body is not significant.  In
   the case of an HTTP error while processing a DSKPP request, the HTTP
   server MUST return a 500 (Internal Server Error) response.  This type
   of error SHOULD be returned for HTTP-related errors detected before
   control is passed to the DSKPP processor, or when the DSKPP processor
   reports an internal error (for example, the DSKPP XML namespace is
   incorrect, or the DSKPP schema cannot be located).  If a request is
   received that is not a DSKPP Client message, the DSKPP responder MUST
   return a 400 (Bad request) response.

   In these cases (i.e., when the HTTP response code is 4xx or 5xx), the
   content of the HTTP body is not significant.

   Redirection status codes (3xx) apply as usual.

   Whenever the HTTP POST is successfully invoked, the DSKPP HTTP
   responder MUST use the 200 status code and provide a suitable DSKPP
   message (possibly with DSKPP error information included) in the HTTP
   body.

7.2.5.  HTTP Authentication

   No support for HTTP/1.1 authentication is assumed.

7.2.6.  Initialization of DSKPP

   If a user requests key initialization in a browsing session, and if
   that request has an appropriate Accept header (e.g., to a specific
   DSKPP Server URL), the DSKPP Server MAY respond by sending a DSKPP

   initialization message in an HTTP response with Content-Type set
   according to Section 7.2.1 and response code set to 200 (OK).  The
   initialization message MAY carry data in its body, such as the URL
   for the DSKPP Client to use when contacting the DSKPP Server.  If the
   message does carry data, the data MUST be a valid instance of a
   &lt;KeyProvTrigger&gt; element.

   Note that if the user&#x27;s request was directed to some other resource,
   the DSKPP Server MUST NOT respond by combining the DSKPP content type
   with response code 200.  In that case, the DSKPP Server SHOULD
   respond by sending a DSKPP initialization message in an HTTP response
   with Content-Type set according to Section 7.2.1 and response code
   set to 406 (Not Acceptable).

7.2.7.  Example Messages

   a.  Initialization from DSKPP Server:
       HTTP/1.1 200 OK

       Cache-Control: no-store
       Content-Type: application/dskpp+xml
       Content-Length: &lt;some value&gt;

       DSKPP initialization data in XML form...

   b.  Initial request from DSKPP Client:
       POST http://example.com/cgi-bin/DSKPP-server HTTP/1.1

       Cache-Control: no-cache, no-store
       Pragma: no-cache
       Host: www.example.com
       Content-Type: application/dskpp+xml
       Content-Length: &lt;some value&gt;

       DSKPP data in XML form (supported version, supported
       algorithms...)

   c.  Initial response from DSKPP Server:
       HTTP/1.1 200 OK

       Cache-Control: no-cache, no-must-revalidate, private
       Pragma: no-cache
       Content-Type: application/dskpp+xml
       Content-Length: &lt;some value&gt;

       DSKPP data in XML form (server random nonce, server public key,
       ...)

8.  DSKPP XML Schema

8.1.  General Processing Requirements

   Some DSKPP elements rely on the parties being able to compare
   received values with stored values.  Unless otherwise noted, all
   elements that have the XML schema &quot;xs:string&quot; type, or a type derived
   from it, MUST be compared using an exact binary comparison.  In
   particular, DSKPP implementations MUST NOT depend on case-insensitive
   string comparisons, normalization or trimming of white space, or
   conversion of locale-specific formats such as numbers.

   Implementations that compare values that are represented using
   different character encodings MUST use a comparison method that
   returns the same result as converting both values to the Unicode
   character encoding [UNICODE] and then performing an exact binary
   comparison.

   No collation or sorting order for attributes or element values is
   defined.  Therefore, DSKPP implementations MUST NOT depend on
   specific sorting orders for values.

8.2.  Schema

    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
    &lt;xs:schema
       xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
       xmlns:dskpp=&quot;urn:ietf:params:xml:ns:keyprov:dskpp&quot;
       xmlns:pskc=&quot;urn:ietf:params:xml:ns:keyprov:pskc&quot;
       xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;
       targetNamespace=&quot;urn:ietf:params:xml:ns:keyprov:dskpp&quot;
       elementFormDefault=&quot;qualified&quot; attributeFormDefault=&quot;unqualified&quot;
          version=&quot;1.0&quot;&gt;
       &lt;xs:import namespace=&quot;http://www.w3.org/2000/09/xmldsig#&quot;
          schemaLocation=
          &quot;http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/
          xmldsig-core-schema.xsd&quot;/&gt;
       &lt;xs:import namespace=&quot;urn:ietf:params:xml:ns:keyprov:pskc&quot;
          schemaLocation=&quot;keyprov-pskc-1.0.xsd&quot;/&gt;
       &lt;xs:complexType name=&quot;AbstractRequestType&quot; abstract=&quot;true&quot;&gt;
          &lt;xs:annotation&gt;
             &lt;xs:documentation&gt; Basic types &lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
          &lt;xs:attribute name=&quot;Version&quot; type=&quot;dskpp:VersionType&quot;
             use=&quot;required&quot;/&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:complexType name=&quot;AbstractResponseType&quot; abstract=&quot;true&quot;&gt;
          &lt;xs:annotation&gt;
             &lt;xs:documentation&gt; Basic types &lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
          &lt;xs:attribute name=&quot;Version&quot; type=&quot;dskpp:VersionType&quot;
             use=&quot;required&quot;/&gt;
          &lt;xs:attribute name=&quot;SessionID&quot; type=&quot;dskpp:IdentifierType&quot; /&gt;
          &lt;xs:attribute name=&quot;Status&quot; type=&quot;dskpp:StatusCode&quot;
             use=&quot;required&quot;/&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:simpleType name=&quot;VersionType&quot;&gt;
          &lt;xs:restriction base=&quot;xs:string&quot;&gt;
             &lt;xs:pattern value=&quot;\d{1,2}\.\d{1,3}&quot; /&gt;
          &lt;/xs:restriction&gt;
       &lt;/xs:simpleType&gt;

       &lt;xs:simpleType name=&quot;IdentifierType&quot;&gt;
          &lt;xs:restriction base=&quot;xs:string&quot;&gt;
             &lt;xs:maxLength value=&quot;128&quot; /&gt;
          &lt;/xs:restriction&gt;
       &lt;/xs:simpleType&gt;

       &lt;xs:simpleType name=&quot;StatusCode&quot;&gt;
          &lt;xs:restriction base=&quot;xs:string&quot;&gt;
             &lt;xs:enumeration value=&quot;Continue&quot; /&gt;
             &lt;xs:enumeration value=&quot;Success&quot; /&gt;
             &lt;xs:enumeration value=&quot;Abort&quot; /&gt;
             &lt;xs:enumeration value=&quot;AccessDenied&quot; /&gt;
             &lt;xs:enumeration value=&quot;MalformedRequest&quot; /&gt;
             &lt;xs:enumeration value=&quot;UnknownRequest&quot; /&gt;
             &lt;xs:enumeration value=&quot;UnknownCriticalExtension&quot; /&gt;
             &lt;xs:enumeration value=&quot;UnsupportedVersion&quot; /&gt;
             &lt;xs:enumeration value=&quot;NoSupportedKeyTypes&quot; /&gt;
             &lt;xs:enumeration value=&quot;NoSupportedEncryptionAlgorithms&quot; /&gt;
             &lt;xs:enumeration value=&quot;NoSupportedMacAlgorithms&quot; /&gt;
             &lt;xs:enumeration value=&quot;NoProtocolVariants&quot; /&gt;
             &lt;xs:enumeration value=&quot;NoSupportedKeyPackages&quot; /&gt;
             &lt;xs:enumeration value=&quot;AuthenticationDataMissing&quot; /&gt;
             &lt;xs:enumeration value=&quot;AuthenticationDataInvalid&quot; /&gt;
             &lt;xs:enumeration value=&quot;InitializationFailed&quot; /&gt;
             &lt;xs:enumeration value=&quot;ProvisioningPeriodExpired&quot; /&gt;
          &lt;/xs:restriction&gt;
       &lt;/xs:simpleType&gt;

       &lt;xs:complexType name=&quot;DeviceIdentifierDataType&quot;&gt;
          &lt;xs:choice&gt;
             &lt;xs:element name=&quot;DeviceId&quot; type=&quot;pskc:DeviceInfoType&quot; /&gt;
             &lt;xs:any namespace=&quot;##other&quot; processContents=&quot;strict&quot; /&gt;
          &lt;/xs:choice&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:simpleType name=&quot;PlatformType&quot;&gt;
          &lt;xs:restriction base=&quot;xs:string&quot;&gt;
             &lt;xs:enumeration value=&quot;Hardware&quot; /&gt;
             &lt;xs:enumeration value=&quot;Software&quot; /&gt;
             &lt;xs:enumeration value=&quot;Unspecified&quot; /&gt;
          &lt;/xs:restriction&gt;
       &lt;/xs:simpleType&gt;

       &lt;xs:complexType name=&quot;TokenPlatformInfoType&quot;&gt;
          &lt;xs:attribute name=&quot;KeyLocation&quot;
             type=&quot;dskpp:PlatformType&quot;/&gt;
          &lt;xs:attribute name=&quot;AlgorithmLocation&quot;
             type=&quot;dskpp:PlatformType&quot;/&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:simpleType name=&quot;NonceType&quot;&gt;
          &lt;xs:restriction base=&quot;xs:base64Binary&quot;&gt;
             &lt;xs:minLength value=&quot;16&quot; /&gt;
          &lt;/xs:restriction&gt;
       &lt;/xs:simpleType&gt;

       &lt;xs:complexType name=&quot;AlgorithmsType&quot;&gt;
          &lt;xs:sequence maxOccurs=&quot;unbounded&quot;&gt;
             &lt;xs:element name=&quot;Algorithm&quot; type=&quot;dskpp:AlgorithmType&quot;/&gt;
          &lt;/xs:sequence&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:simpleType name=&quot;AlgorithmType&quot;&gt;
          &lt;xs:restriction base=&quot;xs:anyURI&quot; /&gt;
       &lt;/xs:simpleType&gt;

       &lt;xs:complexType name=&quot;ProtocolVariantsType&quot;&gt;
          &lt;xs:sequence&gt;
             &lt;xs:element name=&quot;FourPass&quot; minOccurs=&quot;0&quot; /&gt;
             &lt;xs:element name=&quot;TwoPass&quot;
                type=&quot;dskpp:KeyProtectionDataType&quot; minOccurs=&quot;0&quot;/&gt;
          &lt;/xs:sequence&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:complexType name=&quot;KeyProtectionDataType&quot;&gt;
          &lt;xs:annotation&gt;
             &lt;xs:documentation xml:lang=&quot;en&quot;&gt;
                This element is only valid for two-pass DSKPP.
             &lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
          &lt;xs:sequence maxOccurs=&quot;unbounded&quot;&gt;
            &lt;xs:element name=&quot;SupportedKeyProtectionMethod&quot;
               type=&quot;xs:anyURI&quot;/&gt;
            &lt;xs:element name=&quot;Payload&quot;
               type=&quot;dskpp:PayloadType&quot; minOccurs=&quot;0&quot;/&gt;
          &lt;/xs:sequence&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:complexType name=&quot;PayloadType&quot;&gt;
          &lt;xs:choice&gt;
             &lt;xs:element name=&quot;Nonce&quot; type=&quot;dskpp:NonceType&quot; /&gt;
             &lt;xs:any namespace=&quot;##other&quot; processContents=&quot;strict&quot;/&gt;
          &lt;/xs:choice&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:complexType name=&quot;KeyPackagesFormatType&quot;&gt;
          &lt;xs:sequence maxOccurs=&quot;unbounded&quot;&gt;
             &lt;xs:element name=&quot;KeyPackageFormat&quot;
                type=&quot;dskpp:KeyPackageFormatType&quot;/&gt;
          &lt;/xs:sequence&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:simpleType name=&quot;KeyPackageFormatType&quot;&gt;
          &lt;xs:restriction base=&quot;xs:anyURI&quot; /&gt;
       &lt;/xs:simpleType&gt;

       &lt;xs:complexType name=&quot;AuthenticationDataType&quot;&gt;
          &lt;xs:annotation&gt;
             &lt;xs:documentation xml:lang=&quot;en&quot;&gt;
                Authentication Data contains a MAC.
             &lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
          &lt;xs:sequence&gt;
             &lt;xs:element name=&quot;ClientID&quot;
                type=&quot;dskpp:IdentifierType&quot; minOccurs=&quot;0&quot;/&gt;
             &lt;xs:choice&gt;
                &lt;xs:element name=&quot;AuthenticationCodeMac&quot;
                   type=&quot;dskpp:AuthenticationMacType&quot;/&gt;
                &lt;xs:any namespace=&quot;##other&quot; processContents=&quot;strict&quot; /&gt;
             &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:complexType name=&quot;AuthenticationMacType&quot;&gt;
          &lt;xs:sequence&gt;
             &lt;xs:element minOccurs=&quot;0&quot; name=&quot;Nonce&quot;
                type=&quot;dskpp:NonceType&quot;/&gt;
             &lt;xs:element minOccurs=&quot;0&quot; name=&quot;IterationCount&quot;
                type=&quot;xs:int&quot;/&gt;
             &lt;xs:element name=&quot;Mac&quot; type=&quot;dskpp:MacType&quot; /&gt;
          &lt;/xs:sequence&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:complexType name=&quot;MacType&quot;&gt;
          &lt;xs:simpleContent&gt;
             &lt;xs:extension base=&quot;xs:base64Binary&quot;&gt;
                &lt;xs:attribute name=&quot;MacAlgorithm&quot; type=&quot;xs:anyURI&quot;/&gt;
             &lt;/xs:extension&gt;
          &lt;/xs:simpleContent&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:complexType name=&quot;KeyPackageType&quot;&gt;
          &lt;xs:sequence&gt;
             &lt;xs:element minOccurs=&quot;0&quot; name=&quot;ServerID&quot;
                type=&quot;xs:anyURI&quot;/&gt;
             &lt;xs:element minOccurs=&quot;0&quot; name=&quot;KeyProtectionMethod&quot;
                type=&quot;xs:anyURI&quot; /&gt;
             &lt;xs:choice&gt;
                &lt;xs:element name=&quot;KeyContainer&quot;
                   type=&quot;pskc:KeyContainerType&quot;/&gt;
                &lt;xs:any namespace=&quot;##other&quot; processContents=&quot;strict&quot;/&gt;
             &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:complexType name=&quot;InitializationTriggerType&quot;&gt;
          &lt;xs:sequence&gt;
             &lt;xs:element minOccurs=&quot;0&quot; name=&quot;DeviceIdentifierData&quot;
                type=&quot;dskpp:DeviceIdentifierDataType&quot; /&gt;
             &lt;xs:element minOccurs=&quot;0&quot; name=&quot;KeyID&quot;
                type=&quot;xs:base64Binary&quot;/&gt;
             &lt;xs:element minOccurs=&quot;0&quot; name=&quot;TokenPlatformInfo&quot;
                type=&quot;dskpp:TokenPlatformInfoType&quot; /&gt;
             &lt;xs:element name=&quot;AuthenticationData&quot;
                type=&quot;dskpp:AuthenticationDataType&quot; /&gt;
             &lt;xs:element minOccurs=&quot;0&quot; name=&quot;ServerUrl&quot;
                type=&quot;xs:anyURI&quot;/&gt;
             &lt;xs:any minOccurs=&quot;0&quot; namespace=&quot;##other&quot;
                processContents=&quot;strict&quot; /&gt;
          &lt;/xs:sequence&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:complexType name=&quot;ExtensionsType&quot;&gt;
          &lt;xs:annotation&gt;
             &lt;xs:documentation&gt; Extension types &lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
          &lt;xs:sequence maxOccurs=&quot;unbounded&quot;&gt;
             &lt;xs:element name=&quot;Extension&quot;
                type=&quot;dskpp:AbstractExtensionType&quot;/&gt;
          &lt;/xs:sequence&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:complexType name=&quot;AbstractExtensionType&quot; abstract=&quot;true&quot;&gt;
          &lt;xs:attribute name=&quot;Critical&quot; type=&quot;xs:boolean&quot; /&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:complexType name=&quot;ClientInfoType&quot;&gt;
          &lt;xs:complexContent mixed=&quot;false&quot;&gt;
             &lt;xs:extension base=&quot;dskpp:AbstractExtensionType&quot;&gt;
                &lt;xs:sequence&gt;
                   &lt;xs:element name=&quot;Data&quot; type=&quot;xs:base64Binary&quot;/&gt;
                &lt;/xs:sequence&gt;
             &lt;/xs:extension&gt;
          &lt;/xs:complexContent&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:complexType name=&quot;ServerInfoType&quot;&gt;
          &lt;xs:complexContent mixed=&quot;false&quot;&gt;
             &lt;xs:extension base=&quot;dskpp:AbstractExtensionType&quot;&gt;
                &lt;xs:sequence&gt;
                   &lt;xs:element name=&quot;Data&quot; type=&quot;xs:base64Binary&quot;/&gt;
                &lt;/xs:sequence&gt;
             &lt;/xs:extension&gt;
          &lt;/xs:complexContent&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:element name=&quot;KeyProvTrigger&quot;
          type=&quot;dskpp:KeyProvTriggerType&quot;&gt;
          &lt;xs:annotation&gt;
             &lt;xs:documentation&gt; DSKPP PDUs &lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
       &lt;/xs:element&gt;

       &lt;xs:complexType name=&quot;KeyProvTriggerType&quot;&gt;
          &lt;xs:annotation&gt;
          &lt;xs:documentation xml:lang=&quot;en&quot;&gt;
             Message used to trigger the device to initiate a
             DSKPP run.
          &lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
          &lt;xs:sequence&gt;
             &lt;xs:choice&gt;
                &lt;xs:element name=&quot;InitializationTrigger&quot;
                   type=&quot;dskpp:InitializationTriggerType&quot; /&gt;
                &lt;xs:any namespace=&quot;##other&quot; processContents=&quot;strict&quot;/&gt;
             &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name=&quot;Version&quot; type=&quot;dskpp:VersionType&quot;/&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:element name=&quot;KeyProvClientHello&quot;
          type=&quot;dskpp:KeyProvClientHelloPDU&quot;&gt;
          &lt;xs:annotation&gt;
             &lt;xs:documentation&gt;KeyProvClientHello PDU&lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
       &lt;/xs:element&gt;
       &lt;xs:complexType name=&quot;KeyProvClientHelloPDU&quot;&gt;
          &lt;xs:annotation&gt;
             &lt;xs:documentation xml:lang=&quot;en&quot;&gt;
                Message sent from DSKPP Client to DSKPP Server to
                initiate a DSKPP session.
             &lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
          &lt;xs:complexContent mixed=&quot;false&quot;&gt;
             &lt;xs:extension base=&quot;dskpp:AbstractRequestType&quot;&gt;
                &lt;xs:sequence&gt;
                   &lt;xs:element minOccurs=&quot;0&quot; name=&quot;DeviceIdentifierData&quot;
                      type=&quot;dskpp:DeviceIdentifierDataType&quot; /&gt;
                   &lt;xs:element minOccurs=&quot;0&quot; name=&quot;KeyID&quot;
                      type=&quot;xs:base64Binary&quot; /&gt;
                   &lt;xs:element minOccurs=&quot;0&quot; name=&quot;ClientNonce&quot;
                      type=&quot;dskpp:NonceType&quot; /&gt;
                   &lt;xs:element name=&quot;SupportedKeyTypes&quot;
                      type=&quot;dskpp:AlgorithmsType&quot; /&gt;
                   &lt;xs:element name=&quot;SupportedEncryptionAlgorithms&quot;
                      type=&quot;dskpp:AlgorithmsType&quot; /&gt;
                   &lt;xs:element name=&quot;SupportedMacAlgorithms&quot;
                      type=&quot;dskpp:AlgorithmsType&quot; /&gt;
                   &lt;xs:element minOccurs=&quot;0&quot;
                      name=&quot;SupportedProtocolVariants&quot;
                      type=&quot;dskpp:ProtocolVariantsType&quot; /&gt;

                   &lt;xs:element minOccurs=&quot;0&quot; name=&quot;SupportedKeyPackages&quot;
                      type=&quot;dskpp:KeyPackagesFormatType&quot; /&gt;
                   &lt;xs:element minOccurs=&quot;0&quot; name=&quot;AuthenticationData&quot;
                      type=&quot;dskpp:AuthenticationDataType&quot; /&gt;
                   &lt;xs:element minOccurs=&quot;0&quot; name=&quot;Extensions&quot;
                      type=&quot;dskpp:ExtensionsType&quot; /&gt;
                &lt;/xs:sequence&gt;
             &lt;/xs:extension&gt;
          &lt;/xs:complexContent&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:element name=&quot;KeyProvServerHello&quot;
          type=&quot;dskpp:KeyProvServerHelloPDU&quot;&gt;
          &lt;xs:annotation&gt;
             &lt;xs:documentation&gt;KeyProvServerHello PDU&lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
       &lt;/xs:element&gt;
       &lt;xs:complexType name=&quot;KeyProvServerHelloPDU&quot;&gt;
          &lt;xs:annotation&gt;
             &lt;xs:documentation xml:lang=&quot;en&quot;&gt;
                Response message sent from DSKPP Server to DSKPP Client
                in four-pass DSKPP.
             &lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
          &lt;xs:complexContent mixed=&quot;false&quot;&gt;
             &lt;xs:extension base=&quot;dskpp:AbstractResponseType&quot;&gt;
                &lt;xs:sequence minOccurs=&quot;0&quot;&gt;
                   &lt;xs:element name=&quot;KeyType&quot;
                      type=&quot;dskpp:AlgorithmType&quot;/&gt;
                   &lt;xs:element name=&quot;EncryptionAlgorithm&quot;
                      type=&quot;dskpp:AlgorithmType&quot; /&gt;
                   &lt;xs:element name=&quot;MacAlgorithm&quot;
                      type=&quot;dskpp:AlgorithmType&quot;/&gt;
                   &lt;xs:element name=&quot;EncryptionKey&quot;
                      type=&quot;ds:KeyInfoType&quot;/&gt;
                   &lt;xs:element name=&quot;KeyPackageFormat&quot;
                      type=&quot;dskpp:KeyPackageFormatType&quot; /&gt;
                   &lt;xs:element name=&quot;Payload&quot; type=&quot;dskpp:PayloadType&quot;/&gt;
                   &lt;xs:element minOccurs=&quot;0&quot; name=&quot;Extensions&quot;
                      type=&quot;dskpp:ExtensionsType&quot; /&gt;
                   &lt;xs:element minOccurs=&quot;0&quot; name=&quot;Mac&quot;
                      type=&quot;dskpp:MacType&quot;/&gt;
                &lt;/xs:sequence&gt;
             &lt;/xs:extension&gt;
          &lt;/xs:complexContent&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:element name=&quot;KeyProvClientNonce&quot;
          type=&quot;dskpp:KeyProvClientNoncePDU&quot;&gt;
          &lt;xs:annotation&gt;
             &lt;xs:documentation&gt;KeyProvClientNonce PDU&lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
       &lt;/xs:element&gt;
       &lt;xs:complexType name=&quot;KeyProvClientNoncePDU&quot;&gt;
          &lt;xs:annotation&gt;
             &lt;xs:documentation xml:lang=&quot;en&quot;&gt;
                Response message sent from DSKPP Client to
                DSKPP Server in a four-pass DSKPP session.
             &lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
          &lt;xs:complexContent mixed=&quot;false&quot;&gt;
             &lt;xs:extension base=&quot;dskpp:AbstractRequestType&quot;&gt;
                &lt;xs:sequence&gt;
                   &lt;xs:element name=&quot;EncryptedNonce&quot;
                      type=&quot;xs:base64Binary&quot;/&gt;
                   &lt;xs:element minOccurs=&quot;0&quot; name=&quot;AuthenticationData&quot;
                      type=&quot;dskpp:AuthenticationDataType&quot; /&gt;
                   &lt;xs:element minOccurs=&quot;0&quot; name=&quot;Extensions&quot;
                      type=&quot;dskpp:ExtensionsType&quot; /&gt;
                &lt;/xs:sequence&gt;
                &lt;xs:attribute name=&quot;SessionID&quot;
                   type=&quot;dskpp:IdentifierType&quot; use=&quot;required&quot;/&gt;
             &lt;/xs:extension&gt;
          &lt;/xs:complexContent&gt;
       &lt;/xs:complexType&gt;

       &lt;xs:element name=&quot;KeyProvServerFinished&quot;
          type=&quot;dskpp:KeyProvServerFinishedPDU&quot;&gt;
          &lt;xs:annotation&gt;
             &lt;xs:documentation&gt;
                KeyProvServerFinished PDU
             &lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
       &lt;/xs:element&gt;
       &lt;xs:complexType name=&quot;KeyProvServerFinishedPDU&quot;&gt;
          &lt;xs:annotation&gt;
             &lt;xs:documentation xml:lang=&quot;en&quot;&gt;
                Final message sent from DSKPP Server to DSKPP Client in
                a DSKPP session.  A MAC value serves for key
                confirmation, and optional AuthenticationData serves for
                server authentication.
             &lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
          &lt;xs:complexContent mixed=&quot;false&quot;&gt;
             &lt;xs:extension base=&quot;dskpp:AbstractResponseType&quot;&gt;

                &lt;xs:sequence minOccurs=&quot;0&quot;&gt;
                   &lt;xs:element name=&quot;KeyPackage&quot;
                      type=&quot;dskpp:KeyPackageType&quot; /&gt;
                   &lt;xs:element minOccurs=&quot;0&quot; name=&quot;Extensions&quot;
                      type=&quot;dskpp:ExtensionsType&quot; /&gt;
                   &lt;xs:element name=&quot;Mac&quot; type=&quot;dskpp:MacType&quot; /&gt;
                   &lt;xs:element minOccurs=&quot;0&quot; name=&quot;AuthenticationData&quot;
                      type=&quot;dskpp:AuthenticationMacType&quot; /&gt;
                &lt;/xs:sequence&gt;
             &lt;/xs:extension&gt;
          &lt;/xs:complexContent&gt;
       &lt;/xs:complexType&gt;
     &lt;/xs:schema&gt;

9.  Conformance Requirements

   In order to assure that all implementations of DSKPP can
   interoperate, the DSKPP Server:

   a.  MUST implement the four-pass variation of the protocol
       (Section 4)

   b.  MUST implement the two-pass variation of the protocol (Section 5)

   c.  MUST support user authentication (Section 3.2.1)

   d.  MUST support the following key derivation functions:
       *  DSKPP-PRF-AES DSKPP-PRF realization (Appendix D)
       *  DSKPP-PRF-SHA256 DSKPP-PRF realization (Appendix D)

   e.  MUST support the following encryption mechanisms for protection
       of the client nonce in the four-pass protocol:
       *  Mechanism described in Section 4.2.4

   f.  MUST support one of the following encryption algorithms for
       symmetric key operations, e.g., key wrap:
       *  KW-AES128 without padding; refer to
          http://www.w3.org/2001/04/xmlenc#kw-aes128 in [XMLENC]
       *  KW-AES128 with padding; refer to
          http://www.w3.org/2001/04/xmlenc#kw-aes128 in [XMLENC] and
          [RFC5649]
       *  AES-CBC-128; refer to [FIPS197-AES]

   g.  MUST support the following encryption algorithms for asymmetric
       key operations, e.g., key transport:
       *  RSA Encryption Scheme [PKCS-1]

   h.  MUST support the following integrity/KDF MAC functions:
       *  DSKPP-PRF-AES (Appendix D)
       *  DSKPP-PRF-SHA256 (Appendix D)

   i.  MUST support the PSKC key package [RFC6030]; all three PSKC key
       protection methods (Key Transport, Key Wrap, and Passphrase-Based
       Key Wrap) MUST be implemented

   j.  MAY support the ASN.1 key package as defined in [RFC6031]

   DSKPP Clients MUST support either the two-pass or the four-pass
   variant of the protocol.  DSKPP Clients MUST fulfill all requirements
   listed in item (c) - (j).

   Finally, implementations of DSKPP MUST bind DSKPP messages to
   HTTP/1.1 as described in Section 7.2.

   Of course, DSKPP is a security protocol, and one of its major
   functions is to allow only authorized parties to successfully
   initialize a cryptographic module with a new symmetric key.
   Therefore, a particular implementation may be configured with any of
   a number of restrictions concerning algorithms and trusted
   authorities that will prevent universal interoperability.

10.  Security Considerations

10.1.  General

   DSKPP is designed to protect generated keying material from exposure.
   No entities other than the DSKPP Server and the cryptographic module
   will have access to a generated K_TOKEN if the cryptographic
   algorithms used are of sufficient strength and, on the DSKPP Client
   side, generation and encryption of R_C and generation of K_TOKEN take
   place as specified in the cryptographic module.  This applies even if
   malicious software is present in the DSKPP Client.  However, as
   discussed in the following sub-sections, DSKPP does not protect
   against certain other threats resulting from man-in-the-middle
   attacks and other forms of attacks.  DSKPP MUST, therefore, be run
   over a transport providing confidentiality and integrity, such as
   HTTP over Transport Layer Security (TLS) with a suitable ciphersuite
   [RFC2818], when such threats are a concern.  Note that TLS
   ciphersuites with anonymous key exchanges are not suitable in those
   situations [RFC5246].

10.2.  Active Attacks

10.2.1.  Introduction

   An active attacker MAY attempt to modify, delete, insert, replay, or
   reorder messages for a variety of purposes including service denial
   and compromise of generated keying material.

10.2.2.  Message Modifications

   Modifications to a &lt;KeyProvTrigger&gt; message will either cause denial
   of service (modifications of any of the identifiers or the
   Authentication Code) or will cause the DSKPP Client to contact the
   wrong DSKPP Server.  The latter is in effect a man-in-the-middle
   attack and is discussed further in Section 10.2.7.

   An attacker may modify a &lt;KeyProvClientHello&gt; message.  This means
   that the attacker could indicate a different key or device than the
   one intended by the DSKPP Client, and could also suggest other
   cryptographic algorithms than the ones preferred by the DSKPP Client,
   e.g., cryptographically weaker ones.  The attacker could also suggest
   earlier versions of DSKPP, in case these versions have been shown to
   have vulnerabilities.  These modifications could lead to an attacker
   succeeding in initializing or modifying another cryptographic module
   than the one intended (i.e., the server assigning the generated key
   to the wrong module) or gaining access to a generated key through the
   use of weak cryptographic algorithms or protocol versions.  DSKPP
   implementations MAY protect against the latter by having strict
   policies about what versions and algorithms they support and accept.
   The former threat (assignment of a generated key to the wrong module)
   is not possible when the shared-key variant of DSKPP is employed
   (assuming existing shared keys are unique per cryptographic module),
   but is possible in the public key variation.  Therefore, DSKPP
   Servers MUST NOT accept unilaterally provided device identifiers in
   the public key variation.  This is also indicated in the protocol
   description.  In the shared-key variation, however, an attacker may
   be able to provide the wrong identifier (possibly also leading to the
   incorrect user being associated with the generated key) if the
   attacker has real-time access to the cryptographic module with the
   identified key.  The result of this attack could be that the
   generated key is associated with the correct cryptographic module but
   the module is associated with the incorrect user.  See Section 10.5
   for a further discussion of this threat and possible countermeasures.

   An attacker may also modify a &lt;KeyProvServerHello&gt; message.  This
   means that the attacker could indicate different key types,
   algorithms, or protocol versions than the legitimate server would,
   e.g., cryptographically weaker ones.  The attacker may also provide a

   different nonce than the one sent by the legitimate server.  Clients
   MAY protect against the former through strict adherence to policies
   regarding permissible algorithms and protocol versions.  The latter
   (wrong nonce) will not constitute a security problem, as a generated
   key will not match the key generated on the legitimate server.  Also,
   whenever the DSKPP run would result in the replacement of an existing
   key, the &lt;Mac&gt; element protects against modifications of R_S.

   Modifications of &lt;KeyProvClientNonce&gt; messages are also possible.  If
   an attacker modifies the SessionID attribute, then, in effect, a
   switch to another session will occur at the server, assuming the new
   SessionID is valid at that time on the server.  It still will not
   allow the attacker to learn a generated K_TOKEN since R_C has been
   wrapped for the legitimate server.  Modifications of the
   &lt;EncryptedNonce&gt; element, e.g., replacing it with a value for which
   the attacker knows an underlying R&#x27;C, will not result in the client
   changing its pre-DSKPP state, since the server will be unable to
   provide a valid MAC in its final message to the client.  The server
   MAY, however, end up storing K&#x27;TOKEN rather than K_TOKEN.  If the
   cryptographic module has been associated with a particular user, then
   this could constitute a security problem.  For a further discussion
   about this threat, and a possible countermeasure, see Section 10.5
   below.  Note that use of TLS does not protect against this attack if
   the attacker has access to the DSKPP Client (e.g., through malicious
   software, &quot;Trojans&quot;) [RFC5246].

   Finally, attackers may also modify the &lt;KeyProvServerFinished&gt;
   message.  Replacing the &lt;Mac&gt; element will only result in denial of
   service.  Replacement of any other element may cause the DSKPP Client
   to associate, e.g., the wrong service with the generated key.  DSKPP
   SHOULD be run over a transport providing confidentiality and
   integrity when this is a concern.

10.2.3.  Message Deletion

   Message deletion will not cause any other harm than denial of
   service, since a cryptographic module MUST NOT change its state
   (i.e., &quot;commit&quot; to a generated key) until it receives the final
   message from the DSKPP Server and successfully has processed that
   message, including validation of its MAC.  A deleted
   &lt;KeyProvServerFinished&gt; message will not cause the server to end up
   in an inconsistent state vis-a-vis the cryptographic module if the
   server implements the suggestions in Section 10.5.

10.2.4.  Message Insertion

   An active attacker may initiate a DSKPP run at any time, and suggest
   any device identifier.  DSKPP Server implementations MAY receive some
   protection against inadvertently initializing a key or inadvertently
   replacing an existing key or assigning a key to a cryptographic
   module by initializing the DSKPP run by use of the &lt;KeyProvTrigger&gt;.
   The &lt;AuthenticationData&gt; element allows the server to associate a
   DSKPP run e.g., with an earlier user-authenticated session.  The
   security of this method, therefore, depends on the ability to protect
   the &lt;AuthenticationData&gt; element in the DSKPP initialization message.
   If an eavesdropper is able to capture this message, he may race the
   legitimate user for a key initialization.  DSKPP over a transport
   providing confidentiality and integrity, coupled with the
   recommendations in Section 10.5, is RECOMMENDED when this is a
   concern.

   Insertion of other messages into an existing protocol run is seen as
   equivalent to modification of legitimately sent messages.

10.2.5.  Message Replay

   During four-pass DSKPP, attempts to replay a previously recorded
   DSKPP message will be detected, as the use of nonces ensures that
   both parties are live.  For example, a DSKPP Client knows that a
   server it is communicating with is &quot;live&quot; since the server MUST
   create a MAC on information sent by the client.

   The same is true for two-pass DSKPP thanks to the requirement that
   the client sends R in the &lt;KeyProvClientHello&gt; message and that the
   server includes R in the MAC computation.

10.2.6.  Message Reordering

   An attacker may attempt to re-order four-pass DSKPP messages but this
   will be detected, as each message is of a unique type.  Note: Message
   re-ordering attacks cannot occur in two-pass DSKPP since each party
   sends at most one message each.

10.2.7.  Man in the Middle

   In addition to other active attacks, an attacker posing as a man in
   the middle may be able to provide his own public key to the DSKPP
   Client.  This threat and countermeasures to it are discussed in
   Section 4.1.1.  An attacker posing as a man in the middle may also be
   acting as a proxy and, hence, may not interfere with DSKPP runs but
   still learn valuable information; see Section 10.3.

10.3.  Passive Attacks

   Passive attackers may eavesdrop on DSKPP runs to learn information
   that later on may be used to impersonate users, mount active attacks,
   etc.

   If DSKPP is not run over a transport providing confidentiality, a
   passive attacker may learn:

   o  What cryptographic modules a particular user possesses

   o  The identifiers of keys on those cryptographic modules and other
      attributes pertaining to those keys, e.g., the lifetime of the
      keys

   o  DSKPP versions and cryptographic algorithms supported by a
      particular DSKPP Client or server

   o  Any value present in an &lt;extension&gt; that is part of
      &lt;KeyProvClientHello&gt;

   Whenever the above is a concern, DSKPP MUST be run over a transport
   providing confidentiality.  If man-in-the-middle attacks for the
   purposes described above are a concern, the transport MUST also offer
   server-side authentication.

10.4.  Cryptographic Attacks

   An attacker with unlimited access to an initialized cryptographic
   module may use the module as an &quot;oracle&quot; to pre-compute values that
   later on may be used to impersonate the DSKPP Server.  Section 4.1.1
   contains a discussion of this threat and steps RECOMMENDED to protect
   against it.

   Implementers are advised that cryptographic algorithms become weaker
   with time.  As new cryptographic techniques are developed and
   computing performance improves, the work factor to break a particular
   cryptographic algorithm will reduce.  Therefore, cryptographic

   algorithm implementations SHOULD be modular allowing new algorithms
   to be readily inserted.  That is, implementers SHOULD be prepared to
   regularly update the algorithms in their implementations.

10.5.  Attacks on the Interaction between DSKPP and User Authentication

   If keys generated in DSKPP will be associated with a particular user
   at the DSKPP Server (or a server trusted by, and communicating with
   the DSKPP Server), then in order to protect against threats where an
   attacker replaces a client-provided encrypted R_C with his own R&#x27;C
   (regardless of whether the public key variation or the shared-secret
   variation of DSKPP is employed to encrypt the client nonce), the
   server SHOULD NOT commit to associate a generated K_TOKEN with the
   given cryptographic module until the user simultaneously has proven
   both possession of the device that hosts the cryptographic module
   containing K_TOKEN and some out-of-band provided authenticating
   information (e.g., an Authentication Code).  For example, if the
   cryptographic module is a one-time password token, the user could be
   required to authenticate with both a one-time password generated by
   the cryptographic module and an out-of-band provided Authentication
   Code in order to have the server &quot;commit&quot; to the generated OTP value
   for the given user.  Preferably, the user SHOULD perform this
   operation from another host than the one used to initialize keys on
   the cryptographic module, in order to minimize the risk of malicious
   software on the client interfering with the process.

   Note: This scenario, wherein the attacker replaces a client-provided
   R_C with his own R&#x27;C, does not apply to two-pass DSKPP as the client
   does not provide any entropy to K_TOKEN.  The attack as such (and its
   countermeasures) still applies to two-pass DSKPP, however, as it
   essentially is a man-in-the-middle attack.

   Another threat arises when an attacker is able to trick a user into
   authenticating to the attacker rather than to the legitimate service
   before the DSKPP run.  If successful, the attacker will then be able
   to impersonate the user towards the legitimate service, and
   subsequently receive a valid DSKPP trigger.  If the public key
   variant of DSKPP is used, this may result in the attacker being able
   to (after a successful DSKPP run) impersonate the user.  Ordinary
   precautions MUST, therefore, be in place to ensure that users
   authenticate only to legitimate services.

10.6.  Miscellaneous Considerations

10.6.1.  Client Contributions to K_TOKEN Entropy

   In four-pass DSKPP, both the client and the server provide
   randomizing material to K_TOKEN, in a manner that allows both parties
   to verify that they did contribute to the resulting key.  In the two-
   pass DSKPP version defined herein, only the server contributes to the
   entropy of K_TOKEN.  This means that a broken or compromised
   (pseudo)random number generator in the server may cause more damage
   than it would in the four-pass variant.  Server implementations
   SHOULD therefore take extreme care to ensure that this situation does
   not occur.

10.6.2.  Key Confirmation

   four-pass DSKPP Servers provide key confirmation through the MAC on
   R_C in the &lt;KeyProvServerFinished&gt; message.  In the two-pass DSKPP
   variant described herein, key confirmation is provided by the MAC
   including R, using K_MAC.

10.6.3.  Server Authentication

   DSKPP Servers MUST authenticate themselves whenever a successful
   DSKPP two-pass protocol run would result in an existing K_TOKEN being
   replaced by a K_TOKEN&#x27;, or else a denial-of-service attack where an
   unauthorized DSKPP Server replaces a K_TOKEN with another key would
   be possible.  In two-pass DSKPP, servers authenticate by including
   the AuthenticationDataType extension containing a MAC as described in
   Section 5 for two-pass DSKPP.

   Whenever a successful DSKPP two-pass protocol run would result in an
   existing K_TOKEN being replaced by a K_TOKEN&#x27;, the DSKPP Client and
   Server MUST do the following to prevent a denial-of-service attack
   where an unauthorized DSKPP Server replaces a K_TOKEN with another
   key:

   o  The DSKPP Server MUST use the AuthenticationDataType extension to
      transmit a second MAC, calculated as described in Section 5.2.2.

   o  The DSKPP Client MUST authenticate the server using the MAC
      contained in the AuthenticationDataType extension received from
      the DSKPP Server to which it is connected.

10.6.4.  User Authentication

   A DSKPP Server MUST authenticate a client to ensure that K_TOKEN is
   delivered to the intended device.  The following measures SHOULD be
   considered:

   o  When an Authentication Code is used for client authentication, a
      password dictionary attack on the Authentication Data is possible.

   o  The length of the Authentication Code when used over a non-secure
      channel SHOULD be longer than what is used over a secure channel.
      When a device, e.g., some mobile phones with small screens, cannot
      handle a long Authentication Code in a user-friendly manner, DSKPP
      SHOULD rely on a secure channel for communication.

   o  In the case that a non-secure channel has to be used, the
      Authentication Code SHOULD be sent to the server MAC&#x27;d as
      specified in Section 3.4.1.  The Authentication Code and nonce
      value MUST be strong enough to prevent offline brute-force
      recovery of the Authentication Code from the Hashed MAC (HMAC)
      data.  Given that the nonce value is sent in plaintext format over
      a non-secure transport, the cryptographic strength of the
      Authentication Data depends more on the quality of the
      Authentication Code.

   o  When the Authentication Code is sent from the DSKPP Server to the
      device in a DSKPP initialization trigger message, an eavesdropper
      may be able to capture this message and race the legitimate user
      for a key initialization.  To prevent this, the transport layer
      used to send the DSKPP trigger MUST provide confidentiality and
      integrity, e.g. a secure browser session.

10.6.5.  Key Protection in Two-Pass DSKPP

   Three key protection methods are defined for the different usages of
   two-pass DSKPP, which MUST be supported by a key package format, such
   as [RFC6030] and [RFC6031].  Therefore, key protection in the two-
   pass DSKPP is dependent upon the security of the key package format
   selected for a protocol run.  Some considerations for the Passphrase-
   Based Key Wrap method follow.

   The Passphrase-Based Key Wrap method SHOULD depend upon the PBKDF2
   function from [PKCS-5] to generate an encryption key from a
   passphrase and salt string.  It is important to note that passphrase-
   based encryption is generally limited in the security that it
   provides despite the use of salt and iteration count in PBKDF2 to
   increase the complexity of attack.  Implementations SHOULD therefore

   take additional measures to strengthen the security of the
   Passphrase-Based Key Wrap method.  The following measures SHOULD be
   considered where applicable:

   o  The passphrase is the same as the one-time password component of
      the Authentication Code (see Section 3.4.1) for a description of
      the AC format).  The passphrase SHOULD be selected well, and usage
      guidelines such as the ones in [NIST-PWD] SHOULD be taken into
      account.

   o  A different passphrase SHOULD be used for every key initialization
      wherever possible (the use of a global passphrase for a batch of
      cryptographic modules SHOULD be avoided, for example).  One way to
      achieve this is to use randomly generated passphrases.

   o  The passphrase SHOULD be protected well if stored on the server
      and/or on the cryptographic module and SHOULD be delivered to the
      device&#x27;s user using secure methods.

   o  User pre-authentication SHOULD be implemented to ensure that
      K_TOKEN is not delivered to a rogue recipient.

   o  The iteration count in PBKDF2 SHOULD be high to impose more work
      for an attacker using brute-force methods (see [PKCS-5] for
      recommendations).  However, it MUST be noted that the higher the
      count, the more work is required on the legitimate cryptographic
      module to decrypt the newly delivered K_TOKEN.  Servers MAY use
      relatively low iteration counts to accommodate devices with
      limited processing power such as some PDA and cell phones when
      other security measures are implemented and the security of the
      Passphrase-Based Key Wrap method is not weakened.

   o  TLS [RFC5246] SHOULD be used where possible to protect a two-pass
      protocol run.  Transport level security provides a second layer of
      protection for the newly generated K_TOKEN.

10.6.6.  Algorithm Agility

   Many protocols need to be algorithm agile.  One reason for this is
   that in the past many protocols had fixed sized fields for
   information such as hash outputs, keys, etc.  This is not the case
   for DSKPP, except for the key size in the computation of DSKPP-PRF.
   Another reason was that protocols did not support algorithm
   negotiation.  This is also not the case for DSKPP, except for the use
   of SHA-256 in the MAC confirmation message.  Updating the key size
   for DSKPP-PRF or the MAC confirmation message algorithm will require
   a new version of the protocol, which is supported with the Version
   attribute.

11.  Internationalization Considerations

   DSKPP is meant for machine-to-machine communications; as such, its
   elements are tokens not meant for direct human consumption.  DSKPP
   exchanges information using XML.  All XML processors are required to
   understand UTF-8 [RFC3629] encoding, and therefore all DSKPP Clients
   and servers MUST understand UTF-8 encoded XML.  Additionally, DSKPP
   Servers and clients MUST NOT encode XML with encodings other than
   UTF-8.

12.  IANA Considerations

   This document requires several IANA registrations, detailed below.

12.1.  URN Sub-Namespace Registration

   This section registers a new XML namespace,
   &quot;urn:ietf:params:xml:ns:keyprov:dskpp&quot; per the guidelines in
   [RFC3688]:

   URI:  urn:ietf:params:xml:ns:keyprov:dskpp
   Registrant Contact:
      IETF, KEYPROV Working Group (keyprov@ietf.org), Andrea Doherty
      (andrea.doherty@rsa.com)

   XML:
      BEGIN
         &lt;?xml version=&quot;1.0&quot;?&gt;
         &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot;
            &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;
         &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&gt;
         &lt;head&gt;
            &lt;title&gt;DSKPP Messages&lt;/title&gt;
         &lt;/head&gt;
         &lt;body&gt;
            &lt;h1&gt;Namespace for DSKPP Messages&lt;/h1&gt;
            &lt;h2&gt;urn:ietf:params:xml:ns:keyprov:dskpp&lt;/h2&gt;
            &lt;p&gt;See RFC 6063&lt;/p&gt;
         &lt;/body&gt;
         &lt;/html&gt;
      END

12.2.  XML Schema Registration

   This section registers an XML schema as per the guidelines in
   [RFC3688].

   <span class="Verified-inline-styling" id='inline-2948'>URI:  urn:ietf:params:xml:schema:keyprov:dskpp</span id__locate=2948> <button id="btn_2948" target="expand_2948" onclick='hideFunction("expand_2948")'>Expand</button>
<div class="nodeCloseClass" id='expand_2948'><div class='Verified-endnote-styling' id='eid2948'>
<pre>
<b><i><a href='https://www.rfc-editor.org/errata/eid2948'>EID 2948</a> (Verified) is as follows:</i></b>

<b>Section:</b> 12.2

<b>Original Text:</b>

URI:  urn:ietf:params:xml:ns:keyprov:dskpp

<b>Corrected Text:</b>

URI:  urn:ietf:params:xml:schema:keyprov:dskpp
</pre>
<b>Notes:</b><br/>
Section 12.2 is the registration for the schema not the namespace, which is in Section 12.1.  The URI for the schema ought to point to :schema: and not :ns:.  It&#x27;s in the IANA registry it just needs to be updated here.
</div>
</div>   Registrant Contact:
      IETF, KEYPROV Working Group (keyprov@ietf.org), Andrea Doherty
      (andrea.doherty@rsa.com)
   Schema:
      The XML for this schema can be found as the entirety of Section 8
      of this document.

12.3.  MIME Media Type Registration

   This section registers the &quot;application/dskpp+xml&quot; MIME type:

   To:  ietf-types@iana.org
   Subject:  Registration of MIME media type application/dskpp+xml
   MIME media type name:  application
   MIME subtype name:  dskpp+xml
   Required parameters:  (none)
   Optional parameters:  charset
      Indicates the character encoding of enclosed XML.
   Encoding considerations:  Uses XML, which can employ 8-bit
      characters, depending on the character encoding used.  See
      [RFC3023], Section 3.2.  Implementations need to support UTF-8
      [RFC3629].
   Security considerations:  This content type is designed to carry
      protocol data related to key management.  Security mechanisms are
      built into the protocol to ensure that various threats are dealt
      with.  Refer to Section 10 of RFC 6063 for more details
   Interoperability considerations:  None
   Published specification:  RFC 6063.
   Applications that use this media type:  Protocol for key exchange.
   Additional information:
      Magic Number(s): (none)
      File extension(s): .xmls
      Macintosh File Type Code(s): (none)
   Person &amp; email address to contact for further information:
      Andrea Doherty (andrea.doherty@rsa.com)
   Intended usage:  LIMITED USE
   Author/Change controller:  The IETF
   Other information:  This media type is a specialization of
      application/xml [RFC3023], and many of the considerations
      described there also apply to application/dskpp+xml.

12.4.  Status Code Registration

   This section registers status codes included in each DSKPP response
   message.  The status codes are defined in the schema in the
   &lt;StatusCode&gt; type definition contained in the XML schema in
   Section 8.  The following summarizes the registry:

   Related Registry:
      KEYPROV DSKPP Registries, Status codes for DSKPP

   Defining RFC:
      RFC 6063.
   Registration/Assignment Procedures:
      Following the policies outlined in [RFC3575], the IANA policy for
      assigning new values for the status codes for DSKPP MUST be
      &quot;Specification Required&quot; and their meanings MUST be documented in
      an RFC or in some other permanent and readily available reference,
      in sufficient detail that interoperability between independent
      implementations is possible.  No mechanism to mark entries as
      &quot;deprecated&quot; is envisioned.  It is possible to update entries from
      the registry.

   Registrant Contact:
      IETF, KEYPROV working group (keyprov@ietf.org),
      Andrea Doherty (andrea.doherty@rsa.com)

12.5.  DSKPP Version Registration

   This section registers DSKPP version numbers.  The registry has the
   following structure:
   +-------------------------------------------+
   |  DSKPP Version    | Specification         |
   +-------------------------------------------+
   |  1.0              | This document         |
   +-------------------------------------------+

   Standards action is required to define new versions of DSKPP.  It is
   not envisioned to deprecate, delete, or modify existing DSKPP
   versions.

12.6.  PRF Algorithm ID Sub-Registry

   This specification relies on a cryptographic primitive, called
   &quot;DSKPP-PRF&quot; that provides a deterministic transformation of a secret
   key k and a varying length octet string s to a bit string of
   specified length dsLen.  From the point of view of this
   specification, DSKPP-PRF is a &quot;black-box&quot; function that, given the
   inputs, generates a pseudorandom value that can be realized by any

   appropriate and competent cryptographic technique.  Section 3.4.2
   provides two realizations of DSKPP-PRF, DSKPP-PRF-AES, and DSKPP-PRF-
   SHA256.

   This section registers the identifiers associated with these
   realizations.  PRF Algorithm ID Sub-registries are to be subject to
   &quot;Specification Required&quot; as per RFC 5226 [RFC5226].  Updates MUST be
   documented in an RFC or in some other permanent and readily available
   reference, in sufficient detail that interoperability between
   independent implementations is possible.

   Expert approval is required to deprecate a sub-registry.  Once
   deprecated, the PRF Algorithm ID SHOULD NOT be used in any new
   implementations.

12.6.1.  DSKPP-PRF-AES

   This section registers the following in the IETF XML namespace
   registry.

   Common Name:
      DSKPP-PRF-AES

   URI:
      urn:ietf:params:xml:ns:keyprov:dskpp:prf-aes-128

   Identifier Definition:
      The DSKPP-PRF-AES algorithm realization is defined in
      Appendix D.2.2 of this document.

   Registrant Contact:
      IETF, KEYPROV working group (keyprov@ietf.org),
      Andrea Doherty (andrea.doherty@rsa.com)

12.6.2.  DSKPP-PRF-SHA256

   This section registers the following in the IETF XML namespace
   registry.

   Common Name:
      DSKPP-PRF-SHA256

   URI:
      urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256

   Identifier Definition:
      The DSKPP-PRF-SHA256 algorithm realization is defined in
      Appendix D.3.2 of this document.

   Registrant Contact:
      IETF, KEYPROV working group (keyprov@ietf.org),
      Andrea Doherty (andrea.doherty@rsa.com)

12.7.  Key Container Registration

   This section registers the Key Container type.

   Key Container:
      The registration name for the Key Container.

   Specification:
      Key Container defines a key package format that specifies how a
      key should be protected using the three key protection methods
      provided in Section 5.1.

   Registration Procedure:
      Following the policies outlined in [RFC3575], the IANA policy for
      assigning new values for the status codes for DSKPP MUST be
      &quot;Specification Required&quot; and their meanings MUST be documented in
      an RFC or in some other permanent and readily available reference,
      in sufficient detail that interoperability between independent
      implementations is possible.

   Deprecated:
      TRUE if based on expert approval this entry has been deprecated
      and SHOULD NOT be used in any new implementations.  Otherwise,
      FALSE.

   Identifiers:
      The initial URIs for the Key Container defined for this version of
      the document are listed here:

      Name:  PSKC Key Container
      URI:  urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container
      Specification:  [RFC6030]
      Deprecated:  FALSE

      Name:  SKPC Key Container
      URI:  urn:ietf:params:xml:ns:keyprov:dskpp:skpc-key-container
      Specification:  [RFC6031]
      Deprecated:  FALSE

      Name:  PKCS12 Key Container
      URI:  urn:ietf:params:xml:ns:keyprov:dskpp:pkcs12-key-container
      Specification:  [PKCS-12]
      Deprecated:  FALSE

      Name:  PKCS5-XML Key Container
      URI:  urn:ietf:params:xml:ns:keyprov:dskpp:pkcs5-xml-key-container
      Specification:  [PKCS-5-XML]
      Deprecated:  FALSE

   Registrant Contact:
      IETF, KEYPROV working group (keyprov@ietf.org),
      Andrea Doherty (andrea.doherty@rsa.com)

13.  Intellectual Property Considerations

   RSA and RSA Security are registered trademarks or trademarks of RSA
   Security, Inc. in the United States and/or other countries.  The
   names of other products and services mentioned may be the trademarks
   of their respective owners.

14.  Contributors

   This work is based on information contained in [RFC4758], authored by
   Magnus Nystrom, with enhancements borrowed from an individual
   document coauthored by Mingliang Pei and Salah Machani (e.g., user
   authentication, and support for multiple key package formats).

   We would like to thank Philip Hoyer for his work in aligning DSKPP
   and PSKC schemas.

   We would also like to thank Hannes Tschofenig and Phillip Hallam-
   Baker for their reviews, feedback, and text contributions.

15.  Acknowledgements

   We would like to thank the following for review of previous DSKPP
   document versions:

   o  Dr. Ulrike Meyer (Review June 2007)
   o  Niklas Neumann (Review June 2007)
   o  Shuh Chang (Review June 2007)
   o  Hannes Tschofenig (Review June 2007 and again in August 2007)
   o  Sean Turner (Reviews August 2007 and again in July 2008)
   o  John Linn (Review August 2007)
   o  Philip Hoyer (Review September 2007)
   o  Thomas Roessler (Review November 2007)
   o  Lakshminath Dondeti (Comments December 2007)
   o  Pasi Eronen (Comments December 2007)
   o  Phillip Hallam-Baker (Review and Edits November 2008 and again in
      January 2009)
   o  Alexey Melnikov (Review May 2010)
   o  Peter Saint-Andre (Review May 2010)

   We would also like to thank the following for their input to selected
   design aspects of DSKPP:

   o  Anders Rundgren (Key Package Format and Client Authentication
      Data)
   o  Thomas Roessler (HTTP Binding)
   o  Hannes Tschofenig (HTTP Binding)
   o  Phillip Hallam-Baker (Registry for Algorithms)
   o  N. Asokan (original observation of weakness in Authentication
      Data)

   Finally, we would like to thank Robert Griffin for opening
   communication channels for us with the IEEE P1619.3 Key Management
   Group, and facilitating our groups in staying informed of potential
   areas (especially key provisioning and global key identifiers of
   collaboration) of collaboration.

16.  References

16.1.  Normative References

   [FIPS180-SHA]     National Institute of Standards and Technology,
                     &quot;Secure Hash Standard&quot;, FIPS 180-2, February 2004,
                     &lt;http://csrc.nist.gov/publications/fips/fips180-2/
                     fips180-2withchangenotice.pdf&gt;.

   [FIPS197-AES]     National Institute of Standards and Technology,
                     &quot;Specification for the Advanced Encryption Standard
                     (AES)&quot;, FIPS 197, November 2001, &lt;http://
                     csrc.nist.gov/publications/fips/fips197/
                     fips-197.pdf&gt;.

   [ISO3309]         International Organization for Standardization,
                     &quot;ISO Information Processing Systems - Data
                     Communication - High-Level Data Link Control
                     Procedure - Frame Structure&quot;, ISO 3309,
                     3rd Edition, October 1984.

   [PKCS-1]          RSA Laboratories, &quot;RSA Cryptography Standard&quot;,
                     PKCS #1 Version 2.1, June 2002,
                     &lt;http://www.rsasecurity.com/rsalabs/pkcs/&gt;.

   [PKCS-5]          RSA Laboratories, &quot;Password-Based Cryptography
                     Standard&quot;, PKCS #5 Version 2.0, March 1999,
                     &lt;http://www.rsasecurity.com/rsalabs/pkcs/&gt;.

   [PKCS-5-XML]      RSA Laboratories, &quot;XML Schema for PKCS #5 Version
                     2.0&quot;, PKCS #5 Version 2.0 Amd.1 (FINAL DRAFT),
                     October 2006,
                     &lt;http://www.rsasecurity.com/rsalabs/pkcs/&gt;.

   [RFC2104]         Krawczyk, H., Bellare, M., and R. Canetti, &quot;HMAC:
                     Keyed-Hashing for Message Authentication&quot;,
                     RFC 2104, February 1997.

   [RFC2119]         Bradner, S., &quot;Key words for use in RFCs to Indicate
                     Requirement Levels&quot;, BCP 14, RFC 2119, March 1997.

   [RFC2616]         Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
                     Masinter, L., Leach, P., and T. Berners-Lee,
                     &quot;Hypertext Transfer Protocol -- HTTP/1.1&quot;,
                     RFC 2616, June 1999.

   [RFC3394]         Schaad, J. and R. Housley, &quot;Advanced Encryption
                     Standard (AES) Key Wrap Algorithm&quot;, RFC 3394,
                     September 2002.

   [RFC3629]         Yergeau, F., &quot;UTF-8, a transformation format of ISO
                     10646&quot;, STD 63, RFC 3629, November 2003.

   [RFC4013]         Zeilenga, K., &quot;SASLprep: Stringprep Profile for
                     User Names and Passwords&quot;, RFC 4013, February 2005.

   [RFC4210]         Adams, C., Farrell, S., Kause, T., and T. Mononen,
                     &quot;Internet X.509 Public Key Infrastructure
                     Certificate Management Protocol (CMP)&quot;, RFC 4210,
                     September 2005.

   [RFC5272]         Schaad, J. and M. Myers, &quot;Certificate Management
                     over CMS (CMC)&quot;, RFC 5272, June 2008.

   [RFC5280]         Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
                     Housley, R., and W. Polk, &quot;Internet X.509 Public
                     Key Infrastructure Certificate and Certificate
                     Revocation List (CRL) Profile&quot;, RFC 5280, May 2008.

   [RFC5649]         Housley, R. and M. Dworkin, &quot;Advanced Encryption
                     Standard (AES) Key Wrap with Padding Algorithm&quot;,
                     RFC 5649, September 2009.

   [RFC6030]         Hoyer, P., Pei, M., and S. Machani, &quot;Portable
                     Symmetric Key Container (PSKC)&quot;, RFC 6030,
                     October 2010.

   [UNICODE]         Davis, M. and M. Duerst, &quot;Unicode Normalization
                     Forms&quot;, March 2001, &lt;http://www.unicode.org/
                     unicode/reports/tr15/tr15-21.html&gt;.

   [XML]             W3C, &quot;Extensible Markup Language (XML) 1.0 (Fifth
                     Edition)&quot;, W3C Recommendation, November 2008,
                     &lt;http://www.w3.org/TR/2006/REC-xml-20060816/&gt;.

   [XMLDSIG]         W3C, &quot;XML Signature Syntax and Processing&quot;,
                     W3C Recommendation, February 2002, &lt;http://
                     www.w3.org/TR/2002/REC-xmldsig-core-20020212/&gt;.

   [XMLENC]          W3C, &quot;XML Encryption Syntax and Processing&quot;,
                     W3C Recommendation, December 2002, &lt;http://
                     www.w3.org/TR/2002/REC-xmldsig-core-20020212/&gt;.

16.2.  Informative References

   [CT-KIP-P11]      RSA Laboratories, &quot;PKCS #11 Mechanisms for the
                     Cryptographic Token Key Initialization Protocol&quot;,
                     PKCS #11 Version 2.20 Amd.2, December 2005,
                     &lt;http://www.rsasecurity.com/rsalabs/pkcs/&gt;.

   [FAQ]             RSA Laboratories, &quot;Frequently Asked Questions About
                     Today&#x27;s Cryptography&quot;,  Version 4.1, 2000.

   [NIST-PWD]        National Institute of Standards and Technology,
                     &quot;Password Usage&quot;, FIPS 112, May 1985,
                     &lt;http://www.itl.nist.gov/fipspubs/fip112.htm&gt;.

   [NIST-SP800-38B]  International Organization for Standardization,
                     &quot;Recommendations for Block Cipher Modes of
                     Operation: The CMAC Mode for Authentication&quot;,
                     NIST SP800-38B, May 2005, &lt;http://csrc.nist.gov/
                     publications/nistpubs/800-38B/SP_800-38B.pdf&gt;.

   [NIST-SP800-57]   National Institute of Standards and Technology,
                     &quot;Recommendation for Key Management - Part I:
                     General (Revised)&quot;, NIST 800-57, March 2007, &lt;http:
                     //csrc.nist.gov/publications/nistpubs/800-57/
                     sp800-57-Part1-revised2_Mar08-2007.pdf&gt;.

   [PKCS-11]         RSA Laboratories, &quot;Cryptographic Token Interface
                     Standard&quot;, PKCS #11 Version 2.20, June 2004,
                     &lt;http://www.rsasecurity.com/rsalabs/pkcs/&gt;.

   [PKCS-12]         &quot;Personal Information Exchange Syntax Standard&quot;,
                     PKCS #12 Version 1.0, 2005, &lt;ftp://
                     ftp.rsasecurity.com/pub/pkcs/pkcs-12/
                     pkcs-12v1.pdf&gt;.

   [RFC2818]         Rescorla, E., &quot;HTTP Over TLS&quot;, RFC 2818, May 2000.

   [RFC3023]         Murata, M., St. Laurent, S., and D. Kohn, &quot;XML
                     Media Types&quot;, RFC 3023, January 2001.

   [RFC3575]         Aboba, B., &quot;IANA Considerations for RADIUS (Remote
                     Authentication Dial In User Service)&quot;, RFC 3575,
                     July 2003.

   [RFC3688]         Mealling, M., &quot;The IETF XML Registry&quot;, BCP 81,
                     RFC 3688, January 2004.

   [RFC3986]         Berners-Lee, T., Fielding, R., and L. Masinter,
                     &quot;Uniform Resource Identifier (URI): Generic
                     Syntax&quot;, STD 66, RFC 3986, January 2005.

   [RFC4758]         Nystroem, M., &quot;Cryptographic Token Key
                     Initialization Protocol (CT-KIP) Version 1.0
                     Revision 1&quot;, RFC 4758, November 2006.

   [RFC5226]         Narten, T. and H. Alvestrand, &quot;Guidelines for
                     Writing an IANA Considerations Section in RFCs&quot;,
                     BCP 26, RFC 5226, May 2008.

   [RFC5246]         Dierks, T. and E. Rescorla, &quot;The Transport Layer
                     Security (TLS) Protocol Version 1.2&quot;, RFC 5246,
                     August 2008.

   [RFC6031]         Turner, S. and R. , &quot;Cryptographic Message Syntax
                     (CMS) Symmetric Key Package Content Type&quot;,
                     RFC 6031, December 2010.

   [XMLNS]           W3C, &quot;Namespaces in XML&quot;, W3C Recommendation,
                     January 1999,
                     &lt;http://www.w3.org/TR/2009/REC-xml-names-20091208&gt;.

Appendix A.  Usage Scenarios

   DSKPP is expected to be used to provision symmetric keys to
   cryptographic modules in a number of different scenarios, each with
   its own special requirements, as described below.  This appendix
   forms an informative part of the document.

A.1.  Single Key Request

   The usual scenario is that a cryptographic module makes a request for
   a symmetric key from a provisioning server that is located on the
   local network or somewhere on the Internet.  Depending upon the
   deployment scenario, the provisioning server may generate a new key
   on-the-fly or use a pre-generated key, e.g., one provided by a legacy
   back-end issuance server.  The provisioning server assigns a unique
   key ID to the symmetric key and provisions it to the cryptographic
   module.

A.2.  Multiple Key Requests

   A cryptographic module makes multiple requests for symmetric keys
   from the same provisioning server.  The symmetric keys need not be of
   the same type, i.e., the keys may be used with different symmetric
   key cryptographic algorithms, including one-time password
   authentication algorithms, and the AES encryption algorithm.

A.3.  User Authentication

   In some deployment scenarios, a key issuer may rely on a third-party
   provisioning service.  In this case, the issuer directs provisioning
   requests from the cryptographic module to the provisioning service.
   As such, it is the responsibility of the issuer to authenticate the
   user through some out-of-band means before granting him rights to
   acquire keys.  Once the issuer has granted those rights, the issuer
   provides an Authentication Code to the user and makes it available to
   the provisioning service, so that the user can prove that he is
   authorized to acquire keys.

A.4.  Provisioning Time-Out Policy

   An issuer may provide a time-limited Authentication Code to a user
   during registration, which the user will input into the cryptographic
   module to authenticate themselves with the provisioning server.  The
   server will allow a key to be provisioned to the cryptographic module
   hosted by the user&#x27;s device when user authentication is required only
   if the user inputs a valid Authentication Code within the fixed time
   period established by the issuer.

A.5.  Key Renewal

   A cryptographic module requests renewal of the symmetric key material
   attached to a key ID, as opposed to keeping the key value constant
   and refreshing the metadata.  Such a need may occur in the case when
   a user wants to upgrade her device that houses the cryptographic
   module or when a key has expired.  When a user uses the same
   cryptographic module for example, to perform strong authentication at
   multiple Web login sites, keeping the same key ID removes the need
   for the user to register a new key ID at each site.

A.6.  Pre-Loaded Key Replacement

   This scenario represents a special case of symmetric key renewal in
   which a local administrator can authenticate the user procedurally
   before initiating the provisioning process.  It also allows for a
   device issuer to pre-load a key onto a cryptographic module with a
   restriction that the key is replaced with a new key prior to use of
   the cryptographic module.  Another variation of this scenario is the
   organization who recycles devices.  In this case, a key issuer would
   provision a new symmetric key to a cryptographic module hosted on a
   device that was previously owned by another user.

   Note that this usage scenario is essentially the same as the previous
   scenario wherein the same key ID is used for renewal.

A.7.  Pre-Shared Manufacturing Key

   A cryptographic module is loaded onto a smart card after the card is
   issued to a user.  The symmetric key for the cryptographic module
   will then be provisioned using a secure channel mechanism present in
   many smart card platforms.  This allows a direct secure channel to be
   established between the smart card chip and the provisioning server.
   For example, the card commands (i.e., Application Protocol Data
   Units, or APDUs) are encrypted with a pre-issued card manufacturer&#x27;s
   key and sent directly to the smart card chip, allowing secure post-
   issuance in-the-field provisioning.  This secure flow can pass
   Transport Layer Security (TLS) [RFC5246] and other transport security
   boundaries.

   Note that two pre-conditions for this usage scenario are for the
   protocol to be tunneled and the provisioning server to know the
   correct pre-established manufacturer&#x27;s key.

A.8.  End-to-End Protection of Key Material

   In this scenario, Transport Layer Security does not provide end-to-
   end protection of keying material transported from the provisioning
   server to the cryptographic module.  For example, TLS may terminate
   at an application hosted on a PC rather than at the cryptographic
   module (i.e., the endpoint) located on a data storage device
   [RFC5246].  Mutually authenticated key agreement provides end-to-end
   protection, which TLS cannot provide.

Appendix B.  Examples

   This appendix contains example messages that illustrate parameters,
   encoding, and semantics in four- and two-pass DSKPP exchanges.  The
   examples are written using XML, and are syntactically correct.  MAC
   and cipher values are fictitious, however.  This appendix forms an
   informative part of the document.

B.1.  Trigger Message

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
   &lt;dskpp:KeyProvTrigger Version=&quot;1.0&quot;
     xmlns:dskpp=&quot;urn:ietf:params:xml:ns:keyprov:dskpp&quot;
     xmlns:pskc=&quot;urn:ietf:params:xml:ns:keyprov:pskc&quot;&gt;
     &lt;dskpp:InitializationTrigger&gt;
       &lt;dskpp:DeviceIdentifierData&gt;
           &lt;dskpp:DeviceId&gt;
               &lt;pskc:Manufacturer&gt;TokenVendorAcme&lt;/pskc:Manufacturer&gt;
               &lt;pskc:SerialNo&gt;987654321&lt;/pskc:SerialNo&gt;
               &lt;pskc:StartDate&gt;2009-09-01T00:00:00Z&lt;/pskc:StartDate&gt;
               &lt;pskc:ExpiryDate&gt;2014-09-01T00:00:00Z&lt;/pskc:ExpiryDate&gt;
           &lt;/dskpp:DeviceId&gt;
       &lt;/dskpp:DeviceIdentifierData&gt;
       &lt;dskpp:KeyID&gt;SE9UUDAwMDAwMDAx&lt;/dskpp:KeyID&gt;
       &lt;dskpp:TokenPlatformInfo KeyLocation=&quot;Hardware&quot;
         AlgorithmLocation=&quot;Software&quot;/&gt;
       &lt;dskpp:AuthenticationData&gt;
         &lt;dskpp:ClientID&gt;31300257&lt;/dskpp:ClientID&gt;
         &lt;dskpp:AuthenticationCodeMac&gt;
           &lt;dskpp:IterationCount&gt;512&lt;/dskpp:IterationCount&gt;
           &lt;dskpp:Mac&gt;4bRJf9xXd3KchKoTenHJiw==&lt;/dskpp:Mac&gt;
         &lt;/dskpp:AuthenticationCodeMac&gt;
       &lt;/dskpp:AuthenticationData&gt;
       &lt;dskpp:ServerUrl&gt;keyprovservice.example.com
         &lt;/dskpp:ServerUrl&gt;
     &lt;/dskpp:InitializationTrigger&gt;
   &lt;/dskpp:KeyProvTrigger&gt;

B.2.  Four-Pass Protocol

B.2.1.  &lt;KeyProvClientHello&gt; without a Preceding Trigger

    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
    &lt;dskpp:KeyProvClientHello
        xmlns:pskc=&quot;urn:ietf:params:xml:ns:keyprov:pskc&quot;
        xmlns:dskpp=&quot;urn:ietf:params:xml:ns:keyprov:dskpp&quot;
        xmlns:xenc=&quot;http://www.w3.org/2001/04/xmlenc#&quot;
        xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;
        Version=&quot;1.0&quot;&gt;
        &lt;dskpp:DeviceIdentifierData&gt;
            &lt;dskpp:DeviceId&gt;
                &lt;pskc:Manufacturer&gt;TokenVendorAcme&lt;/pskc:Manufacturer&gt;
                &lt;pskc:SerialNo&gt;987654321&lt;/pskc:SerialNo&gt;
                &lt;pskc:StartDate&gt;2009-09-01T00:00:00Z&lt;/pskc:StartDate&gt;
                &lt;pskc:ExpiryDate&gt;2014-09-01T00:00:00Z&lt;/pskc:ExpiryDate&gt;
            &lt;/dskpp:DeviceId&gt;
        &lt;/dskpp:DeviceIdentifierData&gt;
        &lt;dskpp:SupportedKeyTypes&gt;
            &lt;dskpp:Algorithm&gt;
                urn:ietf:params:xml:ns:keyprov:pskc:hotp
            &lt;/dskpp:Algorithm&gt;
            &lt;dskpp:Algorithm&gt;
    http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
            &lt;/dskpp:Algorithm&gt;
        &lt;/dskpp:SupportedKeyTypes&gt;
        &lt;dskpp:SupportedEncryptionAlgorithms&gt;
            &lt;dskpp:Algorithm&gt;
                http://www.w3.org/2001/04/xmlenc#aes128-cbc
            &lt;/dskpp:Algorithm&gt;
        &lt;/dskpp:SupportedEncryptionAlgorithms&gt;
        &lt;dskpp:SupportedMacAlgorithms&gt;
            &lt;dskpp:Algorithm&gt;
                urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256
            &lt;/dskpp:Algorithm&gt;
        &lt;/dskpp:SupportedMacAlgorithms&gt;
        &lt;dskpp:SupportedProtocolVariants&gt;
            &lt;dskpp:FourPass/&gt;
        &lt;/dskpp:SupportedProtocolVariants&gt;
        &lt;dskpp:SupportedKeyPackages&gt;
            &lt;dskpp:KeyPackageFormat&gt;
                urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container
            &lt;/dskpp:KeyPackageFormat&gt;
        &lt;/dskpp:SupportedKeyPackages&gt;
    &lt;/dskpp:KeyProvClientHello&gt;

B.2.2.  &lt;KeyProvClientHello&gt; Assuming a Preceding Trigger

    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
    &lt;dskpp:KeyProvClientHello
        xmlns:pskc=&quot;urn:ietf:params:xml:ns:keyprov:pskc&quot;
        xmlns:dskpp=&quot;urn:ietf:params:xml:ns:keyprov:dskpp&quot;
        xmlns:xenc=&quot;http://www.w3.org/2001/04/xmlenc#&quot;
        xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;
        Version=&quot;1.0&quot;&gt;
        &lt;dskpp:DeviceIdentifierData&gt;
            &lt;dskpp:DeviceId&gt;
                &lt;pskc:Manufacturer&gt;TokenVendorAcme&lt;/pskc:Manufacturer&gt;
                &lt;pskc:SerialNo&gt;987654321&lt;/pskc:SerialNo&gt;
                &lt;pskc:StartDate&gt;2009-09-01T00:00:00Z&lt;/pskc:StartDate&gt;
                &lt;pskc:ExpiryDate&gt;2014-09-01T00:00:00Z&lt;/pskc:ExpiryDate&gt;
            &lt;/dskpp:DeviceId&gt;
        &lt;/dskpp:DeviceIdentifierData&gt;
        &lt;dskpp:KeyID&gt;SE9UUDAwMDAwMDAx&lt;/dskpp:KeyID&gt;
        &lt;dskpp:SupportedKeyTypes&gt;
            &lt;dskpp:Algorithm&gt;
                urn:ietf:params:xml:ns:keyprov:pskc:hotp
            &lt;/dskpp:Algorithm&gt;
            &lt;dskpp:Algorithm&gt;
    http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
            &lt;/dskpp:Algorithm&gt;
        &lt;/dskpp:SupportedKeyTypes&gt;
        &lt;dskpp:SupportedEncryptionAlgorithms&gt;
            &lt;dskpp:Algorithm&gt;
                http://www.w3.org/2001/04/xmlenc#aes128-cbc
            &lt;/dskpp:Algorithm&gt;
        &lt;/dskpp:SupportedEncryptionAlgorithms&gt;
        &lt;dskpp:SupportedMacAlgorithms&gt;
            &lt;dskpp:Algorithm&gt;
                urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256
            &lt;/dskpp:Algorithm&gt;
        &lt;/dskpp:SupportedMacAlgorithms&gt;
        &lt;dskpp:SupportedProtocolVariants&gt;
          &lt;dskpp:FourPass/&gt;
        &lt;/dskpp:SupportedProtocolVariants&gt;
        &lt;dskpp:SupportedKeyPackages&gt;
            &lt;dskpp:KeyPackageFormat&gt;
                urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container
            &lt;/dskpp:KeyPackageFormat&gt;
        &lt;/dskpp:SupportedKeyPackages&gt;
    &lt;/dskpp:KeyProvClientHello&gt;

B.2.3.  &lt;KeyProvServerHello&gt; Without a Preceding Trigger

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
   &lt;dskpp:KeyProvServerHello
       xmlns:pskc=&quot;urn:ietf:params:xml:ns:keyprov:pskc&quot;
       xmlns:dskpp=&quot;urn:ietf:params:xml:ns:keyprov:dskpp&quot;
       xmlns:xenc=&quot;http://www.w3.org/2001/04/xmlenc#&quot;
       xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;
       Version=&quot;1.0&quot;
       Status=&quot;Continue&quot;
       SessionID=&quot;4114&quot;&gt;
       &lt;dskpp:KeyType&gt;
           urn:ietf:params:xml:ns:keyprov:pskc:hotp
       &lt;/dskpp:KeyType&gt;
       &lt;dskpp:EncryptionAlgorithm&gt;
           http://www.w3.org/2001/04/xmlenc#aes128-cbc
       &lt;/dskpp:EncryptionAlgorithm&gt;
       &lt;dskpp:MacAlgorithm&gt;
           urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256
       &lt;/dskpp:MacAlgorithm&gt;
       &lt;dskpp:EncryptionKey&gt;
         &lt;ds:KeyName&gt;Example-Key1&lt;/ds:KeyName&gt;
       &lt;/dskpp:EncryptionKey&gt;
       &lt;dskpp:KeyPackageFormat&gt;
           urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container
       &lt;/dskpp:KeyPackageFormat&gt;
       &lt;dskpp:Payload&gt;
           &lt;dskpp:Nonce&gt;EjRWeJASNFZ4kBI0VniQEg==&lt;/dskpp:Nonce&gt;
       &lt;/dskpp:Payload&gt;
   &lt;/dskpp:KeyProvServerHello&gt;

B.2.4.  &lt;KeyProvServerHello&gt; Assuming Key Renewal

    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
    &lt;dskpp:KeyProvServerHello
      xmlns:dskpp=&quot;urn:ietf:params:xml:ns:keyprov:dskpp&quot;
      xmlns:pskc=&quot;urn:ietf:params:xml:ns:keyprov:pskc&quot;
      xmlns:xenc=&quot;http://www.w3.org/2001/04/xmlenc#&quot;
      xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;
      Version=&quot;1.0&quot;
      SessionID=&quot;4114&quot;
      Status=&quot;Continue&quot;&gt;
      &lt;dskpp:KeyType&gt;
        urn:ietf:params:xml:schema:keyprov:otpalg#SecurID-AES
      &lt;/dskpp:KeyType&gt;
      &lt;dskpp:EncryptionAlgorithm&gt;
         http://www.w3.org/2001/04/xmlenc#aes128-cbc
      &lt;/dskpp:EncryptionAlgorithm&gt;
      &lt;dskpp:MacAlgorithm&gt;
         urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256
      &lt;/dskpp:MacAlgorithm&gt;
      &lt;dskpp:EncryptionKey&gt;
        &lt;ds:KeyName&gt;Example-Key1&lt;/ds:KeyName&gt;
      &lt;/dskpp:EncryptionKey&gt;
      &lt;dskpp:KeyPackageFormat&gt;
        urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container
      &lt;/dskpp:KeyPackageFormat&gt;
      &lt;dskpp:Payload&gt;
        &lt;dskpp:Nonce&gt;qw2ewasde312asder394jw==&lt;/dskpp:Nonce&gt;
      &lt;/dskpp:Payload&gt;
      &lt;dskpp:Mac
        MacAlgorithm=&quot;urn:ietf:params:xml:ns:keyprov:dskpp:prf-aes-128&quot;&gt;
        cXcycmFuZG9tMzEyYXNkZXIzOTRqdw==
      &lt;/dskpp:Mac&gt;
    &lt;/dskpp:KeyProvServerHello&gt;

B.2.5.  &lt;KeyProvClientNonce&gt; Using Default Encryption

   This message contains the nonce chosen by the cryptographic module,
   R_C, encrypted by the specified encryption key and encryption
   algorithm.

    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
    &lt;dskpp:KeyProvClientNonce
        xmlns:pskc=&quot;urn:ietf:params:xml:ns:keyprov:pskc&quot;
        xmlns:dskpp=&quot;urn:ietf:params:xml:ns:keyprov:dskpp&quot;
        xmlns:xenc=&quot;http://www.w3.org/2001/04/xmlenc#&quot;
        xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;
        SessionID=&quot;4114&quot;
        Version=&quot;1.0&quot;&gt;
        &lt;dskpp:EncryptedNonce&gt;
            oTvo+S22nsmS2Z/RtcoF8CTwadRa1PVsRXkZnCihHkU1rPueggrd0NpEWVZR
            16Rg16+FHuTg33GK1wH3wffDZQ==
        &lt;/dskpp:EncryptedNonce&gt;
    &lt;/dskpp:KeyProvClientNonce&gt;

B.2.6.  &lt;KeyProvServerFinished&gt; Using Default Encryption

      &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
      &lt;dskpp:KeyProvServerFinished
          xmlns:pskc=&quot;urn:ietf:params:xml:ns:keyprov:pskc&quot;
          xmlns:dskpp=&quot;urn:ietf:params:xml:ns:keyprov:dskpp&quot;
          xmlns:xenc=&quot;http://www.w3.org/2001/04/xmlenc#&quot;
          xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;
          Version=&quot;1.0&quot;
          Status=&quot;Success&quot;
          SessionID=&quot;4114&quot;&gt;
          &lt;dskpp:KeyPackage&gt;
              &lt;dskpp:KeyContainer Version=&quot;1.0&quot; Id=&quot;KC0001&quot;&gt;
                  &lt;pskc:KeyPackage&gt;
                      &lt;pskc:DeviceInfo&gt;
                          &lt;pskc:Manufacturer&gt;
                             TokenVendorAcme
                          &lt;/pskc:Manufacturer&gt;
                          &lt;pskc:SerialNo&gt;
                             987654321
                          &lt;/pskc:SerialNo&gt;
                          &lt;pskc:StartDate&gt;
                             2009-09-01T00:00:00Z
                          &lt;/pskc:StartDate&gt;
                          &lt;pskc:ExpiryDate&gt;
                             2014-09-01T00:00:00Z
                          &lt;/pskc:ExpiryDate&gt;
                      &lt;/pskc:DeviceInfo&gt;

                      &lt;pskc:CryptoModuleInfo&gt;
                          &lt;pskc:Id&gt;CM_ID_001&lt;/pskc:Id&gt;
                      &lt;/pskc:CryptoModuleInfo&gt;
                      &lt;pskc:Key
                         Id=&quot;MBK000000001&quot;
                         Algorithm=
                            &quot;urn:ietf:params:xml:ns:keyprov:pskc:hotp&quot;&gt;
                         &lt;pskc:Issuer&gt;Example-Issuer&lt;/pskc:Issuer&gt;
                         &lt;pskc:AlgorithmParameters&gt;
                             &lt;pskc:ResponseFormat Length=&quot;6&quot;
                                Encoding=&quot;DECIMAL&quot;/&gt;
                          &lt;/pskc:AlgorithmParameters&gt;
                          &lt;pskc:Data&gt;
                              &lt;pskc:Counter&gt;
                                  &lt;pskc:PlainValue&gt;0&lt;/pskc:PlainValue&gt;
                              &lt;/pskc:Counter&gt;
                          &lt;/pskc:Data&gt;
                          &lt;pskc:Policy&gt;
                              &lt;pskc:KeyUsage&gt;OTP&lt;/pskc:KeyUsage&gt;
                          &lt;/pskc:Policy&gt;
                      &lt;/pskc:Key&gt;
                  &lt;/pskc:KeyPackage&gt;
              &lt;/dskpp:KeyContainer&gt;
          &lt;/dskpp:KeyPackage&gt;
          &lt;dskpp:Mac
              MacAlgorithm=
                 &quot;urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256&quot;&gt;
              151yAR2NqU5dJzETK+SGYqN6sq6DEH5AgHohra3Jpp4=
          &lt;/dskpp:Mac&gt;
      &lt;/dskpp:KeyProvServerFinished&gt;

B.3.  Two-Pass Protocol

B.3.1.  Example Using the Key Transport Method

   The client indicates support for all the Key Transport, Key Wrap, and
   Passphrase-Based Key Wrap key protection methods:

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
   &lt;dskpp:KeyProvClientHello
       xmlns:pskc=&quot;urn:ietf:params:xml:ns:keyprov:pskc&quot;
       xmlns:dskpp=&quot;urn:ietf:params:xml:ns:keyprov:dskpp&quot;
       xmlns:xenc=&quot;http://www.w3.org/2001/04/xmlenc#&quot;
       xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;
       Version=&quot;1.0&quot;&gt;
       &lt;dskpp:DeviceIdentifierData&gt;
           &lt;dskpp:DeviceId&gt;
               &lt;pskc:Manufacturer&gt;TokenVendorAcme&lt;/pskc:Manufacturer&gt;

               &lt;pskc:SerialNo&gt;987654321&lt;/pskc:SerialNo&gt;
               &lt;pskc:StartDate&gt;2009-09-01T00:00:00Z&lt;/pskc:StartDate&gt;
               &lt;pskc:ExpiryDate&gt;2014-09-01T00:00:00Z&lt;/pskc:ExpiryDate&gt;
           &lt;/dskpp:DeviceId&gt;
       &lt;/dskpp:DeviceIdentifierData&gt;
       &lt;dskpp:SupportedKeyTypes&gt;
           &lt;dskpp:Algorithm&gt;
               urn:ietf:params:xml:ns:keyprov:pskc:hotp
           &lt;/dskpp:Algorithm&gt;
           &lt;dskpp:Algorithm&gt;
   http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
           &lt;/dskpp:Algorithm&gt;
       &lt;/dskpp:SupportedKeyTypes&gt;
       &lt;dskpp:SupportedEncryptionAlgorithms&gt;
           &lt;dskpp:Algorithm&gt;
               http://www.w3.org/2001/04/xmlenc#rsa_1_5
           &lt;/dskpp:Algorithm&gt;
       &lt;/dskpp:SupportedEncryptionAlgorithms&gt;
       &lt;dskpp:SupportedMacAlgorithms&gt;
           &lt;dskpp:Algorithm&gt;
               urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256
           &lt;/dskpp:Algorithm&gt;
       &lt;/dskpp:SupportedMacAlgorithms&gt;
       &lt;dskpp:SupportedProtocolVariants&gt;
           &lt;dskpp:TwoPass&gt;
               &lt;dskpp:SupportedKeyProtectionMethod&gt;
                   urn:ietf:params:xml:schema:keyprov:dskpp:transport
               &lt;/dskpp:SupportedKeyProtectionMethod&gt;
               &lt;dskpp:Payload&gt;
                   &lt;ds:KeyInfo&gt;
                       &lt;ds:X509Data&gt;
                           &lt;ds:X509Certificate&gt;
   MIIB5zCCAVCgAwIBAgIESZp/vDANBgkqhkiG9w0BAQUFADA4MQ0wCwYDVQQKEwRJRVRGM
   RMwEQYDVQQLEwpLZXlQcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwHhcNMDkwMjE3MD
   kxMzMyWhcNMTEwMjE3MDkxMzMyWjA4MQ0wCwYDVQQKEwRJRVRGMRMwEQYDVQQLEwpLZXl
   Qcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ
   AoGBALCWLDa2ItYJ6su80hd1gL4cggQYdyyKK17btt/aS6Q/eDsKjsPyFIODsxeKVV/uA
   3wLT4jQJM5euKJXkDajzGGOy92+ypfzTX4zDJMkh61SZwlHNJxBKilAM5aW7C+BQ0RvCx
   vdYtzx2LTdB+X/KMEBA7uIYxLfXH2Mnub3WIh1AgMBAAEwDQYJKoZIhvcNAQEFBQADgYE
   Ae875m84sYUJ8qPeZ+NG7REgTvlHTmoCdoByU0LBBLotUKuqfrnRuXJRMeZXaaEGmzY1k
   LonVjQGzjAkU4dJ+RPmiDlYuHLZS41Pg6VMwY+03lhk6I5A/w4rnqdkmwZX/NgXg06aln
   c2pBsXWhL4O7nk0S2ZrLMsQZ6HcsXgdmHo=
                           &lt;/ds:X509Certificate&gt;
                       &lt;/ds:X509Data&gt;
                   &lt;/ds:KeyInfo&gt;
               &lt;/dskpp:Payload&gt;
           &lt;/dskpp:TwoPass&gt;
       &lt;/dskpp:SupportedProtocolVariants&gt;

       &lt;dskpp:SupportedKeyPackages&gt;
           &lt;dskpp:KeyPackageFormat&gt;
               urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container
           &lt;/dskpp:KeyPackageFormat&gt;
       &lt;/dskpp:SupportedKeyPackages&gt;
       &lt;dskpp:AuthenticationData&gt;
           &lt;dskpp:ClientID&gt;AC00000A&lt;/dskpp:ClientID&gt;
           &lt;dskpp:AuthenticationCodeMac&gt;
               &lt;dskpp:Nonce&gt;
                   ESIzRFVmd4iZqrvM3e7/ESIzRFVmd4iZqrvM3e7/ESI=
               &lt;/dskpp:Nonce&gt;
               &lt;dskpp:IterationCount&gt;100000&lt;/dskpp:IterationCount&gt;
               &lt;dskpp:Mac
                   MacAlgorithm=
                   &quot;urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256&quot;&gt;
                   3eRz51ILqiG+dJW2iLcjuA==
               &lt;/dskpp:Mac&gt;
           &lt;/dskpp:AuthenticationCodeMac&gt;
       &lt;/dskpp:AuthenticationData&gt;
   &lt;/dskpp:KeyProvClientHello&gt;

   In this example, the server responds to the previous request by
   returning a key package in which the provisioning key was encrypted
   using the Key Transport key protection method.

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
   &lt;dskpp:KeyProvServerFinished
       xmlns:pskc=&quot;urn:ietf:params:xml:ns:keyprov:pskc&quot;
       xmlns:dskpp=&quot;urn:ietf:params:xml:ns:keyprov:dskpp&quot;
       xmlns:xenc=&quot;http://www.w3.org/2001/04/xmlenc#&quot;
       xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;
       xmlns:dkey=&quot;http://www.w3.org/2009/xmlsec-derivedkey#&quot;
       xmlns:pkcs5=
          &quot;http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#&quot;
       Version=&quot;1.0&quot;
       Status=&quot;Success&quot;
       SessionID=&quot;4114&quot;&gt;
       &lt;dskpp:KeyPackage&gt;
           &lt;dskpp:KeyContainer Version=&quot;1.0&quot; Id=&quot;KC0001&quot;&gt;
               &lt;pskc:EncryptionKey&gt;
                   &lt;ds:X509Data&gt;
                       &lt;ds:X509Certificate&gt;
   MIIB5zCCAVCgAwIBAgIESZp/vDANBgkqhkiG9w0BAQUFADA4MQ0wCwYDVQQKEwRJRVRGM
   RMwEQYDVQQLEwpLZXlQcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwHhcNMDkwMjE3MD
   kxMzMyWhcNMTEwMjE3MDkxMzMyWjA4MQ0wCwYDVQQKEwRJRVRGMRMwEQYDVQQLEwpLZXl
   Qcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ
   AoGBALCWLDa2ItYJ6su80hd1gL4cggQYdyyKK17btt/aS6Q/eDsKjsPyFIODsxeKVV/uA
   3wLT4jQJM5euKJXkDajzGGOy92+ypfzTX4zDJMkh61SZwlHNJxBKilAM5aW7C+BQ0RvCx

   vdYtzx2LTdB+X/KMEBA7uIYxLfXH2Mnub3WIh1AgMBAAEwDQYJKoZIhvcNAQEFBQADgYE
   Ae875m84sYUJ8qPeZ+NG7REgTvlHTmoCdoByU0LBBLotUKuqfrnRuXJRMeZXaaEGmzY1k
   LonVjQGzjAkU4dJ+RPmiDlYuHLZS41Pg6VMwY+03lhk6I5A/w4rnqdkmwZX/NgXg06aln
   c2pBsXWhL4O7nk0S2ZrLMsQZ6HcsXgdmHo=
                       &lt;/ds:X509Certificate&gt;
                   &lt;/ds:X509Data&gt;
               &lt;/pskc:EncryptionKey&gt;
               &lt;pskc:KeyPackage&gt;
                   &lt;pskc:DeviceInfo&gt;
                       &lt;pskc:Manufacturer&gt;
                          TokenVendorAcme
                       &lt;/pskc:Manufacturer&gt;
                       &lt;pskc:SerialNo&gt;
                          987654321
                       &lt;/pskc:SerialNo&gt;
                       &lt;pskc:StartDate&gt;
                          2009-09-01T00:00:00Z
                       &lt;/pskc:StartDate&gt;
                       &lt;pskc:ExpiryDate&gt;
                          2014-09-01T00:00:00Z
                       &lt;/pskc:ExpiryDate&gt;
                   &lt;/pskc:DeviceInfo&gt;
                   &lt;pskc:Key
                       Id=&quot;MBK000000001&quot;
                       Algorithm=
                          &quot;urn:ietf:params:xml:ns:keyprov:pskc:hotp&quot;&gt;
                       &lt;pskc:Issuer&gt;Example-Issuer&lt;/pskc:Issuer&gt;
                       &lt;pskc:AlgorithmParameters&gt;
                           &lt;pskc:ResponseFormat Length=&quot;6&quot;
                              Encoding=&quot;DECIMAL&quot;/&gt;
                       &lt;/pskc:AlgorithmParameters&gt;
                       &lt;pskc:Data&gt;
                           &lt;pskc:Secret&gt;
                               &lt;pskc:EncryptedValue&gt;
                                   &lt;xenc:EncryptionMethod
                                    Algorithm=
                            &quot;http://www.w3.org/2001/04/xmlenc#rsa_1_5&quot;/&gt;
                                   &lt;xenc:CipherData&gt;
                                       &lt;xenc:CipherValue&gt;
   eyjr23WMy9S2UdKgGnQEbs44T1jmX1TNWEBq48xfS20PK2VWF4ZK1iSctHj/u3uk+7+y8
   uKrAzHEm5mujKPAU4DCbb5mSibXMnAbbIoAi2cJW60/l8FlzwaU4EZsZ1LyQ1GcBQKACE
   eylG5vK8NTo47vZTatL5UxmbmOX2HvaVQ=
                                       &lt;/xenc:CipherValue&gt;
                                   &lt;/xenc:CipherData&gt;
                               &lt;/pskc:EncryptedValue&gt;
                           &lt;/pskc:Secret&gt;
                           &lt;pskc:Counter&gt;
                               &lt;pskc:PlainValue&gt;0&lt;/pskc:PlainValue&gt;

                           &lt;/pskc:Counter&gt;
                       &lt;/pskc:Data&gt;
                       &lt;pskc:Policy&gt;
                           &lt;pskc:KeyUsage&gt;OTP&lt;/pskc:KeyUsage&gt;
                       &lt;/pskc:Policy&gt;
                   &lt;/pskc:Key&gt;
               &lt;/pskc:KeyPackage&gt;
           &lt;/dskpp:KeyContainer&gt;
       &lt;/dskpp:KeyPackage&gt;
       &lt;dskpp:Mac
           MacAlgorithm=
              &quot;urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256&quot;&gt;
           GHZ0H6Y+KpxdlVZ7zgcJDiDdqc8Gcmlcf+HQi4EUxYU=
       &lt;/dskpp:Mac&gt;
   &lt;/dskpp:KeyProvServerFinished&gt;

B.3.2.  Example Using the Key Wrap Method

   The client sends a request that specifies a shared key to protect the
   K_TOKEN, and the server responds using the Key Wrap key protection
   method.  Authentication Data in this example is based on an
   Authentication Code rather than a device certificate.

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
   &lt;dskpp:KeyProvClientHello
       xmlns:pskc=&quot;urn:ietf:params:xml:ns:keyprov:pskc&quot;
       xmlns:dskpp=&quot;urn:ietf:params:xml:ns:keyprov:dskpp&quot;
       xmlns:xenc=&quot;http://www.w3.org/2001/04/xmlenc#&quot;
       xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;
       Version=&quot;1.0&quot;&gt;
       &lt;dskpp:DeviceIdentifierData&gt;
           &lt;dskpp:DeviceId&gt;
               &lt;pskc:Manufacturer&gt;TokenVendorAcme&lt;/pskc:Manufacturer&gt;
               &lt;pskc:SerialNo&gt;987654321&lt;/pskc:SerialNo&gt;
               &lt;pskc:StartDate&gt;2009-09-01T00:00:00Z&lt;/pskc:StartDate&gt;
               &lt;pskc:ExpiryDate&gt;2014-09-01T00:00:00Z&lt;/pskc:ExpiryDate&gt;
           &lt;/dskpp:DeviceId&gt;
       &lt;/dskpp:DeviceIdentifierData&gt;
       &lt;dskpp:SupportedKeyTypes&gt;
           &lt;dskpp:Algorithm&gt;
               urn:ietf:params:xml:ns:keyprov:pskc:hotp
           &lt;/dskpp:Algorithm&gt;
           &lt;dskpp:Algorithm&gt;
    http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
           &lt;/dskpp:Algorithm&gt;
       &lt;/dskpp:SupportedKeyTypes&gt;
       &lt;dskpp:SupportedEncryptionAlgorithms&gt;
           &lt;dskpp:Algorithm&gt;

               http://www.w3.org/2001/04/xmlenc#aes128-cbc
           &lt;/dskpp:Algorithm&gt;
       &lt;/dskpp:SupportedEncryptionAlgorithms&gt;
       &lt;dskpp:SupportedMacAlgorithms&gt;
           &lt;dskpp:Algorithm&gt;
               urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256
           &lt;/dskpp:Algorithm&gt;
       &lt;/dskpp:SupportedMacAlgorithms&gt;
       &lt;dskpp:SupportedProtocolVariants&gt;
           &lt;dskpp:TwoPass&gt;
               &lt;dskpp:SupportedKeyProtectionMethod&gt;
                   urn:ietf:params:xml:schema:keyprov:dskpp:wrap
               &lt;/dskpp:SupportedKeyProtectionMethod&gt;
               &lt;dskpp:Payload&gt;
                   &lt;ds:KeyInfo&gt;
                       &lt;ds:KeyName&gt;Pre-shared-key-1&lt;/ds:KeyName&gt;
                   &lt;/ds:KeyInfo&gt;
               &lt;/dskpp:Payload&gt;
           &lt;/dskpp:TwoPass&gt;
       &lt;/dskpp:SupportedProtocolVariants&gt;
       &lt;dskpp:SupportedKeyPackages&gt;
           &lt;dskpp:KeyPackageFormat&gt;
               urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container
           &lt;/dskpp:KeyPackageFormat&gt;
       &lt;/dskpp:SupportedKeyPackages&gt;
       &lt;dskpp:AuthenticationData&gt;
           &lt;dskpp:ClientID&gt;AC00000A&lt;/dskpp:ClientID&gt;
           &lt;dskpp:AuthenticationCodeMac&gt;
               &lt;dskpp:Nonce&gt;
                   ESIzRFVmd4iZqrvM3e7/ESIzRFVmd4iZqrvM3e7/ESI=
               &lt;/dskpp:Nonce&gt;
               &lt;dskpp:IterationCount&gt;1&lt;/dskpp:IterationCount&gt;
               &lt;dskpp:Mac
                   MacAlgorithm=
                   &quot;urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256&quot;&gt;
                   3eRz51ILqiG+dJW2iLcjuA==
               &lt;/dskpp:Mac&gt;
           &lt;/dskpp:AuthenticationCodeMac&gt;
       &lt;/dskpp:AuthenticationData&gt;
   &lt;/dskpp:KeyProvClientHello&gt;

   In this example, the server responds to the previous request by
   returning a key package in which the provisioning key was encrypted
   using the Key Wrap key protection method.

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
   &lt;dskpp:KeyProvServerFinished
       xmlns:pskc=&quot;urn:ietf:params:xml:ns:keyprov:pskc&quot;

       xmlns:dskpp=&quot;urn:ietf:params:xml:ns:keyprov:dskpp&quot;
       xmlns:xenc=&quot;http://www.w3.org/2001/04/xmlenc#&quot;
       xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;
       xmlns:dkey=&quot;http://www.w3.org/2009/xmlsec-derivedkey#&quot;
       xmlns:pkcs5=
           &quot;http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#&quot;
       Version=&quot;1.0&quot;
       Status=&quot;Success&quot;
       SessionID=&quot;4114&quot;&gt;
       &lt;dskpp:KeyPackage&gt;
            &lt;dskpp:KeyContainer Version=&quot;1.0&quot; Id=&quot;KC0001&quot;&gt;
                &lt;pskc:EncryptionKey&gt;
                   &lt;ds:KeyName&gt;Pre-shared-key-1&lt;/ds:KeyName&gt;
                &lt;/pskc:EncryptionKey&gt;
                &lt;pskc:MACMethod
                    Algorithm=
                       &quot;http://www.w3.org/2000/09/xmldsig#hmac-sha1&quot;&gt;
                    &lt;pskc:MACKey&gt;
                        &lt;xenc:EncryptionMethod
                            Algorithm=
                         &quot;http://www.w3.org/2001/04/xmlenc#aes128-cbc&quot;/&gt;
                        &lt;xenc:CipherData&gt;
                            &lt;xenc:CipherValue&gt;
        2GTTnLwM3I4e5IO5FkufoMUBJBuAf25hARFv0Z7MFk9Ecdb04PWY/qaeCbrgz7Es
                             &lt;/xenc:CipherValue&gt;
                        &lt;/xenc:CipherData&gt;
                    &lt;/pskc:MACKey&gt;
                &lt;/pskc:MACMethod&gt;
                &lt;pskc:KeyPackage&gt;
                    &lt;pskc:DeviceInfo&gt;
                        &lt;pskc:Manufacturer&gt;
                           TokenVendorAcme
                        &lt;/pskc:Manufacturer&gt;
                        &lt;pskc:SerialNo&gt;
                           987654321
                        &lt;/pskc:SerialNo&gt;
                        &lt;pskc:StartDate&gt;
                           2009-09-01T00:00:00Z
                        &lt;/pskc:StartDate&gt;
                        &lt;pskc:ExpiryDate&gt;
                           2014-09-01T00:00:00Z
                        &lt;/pskc:ExpiryDate&gt;
                    &lt;/pskc:DeviceInfo&gt;
                    &lt;pskc:CryptoModuleInfo&gt;
                        &lt;pskc:Id&gt;CM_ID_001&lt;/pskc:Id&gt;
                    &lt;/pskc:CryptoModuleInfo&gt;
                    &lt;pskc:Key
                        Id=&quot;MBK000000001&quot;

                        Algorithm=
                           &quot;urn:ietf:params:xml:ns:keyprov:pskc:hotp&quot;&gt;
                        &lt;pskc:Issuer&gt;Example-Issuer&lt;/pskc:Issuer&gt;
                        &lt;pskc:AlgorithmParameters&gt;
                          &lt;pskc:ResponseFormat Length=&quot;6&quot;
                             Encoding=&quot;DECIMAL&quot;/&gt;
                        &lt;/pskc:AlgorithmParameters&gt;
                        &lt;pskc:Data&gt;
                            &lt;pskc:Secret&gt;
                                &lt;pskc:EncryptedValue&gt;
                                  &lt;xenc:EncryptionMethod
                                  Algorithm=
                         &quot;http://www.w3.org/2001/04/xmlenc#aes128-cbc&quot;/&gt;
                                    &lt;xenc:CipherData&gt;
                                        &lt;xenc:CipherValue&gt;
                                            oTvo+S22nsmS2Z/RtcoF8AabC6vr
                                            09sh0QIU+E224S96sZjpV+6nFYgn
                                            6525OoepbPnL/fGuuey64WCYXoqh
                                            Tg==
                                        &lt;/xenc:CipherValue&gt;
                                    &lt;/xenc:CipherData&gt;
                               &lt;/pskc:EncryptedValue&gt;
                               &lt;pskc:ValueMAC&gt;
                                   o+e9xgMVUbYuZH9UHe0W9dIo88A=
                               &lt;/pskc:ValueMAC&gt;
                           &lt;/pskc:Secret&gt;
                           &lt;pskc:Counter&gt;
                               &lt;pskc:PlainValue&gt;0&lt;/pskc:PlainValue&gt;
                           &lt;/pskc:Counter&gt;
                       &lt;/pskc:Data&gt;
                       &lt;pskc:Policy&gt;
                           &lt;pskc:KeyUsage&gt;OTP&lt;/pskc:KeyUsage&gt;
                       &lt;/pskc:Policy&gt;
                   &lt;/pskc:Key&gt;
               &lt;/pskc:KeyPackage&gt;
           &lt;/dskpp:KeyContainer&gt;
       &lt;/dskpp:KeyPackage&gt;
       &lt;dskpp:Mac
           MacAlgorithm=
              &quot;urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256&quot;&gt;
           l53BmSO6qUzoIgbQegimsKk2es+WRpEl0YFqaOp5PGE=
       &lt;/dskpp:Mac&gt;
   &lt;/dskpp:KeyProvServerFinished&gt;

B.3.3.  Example Using the Passphrase-Based Key Wrap Method

   The client sends a request similar to that in Appendix B.3.1 with
   Authentication Data based on an Authentication Code, and the server
   responds using the Passphrase-Based Key Wrap method to encrypt the
   provisioning key (note that the encryption is derived from the
   password component of the Authentication Code).  The Authentication
   Data is set in clear text when it is sent over a secure transport
   channel such as TLS [RFC5246].

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
   &lt;dskpp:KeyProvClientHello
       xmlns:pskc=&quot;urn:ietf:params:xml:ns:keyprov:pskc&quot;
       xmlns:dskpp=&quot;urn:ietf:params:xml:ns:keyprov:dskpp&quot;
       xmlns:xenc=&quot;http://www.w3.org/2001/04/xmlenc#&quot;
       xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;
       Version=&quot;1.0&quot;&gt;
       &lt;dskpp:DeviceIdentifierData&gt;
           &lt;dskpp:DeviceId&gt;
               &lt;pskc:Manufacturer&gt;TokenVendorAcme&lt;/pskc:Manufacturer&gt;
               &lt;pskc:SerialNo&gt;987654321&lt;/pskc:SerialNo&gt;
               &lt;pskc:StartDate&gt;2009-09-01T00:00:00Z&lt;/pskc:StartDate&gt;
               &lt;pskc:ExpiryDate&gt;2014-09-01T00:00:00Z&lt;/pskc:ExpiryDate&gt;
           &lt;/dskpp:DeviceId&gt;
       &lt;/dskpp:DeviceIdentifierData&gt;
       &lt;dskpp:SupportedKeyTypes&gt;
           &lt;dskpp:Algorithm&gt;
               urn:ietf:params:xml:ns:keyprov:pskc:hotp
           &lt;/dskpp:Algorithm&gt;
           &lt;dskpp:Algorithm&gt;
    http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
           &lt;/dskpp:Algorithm&gt;
       &lt;/dskpp:SupportedKeyTypes&gt;
       &lt;dskpp:SupportedEncryptionAlgorithms&gt;
           &lt;dskpp:Algorithm&gt;
               http://www.w3.org/2001/04/xmlenc#rsa_1_5
           &lt;/dskpp:Algorithm&gt;
       &lt;/dskpp:SupportedEncryptionAlgorithms&gt;
       &lt;dskpp:SupportedMacAlgorithms&gt;
           &lt;dskpp:Algorithm&gt;
               urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256
           &lt;/dskpp:Algorithm&gt;
       &lt;/dskpp:SupportedMacAlgorithms&gt;
       &lt;dskpp:SupportedProtocolVariants&gt;
           &lt;dskpp:TwoPass&gt;
               &lt;dskpp:SupportedKeyProtectionMethod&gt;
                urn:ietf:params:xml:schema:keyprov:dskpp:passphrase-wrap
               &lt;/dskpp:SupportedKeyProtectionMethod&gt;

               &lt;dskpp:Payload&gt;
                   &lt;ds:KeyInfo&gt;
                       &lt;ds:KeyName&gt;Passphrase-1&lt;/ds:KeyName&gt;
                   &lt;/ds:KeyInfo&gt;
               &lt;/dskpp:Payload&gt;
           &lt;/dskpp:TwoPass&gt;
       &lt;/dskpp:SupportedProtocolVariants&gt;
       &lt;dskpp:SupportedKeyPackages&gt;
           &lt;dskpp:KeyPackageFormat&gt;
               urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container
           &lt;/dskpp:KeyPackageFormat&gt;
       &lt;/dskpp:SupportedKeyPackages&gt;
       &lt;dskpp:AuthenticationData&gt;
           &lt;dskpp:ClientID&gt;AC00000A&lt;/dskpp:ClientID&gt;
           &lt;dskpp:AuthenticationCodeMac&gt;
               &lt;dskpp:Nonce&gt;
                   ESIzRFVmd4iZqrvM3e7/ESIzRFVmd4iZqrvM3e7/ESI=
               &lt;/dskpp:Nonce&gt;
               &lt;dskpp:IterationCount&gt;1&lt;/dskpp:IterationCount&gt;
               &lt;dskpp:Mac
                   MacAlgorithm=
                  &quot;urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256&quot;&gt;
                  K4YvLMN6Q1DZvtShoCxQag==
               &lt;/dskpp:Mac&gt;
           &lt;/dskpp:AuthenticationCodeMac&gt;
       &lt;/dskpp:AuthenticationData&gt;
   &lt;/dskpp:KeyProvClientHello&gt;

   In this example, the server responds to the previous request by
   returning a key package in which the provisioning key was encrypted
   using the Passphrase-Based Key Wrap key protection method.

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;
   &lt;dskpp:KeyProvServerFinished
       xmlns:pskc=&quot;urn:ietf:params:xml:ns:keyprov:pskc&quot;
       xmlns:dskpp=&quot;urn:ietf:params:xml:ns:keyprov:dskpp&quot;
       xmlns:xenc=&quot;http://www.w3.org/2001/04/xmlenc#&quot;
       xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;
       xmlns:dkey=&quot;http://www.w3.org/2009/xmlsec-derivedkey#&quot;
       xmlns:pkcs5=
          &quot;http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#&quot;
       Version=&quot;1.0&quot;
       Status=&quot;Success&quot;
       SessionID=&quot;4114&quot;&gt;
       &lt;dskpp:KeyPackage&gt;
           &lt;dskpp:KeyContainer Version=&quot;1.0&quot; Id=&quot;KC0002&quot;&gt;
               &lt;pskc:EncryptionKey&gt;
                   &lt;dkey:DerivedKey&gt;

                       &lt;dkey:KeyDerivationMethod
                       Algorithm=
                       &quot;http://www.rsasecurity.com/rsalabs/pkcs/schemas/
                       pkcs-5v2-0#pbkdf2&quot;&gt;
                           &lt;pkcs5:PBKDF2-params&gt;
                               &lt;Salt&gt;
                                   &lt;Specified&gt;Ej7/PEpyEpw=&lt;/Specified&gt;
                               &lt;/Salt&gt;
                               &lt;IterationCount&gt;1000&lt;/IterationCount&gt;
                               &lt;KeyLength&gt;16&lt;/KeyLength&gt;
                           &lt;/pkcs5:PBKDF2-params&gt;
                       &lt;/dkey:KeyDerivationMethod&gt;
                       &lt;xenc:ReferenceList&gt;
                           &lt;xenc:DataReference URI=&quot;#ED&quot;/&gt;
                       &lt;/xenc:ReferenceList&gt;
                       &lt;dkey:MasterKeyName&gt;
                          Passphrase1
                       &lt;/dkey:MasterKeyName&gt;
                   &lt;/dkey:DerivedKey&gt;
               &lt;/pskc:EncryptionKey&gt;
               &lt;pskc:MACMethod
                   Algorithm=
                      &quot;http://www.w3.org/2000/09/xmldsig#hmac-sha1&quot;&gt;
                   &lt;pskc:MACKey&gt;
                       &lt;xenc:EncryptionMethod
                           Algorithm=
                         &quot;http://www.w3.org/2001/04/xmlenc#aes128-cbc&quot;/&gt;
                       &lt;xenc:CipherData&gt;
                           &lt;xenc:CipherValue&gt;
        2GTTnLwM3I4e5IO5FkufoOEiOhNj91fhKRQBtBJYluUDsPOLTfUvoU2dStyOwYZx
                           &lt;/xenc:CipherValue&gt;
                       &lt;/xenc:CipherData&gt;
                   &lt;/pskc:MACKey&gt;
               &lt;/pskc:MACMethod&gt;
               &lt;pskc:KeyPackage&gt;
                   &lt;pskc:DeviceInfo&gt;
                       &lt;pskc:Manufacturer&gt;
                          TokenVendorAcme
                       &lt;/pskc:Manufacturer&gt;
                       &lt;pskc:SerialNo&gt;
                          987654321
                       &lt;/pskc:SerialNo&gt;
                       &lt;pskc:StartDate&gt;
                          2009-09-01T00:00:00Z
                       &lt;/pskc:StartDate&gt;
                       &lt;pskc:ExpiryDate&gt;
                          2014-09-01T00:00:00Z
                       &lt;/pskc:ExpiryDate&gt;

                   &lt;/pskc:DeviceInfo&gt;
                   &lt;pskc:CryptoModuleInfo&gt;
                       &lt;pskc:Id&gt;CM_ID_001&lt;/pskc:Id&gt;
                   &lt;/pskc:CryptoModuleInfo&gt;
                   &lt;pskc:Key
                       Id=&quot;MBK000000001&quot;
                       Algorithm=
                          &quot;urn:ietf:params:xml:ns:keyprov:pskc:hotp&quot;&gt;
                       &lt;pskc:Issuer&gt;Example-Issuer&lt;/pskc:Issuer&gt;
                       &lt;pskc:AlgorithmParameters&gt;
                          &lt;pskc:ResponseFormat Length=&quot;6&quot;
                             Encoding=&quot;DECIMAL&quot;/&gt;
                       &lt;/pskc:AlgorithmParameters&gt;
                       &lt;pskc:Data&gt;
                           &lt;pskc:Secret&gt;
                               &lt;pskc:EncryptedValue&gt;
                                   &lt;xenc:EncryptionMethod
                                       Algorithm=
                                       &quot;http://www.w3.org/2001/04/
                                       xmlenc#aes128-cbc&quot;/&gt;
                                   &lt;xenc:CipherData&gt;
                                       &lt;xenc:CipherValue&gt;
                                         oTvo+S22nsmS2Z/RtcoF8HX385uMWgJ
                                         myIFMESBmcvtHQXp/6T1TgCS9CsgKtm
                                         cOrF8VoK254tZKnrAjiD5cdw==
                                       &lt;/xenc:CipherValue&gt;
                                   &lt;/xenc:CipherData&gt;
                               &lt;/pskc:EncryptedValue&gt;
                               &lt;pskc:ValueMAC&gt;
                                   pbgEbVYxoYs0x41wdeC7eDRbUEk=
                               &lt;/pskc:ValueMAC&gt;
                           &lt;/pskc:Secret&gt;
                           &lt;pskc:Counter&gt;
                               &lt;pskc:PlainValue&gt;0&lt;/pskc:PlainValue&gt;
                           &lt;/pskc:Counter&gt;
                       &lt;/pskc:Data&gt;
                       &lt;pskc:Policy&gt;
                           &lt;pskc:KeyUsage&gt;OTP&lt;/pskc:KeyUsage&gt;
                       &lt;/pskc:Policy&gt;
                   &lt;/pskc:Key&gt;
               &lt;/pskc:KeyPackage&gt;
           &lt;/dskpp:KeyContainer&gt;
       &lt;/dskpp:KeyPackage&gt;
       &lt;dskpp:Mac MacAlgorithm=
           &quot;urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256&quot;&gt;
           Jc4VsNODYXgfbDmTn9qQZgcL3cKoa//j/NRT7sTpKOM=
       &lt;/dskpp:Mac&gt;
   &lt;/dskpp:KeyProvServerFinished&gt;

Appendix C.  Integration with PKCS #11

   A DSKPP Client that needs to communicate with a connected
   cryptographic module to perform a DSKPP exchange MAY use PKCS #11
   [PKCS-11] as a programming interface as described herein.  This
   appendix forms an informative part of the document.

C.1.  The Four-Pass Variant

   When performing four-pass DSKPP with a cryptographic module using the
   PKCS #11 programming interface, the procedure described in
   [CT-KIP-P11], Appendix B, is RECOMMENDED.

C.2.  The Two-Pass Variant

   A suggested procedure to perform two-pass DSKPP with a cryptographic
   module through the PKCS #11 interface using the mechanisms defined in
   [CT-KIP-P11] is as follows:

   a.  On the client side,

       1.  The client selects a suitable slot and token (e.g., through
           use of the &lt;DeviceIdentifier&gt; or the &lt;PlatformInfo&gt; element
           of the DSKPP trigger message).

       2.  A nonce R is generated, e.g., by calling C_SeedRandom and
           C_GenerateRandom.

       3.  The client sends its first message to the server, including
           the nonce R.

   b.  On the server side,

       1.  A generic key K_PROV = K_TOKEN | K_MAC (where &#x27;|&#x27; denotes
           concatenation) is generated, e.g., by calling C_GenerateKey
           (using key type CKK_GENERIC_SECRET).  The template for K_PROV
           MUST allow it to be exported (but only in wrapped form, i.e.,
           CKA_SENSITIVE MUST be set to CK_TRUE and CKA_EXTRACTABLE MUST
           also be set to CK_TRUE), and also to be used for further key
           derivation.  From K, a token key K_TOKEN of suitable type is
           derived by calling C_DeriveKey using the PKCS #11 mechanism
           CKM_EXTRACT_KEY_FROM_KEY and setting the CK_EXTRACT_PARAMS to
           the first bit of the generic secret key (i.e., set to 0).
           Likewise, a MAC key K_MAC is derived from K_PROV by calling
           C_DeriveKey using the CKM_EXTRACT_KEY_FROM_KEY mechanism,
           this time setting CK_EXTRACT_PARAMS to the length of K_PROV
           (in bits) divided by two.

       2.  The server wraps K_PROV with either the public key of the
           DSKPP Client or device, the pre-shared secret key, or the
           derived shared secret key by using C_WrapKey.  If use of the
           DSKPP key wrap algorithm has been negotiated, then the
           CKM_KIP_WRAP mechanism MUST be used to wrap K.  When calling
           C_WrapKey, the hKey handle in the CK_KIP_PARAMS structure
           MUST be set to NULL_PTR.  The pSeed parameter in the
           CK_KIP_PARAMS structure MUST point to the nonce R provided by
           the DSKPP Client, and the ulSeedLen parameter MUST indicate
           the length of R.  The hWrappingKey parameter in the call to
           C_WrapKey MUST be set to refer to the key wrapping key.

       3.  Next, the server needs to calculate a MAC using K_MAC.  If
           use of the DSKPP MAC algorithm has been negotiated, then the
           MAC is calculated by calling C_SignInit with the CKM_KIP_MAC
           mechanism followed by a call to C_Sign.  In the call to
           C_SignInit, K_MAC MUST be the signature key, the hKey
           parameter in the CK_KIP_PARAMS structure MUST be set to
           NULL_PTR, the pSeed parameter of the CT_KIP_PARAMS structure
           MUST be set to NULL_PTR, and the ulSeedLen parameter MUST be
           set to zero.  In the call to C_Sign, the pData parameter MUST
           be set to the concatenation of the string ServerID and the
           nonce R, and the ulDataLen parameter MUST be set to the
           length of the concatenated string.  The desired length of the
           MAC MUST be specified through the pulSignatureLen parameter
           and MUST be set to the length of R.

       4.  If the server also needs to authenticate its message (due to
           an existing K_TOKEN being replaced), the server MUST
           calculate a second MAC.  Again, if use of the DSKPP MAC
           algorithm has been negotiated, then the MAC is calculated by
           calling C_SignInit with the CKM_KIP_MAC mechanism followed by
           a call to C_Sign.  In this call to C_SignInit, the K_MAC&#x27;
           existing before this DSKPP run MUST be the signature key (the
           implementation may specify K_MAC&#x27; to be the value of the
           K_TOKEN that is being replaced, or a version of K_MAC from
           the previous protocol run), the hKey parameter in the
           CK_KIP_PARAMS structure MUST be set to NULL, the pSeed
           parameter of the CT_KIP_PARAMS structure MUST be set to
           NULL_PTR, and the ulSeedLen parameter MUST be set to zero.
           In the call to C_Sign, the pData parameter MUST be set to the
           concatenation of the string ServerID and the nonce R, and the
           ulDataLen parameter MUST be set to the length of concatenated
           string.  The desired length of the MAC MUST be specified
           through the pulSignatureLen parameter and MUST be set to the
           length of R.

       5.  The server sends its message to the client, including the
           wrapped key K_TOKEN, the MAC and possibly also the
           authenticating MAC.

   c.  On the client side,

       1.  The client calls C_UnwrapKey to receive a handle to K.  After
           this, the client calls C_DeriveKey twice: once to derive
           K_TOKEN and once to derive K_MAC.  The client MUST use the
           same mechanism (CKM_EXTRACT_KEY_FROM_KEY) and the same
           mechanism parameters as used by the server above.  When
           calling C_UnwrapKey and C_DeriveKey, the pTemplate parameter
           MUST be used to set additional key attributes in accordance
           with local policy and as negotiated and expressed in the
           protocol.  In particular, the value of the &lt;KeyID&gt; element in
           the server&#x27;s response message MAY be used as CKA_ID for
           K_TOKEN.  The key K_PROV MUST be destroyed after deriving
           K_TOKEN and K_MAC.

       2.  The MAC is verified in a reciprocal fashion as it was
           generated by the server.  If use of the CKM_KIP_MAC mechanism
           has been negotiated, then in the call to C_VerifyInit, the
           hKey parameter in the CK_KIP_PARAMS structure MUST be set to
           NULL_PTR, the pSeed parameter MUST be set to NULL_PTR, and
           ulSeedLen MUST be set to 0.  The hKey parameter of
           C_VerifyInit MUST refer to K_MAC.  In the call to C_Verify,
           pData MUST be set to the concatenation of the string ServerID
           and the nonce R, and the ulDataLen parameter MUST be set to
           the length of the concatenated string, pSignature to the MAC
           value received from the server, and ulSignatureLen to the
           length of the MAC.  If the MAC does not verify the protocol
           session ends with a failure.  The token MUST be constructed
           to not &quot;commit&quot; to the new K_TOKEN or the new K_MAC unless
           the MAC verifies.

       3.  If an authenticating MAC was received (REQUIRED if the new
           K_TOKEN will replace an existing key on the token), then it
           is verified in a similar vein but using the K_MAC&#x27; associated
           with this server and existing before the protocol run (the
           implementation may specify K_MAC&#x27; to be the value of the
           K_TOKEN that is being replaced, or a version of K_MAC from
           the previous protocol run).  Again, if the MAC does not
           verify the protocol session ends with a failure, and the
           token MUST be constructed not to &quot;commit&quot; to the new K_TOKEN
           or the new K_MAC unless the MAC verifies.

Appendix D.  Example of DSKPP-PRF Realizations

D.1.  Introduction

   This example appendix defines DSKPP-PRF in terms of AES [FIPS197-AES]
   and HMAC [RFC2104].  This appendix forms a normative part of the
   document.

D.2.  DSKPP-PRF-AES

D.2.1.  Identification

   For cryptographic modules supporting this realization of DSKPP-PRF,
   the following URN MUST be used to identify this algorithm in DSKPP:

   urn:ietf:params:xml:ns:keyprov:dskpp:prf-aes-128

   When this URN is used to identify the encryption algorithm, the
   method for encryption of R_C values described in Section 4.2.4 MUST
   be used.

D.2.2.  Definition

   DSKPP-PRF-AES (k, s, dsLen)

   Input:

   k         Encryption key to use
   s         Octet string consisting of randomizing material.  The
             length of the string s is sLen.
   dsLen     Desired length of the output

   Output:

   DS        A pseudorandom string, dsLen-octets long

   Steps:

   1.  Let bLen be the output block size of AES in octets:

       bLen = (AES output block length in octets)
       (normally, bLen = 16)

   2.  If dsLen &gt; (2**32 - 1) * bLen, output &quot;derived data too long&quot; and
       stop

   3.  Let n be the number of bLen-octet blocks in the output data,
       rounding up, and let j be the number of octets in the last block:

       n = CEILING( dsLen / bLen)
       j = dsLen - (n - 1) * bLen

   4.  For each block of the pseudorandom string DS, apply the function
       F defined below to the key k, the string s and the block index to
       compute the block:

       B1 = F (k, s, 1) ,
       B2 = F (k, s, 2) ,
       ...
       Bn = F (k, s, n)

   The function F is defined in terms of the CMAC construction from
   [NIST-SP800-38B], using AES as the block cipher:

   F (k, s, i) = CMAC-AES (k, INT (i) || s)

   where INT (i) is a four-octet encoding of the integer i, most
   significant octet first, and the output length of CMAC is set to
   bLen.

   Concatenate the blocks and extract the first dsLen octets to produce
   the desired data string DS:

   DS = B1 || B2 || ... || Bn&lt;0..j-1&gt;

   Output the derived data DS.

D.2.3.  Example

   If we assume that dsLen = 16, then:

   n = 16 / 16 = 1

   j = 16 - (1 - 1) * 16 = 16

   DS = B1 = F (k, s, 1) = CMAC-AES (k, INT (1) || s)

D.3.  DSKPP-PRF-SHA256

D.3.1.  Identification

   For cryptographic modules supporting this realization of DSKPP-PRF,
   the following URN MUST be used to identify this algorithm in DSKPP:

   urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256

   When this URN is used to identify the encryption algorithm to use,
   the method for encryption of R_C values described in Section 4.2.4
   MUST be used.

D.3.2.  Definition

   DSKPP-PRF-SHA256 (k, s, dsLen)

   Input:

   k         Encryption key to use
   s         Octet string consisting of randomizing material.  The
             length of the string s is sLen.
   dsLen     Desired length of the output

   Output:

   DS        A pseudorandom string, dsLen-octets long

   Steps:

   1.  Let bLen be the output size of SHA-256 in octets of [FIPS180-SHA]
       (no truncation is done on the HMAC output):

       bLen = 32
       (normally, bLen = 16)

   2.  If dsLen &gt; (2**32 - 1) * bLen, output &quot;derived data too long&quot; and
       stop

   3.  Let n be the number of bLen-octet blocks in the output data,
       rounding up, and let j be the number of octets in the last block:

       n = CEILING( dsLen / bLen)
       j = dsLen - (n - 1) * bLen

   4.  For each block of the pseudorandom string DS, apply the function
       F defined below to the key k, the string s and the block index to
       compute the block:

       B1 = F (k, s, 1),
       B2 = F (k, s, 2),
       ...
       Bn = F (k, s, n)

   The function F is defined in terms of the HMAC construction from
   [RFC2104], using SHA-256 as the digest algorithm:

   F (k, s, i) = HMAC-SHA256 (k, INT (i) || s)

   where INT (i) is a four-octet encoding of the integer i, most
   significant octet first, and the output length of HMAC is set to
   bLen.

   Concatenate the blocks and extract the first dsLen octets to produce
   the desired data string DS:

   DS = B1 || B2 || ... || Bn&lt;0..j-1&gt;

   Output the derived data DS.

D.3.3.  Example

   If we assume that sLen = 256 (two 128-octet long values) and dsLen =
   16, then:

   n = CEILING( 16 / 32 ) = 1

   j = 16 - (1 - 1) * 32 = 16

   B1 = F (k, s, 1) = HMAC-SHA256 (k, INT (1) || s)

   DS = B1&lt;0 ... 15&gt;

   That is, the result will be the first 16 octets of the HMAC output.

Authors&#x27; Addresses

   Andrea Doherty
   RSA, The Security Division of EMC
   174 Middlesex Turnpike
   Bedford, MA  01730
   USA

   EMail: andrea.doherty@rsa.com


   Mingliang Pei
   VeriSign, Inc.
   487 E. Middlefield Road
   Mountain View, CA  94043
   USA

   EMail: mpei@verisign.com


   Salah Machani
   Diversinet Corp.
   2225 Sheppard Avenue East, Suite 1801
   Toronto, Ontario  M2J 5C2
   Canada

   EMail: smachani@diversinet.com


   Magnus Nystrom
   Microsoft Corp.
   One Microsoft Way
   Redmond, WA  98052
   USA

   EMail: mnystrom@microsoft.com


        </re>
        
    </body>
</html>
