H_0 = H^(64)(LE32(p) || LE32(T) || LE32(m) || LE32(t) ||
                     LE32(v) || LE32(y) || LE32(length(P)) || P ||
                     LE32(length(S)) || S ||  LE32(length(K)) || K ||
                     LE32(length(X)) || X)

                              H_0 generation

C = B[0][q-1] XOR B[1][q-1] XOR ... XOR B[p-1][q-1]

                                Final block

r = ceil(T/32)-2
V_1 = H^(64)(LE32(T)||A)
V_2 = H^(64)(V_1)
V_r = H^(64)(V_{r-1})
J_1 = int32(extract(B[i][j-1], 0))
J_2 = int32(extract(B[i][j-1], 1))

                         Deriving J1,J2 in Argon2d

Z= ( LE64(r) || LE64(l) || LE64(sl) || LE64(m') ||
           LE64(t) || LE64(y) ), where

       r  -- the pass number
       l  -- the lane number
       sl  -- the slice number
       m' -- the total number of memory blocks
       t  -- the total number of passes
       y  -- the Argon2 type (0 for Argon2d,
                           1 for Argon2i, 2 for Argon2id)

                     Input to compute J1,J2 in Argon2i
x = J_1^2 / 2^(32)
y = (|W| * x) / 2^(32)
zz = |W| - 1 - y

                           Computing J1, part 2
a = (a + b + 2 * trunc(a) * trunc(b)) mod 2^(64)
d = (d XOR a) >>> 32
c = (c + d + 2 * trunc(c) * trunc(d)) mod 2^(64)
b = (b XOR c) >>> 24

a = (a + b + 2 * trunc(a) * trunc(b)) mod 2^(64)
d = (d XOR a) >>> 16
c = (c + d + 2 * trunc(c) * trunc(d)) mod 2^(64)
b = (b XOR c) >>> 63

                               Details of GB

