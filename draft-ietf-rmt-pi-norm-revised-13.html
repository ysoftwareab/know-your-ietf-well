<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>NACK-Oriented Reliable Multicast Transport
    Protocol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="NACK-Oriented Reliable Multicast Transport
    Protocol">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Network Working Group</td><td class="header">B. Adamson</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Naval Research Laboratory</td></tr>
<tr><td class="header">Obsoletes: <a href='http://tools.ietf.org/html/rfc3940'>3940</a> (if&nbsp;approved)</td><td class="header">C. Bormann</td></tr>
<tr><td class="header">Intended status: Standards Track</td><td class="header">Universitaet Bremen TZI</td></tr>
<tr><td class="header">Expires: December 5, 2009</td><td class="header">M. Handley</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">University College London</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">J. Macker</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Naval Research Laboratory</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">June 03, 2009</td></tr>
</table></td></tr></table>
<h1><br />NACK-Oriented Reliable Multicast Transport
    Protocol<br />draft-ietf-rmt-pi-norm-revised-13</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.
This document may contain material from IETF Documents or IETF
Contributions published or made publicly available before November
10, 2008. The person(s) controlling the copyright in some of this
material may not have granted the IETF Trust the right to allow
modifications of such material outside the IETF Standards Process.
Without obtaining an adequate license from the person(s) controlling
the copyright in such materials, this document may not be modified
outside the IETF Standards Process, and derivative works of it may
not be created outside the IETF Standards Process, except to format
it for publication as an RFC or to translate it into languages other
than English.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on December 5, 2009.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>This document describes the messages and procedures of the
      Negative-ACKnowledgment (NACK) Oriented Reliable Multicast (NORM)
      Protocol. This protocol can provide end-to-end reliable transport of
      bulk data objects or streams over generic IP multicast routing and
      forwarding services. NORM uses a selective, negative acknowledgment
      mechanism for transport reliability and offers additional protocol
      mechanisms to allow for operation with minimal <em>a priori</em>
      coordination among senders and receivers. A congestion control scheme is
      specified to allow the NORM protocol to fairly share available network
      bandwidth with other transport protocols such as Transmission Control
      Protocol (TCP). It is capable of operating with both reciprocal
      multicast routing among senders and receivers and with asymmetric
      connectivity (possibly a unicast return path) between the senders and
      receivers. The protocol offers a number of features to allow different
      types of applications or possibly other higher level transport protocols
      to utilize its service in different ways. The protocol leverages the use
      of FEC-based repair and other IETF Reliable Multicast Transport (RMT)
      building blocks in its design. This document obsoletes <a class='info' href='#RFC3940'>RFC 3940<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol,&rdquo; November&nbsp;2004.</span><span>)</span></a>.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction and Applicability<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">1.1.</a>&nbsp;
Requirements Language<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">1.2.</a>&nbsp;
NORM Data Delivery Service Model<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor4">1.3.</a>&nbsp;
NORM Scalability<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor5">1.4.</a>&nbsp;
Environmental Requirements and Considerations<br />
<a href="#anchor6">2.</a>&nbsp;
Architecture Definition<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ProtocolOverview">2.1.</a>&nbsp;
Protocol Operation Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">2.2.</a>&nbsp;
Protocol Building Blocks<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">2.3.</a>&nbsp;
Design Tradeoffs<br />
<a href="#anchor9">3.</a>&nbsp;
Conformance Statement<br />
<a href="#anchor10">4.</a>&nbsp;
Message Formats<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#CommonHeader">4.1.</a>&nbsp;
NORM Common Message Header and Extensions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor11">4.2.</a>&nbsp;
Sender Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor12">4.2.1.</a>&nbsp;
NORM_DATA Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor13">4.2.2.</a>&nbsp;
NORM_INFO Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#NORM_CMD">4.2.3.</a>&nbsp;
NORM_CMD Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor21">4.3.</a>&nbsp;
Receiver Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor22">4.3.1.</a>&nbsp;
NORM_NACK Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor23">4.3.2.</a>&nbsp;
NORM_ACK Message<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor24">4.4.</a>&nbsp;
General Purpose Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor25">4.4.1.</a>&nbsp;
NORM_REPORT Message<br />
<a href="#ProtocolDetails">5.</a>&nbsp;
Detailed Protocol Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor26">5.1.</a>&nbsp;
Sender Initialization and Transmission<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#SegmentationAlgorithm">5.1.1.</a>&nbsp;
Object Segmentation Algorithm<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ReceiverInitialization">5.2.</a>&nbsp;
Receiver Initialization and Reception<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#NackProcedure">5.3.</a>&nbsp;
Receiver NACK Procedure<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor27">5.4.</a>&nbsp;
Sender NACK Processing and Response<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor28">5.4.1.</a>&nbsp;
Sender Repair State Aggregation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor29">5.4.2.</a>&nbsp;
Sender FEC Repair Transmission Strategy<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor30">5.4.3.</a>&nbsp;
Sender NORM_CMD(SQUELCH) Generation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor31">5.4.4.</a>&nbsp;
Sender NORM_CMD(REPAIR_ADV) Generation<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor32">5.5.</a>&nbsp;
Additional Protocol Mechanisms<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#GrttCollection">5.5.1.</a>&nbsp;
Group Round-trip Time (GRTT) Collection<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#CongestionControl">5.5.2.</a>&nbsp;
NORM Congestion Control Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PositiveAcknowledgment">5.5.3.</a>&nbsp;
NORM Positive Acknowledgment Procedure<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor36">5.5.4.</a>&nbsp;
Group Size Estimate<br />
<a href="#anchor37">6.</a>&nbsp;
Configurable Elements<br />
<a href="#anchor38">7.</a>&nbsp;
Security Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#NormIPsec">7.1.</a>&nbsp;
Baseline Secure NORM Operation<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor39">7.1.1.</a>&nbsp;
IPsec Approach<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor40">7.1.2.</a>&nbsp;
IPsec Requirements<br />
<a href="#anchor47">8.</a>&nbsp;
IANA Considerations<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor48">8.1.</a>&nbsp;
Explicit IANA Assignment Guidelines<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor49">8.1.1.</a>&nbsp;
NORM Header Extension Types<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor50">8.1.2.</a>&nbsp;
NORM Stream Control Codes<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor51">8.1.3.</a>&nbsp;
NORM_CMD Message Sub-types<br />
<a href="#anchor52">9.</a>&nbsp;
Suggested Use<br />
<a href="#ProtocolChanges">10.</a>&nbsp;
Changes from RFC3940<br />
<a href="#anchor53">11.</a>&nbsp;
Acknowledgments<br />
<a href="#rfc.references1">12.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">12.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">12.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction and Applicability</h3>

<p>The Negative-acknowledgment (NACK) Oriented Reliable Multicast (NORM)
      protocol can provide reliable transport of data from one or more
      sender(s) to a group of receivers over an IP multicast network. The
      primary design goals of NORM are to provide efficient, scalable, and
      robust bulk data (e.g., computer files, transmission of persistent data)
      transfer across possibly heterogeneous IP networks and topologies. The
      NORM protocol design provides support for distributed multicast session
      participation with minimal coordination among senders and receivers.
      NORM allows senders and receivers to dynamically join and leave
      multicast sessions at will with minimal overhead for control information
      and timing synchronization among participants. To accommodate this
      capability, NORM protocol message headers contain some common
      information allowing receivers to easily synchronize to senders
      throughout the lifetime of a reliable multicast session. NORM is
      self-adapting to a wide range of dynamic network conditions with little
      or no pre-configuration. The protocol is tolerant of inaccurate timing
      estimations or lossy conditions that can occur in many networks
      including mobile and wireless. The protocol can also converge and
      maintain efficient operation even in situations of heavy packet loss and
      large queuing or transmission delays. This document obsoletes the
      Experimental <a class='info' href='#RFC3940'>RFC 3940<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol,&rdquo; November&nbsp;2004.</span><span>)</span></a>
      specification.
</p>
<p>This document is a product of the IETF RMT working group and follows
      the guidelines provided in the <a class='info' href='#RFC3269'>Author Guidelines
      for Reliable Multicast Transport (RMT) Building Blocks and Protocol
      Instantiation documents<span> (</span><span class='info'>Kermode, R. and L. Vicisano, &ldquo;Author Guidelines for Reliable Multicast Transport (RMT) Building Blocks and Protocol Instantiation documents,&rdquo; April&nbsp;2002.</span><span>)</span></a> [RFC3269].
</p>
<p><strong>Statement of Intent</strong>
</p>
<p>This memo contains the definitions necessary to fully specify a
      Reliable Multicast Transport protocol in accordance with the criteria of
      <a class='info' href='#RFC2357'>IETF Criteria for Evaluating Reliable Multicast
      Transport and Application Protocols<span> (</span><span class='info'>Mankin, A., Romanov, A., Bradner, S., and V. Paxson, &ldquo;IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols,&rdquo; June&nbsp;1998.</span><span>)</span></a> [RFC2357]. The NORM specification
      described in this document was previously published in the "Experimental
      Category" <a class='info' href='#RFC3940'>[RFC3940]<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol,&rdquo; November&nbsp;2004.</span><span>)</span></a>. It was the stated intent of
      the RMT working group to re-submit this specifications as an IETF
      Proposed Standard in due course. This Proposed Standard specification is
      thus based on RFC 3940 and has been updated according to accumulated
      experience and growing protocol maturity since the publication of RFC
      3940. Said experience applies both to this specification itself and to
      congestion control strategies related to the use of this specification.
      The differences between RFC 3940 and this document are listed in <a class='info' href='#ProtocolChanges'>Section&nbsp;10<span> (</span><span class='info'>Changes from RFC3940</span><span>)</span></a>.
</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Requirements Language</h3>

<p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
NORM Data Delivery Service Model</h3>

<p>A NORM protocol instance (<em>NormSession</em>)
        is defined within the context of participants communicating
        connectionless (e.g., Internet Protocol (IP) or User Datagram Protocol
        (UDP)) packets over a network using pre-determined addresses and host
        port numbers. Generally, the participants exchange packets using an IP
        multicast group address, but unicast transport MAY also be established
        or applied as an adjunct to multicast delivery. In the case of
        multicast, the participating <em>NormNodes</em>
        will communicate using a common IP multicast group address and port
        number chosen via means outside the context of the given <em>NormSession</em>. Other existing IETF data format and
        protocol standards MAY be applied to describe and convey the necessary
        <em>a priori</em> information for a specific <em>NormSession</em> (e.g., <a class='info' href='#RFC4566'>Session
        Description Protocol (SDP)<span> (</span><span class='info'>Handley, M., Jacobson, V., and C. Perkins, &ldquo;SDP: Session Description Protocol,&rdquo; July&nbsp;2006.</span><span>)</span></a> [RFC4566], <a class='info' href='#RFC2974'>Session
        Announcement Protocol (SAP)<span> (</span><span class='info'>Handley, M., Perkins, C., and E. Whelan, &ldquo;Session Announcement Protocol,&rdquo; October&nbsp;2000.</span><span>)</span></a> [RFC2974], etc.).
</p>
<p>The NORM protocol design is principally driven by the assumption of
        a single sender transmitting bulk data content to a group of
        receivers. However, the protocol MAY operate with multiple senders
        within the context of a single <em>NormSession</em>.
        In initial implementations of this protocol, it is anticipated
        multiple senders will transmit independent of one another and
        receivers will maintain state as necessary for each sender. In future
        versions of NORM, it is possible some aspects of protocol operation
        (e.g., round-trip time collection) will provide for alternate modes
        allowing more efficient performance for applications requiring
        multiple senders.
</p>
<p>NORM provides for three types of bulk data content objects (<em>NormObjects</em>) to be reliably transported. These
        types include:
</p>
<p></p>
<ol class="text">
<li>static computer memory data content (<tt>NORM_OBJECT_DATA</tt>
            type),
</li>
<li>computer storage files (<tt>NORM_OBJECT_FILE</tt>
            type), and
</li>
<li>non-finite streams of continuous data content (<tt>NORM_OBJECT_STREAM</tt> type).
</li>
</ol>

<p>The distinction between <tt>NORM_OBJECT_DATA</tt>
        and <tt>NORM_OBJECT_FILE</tt> is simply to provide
        a hint to receivers in <em>NormSessions</em>
        serving multiple types of content as to what type of storage to
        allocate for received content (i.e., memory or file storage). Other
        than that distinction, the two are identical, providing for reliable
        transport of finite (but potentially very large) units of content.
        These static data and file services are anticipated to be useful for
        multicast-based cache applications with the ability to reliably
        provide transmission of large quantities of static data. Other types
        of static data/file delivery services might make use of these
        transport object types, too. The use of the <tt>NORM_OBJECT_STREAM</tt>
        type is at the application's discretion and could be used to carry
        static data or file content also. The NORM reliable stream service
        opens up additional possibilities such as serialized reliable
        messaging or other unbounded, perhaps dynamically produced content.
        The <tt>NORM_OBJECT_STREAM</tt> provides for
        reliable transport analogous to that of the Transmission Control
        Protocol (TCP), although NORM receivers will be able to begin
        receiving stream content at any point in time. The applicability of
        this feature will depend upon the application.
</p>
<p>The NORM protocol also allows for a small amount of out-of-band
        data (sent as <tt>NORM_INFO</tt> messages) to be
        attached to the data content objects transmitted by the sender. This
        readily-available out-of-band data allows multicast receivers to
        quickly and efficiently determine the nature of the corresponding
        data, file, or stream bulk content being transmitted. This allows
        application-level control of the receiver node's participation in the
        current transport activity. This also allows the protocol to be
        flexible with minimal pre-coordination among senders and receivers.
        The <tt>NORM_INFO</tt> content is atomic in that
        its size MUST fit into the payload portion of a single NORM
        message.
</p>
<p>NORM does NOT provide for global or application-level
        identification of data content within in its message headers. Note the
        <tt>NORM_INFO</tt> out-of-band data mechanism can
        be leveraged by the application for this purpose if desired, or
        identification can alternatively be embedded within the data content.
        NORM does identify transmitted content (<em>NormObjects</em>)
        with transport identifiers that are applicable only while the sender
        is transmitting and/or repairing the given object. These transport
        data content identifiers (<em>NormTransportIds</em>)
        are assigned in a monotonically increasing fashion by each NORM sender
        during the course of a <em>NormSession</em>.
        Participants, including senders, in NORM protocol sessions are also
        identified with unique identifiers (<em>NormNodeId</em>s).
        Each sender maintains its <em>NormTransportId</em>
        assignments independently and thus individual <em>NormObjects</em>
        can be uniquely identified during transport by concatenation of the
        session-unique sender identifier (<em>NormNodeId</em>)
        and the assigned <em>NormTransportId</em>. The
        <em>NormTransportId</em>s are assigned from a
        large, but fixed, numeric space in increasing order and will be
        reassigned during long-lived sessions. The NORM protocol provides
        mechanisms so the sender application can terminate transmission of
        data content and inform the group of this in an efficient manner.
        Other similar protocol control mechanisms (e.g., session termination,
        receiver synchronization, etc.) are specified so reliable multicast
        application variants can realize different, complete bulk transfer
        communication models to meet their goals.
</p>
<p>To summarize, the NORM protocol provides reliable transport of
        different types of data content (including potentially mixed types).
        The senders enqueue and transmit bulk content in the form of static
        data or files and/or non-finite, ongoing stream types. NORM senders
        provide for repair transmission of data and/or FEC content in response
        to NACK messages received from the receiver group. Mechanisms for
        out-of-band information and other transport control mechanisms are
        specified for use by applications to form complete reliable multicast
        solutions for different purposes.
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.3"></a><h3>1.3.&nbsp;
NORM Scalability</h3>

<p>Group communication scalability requirements lead to adaptation of
        negative acknowledgment (NACK) based protocol schemes when feedback
        for reliability is needed <a class='info' href='#RmComparison'>[RmComparison]<span> (</span><span class='info'>Pingali, S., Towsley, D., and J. Kurose, &ldquo;A Comparison of Sender-Initiated and Receiver-Initiated           Reliable Multicast Protocols,&rdquo; October&nbsp;1993.</span><span>)</span></a>. NORM is
        a protocol centered around the use of selective NACKs to request
        repairs of missing data. NORM provides for the use of packet-level
        forward error correction (FEC) techniques for efficient multicast
        repair and OPTIONAL proactive transmission robustness <a class='info' href='#RFC3453'>[RFC3453]<span> (</span><span class='info'>Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;The Use of Forward Error Correction (FEC) in Reliable Multicast,&rdquo; December&nbsp;2002.</span><span>)</span></a>. FEC-based repair can be used to greatly
        reduce the quantity of reliable multicast repair requests and repair
        transmissions <a class='info' href='#MdpToolkit'>[MdpToolkit]<span> (</span><span class='info'>Macker,  J. and B. Adamson, &ldquo;The Multicast Dissemination Protocol (MDP) Toolkit,&rdquo; October&nbsp;1999.</span><span>)</span></a> in a NACK-oriented
        protocol. The principal factor in NORM scalability is the volume of
        feedback traffic generated by the receiver set to facilitate
        reliability and congestion control. NORM uses probabilistic
        suppression of redundant feedback based on exponentially distributed
        random backoff timers. The performance of this type of suppression
        relative to other techniques is described in <a class='info' href='#McastFeedback'>[McastFeedback]<span> (</span><span class='info'>Nonnenmacher, J. and E. Biersack, &ldquo;Optimal Multicast Feedback,&rdquo; March/April&nbsp;1998.</span><span>)</span></a>. NORM dynamically measures the group's
        round-trip timing status to set its suppression and other protocol
        timers. This allows NORM to scale well while maintaining reliable data
        delivery transport with low latency relative to the network topology
        over which it is operating.
</p>
<p>Feedback messages can be either multicast to the group at large or
        sent via unicast routing to the sender. In the case of unicast
        feedback, the sender relays the feedback state to the group to
        facilitate feedback suppression. In typical Internet environments, the
        NORM protocol will readily scale to group sizes on the order of tens
        of thousands of receivers. A study of the quantity of feedback for
        this type of protocol is described in <a class='info' href='#NormFeedback'>[NormFeedback]<span> (</span><span class='info'>Adamson, B. and J. Macker, &ldquo;Quantitative Prediction of NACK-Oriented Reliable Multicast           (NORM) Feedback,&rdquo; October&nbsp;2002.</span><span>)</span></a>. NORM is able to operate with a smaller
        amount of feedback than a single TCP connection, even with relatively
        large numbers of receivers. Thus, depending upon the network topology,
        it is possible for NORM to scale to larger group sizes. With respect
        to computer resource usage, the NORM protocol does not need state to
        be kept on all receivers in the group. NORM senders maintain state
        only for receivers providing explicit congestion control feedback.
        However, NORM receivers need to maintain state for each active sender.
        This can constrain the number of simultaneous senders in some uses of
        NORM.
</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.4"></a><h3>1.4.&nbsp;
Environmental Requirements and Considerations</h3>

<p>All of the environmental requirements and considerations that apply
        to the <a class='info' href='#RFC5401'>Multicast NACK Building Block<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5401],
        <a class='info' href='#RFC5052'>FEC Building Block<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052], and <a class='info' href='#RFC4654'>TCP-Friendly Multicast Congestion Control (TFMCC)
        Building Block<span> (</span><span class='info'>Widmer, J. and M. Handley, &ldquo;TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification,&rdquo; August&nbsp;2006.</span><span>)</span></a> [RFC4654] also apply to the NORM protocol.
</p>
<p>The NORM protocol SHALL be capable of operating in an end-to-end
        fashion with no assistance from intermediate systems beyond basic IP
        multicast group management, routing, and forwarding services. While
        the techniques utilized in NORM are principally applicable to flat,
        end-to-end IP multicast topologies, they could also be applied in the
        sub-levels of hierarchical (e.g., tree-based) multicast distribution
        if so desired. NORM can make use of reciprocal (among senders and
        receivers) multicast communication under the Any-Source Multicast
        (ASM) model defined in <a class='info' href='#RFC1112'>Host Extensions for IP
        Multicasting<span> (</span><span class='info'>Deering, S., &ldquo;Host extensions for IP multicasting,&rdquo; August&nbsp;1989.</span><span>)</span></a> [RFC1112], but SHALL also be capable of scalable operation
        in asymmetric topologies such as <a class='info' href='#RFC4607'>Source-Specific Multicast (SSM)<span> (</span><span class='info'>Holbrook, H. and B. Cain, &ldquo;Source-Specific Multicast for IP,&rdquo; August&nbsp;2006.</span><span>)</span></a> [RFC4607] where only
        unicast routing service is available from the receivers to the
        sender(s).
</p>
<p>NORM is compatible with IPv4 and IPv6. Additionally, NORM can be
        used with networks employing Network Address Translation (NAT)
        providing the NAT device supports IP multicast and/or can cache UDP
        traffic source port numbers for remapping feedback traffic from
        receivers to the sender(s).
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Architecture Definition</h3>

<p>A <em>NormSession</em> is comprised of
      participants (<em>NormNodes</em>) acting as senders
      and/or receivers. NORM senders transmit data content in the form of
      <em>NormObjects</em> to the session destination
      address and the NORM receivers attempt to reliably receive the
      transmitted content using negative acknowledgments to request repair.
      Each <em>NormNode</em> within a <em>NormSession</em>
      is assumed to have a preselected unique 32-bit identifier (<em>NormNodeId</em>). <em>NormNodes</em>
      MUST have uniquely assigned identifiers within a single <em>NormSession</em> to distinguish between possible
      multiple senders and to distinguish feedback information from different
      receivers. There are two reserved <em>NormNodeId</em>
      values. A value of <tt>0x00000000</tt> is considered
      an invalid <em>NormNodeId</em> (<tt>NORM_NODE_NONE</tt>)
      and a value of <tt>0xffffffff</tt> is a "wild card"
      <em>NormNodeId</em> (<tt>NORM_NODE_ANY</tt>).
      While the protocol does not preclude multiple sender nodes concurrently
      transmitting within the context of a single NORM session (i.e., many-
      to-many operation), any type of interactive coordination among NORM
      senders is assumed to be controlled by the application or higher
      protocol layer. There are some OPTIONAL mechanisms specified in this
      document that can be leveraged for such application layer
      coordination.
</p>
<p>As previously noted, NORM allows for reliable transmission of three
      different basic types of data content. The first type is <tt>NORM_OBJECT_DATA</tt>, that is used for static,
      persistent blocks of data content maintained in the sender's application
      memory storage. The second type is <tt>NORM_OBJECT_FILE</tt>,
      that corresponds to data stored in the sender's non-volatile file
      system. The <tt>NORM_OBJECT_DATA</tt> and <tt>NORM_OBJECT_FILE</tt> types both represent <em>NormObjects</em> of finite but potentially very large
      size. The third type of data content is <tt>NORM_OBJECT_STREAM</tt>,
      that corresponds to an ongoing transmission of undefined length. This is
      analogous to the reliable stream service provide by TCP for unicast data
      transport. The format of the stream content is application-defined and
      can be "byte" or "message" oriented. The NORM protocol provides for
      "flushing" of the stream to expedite delivery or possibly enforce
      application message boundaries. NORM protocol implementations MAY offer
      either (or both) in-order delivery of the stream data to the receive
      application or out-of-order (more immediate) delivery of received
      segments of the stream to the receiver application. In either case, NORM
      sender and receiver implementations provide buffering to facilitate
      repair of the stream as it is transported.
</p>
<p>All <em>NormObjects</em> are logically segmented
      into FEC coding blocks and symbols for transmission by the sender. In
      NORM, an FEC encoding symbol directly corresponds to the payload of
      <tt>NORM_DATA</tt> messages or "segment". Note that
      when systematic FEC codes are used, the payload of <tt>NORM_DATA</tt>
      messages sent for the first portion of a FEC encoding block are source
      symbols (actual segments of original user data), while the remaining
      symbols for the block consist of parity symbols generated by FEC
      encoding. These parity symbols are generally sent in response to repair
      requests, but some number MAY be sent proactively at the end each
      encoding block to increase the robustness of transmission. When
      non-systematic FEC codes are used, all symbols sent consist of FEC
      encoding parity content. In this case, the receiver needs to receive a
      sufficient number of symbols to reconstruct (via FEC decoding) the
      original user data for the given block.
</p>
<p>Transmitted <em>NormObjects</em> are temporarily
      yet uniquely identified within the <em>NormSession</em>
      context using the given sender's <em>NormNodeId</em>,
      <em>NormInstanceId</em>, and a temporary <em>NormTransportId</em>. Depending upon the implementation,
      individual NORM senders can manage their <em>NormInstanceIds</em>
      independently, or a common <em>NormInstanceId</em>
      could be agreed upon for all participating nodes within a session if
      needed as a session identifier. NORM <em>NormTransportId</em>
      data content identifiers are sender-assigned and applicable and valid
      only during a <em>NormObject</em>'s actual transport
      (i.e., for as long as the sender is transmitting and providing repair of
      the indicated <em>NormObject</em>). For a long-lived
      session, the <em>NormTransportId</em> field can wrap
      and previously-used identifiers will be re-used. Note that globally
      unique identification of transported data content is not provided by
      NORM and, if necessary, is expected to be managed by the NORM
      application. The individual segments or symbols of the <em>NormObject</em> are further identified with FEC payload
      identifiers that include coding block and symbol identifiers. These are
      discussed in detail later in this document.
</p>
<a name="ProtocolOverview"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Protocol Operation Overview</h3>

<p>A NORM sender primarily generates messages of type <tt>NORM_DATA</tt>. These messages carry original data
        segments or FEC symbols and repair segments/symbols for the bulk
        data/file or stream <em>NormObjects</em> being
        transferred. By default, redundant FEC symbols are sent only in
        response to receiver repair requests (NACKs) and thus normally little
        or no additional transmission overhead is imposed due to FEC encoding.
        However, the NORM implementation MAY be configured to proactively
        transmit some amount of redundant FEC symbols along with the original
        content to potentially enhance performance (e.g., improved delay) at
        the cost of additional transmission overhead. This configuration is
        sensible for certain network conditions and can allow for robust,
        asymmetric multicast (e.g., unidirectional routing, satellite, cable)
        <a class='info' href='#FecHybrid'>[FecHybrid]<span> (</span><span class='info'>Gossink, D. and J. Macker, &ldquo;Reliable Multicast and Integrated Parity Retransmission with           Channel Estimation,&rdquo; 1998.</span><span>)</span></a> with reduced receiver feedback, or,
        in some cases, no feedback.
</p>
<p>A sender message of type <tt>NORM_INFO</tt> is
        also defined and is used to carry OPTIONAL out-of-band context
        information for a given transport object. A single <tt>NORM_INFO</tt> message can be associated with a <em>NormObject</em>. Because of its atomic nature, missing
        <tt>NORM_INFO</tt> messages can be NACKed and
        repaired with a slightly lower delay process than NORM's general
        FEC-encoded data content. The <tt>NORM_INFO</tt>
        message can serve special purposes for some bulk transfer, reliable
        multicast applications where receivers join the group mid-stream and
        need to ascertain contextual information on the current content being
        transmitted. The NACK process for <tt>NORM_INFO</tt>
        will be described later. When the <tt>NORM_INFO</tt>
        message type is used, its transmission SHOULD precede transmission of
        any <tt>NORM_DATA</tt> message for the associated
        <em>NormObject</em>.
</p>
<p>The sender also generates messages of type <tt>NORM_CMD</tt>
        to assist in certain protocol operations such as congestion control,
        end-of-transmission flushing, group round trip time (GRTT) estimation,
        receiver synchronization, and OPTIONAL positive acknowledgment
        requests or application defined commands. The transmission of <tt>NORM_CMD</tt> messages from the sender is accomplished
        by one of three different procedures. These procedures are: single,
        best effort unreliable transmission of the command; repeated redundant
        transmissions of the command; and positively-acknowledged commands.
        The transmission technique used for a given command depends upon the
        function of the command. Several core commands are defined for basic
        protocol operation. Additionally, implementations MAY wish to consider
        providing the OPTIONAL application-defined commands that can take
        advantage of the transmission methodologies available for commands.
        This allows for application-level session management mechanisms that
        can make use of information available to the underlying NORM protocol
        engine (e.g., round-trip timing, transmission rate, etc.). A notable
        distinction between <tt>NORM_DATA</tt> message and
        some <tt>NORM_CMD</tt> message transmissions is
        that typically a receiver will need to allocate resources to manage
        reliable reception when <tt>NORM_DATA</tt> messages
        are received. However some <tt>NORM_CMD</tt>
        messages are completely atomic and no specific reliability (buffering)
        state needs to be kept. Thus, for session management or other purposes
        it is possible that even participants acting principally as data
        receivers MAY transmit <tt>NORM_CMD</tt> messages.
        However, it is RECOMMENDED that this is not done within the context of
        the NORM multicast session unless congestion control is addressed. For
        example, many receiver nodes transmitting <tt>NORM_CMD</tt>
        messages simultaneously can cause congestion for the
        destination(s).
</p>
<p>All sender transmissions are subject to rate control governed by a
        peak transmission rate set for each participant by the application.
        This can be used to limit the quantity of multicast data transmitted
        by the group. When NORM's congestion control algorithm is enabled the
        rate for senders is automatically adjusted. In some networks, it is
        desirable to establish minimum and maximum bounds for the rate
        adjustment depending upon the application even when dynamic congestion
        control is enabled. However, in the case of the general Internet,
        congestion control policy SHALL be observed that is compatible with
        coexistent TCP flows.
</p>
<p>NORM receivers generate messages of type <tt>NORM_NACK</tt>
        or <tt>NORM_ACK</tt> in response to transmissions
        of data and commands from a sender. The <tt>NORM_NACK</tt>
        messages are generated to request repair of detected data transmission
        losses. Receivers generally detect losses by tracking the sequence of
        transmission from a sender. Sequencing information is embedded in the
        transmitted data packets and end-of-transmission commands from the
        sender. <tt>NORM_ACK</tt> messages are generated in
        response to certain commands transmitted by the sender. In the general
        (and most scalable) protocol mode, <tt>NORM_ACK</tt>
        messages are sent only in response to congestion control commands from
        the sender. The feedback volume of these congestion control <tt>NORM_ACK</tt> messages is controlled using the same
        timer-based probabilistic suppression techniques as for <tt>NORM_NACK</tt> messages to avoid feedback implosion.
        In order to meet potential application requirements for positive
        acknowledgment from receivers, other <tt>NORM_ACK</tt>
        messages are defined and available for use.
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Protocol Building Blocks</h3>

<p>The operation of the NORM protocol is based primarily upon the
        concepts presented in the <a class='info' href='#RFC5401'>Multicast NACK
        Building Block<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5401] document. This includes the basic NORM
        architecture and the data transmission, repair, and feedback
        strategies discussed in that document. The reliable multicast building
        block approach, as described in <a class='info' href='#RFC3048'>Reliable
        Multicast Transport Building Blocks for One-to-Many Bulk-Data
        Transfer<span> (</span><span class='info'>Whetten, B., Vicisano, L., Kermode, R., Handley, M., Floyd, S., and M. Luby, &ldquo;Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer,&rdquo; January&nbsp;2001.</span><span>)</span></a> [RFC3048], is applied in creating the full NORM protocol
        instantiation. NORM also makes use of the parity-based encoding
        techniques for repair messaging and added transmission robustness as
        described in <a class='info' href='#RFC3453'>The Use of Forward Error
        Correction (FEC) in Reliable Multicast<span> (</span><span class='info'>Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;The Use of Forward Error Correction (FEC) in Reliable Multicast,&rdquo; December&nbsp;2002.</span><span>)</span></a> [RFC3453]. NORM uses the FEC
        Payload ID as specified by the <a class='info' href='#RFC5052'>FEC Building
        Block document<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052]. Additionally, for congestion control, this
        document fully specifies a baseline congestion control mechanism
        (NORM-CC) based on the TCP-Friendly Multicast Congestion Control
        (TFMCC) scheme<a class='info' href='#TfmccPaper'>[TfmccPaper]<span> (</span><span class='info'>Widmer, J. and M. Handley, &ldquo;Extending Equation-Based Congestion Control to Multicast           Applications,&rdquo; August&nbsp;2001.</span><span>)</span></a>, <a class='info' href='#RFC4654'>[RFC4654]<span> (</span><span class='info'>Widmer, J. and M. Handley, &ldquo;TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification,&rdquo; August&nbsp;2006.</span><span>)</span></a>.
</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Design Tradeoffs</h3>

<p>While the various features of NORM provide some measure of general
        purpose utility, it is important to emphasize the understanding that
        "no one size fits all" in the reliable multicast transport arena.
        There are numerous engineering trade-offs involved in reliable
        multicast transport design and this necessitates an increased
        awareness of application and network architecture considerations.
        Performance requirements affecting design can include: group size,
        heterogeneity (e.g., capacity and/or delay), asymmetric delivery, data
        ordering, delivery delay, group dynamics, mobility, congestion
        control, and transport across low capacity connections. NORM contains
        various parameters to accommodate many of these differing
        requirements. The NORM protocol and its mechanisms MAY be applied in
        multicast applications outside of bulk data transfer, but there is an
        assumed model of bulk transfer transport service that drives the
        trade-offs that determine the scalability and performance described in
        this document.
</p>
<p>The ability of NORM to provide reliable data delivery is also
        governed by any buffer constraints of the sender and receiver
        applications. NORM protocol implementations SHOULD operate with the
        greatest efficiency and robustness possible within application-defined
        buffer constraints. Buffer requirements for reliability, as always,
        are a function of the delay-bandwidth product of the network topology.
        NORM performs best when allowed more buffering resources than typical
        point-to-point transport protocols. This is because NORM feedback
        suppression is based upon randomly-delayed transmissions from the
        receiver set, rather than immediately transmitted feedback. There are
        definitive trade-offs between buffer utilization, group size
        scalability, and efficiency of performance. Large buffer sizes allow
        the NORM protocol to perform most efficiently in large delay-bandwidth
        topologies and allow for longer feedback suppression backoff timeouts.
        This yields improved group size scalability. NORM can operate with
        reduced buffering but at a cost of decreased efficiency (lower
        relative goodput) and reduced group size scalability.
</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Conformance Statement</h3>

<p>This RMT Protocol Instantiation document, in conjunction with the
      <a class='info' href='#RFC5401'>Multicast Negative-Acknowledgment (NACK)<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5401]
      and <a class='info' href='#RFC5052'>Forward Error Correction (FEC)<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052]
      Building Blocks, completely specifies a working reliable multicast
      transport protocol that conforms to the requirements described in <a class='info' href='#RFC2357'>RFC 2357<span> (</span><span class='info'>Mankin, A., Romanov, A., Bradner, S., and V. Paxson, &ldquo;IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols,&rdquo; June&nbsp;1998.</span><span>)</span></a>.
</p>
<p>This document specifies the following message types and mechanisms
      that are REQUIRED in complying NORM protocol implementations:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left" width="25%"><col align="left" width="75%">
<tr><th align="left">Message Type</th><th align="left">Purpose</th></tr>
<tr>
<td align="left"><tt>NORM_DATA</tt>&nbsp;</td>
<td align="left">Sender message for application data transmission. Implementations
        MUST support at least one of the <tt>NORM_OBJECT_DATA</tt>,
        <tt>NORM_OBJECT_FILE</tt>, or <tt>NORM_OBJECT_STREAM</tt>
        delivery services. The use of the NORM FEC Object Transmission
        Information header extension is OPTIONAL with <tt>NORM_DATA</tt>
        messages.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(FLUSH)</tt>&nbsp;</td>
<td align="left">Sender command to excite receivers for repair requests in lieu of
        ongoing <tt>NORM_DATA</tt> transmissions. Note the
        use of the <tt>NORM_CMD(FLUSH)</tt> for positive
        acknowledgment of data receipt is OPTIONAL.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(SQUELCH)</tt>&nbsp;</td>
<td align="left">Sender command to advertise its current valid repair window in
        response to invalid requests for repair.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(REPAIR_ADV)</tt>&nbsp;</td>
<td align="left">Sender command to advertise current repair (and congestion control
        state) to group when unicast feedback messages are detected. Used to
        control/suppress excessive receiver feedback in asymmetric multicast
        topologies.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(CC)</tt>&nbsp;</td>
<td align="left">Sender command used in collection of round trip timing and
        congestion control status from group (this is OPTIONAL if alternative
        congestion control mechanism and round trip timing collection is
        used).</td>
</tr>
<tr>
<td align="left"><tt>NORM_NACK</tt>&nbsp;</td>
<td align="left">Receiver message used to request repair of missing transmitted
        content.</td>
</tr>
<tr>
<td align="left"><tt>NORM_ACK</tt>&nbsp;</td>
<td align="left">Receiver message used to proactively provide feedback for
        congestion control purposes. Also used with the OPTIONAL NORM Positive
        Acknowledgment Process.</td>
</tr>
</table>
<br clear="all" />

<p>This document also describes the following message types and
      associated mechanisms that are OPTIONAL for complying NORM protocol
      implementations:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left" width="25%"><col align="left">
<tr><th align="left">Message Type</th><th align="left">Purpose</th></tr>
<tr>
<td align="left"><tt>NORM_INFO</tt>&nbsp;</td>
<td align="left">Sender message for providing ancillary context information
        associated with NORM transport objects. The use of the NORM FEC Object
        Transmission Information header extension is OPTIONAL with <tt>NORM_INFO</tt> messages.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(EOT)</tt>&nbsp;</td>
<td align="left">Sender command to indicate it has reached end-of-transmission and
        will no longer respond to repair requests.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(ACK_REQ)</tt>&nbsp;</td>
<td align="left">Sender command to support application-defined, positively
        acknowledged commands sent outside of the context of the bulk data
        content being transmitted. The NORM Positive Acknowledgment Procedure
        associated with this message type is OPTIONAL.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(APPLICATION)</tt>&nbsp;</td>
<td align="left">Sender command containing application-defined commands sent outside
        of the context of the bulk data content being transmitted.</td>
</tr>
<tr>
<td align="left"><tt>NORM_REPORT</tt>&nbsp;</td>
<td align="left">Optional message type reserved for experimental implementations of
        the NORM protocol.</td>
</tr>
</table>
<br clear="all" />

<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Message Formats</h3>

<p>There are two primary classes of NORM messages (see <a class='info' href='#ProtocolOverview'>Section&nbsp;2.1<span> (</span><span class='info'>Protocol Operation Overview</span><span>)</span></a>): sender messages and receiver
      messages. <tt>NORM_CMD</tt>, <tt>NORM_INFO</tt>,
      and <tt>NORM_DATA</tt> message types are generated by
      senders of data content, and <tt>NORM_NACK</tt> and
      <tt>NORM_ACK</tt> messages generated by receivers
      within a <em>NormSession</em>. Sender messages SHALL
      be governed by congestion control for Internet use. For session
      management or other purposes, receivers can also employ <tt>NORM_CMD</tt> message transmissions. The principal
      rationale for distinguishing sender and receiver messages is that
      receivers will typically need to allocate resources to support reliable
      reception from sender(s) and NORM sender messages are subject to
      congestion control. NORM receivers MAY employ the <tt>NORM_CMD</tt>
      message type for application-defined purposes but it is RECOMMENDED that
      congestion control and feedback implosion issues be addressed.
      Additionally, an auxiliary message type of <tt>NORM_REPORT</tt>
      is also provided for experimental purposes. This section describes the
      message formats used by the NORM protocol. These messages and their
      fields are referenced in the detailed functional description of the NORM
      protocol given in <a class='info' href='#ProtocolDetails'>Section&nbsp;5<span> (</span><span class='info'>Detailed Protocol Operation</span><span>)</span></a>. Individual
      NORM messages are compatible with the Maximum Transmission Unit (MTU)
      limitations of encapsulating Internet protocols including IPv4, IPv6,
      and UDP. The current NORM protocol specification assumes UDP
      encapsulation and leverages the transport features of UDP. The NORM
      messages are independent of network addresses and can be used in IPv4
      and IPv6 networks.
</p>
<a name="CommonHeader"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
NORM Common Message Header and Extensions</h3>

<p>There are some common message fields contained in all NORM message
        types. Additionally, a header extension mechanism is defined to expand
        the functionality of the NORM protocol without revision to this
        document. All NORM protocol messages begin with a common header with
        information fields as follows:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version|  type |    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM Common Message Header Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The "version" field is a 4-bit value indicating the protocol
        version number. NORM implementations SHOULD ignore received messages
        with version numbers different from their own. This number is intended
        to indicate and distinguish upgrades of the protocol that are
        non-interoperable. The NORM version number for this specification is
        1.
</p>
<p>The message "type" field is a 4-bit value indicating the NORM
        protocol message type. These types are defined as follows:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left" width="25%"><col align="center" width="25%">
<tr><th align="left">Message</th><th align="center">Value</th></tr>
<tr>
<td align="left"><tt>NORM_INFO</tt>&nbsp;</td>
<td align="center">1</td>
</tr>
<tr>
<td align="left"><tt>NORM_DATA</tt>&nbsp;</td>
<td align="center">2</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD</tt>&nbsp;</td>
<td align="center">3</td>
</tr>
<tr>
<td align="left"><tt>NORM_NACK</tt>&nbsp;</td>
<td align="center">4</td>
</tr>
<tr>
<td align="left"><tt>NORM_ACK</tt>&nbsp;</td>
<td align="center">5</td>
</tr>
<tr>
<td align="left"><tt>NORM_REPORT</tt>&nbsp;</td>
<td align="center">6</td>
</tr>
</table>
<br clear="all" />

<p>The 8-bit "hdr_len" field indicates the number of 32-bit words that
        comprise the given message's header portion. This is used to
        facilitate addition of header extensions. The presence of header
        extensions are implied when the "hdr_len" value is greater than the
        base value for the given message "type".
</p>
<p>The "sequence" field is a 16-bit value that is set by the message
        originator. The "sequence" field serves two separate purposes,
        depending upon the message type:</p>
<ol class="text">
<li>NORM senders MUST set the "sequence" field of sender messages
            (<tt>NORM_INFO</tt>, <tt>NORM_DATA</tt>,
            and <tt>NORM_CMD</tt>) so that receivers can
            monitor the "sequence" value to maintain an estimate of packet
            loss that can be used for congestion control purposes (See <a class='info' href='#CongestionControl'>Section&nbsp;5.5.2<span> (</span><span class='info'>NORM Congestion Control Operation</span><span>)</span></a> for a detailed description of
            NORM Congestion Control operation). A monotonically-increasing
            sequence number space MUST be maintained to mark NORM sender
            messages in this way. Note that this "sequence" number is
            explicitly NOT used in NORM as part of its reliability procedures.
            The NORM object and FEC payload identifiers are used to detect
            missing content for reliable transfer purposes.
</li>
<li>NORM receivers SHOULD set the "sequence" field to support
            protection from message replay attacks of <tt>NORM_NACK</tt>
            or <tt>NORM_NACK</tt> messages. Note that,
            depending upon configuration, NORM feedback messages are sent to
            the session multicast address or the unicast address[es] of the
            active NORM sender[s]. Thus, a separate, monotonically-increasing
            sequence number space MUST be maintained for each destination
            address to which the NORM receiver is transmitting feedback
            messages.
</li>
</ol>

<p>Note that these two separate purposes necessitate the maintenance
        of separate sequence spaces to support the functions described here.
        And, in the case of NORM receivers, additional sequence spaces are
        needed when feedback messages are sent to the sender unicast
        address[es] instead of the session address.
</p>
<p>The "source_id" field is a 32-bit value that uniquely identifies
        the node that sent the message within the context of a single <em>NormSession</em>. This value is termed the NORM node
        identifier (<em>NormNodeId</em>) and unique <em>NormNodeId</em> identifiers MUST be assigned within a
        single <em>NormSession</em>. In some cases, use of
        the host IPv4 address or a hash of an address can suffice, but
        alternative methodologies for assignment and potential collision
        resolution of node identifiers within a multicast session SHOULD be
        considered. For example, the techniques for managing the 32-bit
        "synchronization source" (SSRC) identifiers defined in the Real-Time
        Protocol (RTP) specification <a class='info' href='#RFC3550'>[RFC3550]<span> (</span><span class='info'>Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;RTP: A Transport Protocol for Real-Time Applications,&rdquo; July&nbsp;2003.</span><span>)</span></a> are
        applicable for use with NORM node identifiers. In most deployments of
        the NORM protocol to date, the <em>NormNodeId</em>
        assignments are administratively configured.
</p>
<p><strong>NORM Header Extensions</strong>
</p>
<p>When header extensions are applied, they follow the message type's
        base header and precede any payload portion. There are two formats for
        header extensions, both of which begin with an 8-bit "het" (header
        extension type) field. One format is provided for variable-length
        extensions with "het" values in the range from 0 through 127. The
        other format is for fixed length (one 32-bit word) extensions with
        "het" values in the range from 128 through 255.
</p>
<p>For variable-length extensions, the value of the "hel" field is the
        length of the entire header extension, expressed in multiples of
        32-bit words. The "hel" field MUST be present for variable-length
        extensions ("het" between 0 and 127) and MUST NOT be present for
        fixed-length extensions ("het" between 128 and 255).
</p>
<p>The formats of the variable-length and fixed-length header
        extensions are given, respectively, here:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   het &lt;=127   |      hel      |                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               |
|                    Header Extension Content                   |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM Variable Length Header Extension Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />
<br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   het &gt;=128   |    reserved   |    Header Extension Content   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM Fixed Length (32-bit) Header Extension Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The "Header Extension Content" portion of the header extension is
        defined for each extension type. Some header extensions are defined
        within this document for NORM baseline FEC and congestion control
        operations.
</p>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Sender Messages</h3>

<p>NORM sender messages include the <tt>NORM_DATA</tt>
        type, the <tt>NORM_INFO</tt> type, and the <tt>NORM_CMD</tt> type. <tt>NORM_DATA</tt>
        and <tt>NORM_INFO</tt> messages contain application
        data content while <tt>NORM_CMD</tt> messages are
        used for various protocol control functions.
</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
NORM_DATA Message</h3>

<p>The <tt>NORM_DATA</tt> message is generally
          the predominant type transmitted by NORM senders. These messages are
          used to encapsulate segmented data content for objects of type
          <tt>NORM_OBJECT_DATA</tt>, <tt>NORM_OBJECT_FILE</tt>,
          and <tt>NORM_OBJECT_STREAM</tt>. <tt>NORM_DATA</tt> messages contain original or
          FEC-encoded application data content.
</p>
<p>The format of <tt>NORM_DATA</tt> messages is
          comprised of three logical portions: 1) a fixed-format <tt>NORM_DATA</tt> header portion, 2) a FEC Payload ID
          portion with a format dependent upon the FEC encoding used, and 3) a
          payload portion containing source or encoded application data
          content. Note for objects of type <tt>NORM_OBJECT_STREAM</tt>,
          the payload portion contains additional fields used to appropriately
          recover stream content. NORM implementations MAY also extend the
          <tt>NORM_DATA</tt> header to include a FEC Object
          Transmission Information (EXT_FTI) header extension. This allows
          NORM receivers to automatically allocate resources and properly
          perform FEC decoding without the need for pre-configuration or
          out-of-band information.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=2|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     flags     |    fec_id     |     object_transport_id       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         fec_payload_id                        |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                header_extensions (if applicable)              |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          payload_len*         |       payload_msg_start*      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        payload_offset*                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          payload_data*                        |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_DATA Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>*IMPORTANT NOTE: The "payload_len", "payload_msg_start" and
          "payload_offset" fields are present <em>only</em>
          for objects of type <tt>NORM_OBJECT_STREAM</tt>.
          These fields, as with the entire payload, are subject to any FEC
          encoding used. Thus, when systematic FEC codes are used, these
          values can be directly interpreted only for packets containing
          source symbols while packets containing FEC parity content need
          decoding before these fields can be interpreted.
</p>
<p>The "version", "type", "hdr_len", "sequence", and "source_id"
          fields form the NORM Common Message Header as described in <a class='info' href='#CommonHeader'>Section&nbsp;4.1<span> (</span><span class='info'>NORM Common Message Header and Extensions</span><span>)</span></a>. The value of the <tt>NORM_DATA</tt>
          "type" field is 2. The <tt>NORM_DATA</tt> base
          "hdr_len" value is 4 (i.e. 4 32-bit words) plus the size of the
          "fec_payload_id" field. The "fec_payload_id" field size depends upon
          the FEC encoding type referenced by the "fec_id" field. For example,
          when small block, systematic codes are used, a "fec_id" value of 129
          is indicated and the size of the "fec_payload_id" is two 32-bit
          words. In this case the <tt>NORM_DATA</tt> base
          "hdr_len" value is 6. The cumulative size of any header extensions
          applied is added into the "hdr_len" field.
</p>
<p>The "instance_id" field contains a value generated by the sender
          to uniquely identify its current instance of participation in the
          <em>NormSession</em>. This allows receivers to
          detect when senders have perhaps left and rejoined a session in
          progress. When a sender (identified by its "source_id") is detected
          to have a new "instance_id", the NORM receivers SHOULD drop their
          previous state on the sender and begin reception anew, or at least
          treat this "instance" as a new, separate sender.
</p>
<p>The "grtt" field contains a non-linear quantized representation
          of the sender's current estimate of group round-trip time (<tt>GRTT_sender</tt>) (this is also referred to as
          <tt>R_max</tt> in <a class='info' href='#TfmccPaper'>[TfmccPaper]<span> (</span><span class='info'>Widmer, J. and M. Handley, &ldquo;Extending Equation-Based Congestion Control to Multicast           Applications,&rdquo; August&nbsp;2001.</span><span>)</span></a>). This value is used to control timing
          of the NACK repair process and other aspects of protocol operation
          as described in this document. Normally, the advertised "grtt" value
          will correspond to what the sender has measured based on feedback
          from the group, but, at low transmission rates, the advertised
          "grtt" SHALL be set to <tt>MAX(grttMeasured, NormSegmentSize/senderRate)</tt>
          where the <tt>NormSegmentSize</tt> is sender's
          segment size in bytes and the <tt>senderRate</tt>
          is the sender's current transmission rate in bytes per second. The
          algorithm for encoding and decoding this field is described in the
          <a class='info' href='#RFC5401'>Multicast NACK Building Block<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5401].
</p>
<p>The "backoff" field value is used by receivers to determine the
          maximum backoff timer value used in the timer-based NORM NACK
          feedback suppression. This 4-bit field supports values from 0-15
          that is multiplied by <tt>GRTT_sender</tt> to
          determine the maximum backoff timeout. The "backoff" field informs
          the receivers of the sender's backoff factor parameter (<tt>K_sender</tt>). Recommended values and their use are
          described in the NORM receiver NACK procedure description in <a class='info' href='#NackProcedure'>Section&nbsp;5.3<span> (</span><span class='info'>Receiver NACK Procedure</span><span>)</span></a>.
</p>
<p>The "gsize" field contains a representation of the sender's
          current estimate of group size (<tt>GSIZE_sender</tt>).
          This 4-bit field can roughly represent values from ten to 500
          million where the most significant bit value of 0 or 1 represents a
          mantissa of 1 or 5, respectively and the three least significant
          bits incremented by one represent a base 10 exponent (order of
          magnitude). For examples, a field value of "0x0" represents 1.0e+01
          (10), a value of "0x8" represents 5.0e+01 (50), a value of "0x1"
          represents 1.0e+02 (100), and a value of "0xf" represents 5.0e+08.
          For NORM feedback suppression purposes, the group size does not need
          to be represented with a high degree of precision. The group size
          MAY even be estimated somewhat conservatively (i.e., overestimated)
          to maintain low levels of feedback traffic. A default group size
          estimate of 10,000 ("gsize" = 0x3) is RECOMMENDED for general
          purpose reliable multicast applications using the NORM protocol.
</p>
<p>The "flags" field contains a number of different binary flags
          providing information and hints for the receiver to appropriately
          handle the identified object. Defined flags in this field
          include:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left" width="30%"><col align="center" width="10%"><col align="left" width="60%">
<tr><th align="left">Flag</th><th align="center">Value</th><th align="left">Purpose</th></tr>
<tr>
<td align="left"><tt>NORM_FLAG_REPAIR</tt>&nbsp;</td>
<td align="center">0x01</td>
<td align="left">Indicates message is a repair transmission</td>
</tr>
<tr>
<td align="left"><tt>NORM_FLAG_EXPLICIT</tt>&nbsp;</td>
<td align="center">0x02</td>
<td align="left">Indicates a repair segment intended to meet a specific receiver
            erasure, as compared to parity segments provided by the sender for
            general purpose (with respect to an FEC coding block) erasure
            filling.</td>
</tr>
<tr>
<td align="left"><tt>NORM_FLAG_INFO</tt>&nbsp;</td>
<td align="center">0x04</td>
<td align="left">Indicates availability of <tt>NORM_INFO</tt>
            for object.</td>
</tr>
<tr>
<td align="left"><tt>NORM_FLAG_UNRELIABLE</tt>&nbsp;</td>
<td align="center">0x08</td>
<td align="left">Indicates that repair transmissions for the specified object
            will be unavailable (One-shot, best effort transmission).</td>
</tr>
<tr>
<td align="left"><tt>NORM_FLAG_FILE</tt>&nbsp;</td>
<td align="center">0x10</td>
<td align="left">Indicates object is file-based data (hint to use disk storage
            for reception).</td>
</tr>
<tr>
<td align="left"><tt>NORM_FLAG_STREAM</tt>&nbsp;</td>
<td align="center">0x20</td>
<td align="left">Indicates object is of type <tt>NORM_OBJECT_STREAM</tt>.</td>
</tr>
</table>
<br clear="all" />

<p><tt>NORM_FLAG_REPAIR</tt> is set when the
          associated message is a repair transmission. This information can be
          used by receivers to help observe a join policy where it is desired
          that newly joining receivers only begin participating in the NACK
          process upon receipt of new (non-repair) data content. <tt>NORM_FLAG_EXPLICIT</tt> is used to mark repair
          messages sent when the data sender has exhausted its ability to
          provide "fresh" (not previously transmitted) parity segments as
          repair. This flag could possibly be used by intermediate systems
          implementing functionality to control sub-casting of repair content
          to different legs of a reliable multicast topology with disparate
          repair needs. <tt>NORM_FLAG_INFO</tt> is set only
          when OPTIONAL <tt>NORM_INFO</tt> content is
          actually available for the associated object. Thus, receivers will
          NACK for retransmission of <tt>NORM_INFO</tt>
          only when it is available for a given object. <tt>NORM_FLAG_UNRELIABLE</tt>
          is set when the sender wishes to transmit an object with only "best
          effort" delivery and will not supply repair transmissions for the
          object. NORM receivers SHOULD NOT execute repair requests for
          objects marked with the <tt>NORM_FLAG_UNRELIABLE</tt>
          flag. There are cases where receivers can inadvertently request
          repair of such objects when all segments (or info content) for those
          objects are not received (i.e., a gap in the "object_transport_id"
          sequence is noted). In this case, the sender SHALL invoke the <tt>NORM_CMD(SQUELCH)</tt> process as described in <a class='info' href='#NORM_CMD'>Section&nbsp;4.2.3<span> (</span><span class='info'>NORM_CMD Messages</span><span>)</span></a>.
</p>
<p><tt>NORM_FLAG_FILE</tt> can be set as a hint
          from the sender that the associated object SHOULD be stored in
          non-volatile storage. <tt>NORM_FLAG_STREAM</tt>
          is set when the identified object is of type <tt>NORM_OBJECT_STREAM</tt>.
          The presence of <tt>NORM_FLAG_STREAM</tt>
          overrides that of <tt>NORM_FLAG_FILE</tt> with
          respect to interpretation of object size and the format of <tt>NORM_DATA</tt> messages.
</p>
<p>The "fec_id" field corresponds to the FEC Encoding Identifier
          described in the FEC Building Block document <a class='info' href='#RFC5052'>[RFC5052]<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a>. The "fec_id" value implies the format of
          the "fec_payload_id" field and, coupled with FEC Object Transmission
          Information, the procedures to decode FEC encoded content. Small
          block, systematic codes ("fec_id" = 129) are expected to be used for
          most NORM purposes and systematic FEC codes are RECOMMENDED for most
          efficient performance of <tt>NORM_OBJECT_STREAM</tt>
          transport.
</p>
<p>The "object_transport_id" field is a monotonically and
          incrementally increasing value assigned by the sender to <em>NormObjects</em> being transmitted. Transmissions
          and repair requests related to that object use the same
          "object_transport_id" value. For sessions of very long or indefinite
          duration, the "object_transport_id" field will wrap and be repeated,
          but it is presumed that the 16-bit field size provides a sufficient
          sequence space to avoid object confusion amongst receivers and
          sources (i.e., receivers SHOULD re-synchronize with a server when
          receiving object sequence identifiers sufficiently out-of-range with
          the current state kept for a given source). During the course of its
          transmission within a NORM session, an object is uniquely identified
          by the concatenation of the sender "source_id" and the given
          "object_transport_id". Note that <tt>NORM_INFO</tt>
          messages associated with the identified object carry the same
          "object_transport_id" value.
</p>
<p>The "fec_payload_id" identifies the attached <tt>NORM_DATA</tt>
          "payload" content. The size and format of the "fec_payload_id" field
          depends upon the FEC type indicated by the "fec_id" field. These
          formats are given in the descriptions of specific FEC schemes such
          as those described in the <a class='info' href='#RFC5445'>FEC Basic
          Schemes<span> (</span><span class='info'>Watson, M., &ldquo;Basic Forward Error Correction (FEC) Schemes,&rdquo; March&nbsp;2009.</span><span>)</span></a> [RFC5445] specification or in other FEC Schemes. As an example,
          the format of the "fec_payload_id" format for Small Block,
          Systematic codes ("fec_id" = 129) from the<a class='info' href='#RFC5445'>FEC Basic Schemes<span> (</span><span class='info'>Watson, M., &ldquo;Basic Forward Error Correction (FEC) Schemes,&rdquo; March&nbsp;2009.</span><span>)</span></a> [RFC5445] specification is given here:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       source_block_number                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|        source_block_len       |      encoding_symbol_id       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Example: FEC Payload Id Format for 'fec_id' = 129&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In this example FEC payload identifier, the
          "source_block_number", "source_block_len", and "encoding_symbol_id"
          fields correspond to the "Source Block Number", "Source Block
          Length, and "Encoding Symbol ID" fields of the FEC Payload ID format
          for Small Block Systematic FEC Schemes identified by a "fec_id"
          value of 129 as specified by the <a class='info' href='#RFC5445'>FEC Basic
          Schemes<span> (</span><span class='info'>Watson, M., &ldquo;Basic Forward Error Correction (FEC) Schemes,&rdquo; March&nbsp;2009.</span><span>)</span></a> [RFC5445] specification. The "source_block_number" identifies
          the coding block's relative position with a <em>NormObject</em>.
          Note that, for <em>NormObjects</em> of type
          <tt>NORM_OBJECT_STREAM</tt>, the
          "source_block_number" will wrap for very long lived sessions. The
          "source_block_len" indicates the number of user data segments in the
          identified coding block. Given the "source_block_len" information of
          how many symbols of application data are contained in the block, the
          receiver can determine whether the attached segment is data or
          parity content and treat it appropriately. Applications MAY
          dynamically "shorten" code blocks when the pending information
          content is not predictable (e.g. real-time message streams). In that
          case, the "source_block_len" value given for an "encoding_symbol_id"
          that contains FEC parity content SHALL take precedence over the
          "source_block_len" value provided for any packets containing source
          symbols. Also, the "source_block_len" value given for an ordinally
          higher "encoding_symbol_id" SHALL take precedence over the
          "source_block_len" given for prior encoding symbols. The reason for
          this is that the sender will only know the maximum source block
          length at the time is transmitting source symbols, but then
          subsequently "shorten" the code and then provide that last source
          symbol and/or encoding symbols with FEC parity content. The
          "encoding_symbol_id" identifies which specific symbol (segment)
          within the coding block the attached payload conveys. Depending upon
          the value of the "encoding_symbol_id" and the associated
          "source_block_len" parameters for the block, the symbol (segment)
          referenced will be a user data or an FEC parity segment. For
          systematic codes, encoding symbols numbered less than the <tt>source_block_len</tt> contain original application
          data while segments greater than or equal to <tt>source_block_len</tt>
          contain parity symbols calculated for the block. The concatenation
          of <tt>object_transport_id::fec_payload_id</tt>
          can be viewed as a unique transport protocol data unit identifier
          for the attached segment with respect to the NORM sender's instance
          within a session.
</p>
<p>Additional FEC Object Transmission Information (FTI) (as
          described in the <a class='info' href='#RFC5052'>FEC Building Block<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052])
          is needed to properly receive and decode NORM transport objects.
          This information MAY be provided as out-of-band session information.
          In some cases, it will be useful for the sender to include this
          information "in-band" to facilitate receiver operation with minimal
          pre-configuration. For this purpose, the NORM FEC Object
          Transmission Information Header Extension (EXT_FTI) is defined. This
          header extension MAY be applied to <tt>NORM_DATA</tt>
          and <tt>NORM_INFO</tt> messages to provide this
          necessary information. The format of the EXT_FTI consists of two
          parts, a general part that contains the size of the associated
          transport object and a portion that depends upon the FEC scheme
          being used. The "fec_id" field in <tt>NORM_DATA</tt>
          and <tt>NORM_INFO</tt> messages identifies the
          FEC scheme. The format of the EXT_FTI general part is given
          here.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    het = 64   |    hel = 4    |       object_size (msb)       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       object_size (lsb)                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  FEC Scheme specific content ...              |</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;EXT_FTI Header Extension General Portion Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The header extension type "het" field value for the EXT_FTI
          header extension is 64. The header extension length "hel" value
          depends upon the format of the FTI for encoding type identified by
          the "fec_id" field.
</p>
<p>The 48-bit "object_size" field indicates the total length of the
          object (in bytes) for the static object types of <tt>NORM_OBJECT_FILE</tt> and <tt>NORM_OBJECT_DATA</tt>.
          This information is used by receivers to determine storage
          requirements and/or allocate storage for the received object.
          Receivers with insufficient storage capability might wish to forego
          reliable reception (i.e., not NACK for) of the indicated object. In
          the case of objects of type <tt>NORM_OBJECT_STREAM</tt>,
          the "object_size" field is used by the sender to advertise the size
          of its stream buffer to the receiver group. In turn, the receivers
          SHOULD use this information to allocate a stream buffer for
          reception of corresponding size.
</p>
<p>As noted, the format of the extension depends upon the FEC code
          in use, but in general it contains any necessary details on the code
          in use (e.g., FEC Instance ID, etc.). As an example, the format of
          the EXT_FTI for small block systematic codes ("fec_id" = 129) is
          given here:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    het = 64   |    hel = 4    |       object_size (msb)       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       object_size (lsb)                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       fec_instance_id         |          segment_size         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       fec_max_block_len       |         fec_num_parity        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Example: EXT_FTI Header Extension Format for 'fec_id' = 129&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In this example (for "fec_id" = 129), the "hel" field value is 4.
          The size of the EXT_FTI header extension will possibly be different
          for other FEC schemes.
</p>
<p>The 48-bit "object_size" serves the purpose described
          previously.
</p>
<p>The "fec_instance_id" corresponds to the "FEC Instance ID"
          described in the <a class='info' href='#RFC5052'>FEC Building Block<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052].
          In this case, the "fec_instance_id" is a value corresponding to the
          particular type of Small Block Systematic Code being used (e.g.,
          Reed-Solomon GF(2^8), Reed-Solomon GF(2^16), etc). The standardized
          assignment of FEC Instance ID values is described in <a class='info' href='#RFC5052'>RFC 5052<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a>.
</p>
<p>The "segment_size" field indicates the sender's current setting
          for maximum message payload content (in bytes). This allows
          receivers to allocate appropriate buffering resources and to
          determine other information in order to properly process received
          data messaging. Typically, FEC parity symbol segments will be of
          this size.
</p>
<p>The "fec_max_block_len" indicates the current maximum number of
          user data segments per FEC coding block to be used by the sender
          during the session. This allows receivers to allocate appropriate
          buffer space for buffering blocks transmitted by the sender.
</p>
<p>The "fec_num_parity" corresponds to the "maximum number of
          encoding symbols that can be generated for any source block" as
          described in for FEC Object Transmission Information for Small Block
          Systematic Codes in the <a class='info' href='#RFC5052'>FEC Building
          Block<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052]. For example, Reed-Solomon codes can be arbitrarily
          shortened to create different code variations for a given block
          length. In the case of Reed-Solomon (GF(2^8) and GF(2^16)) codes,
          this value indicates the maximum number of parity segments available
          from the sender for the coding blocks. This field MAY be interpreted
          differently for other systematic codes as they are defined.
</p>
<p>The payload portion of <tt>NORM_DATA</tt>
          messages includes source data or FEC encoded application content.
          The content of this payload depends upon the FEC scheme being
          employed, and support for streaming using the <tt>NORM_OBJECT_STREAM</tt>
          type, when applicable, necessitates some additional content in the
          payload.
</p>
<p>The "payload_len", "payload_msg_start", and "payload_offset"
          fields are present <em>only</em> for transport
          objects of type <tt>NORM_OBJECT_STREAM</tt>.
          These REQUIRED fields allow senders to arbitrarily vary the size of
          <tt>NORM_DATA</tt> payload segments for streams.
          This allows applications to flush transmitted streams as needed to
          meet unique streaming requirements. For objects of types <tt>NORM_OBJECT_FILE</tt> and <tt>NORM_OBJECT_DATA</tt>,
          these fields are unnecessary since the receiver can calculate the
          payload length and offset information from the "fec_payload_id"
          using the REQUIRED block partitioning algorithm described in the
          <a class='info' href='#RFC5052'>FEC Building Block<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052]. When systematic
          FEC codes (e.g., "fec_id" = 129) are used, the "payload_len",
          "payload_msg_start", and "payload_offset" fields contain actual
          payload_data length, message start index (or stream control code),
          and byte offset values for the associated application stream data
          segment (the remainder of the "payload_data" field content) for
          those <tt>NORM_DATA</tt> messages containing
          source data symbols. In <tt>NORM_DATA</tt>
          messages that contain FEC parity content, these fields do not
          contain values that can be directly interpreted, but instead are
          values computed from FEC encoding the "payload_len",
          "payload_msg_start", and "payload_offset" fields for the source data
          segments of the corresponding coding block. The actual
          "payload_msg_start", "payload_len" and "payload_offset" values of
          missing data content can be determined upon decoding a FEC coding
          block. Note that these fields do NOT contribute to the value of the
          <tt>NORM_DATA</tt> "hdr_len" field. These fields
          are present only when the "flags" portion of the <tt>NORM_DATA</tt> message indicate the transport object
          is of type <tt>NORM_OBJECT_STREAM</tt>.
</p>
<p>The "payload_len" value, when non-zero, indicates the length (in
          bytes) of the source content contained in the associated
          "payload_data" field. However, when the "payload_len" value is equal
          to <tt>ZERO</tt>, this indicates that the
          "payload_msg_start" field be alternatively interpreted as a
          "stream_control_code". The only "stream_control_code" value defined
          is <tt>NORM_STREAM_END = 0</tt>. The <tt>NORM_STREAM_END</tt> code indicates that the sender
          is terminating transmission of stream content at the corresponding
          position in the stream and the receiver MUST NOT expect content (or
          request repair for any content) following that position in the
          stream. Additional specifications MAY extend the functionality of
          the NORM stream transport mode by defining additional stream control
          codes. These control codes are delivered to the recipient
          application reliably, in-order with respect to the streamed
          application data content.
</p>
<p>The "payload_msg_start" field serves one of two exclusive
          purposes. When the "payload_len" value is non-zero, the
          "payload_msg_start" field, when also set to a non-zero value,
          indicates that the associated "payload_data" content contains an
          application-defined message boundary (start-of-message). When such a
          message boundary is indicated, the first byte of an
          application-defined message, with respect to the "payload_data"
          field, will be found at an offset of "payload_msg_start - 1" bytes.
          Thus, if a <tt>NORM_DATA</tt> payload for a
          <tt>NORM_OBJECT_STREAM</tt> contains the start of
          an application message at the first byte of the "payload_data"
          field, the value of the "payload_msg_start" field will be '1'. NORM
          implementations SHOULD provide sender stream applications with a
          capability to mark message boundaries in this manner. Similarly, the
          NORM receiver implementation SHOULD enable the application to
          recover such message boundary information. This enables NORM
          receivers to "synchronize" reliable reception of transmitted message
          stream content in a meaningful way (i.e., meaningful to the
          application) at any time, whether joining a session already in
          progress, or departing the session and returning. Note that if the
          value of the "payload_msg_start" field is <tt>ZERO</tt>,
          no message boundary is present. The "payload_msg_start" value will
          always be less than or equal to the "payload_len" value except for
          the special case of "payload_len = 0", that indicates the
          "payload_msg_start" field be instead interpreted as a
          "stream_control_code"
</p>
<p>The "payload_offset" field indicates the relative byte position
          (from the sender stream transmission start) of the source content
          contained in the "payload_data" field. Note that for long-lived
          streams, the "payload_offset" field will wrap.
</p>
<p>The "payload_data" field contains the original application source
          or parity content for the symbol identified by the "fec_payload_id".
          The length of this field SHALL be limited to a maximum of the
          sender's <em>NormSegmentSize</em> bytes as given
          in the FTI for the object. Note the length of this field for
          messages containing parity content will always be of length <em>NormSegmentSize</em>. When encoding data segments of
          varying sizes, the FEC encoder SHALL assume <tt>ZERO</tt>
          value padding for data segments with length less than the <em>NormSegmentSize</em>. It is RECOMMENDED that a
          sender's <em>NormSegmentSize</em> generally be
          constant for the duration of a given sender's term of participation
          in the session, but can possibly vary on a per-object basis. The
          <em>NormSegmentSize</em> SHOULD be configurable
          by the sender application prior to session participation as needed
          for network topology MTU considerations. For IPv6, MTU discovery MAY
          be possibly leveraged at session startup to perform this
          configuration. The "payload_data" content MAY be delivered directly
          to the application for source symbols (when systematic FEC encoding
          is used) or upon decoding of the FEC block. For <tt>NORM_OBJECT_FILE</tt>
          and <tt>NORM_OBJECT_STREAM</tt> objects, the data
          segment length and offset can be calculated using the block
          partitioning algorithm described in the <a class='info' href='#RFC5052'>FEC
          Building Block<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052]. For <tt>NORM_OBJECT_STREAM</tt>
          objects, the length and offset is obtained from the segment's
          corresponding embedded "payload_len" and "payload_offset"
          fields.
</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.2"></a><h3>4.2.2.&nbsp;
NORM_INFO Message</h3>

<p>The <tt>NORM_INFO</tt> message is used to
          convey OPTIONAL, application-defined, out-of-band context
          information for transmitted <em>NormObjects</em>.
          An example <tt>NORM_INFO</tt> use for bulk file
          transfer is to place MIME type information for the associated file,
          data, or stream object into the <tt>NORM_INFO</tt>
          payload. Receivers could then use the <tt>NORM_INFO</tt>
          content to make a decision as whether to participate in reliable
          reception of the associated object. Each <em>NormObject</em>
          can have an independent unit of <tt>NORM_INFO</tt>
          associated with it. <tt>NORM_DATA</tt> messages
          contain a flag to indicate the availability of <tt>NORM_INFO</tt>
          for a given <em>NormObject</em>. NORM receivers
          will NACK for retransmission of <tt>NORM_INFO</tt>
          when they have not received it for a given <em>NormObject</em>.
          The size of the <tt>NORM_INFO</tt> content is
          limited to that of a single <em>NormSegmentSize</em>
          for the given sender. This atomic nature allows the <tt>NORM_INFO</tt> to be rapidly and efficiently
          repaired within the NORM reliable transmission process.
</p>
<p>When <tt>NORM_INFO</tt> content is available
          for a <em>NormObject</em>, the NORM_FLAG_INFO
          flag SHALL be set in <tt>NORM_DATA</tt> messages
          for the corresponding "object_transport_id" and the <tt>NORM_INFO</tt> message SHALL be transmitted as the
          first message for the <em>NormObject</em>.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=1|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     flags     |     fec_id    |     object_transport_id       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                header_extensions (if applicable)              |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         payload_data                          |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_INFO Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The "version", "type", "hdr_len", "sequence", and "source_id"
          fields form the NORM Common Message Header as described in <a class='info' href='#CommonHeader'>Section&nbsp;4.1<span> (</span><span class='info'>NORM Common Message Header and Extensions</span><span>)</span></a>. The value of "hdr_len" field when no
          header extensions are present is 4.
</p>
<p>The "instance_id", "grtt", "backoff", "gsize", "flags", "fec_id",
          and "object_transport_id" fields carry the same information and
          serve the same purpose as with <tt>NORM_DATA</tt>
          messages. These values allow the receiver to prepare appropriate
          buffering, etc, for further transmissions from the sender when
          <tt>NORM_INFO</tt> is the first message
          received.
</p>
<p>As with <tt>NORM_DATA</tt> messages, the NORM
          FTI Header Extension (EXT_FTI) MAY be optionally applied to <tt>NORM_INFO</tt> messages. To conserve protocol
          overhead, NORM implementations MAY apply the EXT_FTI when used to
          <tt>NORM_INFO</tt> messages only and not to
          <tt>NORM_DATA</tt> messages.
</p>
<p>The <tt>NORM_INFO</tt> "payload_data" field
          contains sender application-defined content that can be used by
          receiver applications for various purposes as described above.
</p>
<a name="NORM_CMD"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3"></a><h3>4.2.3.&nbsp;
NORM_CMD Messages</h3>

<p><tt>NORM_CMD</tt> messages are transmitted by
          senders to perform a number of different protocol functions. This
          includes functions such as round-trip timing collection, congestion
          control functions, synchronization of sender/receiver repair
          "windows", and notification of sender status. A core set of <tt>NORM_CMD</tt> messages is enumerated. Additionally,
          a range of command types remain available for potential
          application-specific use. Some <tt>NORM_CMD</tt>
          types can have dynamic content attached. Any attached content will
          be limited to maximum length of the sender <em>NormSegmentSize</em>
          to retain the atomic nature of commands. All <tt>NORM_CMD</tt>
          messages begin with a common set of fields, after the usual NORM
          message common header. The standard <tt>NORM_CMD</tt>
          fields are:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    sub-type   |                                               |
+-+-+-+-+-+-+-+-+        NORM_CMD Content                       +
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_CMD Standard Fields&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The "version", "type", "hdr_len", "sequence", and "source_id"
          fields form the NORM Common Message Header as described in <a class='info' href='#CommonHeader'>Section&nbsp;4.1<span> (</span><span class='info'>NORM Common Message Header and Extensions</span><span>)</span></a>. The value of the "hdr_len" field for
          <tt>NORM_CMD</tt> messages without header
          extensions present depends upon the "sub-type" field.
</p>
<p>The "instance_id", "grtt", "backoff", and "gsize" fields provide
          the same information and serve the same purpose as with <tt>NORM_DATA</tt> and <tt>NORM_INFO</tt>
          messages. The "sub-type" field indicates the type of command to
          follow. The remainder of the <tt>NORM_CMD</tt>
          message is dependent upon the command sub-type. NORM command
          sub-types include:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left" width="30%"><col align="center" width="10%"><col align="left" width="60%">
<tr><th align="left">Command</th><th align="center">Sub-type</th><th align="left">Purpose</th></tr>
<tr>
<td align="left"><tt>NORM_CMD(FLUSH)</tt>&nbsp;</td>
<td align="center">1</td>
<td align="left">Used to indicate sender temporary end-of-transmission. (Assists
            in robustly initiating outstanding repair requests from
            receivers). May also be optionally used to collect positive
            acknowledgment of reliable reception from subset of receivers.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(EOT)</tt>&nbsp;</td>
<td align="center">2</td>
<td align="left">Used to indicate sender permanent end-of-transmission.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(SQUELCH)</tt>&nbsp;</td>
<td align="center">3</td>
<td align="left">Used to advertise sender's current repair window in response to
            out-of-range NACKs from receivers.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(CC)</tt>&nbsp;</td>
<td align="center">4</td>
<td align="left">Used for GRTT measurement and collection of congestion control
            feedback.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(REPAIR_ADV)</tt>&nbsp;</td>
<td align="center">5</td>
<td align="left">Used to advertise sender's aggregated repair/feedback state for
            suppression of unicast feedback from receivers.</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(ACK_REQ)</tt>&nbsp;</td>
<td align="center">6</td>
<td align="left">Used to request application-defined positive acknowledgment
            from a list of receivers (OPTIONAL).</td>
</tr>
<tr>
<td align="left"><tt>NORM_CMD(APPLICATION)</tt>&nbsp;</td>
<td align="center">7</td>
<td align="left">Used for application-defined purposes that need to temporarily
            preempt or supplement data transmission (OPTIONAL).</td>
</tr>
</table>
<br clear="all" />

<a name="anchor14"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3.1"></a><h3>4.2.3.1.&nbsp;
NORM_CMD(FLUSH) Message</h3>

<p>The <tt>NORM_CMD(FLUSH)</tt> command is sent
            when the sender reaches the end of all data content and pending
            repairs it has queued for transmission. This can indicate either a
            temporary or permanent end of data transmission, but the sender is
            still willing to respond to repair requests. This command is
            repeated once per <tt>2*GRTT_sender</tt> to
            excite the receiver set for any outstanding repair requests up to
            and including the transmission point indicated within the <tt>NORM_CMD(FLUSH)</tt> message. The number of
            repeats is equal to <tt>NORM_ROBUST_FACTOR</tt>
            unless a list of receivers from which explicit positive
            acknowledgment is expected ("acking_node_list") is given. In that
            case, the "acking_node_list" is updated as acknowledgments are
            received and the <tt>NORM_CMD(FLUSH)</tt> is
            repeated according to the mechanism described in <a class='info' href='#PositiveAcknowledgment'>Section&nbsp;5.5.3<span> (</span><span class='info'>NORM Positive Acknowledgment Procedure</span><span>)</span></a>. The greater the <tt>NORM_ROBUST_FACTOR</tt>, the greater the
            probability that all applicable receivers will be excited for
            acknowledgment or repair requests (NACKs) AND that the
            corresponding NACKs are delivered to the sender. A default value
            of <tt>NORM_ROBUST_FACTOR</tt> equal to 20 is
            RECOMMENDED. If a <tt>NORM_NACK</tt> message
            interrupts the flush process, the sender SHALL re-initiate the
            flush process after any resulting repair transmissions are
            completed.
</p>
<p>Note that receivers also employ a timeout mechanism to
            self-initiate NACKing (if there are outstanding repair needs) when
            no messages of any type are received from a sender. This
            inactivity timeout is related to the <tt>NORM_CMD(FLUSH)</tt>
            and <tt>NORM_ROBUST_FACTOR</tt> and is
            specified in <a class='info' href='#NackProcedure'>Section&nbsp;5.3<span> (</span><span class='info'>Receiver NACK Procedure</span><span>)</span></a>. Receivers SHALL
            self-initiate the NACK repair process when the inactivity timeout
            has expired for a specific sender and the receiver has pending
            repairs needed from that sender. With a sufficiently large <tt>NORM_ROBUST_FACTOR</tt> value, data content is
            delivered with a high assurance of reliability. The penalty of a
            large <tt>NORM_ROBUST_FACTOR</tt> value is the
            potential transmission of excess <tt>NORM_CMD(FLUSH)</tt>
            messages and a longer inactivity timeout for receivers to
            self-initiate a terminal NACK process.
</p>
<p>For finite-size transport objects such as <tt>NORM_OBJECT_DATA</tt>
            and <tt>NORM_OBJECT_FILE</tt>, the flush
            process (if there are no further pending objects) occurs at the
            end of these objects. Thus, FEC repair information is always
            available for repairs in response to repair requests elicited by
            the flush command. However, for <tt>NORM_OBJECT_STREAM</tt>,
            the flush can occur at any time, including in the middle of an FEC
            coding block if systematic FEC codes are employed. In this case,
            the sender will not yet be able to provide FEC parity content for
            the concurrent coding block and will be limited to explicitly
            repairing the stream with source data content for that block.
            Applications that anticipate frequent flushing of stream content
            SHOULD be judicious in the selection of the FEC coding block size
            (i.e., do not use a very large coding block size if frequent
            flushing occurs). For example, a reliable multicast application
            transmitting an on-going series of intermittent, relatively small
            messages will need to trade-off using the <tt>NORM_OBJECT_DATA</tt>
            paradigm versus the <tt>NORM_OBJECT_STREAM</tt>
            paradigm with an appropriate FEC coding block size. This is
            analogous to application trade-offs for other transport protocols
            such as the selection of different TCP modes of operation such as
            "no delay", etc.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  sub-type = 1 |    fec_id     |      object_transport_id      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         fec_payload_id                        |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                acking_node_list (if applicable)               |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_CMD(FLUSH) Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The "version", "type", "hdr_len", "sequence", and "source_id"
            fields form the NORM Common Message Header as described in <a class='info' href='#CommonHeader'>Section&nbsp;4.1<span> (</span><span class='info'>NORM Common Message Header and Extensions</span><span>)</span></a>. In addition to the NORM common
            message header and standard <tt>NORM_CMD</tt>
            fields, the <tt>NORM_CMD(FLUSH)</tt> message
            contains fields to identify the current status and logical
            transmit position of the sender.
</p>
<p>The "fec_id" field indicates the FEC type used for the flushing
            "object_transport_id" and implies the size and format of the
            "fec_payload_id" field. Note the "hdr_len" value for the <tt>NORM_CMD(FLUSH)</tt> message is 4 plus the size of
            the "fec_payload_id" field when no header extensions are
            present.
</p>
<p>The "object_transport_id" and "fec_payload_id" fields indicate
            the sender's current logical "transmit position". These fields are
            interpreted in the same manner as in the <tt>NORM_DATA</tt>
            message type. Upon receipt of the <tt>NORM_CMD(FLUSH)</tt>,
            receivers are expected to check their completion state THROUGH
            (including) this transmission position. If receivers have
            outstanding repair needs in this range, they SHALL initiate the
            NORM NACK Repair Process as described in <a class='info' href='#NackProcedure'>Section&nbsp;5.3<span> (</span><span class='info'>Receiver NACK Procedure</span><span>)</span></a>. If receivers have no outstanding
            repair needs, no response to the <tt>NORM_CMD(FLUSH)</tt>
            is generated.
</p>
<p>For <tt>NORM_OBJECT_STREAM</tt> objects
            using systematic FEC codes, receivers MUST request "explicit-only"
            repair of the identified "source_block_number" if the given
            "encoding_symbol_id" is less than the "source_block_len". This
            condition indicates the sender has not yet completed encoding the
            corresponding FEC block and parity content is not yet available.
            An "explicit-only" repair request consists of NACK content for the
            applicable "source_block_number" that does not include any
            requests for parity-based repair. This allows NORM sender
            applications to "flush" an ongoing stream of transmission when
            needed, even if in the middle of an FEC block. Once the sender
            resumes stream transmission and passes the end of the pending
            coding block, subsequent NACKs from receivers SHALL request
            parity-based repair as usual. Note that the use of a systematic
            FEC code is assumed here. Note that a sender has the option of
            arbitrarily shortening a given code block when such an application
            "flush" occurs. In this case, the receiver will request explicit
            repair, but the sender MAY provide FEC-based repair (parity
            segments) in response. These parity segments MUST contain the
            corrected "source_block_len" for the shortened block and that
            "source_block_len" associated with segments containing parity
            content SHALL override the previously advertised
            "source_block_len". Similarly, the "source_block_len" associated
            with the highest ordinal "encoding_symbol_id" SHALL take
            precedence over prior symbols when a difference (e.g., due to code
            shortening at the sender) occurs. Normal receiver NACK initiation
            and construction is discussed in detail in <a class='info' href='#NackProcedure'>Section&nbsp;5.3<span> (</span><span class='info'>Receiver NACK Procedure</span><span>)</span></a>.
</p>
<p>The OPTIONAL "acking_node_list" field contains a list of <em>NormNodeIds</em> for receivers from which the
            sender is requesting explicit positive acknowledgment of reception
            up through the transmission point identified by the
            "object_transport_id" and "fec_payload_id" fields. The length of
            the list can be inferred from the length of the received <tt>NORM_CMD(FLUSH)</tt> message. When the
            "acking_node_list" is present, the lightweight positive
            acknowledgment process described in <a class='info' href='#PositiveAcknowledgment'>Section&nbsp;5.5.3<span> (</span><span class='info'>NORM Positive Acknowledgment Procedure</span><span>)</span></a> SHALL be observed.
</p>
<a name="anchor15"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3.2"></a><h3>4.2.3.2.&nbsp;
NORM_CMD(EOT) Message</h3>

<p>The <tt>NORM_CMD(EOT)</tt> command is sent
            when the sender reaches permanent end-of-transmission with respect
            to the <em>NormSession</em> and will not
            respond to further repair requests. This allows receivers to
            gracefully reach closure of operation with this sender (without
            requiring any timeout) and free any resources that are no longer
            needed. The <tt>NORM_CMD(EOT)</tt> command
            SHOULD be sent with the same robust mechanism as used for <tt>NORM_CMD(FLUSH)</tt> commands to provide a high
            assurance of reception by the receiver set.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  sub-type = 2 |                    reserved                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_CMD(EOT) Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The value of the "hdr_len" field for <tt>NORM_CMD(EOT)</tt>
            messages without header extensions present is 4. The "reserved"
            field is reserved for future use and MUST be set to an all <tt>ZERO</tt> value. Receivers MUST ignore the
            "reserved" field.
</p>
<a name="anchor16"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3.3"></a><h3>4.2.3.3.&nbsp;
NORM_CMD(SQUELCH) Message</h3>

<p>The <tt>NORM_CMD(SQUELCH)</tt> command is
            transmitted in response to outdated or invalid <tt>NORM_NACK</tt> content received by the sender.
            Invalid <tt>NORM_NACK</tt> content consists of
            repair requests for <em>NormObjects</em> for
            which the sender is unable or unwilling to provide repair. This
            includes repair requests for outdated objects, aborted objects, or
            those objects that the sender previously transmitted marked with
            the <tt>NORM_FLAG_UNRELIABLE</tt> flag. This
            command indicates to receivers what content is available for
            repair, thus serving as a description of the sender's current
            "repair window". Receivers SHALL NOT generate repair requests for
            content identified as invalid by a <tt>NORM_CMD(SQUELCH)</tt>.
</p>
<p>The <tt>NORM_CMD(SQUELCH)</tt> command is
            sent once per <tt>2*GRTT_sender</tt> at the
            most. The <tt>NORM_CMD(SQUELCH)</tt> advertises
            the current "repair window" of the sender by identifying the
            earliest (lowest) transmission point for which it will provide
            repair, along with an encoded list of objects from that point
            forward that are no longer valid for repair. This mechanism allows
            the sender application to cancel or abort transmission and/or
            repair of specific previously enqueued objects. The list also
            contains the identifiers for any objects within the repair window
            that were sent with the <tt>NORM_FLAG_UNRELIABLE</tt>
            flag set. In normal conditions, the <tt>NORM_CMD(SQUELCH)</tt>
            will be needed infrequently, and generally only to provide a
            reference repair window for receivers who have fallen
            "out-of-sync" with the sender due to extremely poor network
            conditions.
</p>
<p>The starting point of the invalid <em>NormObject</em>
            list begins with the lowest invalid <em>NormTransportId</em>
            greater than the current "repair window" start from the invalid
            NACK(s) that prompted the generation of the squelch. The length of
            the list is limited by the sender's <em>NormSegmentSize</em>.
            This allows the receivers to learn the status of the sender's
            applicable object repair window with minimal transmission of
            <tt>NORM_CMD(SQUELCH)</tt> commands. The format
            of the <tt>NORM_CMD(SQUELCH)</tt> message
            is:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| sub-type = 3  |     fec_id    |      object_transport_id      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         fec_payload_id                        |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        invalid_object_list                    |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_CMD(SQUELCH) Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>In addition to the NORM common message header and standard
            <tt>NORM_CMD</tt> fields, the <tt>NORM_CMD(SQUELCH)</tt> message contains fields to
            identify the earliest logical transmit position of the sender's
            current repair window and an "invalid_object_list" beginning with
            the index of the logically earliest invalid repair request from
            the offending NACK message that initiated the <tt>NORM_CMD(SQUELCH)</tt>
            transmission. The value of the "hdr_len" field when no extensions
            are present is 4 plus the size of the "fec_payload_id" field that
            is dependent upon the FEC scheme identified by the "fec_id"
            field.
</p>
<p>The "object_transport_id" and "fec_payload_id" fields are
            concatenated to indicate the beginning of the sender's current
            repair window (i.e., the logically earliest point in its
            transmission history for which the sender can provide repair). The
            "fec_id" field implies the size and format of the "fec_payload_id"
            field. This serves as an advertisement of a "synchronization"
            point for receivers to request repair. Note, that while an
            "encoding_symbol_id" MAY be included in the "fec_payload_id"
            field, the sender's repair window SHOULD be aligned on FEC coding
            block boundaries and thus the "encoding_symbol_id" SHOULD be
            zero.
</p>
<p>The "invalid_object_list" is a list of 16-bit <em>NormTransportIds</em> that, although they are
            within the range of the sender's current repair window, are no
            longer available for repair from the sender. For example, a sender
            application MAY dequeue an out-of-date object even though it is
            still within the repair window. The total size of the
            "invalid_object_list" content is can be determined from the
            packet's payload length and is limited to a maximum of the <em>NormSegmentSize</em> of the sender. Thus, for very
            large repair windows, it is possible that a single <tt>NORM_CMD(SQUELCH)</tt> message cannot include the
            entire set of invalid objects in the repair window. In this case,
            the sender SHALL ensure that the list begins with a <em>NormObjectId</em> that is greater than or equal to
            the lowest ordinal invalid <em>NormObjectId</em>
            from the NACK message(s) that prompted the <tt>NORM_CMD(SQUELCH)</tt>
            generation. The <em>NormObjectIds</em> in the
            "invalid_object_list" MUST be ordinally greater than the
            "object_transport_id" marking the beginning of the sender's repair
            window. This insures convergence of the squelch process, even if
            multiple invalid NACK/ squelch iterations are required. This
            explicit description of invalid content within the sender's
            current window allows the sender application (most notably for
            discrete object transport) to arbitrarily invalidate (i.e.,
            dequeue) portions of enqueued content (e.g., certain objects) for
            which it no longer wishes to provide reliable transport.
</p>
<a name="anchor17"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3.4"></a><h3>4.2.3.4.&nbsp;
NORM_CMD(CC) Message</h3>

<p>The <tt>NORM_CMD(CC)</tt> messages contains
            fields to enable sender-to-group GRTT measurement and to excite
            the group for congestion control feedback. A baseline NORM
            congestion control scheme (NORM-CC), based on the TCP-Friendly
            Multicast Congestion Control (TFMCC) scheme of <a class='info' href='#RFC4654'>RFC 4654<span> (</span><span class='info'>Widmer, J. and M. Handley, &ldquo;TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification,&rdquo; August&nbsp;2006.</span><span>)</span></a> is fully specified in <a class='info' href='#CongestionControl'>Section&nbsp;5.5.2<span> (</span><span class='info'>NORM Congestion Control Operation</span><span>)</span></a> of this document. The <tt>NORM_CMD(CC)</tt> message is usually transmitted
            as part of NORM-CC congestion control operation. A NORM header
            extension is defined below to be used with the <tt>NORM_CMD(CC)</tt> message to support NORM-CC
            operation. Different header extensions MAY be defined for the
            <tt>NORM_CMD(CC)</tt> (and/or other NORM
            messages as needed) to support alternative congestion control
            schemes in the future. If NORM is operated in a network where
            resources are explicitly dedicated to the NORM session and
            therefore congestion control operation is disabled, the <tt>NORM_CMD(CC)</tt> message is then used solely for
            GRTT measurement and MAY be sent less frequently than with
            congestion control operation.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |            sequence           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  sub-type = 4 |    reserved   |          cc_sequence          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                         send_time_sec                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        send_time_usec                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               header extensions (if applicable)               |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  cc_node_list (if applicable)                 |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_CMD(CC) Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The NORM common message header and standard <tt>NORM_CMD</tt> fields serve their usual purposes.
            The value of the "hdr_len" field when no header extensions are
            present is 6.
</p>
<p>The "reserved" field is for potential future use and MUST be
            set to <tt>ZERO</tt> in this version of the
            NORM protocol and its baseline NORM-CC congestion control scheme.
            It is possible for alternative congestion control schemes to use
            the <tt>NORM_CMD(CC)</tt> message defined here
            and leverage the "reserved" field for scheme-specific
            purposes.
</p>
<p>The "cc_sequence" field is a sequence number applied by the
            sender. For NORM-CC operation, it is used to provide functionality
            equivalent to the "feedback round number" (<tt>fb_nr</tt>)
            described in <a class='info' href='#RFC4654'>RFC 4654<span> (</span><span class='info'>Widmer, J. and M. Handley, &ldquo;TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification,&rdquo; August&nbsp;2006.</span><span>)</span></a>.
            The most recently received "cc_sequence" value is recorded by
            receivers and can be fed back to the sender in congestion control
            feedback generated by the receivers for that sender. The
            "cc_sequence" number can also be used in NORM implementations to
            assess how recently a receiver has received <tt>NORM_CMD(CC)</tt>
            probes from the sender. This can be useful instrumentation for
            complex or experimental multicast routing environments.
</p>
<p>The "send_time" field is a timestamp indicating the time that
            the <tt>NORM_CMD(CC)</tt> message was
            transmitted. This consists of a 64-bit field containing 32-bits
            with the time in seconds ("send_time_sec") and 32-bits with the
            time in microseconds ("send_time_usec") since some reference time
            the source maintains (usually 00:00:00, 1 January 1970). The byte
            ordering of the fields is "Big Endian" network order. Receivers
            use this timestamp adjusted by the amount of delay from the time
            they received the <tt>NORM_CMD(CC)</tt> message
            to the time of their response as the "grtt_response" portion of
            <tt>NORM_ACK</tt> and <tt>NORM_NACK</tt>
            messages generated. This allows the sender to evaluate round-trip
            times to different receivers for congestion control and other
            (e.g., GRTT determination) purposes.
</p>
<p>To facilitate the baseline NORM-CC scheme described in <a class='info' href='#CongestionControl'>Section&nbsp;5.5.2<span> (</span><span class='info'>NORM Congestion Control Operation</span><span>)</span></a>, a NORM-CC Rate header
            extension (EXT_RATE) is defined to inform the group of the
            sender's current transmission rate. This is used along with the
            loss detection "sequence" field of all NORM sender messages and
            the <tt>NORM_CMD(CC)</tt> GRTT collection
            process to support NORM-CC congestion control operation. The
            format of this header extension is as follows:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    het = 128  |    reserved   |           send_rate           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div>
<p>The "send_rate" field indicates the sender's current
            transmission rate in bytes per second. The 16-bit "send_rate"
            field consists of 12 bits of mantissa in the most significant
            portion and 4 bits of base 10 integer exponent (E) information in
            the least significant portion. The 12-bit mantissa portion of the
            field is scaled such that a base 10 mantissa (M) floating point
            value of 0.0 corresponds to 0 and a value of 10.0 corresponds to
            4096 in the upper 12 bits of the 16-bit "send_rate" field.
            Thus:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
send_rate = (((int)(M * 4096.0 / 10.0 + 0.5)) &lt;&lt; 4) | E;</pre></div>
<p>For example, to represent a transmission rate of 256kbps
            (3.2e+04 bytes per second), the lower 4 bits of the 16-bit field
            contain a value of 0x04 to represent the exponent (E) while the
            upper 12 bits contain a value of 0x51f (M) as determined from the
            equation given above:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>send_rate = (((int)((3.2 * 4096.0 / 10.0) + 0.5)) &lt;&lt; 4) | 4;
          = (0x51f &lt;&lt; 4) | 0x4
          = 0x51f4</pre></div>
<p>To decode the "send_rate" field, the following equation can be
            used:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>value = (send_rate &gt;&gt; 4) * (10/4096) * power(10, (send_rate &amp; x000f))</pre></div>
<p>Note the maximum transmission rate that can be represented by
            this scheme is approximately 9.99e+15 bytes per second.
</p>
<p>When this extension is present, a "cc_node_list" might be
            attached as the payload of the <tt>NORM_CMD(CC)</tt>
            message. The presence of this header extension also implies that
            NORM receivers MUST respond according to the procedures described
            in <a class='info' href='#CongestionControl'>Section&nbsp;5.5.2<span> (</span><span class='info'>NORM Congestion Control Operation</span><span>)</span></a>.
</p>
<p>The "cc_node_list" consists of a list of <em>NormNodeIds</em>
            and their associated congestion control status. This includes the
            current limiting receiver (CLR) node, any potential limiting
            receiver (PLR) nodes that have been identified, and some number of
            receivers for which congestion control status is being provided,
            most notably including the receivers' current RTT measurement. The
            maximum length of the "cc_node_list" provides for at least the CLR
            and one other receiver, but can be increased for more timely
            feedback to the group. The list length can be inferred from the
            length of the <tt>NORM_CMD(CC)</tt>
            message.
</p>
<p>Each item in the "cc_node_list" is in the following format:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          cc_node_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    cc_flags   |     cc_rtt    |            cc_rate            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div>
<p>The "cc_node_id" is the <em>NormNodeId</em>
            of the receiver the item represents.
</p>
<p>The "cc_flags" field contains flags indicating the congestion
            control status of the indicated receiver. The following flags are
            defined:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left" width="30%"><col align="center" width="10%"><col align="left" width="60%">
<tr><th align="left">Flag</th><th align="center">Value</th><th align="left">Purpose</th></tr>
<tr>
<td align="left"><tt>NORM_FLAG_CC_CLR</tt>&nbsp;</td>
<td align="center">0x01</td>
<td align="left">Receiver is the current limiting receiver (CLR).</td>
</tr>
<tr>
<td align="left"><tt>NORM_FLAG_CC_PLR</tt>&nbsp;</td>
<td align="center">0x02</td>
<td align="left">Receiver is a potential limiting receiver (PLR).</td>
</tr>
<tr>
<td align="left"><tt>NORM_FLAG_CC_RTT</tt>&nbsp;</td>
<td align="center">0x04</td>
<td align="left">Receiver has measured RTT with respect to sender.</td>
</tr>
<tr>
<td align="left"><tt>NORM_FLAG_CC_START</tt>&nbsp;</td>
<td align="center">0x08</td>
<td align="left">Sender/receiver is in "slow start" phase of congestion
              control operation (i.e., The receiver has not yet detected any
              packet loss and the "cc_rate" field is the receiver's actual
              measured receive rate).</td>
</tr>
<tr>
<td align="left"><tt>NORM_FLAG_CC_LEAVE</tt>&nbsp;</td>
<td align="center">0x10</td>
<td align="left">Receiver is imminently leaving the session and its feedback
              SHOULD not be considered in congestion control operation.</td>
</tr>
</table>
<br clear="all" />

<p>The "cc_rtt" contains a quantized representation of the RTT as
            measured by the sender with respect to the indicated receiver.
            This field is valid only if the <tt>NORM_FLAG_CC_RTT</tt>
            flag is set in the "cc_flags" field. This one byte field is a
            quantized representation of the RTT using the algorithm described
            in the <a class='info' href='#RFC5401'>Multicast NACK Building
            Block<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5401].
</p>
<p>The "cc_rate" field contains a representation of the receiver's
            current calculated (during steady-state congestion control
            operation) or twice its measured (during the <em>slow start</em>
            phase) congestion control rate. This field is encoded and decoded
            using the same technique as described for the <tt>NORM_CMD(CC)</tt>
            "send_rate" field.
</p>
<a name="anchor18"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3.5"></a><h3>4.2.3.5.&nbsp;
NORM_CMD(REPAIR_ADV) Message</h3>

<p>The <tt>NORM_CMD(REPAIR_ADV)</tt> message is
            used by the sender to "advertise" its aggregated repair state from
            <tt>NORM_NACK</tt> messages accumulated during
            a repair cycle and/or congestion control feedback received. This
            message is sent only when the sender has received <tt>NORM_NACK</tt> and/or <tt>NORM_ACK(CC)</tt>
            (when congestion control is enabled) messages via unicast
            transmission instead of multicast. By relaying this information to
            the receiver set, suppression of feedback can be achieved even
            when receivers are unicasting that feedback instead of
            multicasting it among the group <a class='info' href='#NormFeedback'>[NormFeedback]<span> (</span><span class='info'>Adamson, B. and J. Macker, &ldquo;Quantitative Prediction of NACK-Oriented Reliable Multicast           (NORM) Feedback,&rdquo; October&nbsp;2002.</span><span>)</span></a>.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| sub-type = 5  |     flags     |            reserved           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               header extensions (if applicable)               |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       repair_adv_payload                      |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_CMD(REPAIR_ADV) Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The "instance_id", "grtt", "backoff", "gsize", and "sub-type"
            fields serve the same purpose as in other <tt>NORM_CMD</tt>
            messages. The value of the "hdr_len" field when no extensions are
            present is 4.
</p>
<p>The "flags" field provide information on the <tt>NORM_CMD(REPAIR_ADV)</tt> content. There is
            currently one <tt>NORM_CMD(REPAIR_ADV)</tt>
            flag defined:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>NORM_REPAIR_ADV_FLAG_LIMIT = 0x01</pre></div>
<p>This flag is set by the sender when it is unable to fit its
            full current repair state into a single <em>NormSegmentSize</em>.
            If this flag is set, receivers SHALL limit their NACK response to
            generating NACK content only up through the maximum ordinal
            transmission position <em>(objectId::fecPayloadId)</em>
            included in the "repair_adv_content".
</p>
<p>When congestion control operation is enabled, a header
            extension SHOULD be applied to the <tt>NORM_CMD(REPAIR_ADV)</tt>
            representing the most limiting (in terms of congestion control
            feedback suppression) congestion control response. This allows the
            <tt>NORM_CMD(REPAIR_ADV)</tt> message to
            suppress receiver congestion control responses as well as NACK
            feedback messages. The field is defined as a header extension so
            that alternative congestion control schemes can be used for NORM
            without revision to this document. A NORM-CC Feedback Header
            Extension (EXT_CC) is defined to encapsulate congestion control
            feedback within <tt>NORM_NACK</tt>, <tt>NORM_ACK</tt>, and <tt>NORM_CMD(REPAIR_ADV)</tt>
            messages. If another congestion control technique (e.g., Pragmatic
            General Multicast Congestion Control (PGMCC) <a class='info' href='#PgmccPaper'>[PgmccPaper]<span> (</span><span class='info'>Rizzo, L., &ldquo;pgmcc: A TCP-Friendly Single-Rate Multicast Congestion           Control Scheme,&rdquo; August&nbsp;2000.</span><span>)</span></a>) is used within a NORM implementation,
            an additional header extension MAY need to be defined encapsulate
            any required feedback content. The NORM-CC Feedback Header
            Extension format is:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     het = 3   |    hel = 3    |          cc_sequence          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    cc_flags   |     cc_rtt    |            cc_loss            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|            cc_rate            |          cc_reserved          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div>
<p>The "cc_sequence" field contains the current greatest
            "cc_sequence" value receivers have received in <tt>NORM_CMD(CC)</tt> messages from the sender. This
            information assists the sender in congestion control operation by
            providing an indicator of how current ("fresh") the receiver's
            round-trip measurement reference time is and whether the receiver
            has been successfully receiving recent congestion control probes.
            For example, if it is apparent the receiver has not been receiving
            recent congestion control probes (and thus possibly other messages
            from the sender), the sender SHOULD choose to take congestion
            avoidance measures. For <tt>NORM_CMD(REPAIR_ADV)</tt>
            messages, the sender SHALL set the "cc_sequence" field value to
            the value set in the last <tt>NORM_CMD(CC)</tt>
            message sent.
</p>
<p>The "cc_flags" field contains bits representing the receiver's
            state with respect to congestion control operation. The possible
            values for the "cc_flags" field are those specified for the <tt>NORM_CMD(CC)</tt> message node list item flags.
            These fields are used by receivers in controlling (suppressing as
            necessary) their congestion control feedback. For <tt>NORM_CMD(REPAIR_ADV)</tt> messages, the <tt>NORM_FLAG_CC_RTT</tt> SHALL be set <em>only</em> when <em>all</em>
            feedback messages received by the sender have the flag set.
            Similarly, the <tt>NORM_FLAG_CC_CLR</tt> or
            <tt>NORM_FLAG_CC_PLR</tt> SHALL be set only
            when <em>no</em> feedback has been received
            from non-CLR or non-PLR receivers. And the <tt>NORM_FLAG_CC_LEAVE</tt>
            SHALL be set only when all feedback messages the sender has
            received have this flag set. These heuristics for setting the
            flags in <tt>NORM_CMD(REPAIR_ADV)</tt> ensure
            the most effective suppression of receivers providing unicast
            feedback messages.
</p>
<p>The "cc_rtt" field SHALL be set to a default maximum value and
            the <tt>NORM_FLAG_CC_RTT</tt> flag SHALL be
            cleared when no receiver has yet received RTT measurement
            information. When a receiver has received RTT measurement
            information, it SHALL set the "cc_rtt" value accordingly and set
            the <tt>NORM_FLAG_CC_RTT</tt> flag in the
            "cc_flags" field. For <tt>NORM_CMD(REPAIR_ADV)</tt>
            messages, the sender SHALL set the "cc_rtt" field value to the
            largest non-CLR/non-PLR RTT it has measured from receivers for the
            current feedback round.
</p>
<p>The "cc_loss" field represents the receiver's current packet
            loss fraction estimate for the indicated source. The loss fraction
            is a value from 0.0 to 1.0 corresponding to a range of zero to 100
            percent packet loss. The 16-bit "cc_loss" value is calculated by
            the following formula:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>
"cc_loss" = floor(decimal_loss_fraction * 65535.0)</pre></div>
<p>For <tt>NORM_CMD(REPAIR_ADV)</tt> messages,
            the sender SHALL set the "cc_loss" field value to the largest
            non-CLR/non-PLR loss estimate it has received from receivers for
            the current feedback round.
</p>
<p>The "cc_rate" field represents the receivers current local
            congestion control rate. During "slow start", when the receiver
            has detected no loss, this value is set to twice the actual rate
            it has measured from the corresponding sender and the <tt>NORM_FLAG_CC_START</tt> is set in the "cc_flags'
            field. Otherwise, the receiver calculates a congestion control
            rate based on its loss measurement and RTT measurement information
            (even if default) for the "cc_rate" field. For <tt>NORM_CMD(REPAIR_ADV)</tt> messages, the sender
            SHALL set the "cc_loss" field value to the lowest non-CLR/non-PLR
            "cc_rate" report it has received from receivers for the current
            feedback round.
</p>
<p>The "cc_reserved" field is reserved for future NORM protocol
            use. Currently, senders SHALL set this field to <tt>ZERO</tt>, and receivers SHALL ignore the content
            of this field.
</p>
<p>The "repair_adv_payload" is in exactly the same form as the
            "nack_content" of <tt>NORM_NACK</tt> messages
            and can be processed by receivers for suppression purposes in the
            same manner, with the exception of the condition when the <tt>NORM_REPAIR_ADV_FLAG_LIMIT</tt> is set.
</p>
<a name="anchor19"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3.6"></a><h3>4.2.3.6.&nbsp;
NORM_CMD(ACK_REQ) Message</h3>

<p>The <tt>NORM_CMD(ACK_REQ)</tt> message is
            used by the sender to request acknowledgment from a specified list
            of receivers. This message is used in providing a lightweight
            positive acknowledgment mechanism that is OPTIONAL for use by the
            reliable multicast application. A range of acknowledgment request
            types is provided for use at the application's discretion.
            Provision for application-defined, positively-acknowledged
            commands allows the application to automatically take advantage of
            transmission and round-trip timing information available to the
            NORM protocol. The details of the NORM positive acknowledgment
            process including transmission of the <tt>NORM_CMD(ACK_REQ)</tt>
            messages and the receiver response (<tt>NORM_ACK</tt>)
            are described in <a class='info' href='#PositiveAcknowledgment'>Section&nbsp;5.5.3<span> (</span><span class='info'>NORM Positive Acknowledgment Procedure</span><span>)</span></a>.
            The format of the <tt>NORM_CMD(ACK_REQ)</tt>
            message is:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| sub-type = 6  |    reserved   |    ack_type   |    ack_id     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       acking_node_list                        |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_CMD(ACK_REQ) Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The NORM common message header and standard <tt>NORM_CMD</tt> fields serve their usual purposes.
            The value of the "hdr_len" field for <tt>NORM_CMD(ACK_REQ)</tt>
            messages with no header extension present is 4.
</p>
<p>The "ack_type" field indicates the type of acknowledgment being
            requested and thus implies rules for how the receiver will treat
            this request. The following "ack_type" values are defined and are
            also used in <tt>NORM_ACK</tt> messages
            described later:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left" width="30%"><col align="left" width="20%"><col align="left" width="50%">
<tr><th align="left">ACK Type</th><th align="left">Value</th><th align="left">Purpose</th></tr>
<tr>
<td align="left"><tt>NORM_ACK_CC</tt>&nbsp;</td>
<td align="left">1</td>
<td align="left">Used to identify <tt>NORM_ACK</tt>
              messages sent in response to <tt>NORM_CMD(CC)</tt>
              messages.</td>
</tr>
<tr>
<td align="left"><tt>NORM_ACK_FLUSH</tt>&nbsp;</td>
<td align="left">2</td>
<td align="left">Used to identify <tt>NORM_ACK</tt>
              messages sent in response to <tt>NORM_CMD(FLUSH)</tt>
              messages.</td>
</tr>
<tr>
<td align="left"><tt>NORM_ACK_RESERVED</tt>&nbsp;</td>
<td align="left">3-15</td>
<td align="left">Reserved for possible future NORM protocol use.</td>
</tr>
<tr>
<td align="left"><tt>NORM_ACK_APPLICATION</tt>&nbsp;</td>
<td align="left">16-255</td>
<td align="left">Used at application's discretion.</td>
</tr>
</table>
<br clear="all" />

<p>The <tt>NORM_ACK_CC</tt> value is provided
            for use only in <tt>NORM_ACKs</tt> generated in
            response to the <tt>NORM_CMD(CC)</tt> messages
            used in congestion control operation. Similarly, the <tt>NORM_ACK_FLUSH</tt> is provided for use only in
            <tt>NORM_ACKs</tt> generated in response to
            applicable <tt>NORM_CMD(FLUSH)</tt> messages.
            <tt>NORM_CMD</tt>(ACK_REQ) messages with
            "ack_type" of <tt>NORM_ACK_CC</tt> or <tt>NORM_ACK_FLUSH</tt> SHALL NOT be generated by the
            sender.
</p>
<p>The <tt>NORM_ACK_RESERVED</tt> range of
            "ack_type" values is provided for possible future NORM protocol
            use.
</p>
<p>The <tt>NORM_ACK_APPLICATION</tt> range of
            "ack_type" values is provided so that NORM applications can
            implement application-defined, positively-acknowledged commands
            that are able to leverage internal transmission and round-trip
            timing information available to the NORM protocol
            implementation.
</p>
<p>The "ack_id" provides a sequenced identifier for the given
            <tt>NORM_CMD(ACK_REQ)</tt> message. This
            "ack_id" is returned in <tt>NORM_ACK</tt>
            messages generated by the receivers so that the sender can
            associate the response with its corresponding request.
</p>
<p>The "reserved" field is reserved for possible future protocol
            use and SHALL be set to <tt>ZERO</tt> by
            senders and ignored by receivers.
</p>
<p>The "acking_node_list" field contains the <em>NormNodeIds</em>
            of the current NORM receivers that are desired to provide positive
            acknowledge (<tt>NORM_ACK</tt>) to this
            request. The packet payload length implies the length of the
            "acking_node_list" and its length is limited to the sender <em>NormSegmentSize</em>. The individual <em>NormNodeId</em> items are listed in network (Big
            Endian) byte order. If a receiver's <em>NormNodeId</em>
            is included in the "acking_node_list", it SHALL schedule
            transmission of a <tt>NORM_ACK</tt> message as
            described in <a class='info' href='#PositiveAcknowledgment'>Section&nbsp;5.5.3<span> (</span><span class='info'>NORM Positive Acknowledgment Procedure</span><span>)</span></a>.
</p>
<a name="anchor20"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.3.7"></a><h3>4.2.3.7.&nbsp;
NORM_CMD(APPLICATION) Message</h3>

<p>This command allows the NORM application to robustly transmit
            application-defined commands. The command message preempts any
            ongoing data transmission and is repeated up to <tt>NORM_ROBUST_FACTOR</tt> times at a rate of once
            per <tt>2*GRTT_sender</tt>. This rate of
            repetition allows the application to observe any response (if that
            is the application's purpose for the command) before it is
            repeated. Possible responses can include initiation of data
            transmission, other <tt>NORM_CMD(APPLICATION)</tt>
            messages, or even application-defined, positively-acknowledge
            commands from other <em>NormSession</em>
            participants. The transmission of these commands will preempt data
            transmission when they are scheduled and can be multiplexed with
            ongoing data transmission. This type of robustly transmitted
            command allows NORM applications to define a complete set of
            session control mechanisms with less state than the transfer of
            FEC encoded reliable content needs while taking advantage of NORM
            transmission and round-trip timing information.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=3|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          instance_id          |     grtt      |backoff| gsize |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| sub-type = 7  |                    reserved                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   Application-Defined Content                 |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_CMD(APPLICATION) Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The NORM common message header and <tt>NORM_CMD</tt>
            fields are interpreted as previously described. The value of the
            <tt>NORM_CMD(APPLICATION)</tt> "hdr_len" field
            when no header extensions are present is 4.
</p>
<p>The "Application-Defined Content" area contains information in
            a format at the discretion of the application. The size of this
            payload SHALL be limited to a maximum of the sender's <em>NormSegmentSize</em> setting. Upon reception, the
            NORM protocol implementation SHALL deliver the content to the
            receiver application. Note that any detection of duplicate
            reception of a <tt>NORM_CMD(APPLICATION)</tt>
            message is the responsibility of the application.
</p>
<a name="anchor21"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Receiver Messages</h3>

<p>The NORM message types generated by participating receivers consist
        of the <tt>NORM_NACK</tt> and <tt>NORM_ACK</tt>
        message types. <tt>NORM_NACK</tt> messages are sent
        to request repair of missing data content from sender transmission and
        <tt>NORM_ACK</tt> messages are generated in
        response to certain sender commands including <tt>NORM_CMD(CC)</tt>
        and <tt>NORM_CMD(ACK_REQ)</tt>.
</p>
<a name="anchor22"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.1"></a><h3>4.3.1.&nbsp;
NORM_NACK Message</h3>

<p>The principal purpose of <tt>NORM_NACK</tt>
          messages is for receivers to request repair of sender content via
          selective, negative acknowledgment upon detection of incomplete
          data. <tt>NORM_NACK</tt> messages will be
          transmitted according to the rules of <tt>NORM_NACK</tt>
          generation and suppression described in <a class='info' href='#NackProcedure'>Section&nbsp;5.3<span> (</span><span class='info'>Receiver NACK Procedure</span><span>)</span></a>. <tt>NORM_NACK</tt>
          messages also contain additional fields to provide feedback to the
          sender(s) for purposes of round-trip timing collection and
          congestion control.
</p>
<p>The payload of <tt>NORM_NACK</tt> messages
          contains one or more repair requests for different objects or
          portions of those objects. The <tt>NORM_NACK</tt>
          message format is as follows:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=4|    hdr_len    |            sequence           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           server_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           instance_id         |            reserved           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       grtt_response_sec                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       grtt_response_usec                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               header extensions (if applicable)               |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          nack_payload                         |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_NACK Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The NORM common message header fields serve their usual purposes.
          The value of the "hdr_len" field for <tt>NORM_NACK</tt>
          messages without header extensions present is 6.
</p>
<p>The "server_id" field identifies the NORM sender to which the
          <tt>NORM_NACK</tt> message is destined.
</p>
<p>The "instance_id" field contains the current session identifier
          given by the sender identified by the "server_id" field in its
          sender messages. The sender SHOULD ignore feedback messages
          containing an invalid "instance_id" value.
</p>
<p>The "grtt_response" fields contain an adjusted version of the
          timestamp from the most recently received <tt>NORM_CMD(CC)</tt>
          message for the indicated NORM sender. The format of the
          "grtt_response" is the same as the "send_time" field of the <tt>NORM_CMD(CC)</tt>. The "grtt_response" value is
          relative to the "send_time" the source provided with a corresponding
          <tt>NORM_CMD(CC)</tt> command. The receiver
          adjusts the source's <tt>NORM_CMD(CC)</tt>
          "send_time" timestamp by adding the time delta from when the
          receiver received the <tt>NORM_CMD(CC)</tt> to
          when the <tt>NORM_NACK</tt> is transmitted in
          response to calculate the value in the "grtt_response" field. This
          is the "receive_to_response_delta" value used in the following
          formula:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>grtt_response = NORM_CMD(CC) send_time + receive_to_response_delta</pre></div>
<p>The receiver SHALL set the "grtt_response" to a <tt>ZERO</tt> value, to indicate it has not yet received
          a <tt>NORM_CMD(CC)</tt> message from the
          indicated sender and the sender MUST ignore the "grtt_response" in
          this message.
</p>
<p>For NORM-CC operation, the NORM-CC Feedback Header Extension, as
          described in the <tt>NORM_CMD(REPAIR_ADV}</tt>
          message description, is added to <tt>NORM_NACK</tt>
          messages to provide feedback on the receivers current state with
          respect to congestion control operation. Alternative header
          extensions for congestion control feedback MAY be defined for
          alternative congestion control schemes for NORM use in the
          future.
</p>
<p>The "reserved" field is for potential future NORM use and SHALL
          be set to <tt>ZERO</tt> for this version of the
          protocol.
</p>
<p>The "nack_payload" of the <tt>NORM_NACK</tt>
          message specifies the repair needs of the receiver with respect to
          the NORM sender indicated by the "server_id" field. The receiver
          constructs repair requests based on the <tt>NORM_DATA</tt>
          and/or <tt>NORM_INFO</tt> segments it needs from
          the sender to complete reliable reception up to the sender's
          transmission position at the moment the receiver initiates the NACK
          Procedure as described in <a class='info' href='#NackProcedure'>Section&nbsp;5.3<span> (</span><span class='info'>Receiver NACK Procedure</span><span>)</span></a>. A
          single NORM Repair Request consists of a list of items, ranges,
          and/or FEC coding block erasure counts for needed <tt>NORM_DATA</tt> and/or <tt>NORM_INFO</tt>
          content. Multiple repair requests can be concatenated within the
          "nack_payload" field of a <tt>NORM_NACK</tt>
          message. A single NORM Repair Request can possibly include multiple
          "items", "ranges", or "erasure_counts". In turn, the "nack_payload"
          field MAY contain multiple repair requests. A single NORM Repair
          Request has the following format:
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|      form     |     flags     |             length            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      repair_request_items                     |
|                             ...                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM Repair Request Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The "form" field indicates the type of repair request items given
          in the "repair_request_items" list. Possible values for the "form"
          field include:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="center">
<tr><th align="left">Form</th><th align="center">Value</th></tr>
<tr>
<td align="left"><tt>NORM_NACK_ITEMS</tt>&nbsp;</td>
<td align="center">1</td>
</tr>
<tr>
<td align="left"><tt>NORM_NACK_RANGES</tt>&nbsp;</td>
<td align="center">2</td>
</tr>
<tr>
<td align="left"><tt>NORM_NACK_ERASURES</tt>&nbsp;</td>
<td align="center">3</td>
</tr>
</table>
<br clear="all" />

<p>A "form" value of <tt>NORM_NACK_ITEMS</tt>
          indicates each repair request item in the "repair_request_items"
          list is to be treated as an individual request. A value of <tt>NORM_NACK_RANGES</tt> indicates the
          "repair_request_items" list consists of <em>pairs</em>
          of repair request items corresponding to the inclusive ranges of
          repair needs. And the <tt>NORM_NACK_ERASURES</tt>
          "form" indicates the repair request items are to be treated
          individually and the "encoding_symbol_id" portion of the
          "fec_payload_id" field of the repair request item (see below) is to
          be interpreted as an erasure count for the FEC coding block
          identified by the repair request item's "source_block_number".
</p>
<p>The "flags" field is currently used to indicate the level of data
          content for which the repair request items apply (i.e., an
          individual segment, entire FEC coding block, or entire transport
          object). Possible flag values include:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left" width="30%"><col align="center" width="10%"><col align="left" width="60%">
<tr><th align="left">Flag</th><th align="center">Value</th><th align="left">Purpose</th></tr>
<tr>
<td align="left"><tt>NORM_NACK_SEGMENT</tt>&nbsp;</td>
<td align="center">0x01</td>
<td align="left">Indicates the listed segment(s) or range of segments needed as
            repair.</td>
</tr>
<tr>
<td align="left"><tt>NORM_NACK_BLOCK</tt>&nbsp;</td>
<td align="center">0x02</td>
<td align="left">Indicates the listed block(s) or range of blocks in entirety
            are needed as repair.</td>
</tr>
<tr>
<td align="left"><tt>NORM_NACK_INFO</tt>&nbsp;</td>
<td align="center">0x04</td>
<td align="left">Indicates <tt>NORM_INFO</tt> is needed as
            repair for the listed object(s).</td>
</tr>
<tr>
<td align="left"><tt>NORM_NACK_OBJECT</tt>&nbsp;</td>
<td align="center">0x08</td>
<td align="left">Indicates the listed object(s) or range of objects in entirety
            are needed as repair.</td>
</tr>
</table>
<br clear="all" />

<p>When the <tt>NORM_NACK_SEGMENT</tt> flag is
          set, the "object_transport_id" and "fec_payload_id" fields are used
          to determine which sets or ranges of individual <tt>NORM_DATA</tt>
          segments are needed to repair content at the receiver. When the
          <tt>NORM_NACK_BLOCK</tt> flag is set, this
          indicates the receiver is completely missing the indicated coding
          block(s) and transmissions sufficient to repair the indicated
          block(s) in their entirety are needed. When the <tt>NORM_NACK_INFO</tt>
          flag is set, this indicates the receiver is missing the <tt>NORM_INFO</tt> segment for the indicated
          "object_transport_id". Note the <tt>NORM_NACK_INFO</tt>
          can be set in combination with the <tt>NORM_NACK_BLOCK</tt>
          or <tt>NORM_NACK_SEGMENT</tt> flags, or can be
          set alone. When the <tt>NORM_NACK_OBJECT</tt>
          flag is set, this indicates the receiver is missing the entire
          <em>NormTransportObject</em> referenced by the
          "object_transport_id". This also implicitly requests any available
          <tt>NORM_INFO</tt> for the <em>NormObject</em>,
          if applicable. The "fec_payload_id" field is ignored when the flag
          <tt>NORM_NACK_OBJECT</tt> is set.
</p>
<p>The "length" field value is the length in bytes of the
          "repair_request_items" field.
</p>
<p>The "repair_request_items" field consists of a list of individual
          or range pairs of transport data unit identifiers in the following
          format.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     fec_id    |   reserved    |      object_transport_id      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        fec_payload_id                         |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM Repair Request Item Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The "fec_id" indicates the FEC type and can be used to determine
          the format of the "fec_payload_id" field. The "reserved" field is
          kept for possible future use and SHALL be set to a <tt>ZERO</tt> value and ignored by NORM nodes processing
          NACK content.
</p>
<p>The "object_transport_id" corresponds to the <em>NormObject</em>
          for which repair is being requested and the "fec_payload_id"
          identifies the specific FEC coding block and/or segment being
          requested. When the <tt>NORM_NACK_OBJECT</tt>
          flag is set, the value of the "fec_payload_id" field is ignored.
          When the <tt>NORM_NACK_BLOCK</tt> flag is set,
          only the FEC code block identifier portion of the "fec_payload_id"
          is to be interpreted.
</p>
<p>The format of the "fec_payload_id" field depends upon the
          "fec_id" field value.
</p>
<p>When the receiver's repair needs dictate that different forms
          (mixed ranges and/or individual items) or types (mixed specific
          segments and/or blocks or objects in entirety) are needed to
          complete reliable transmission, multiple NORM Repair Requests with
          different "form" and or "flags" values can be concatenated within a
          single <tt>NORM_NACK</tt> message. Additionally,
          NORM receivers SHALL construct <tt>NORM_NACK</tt>
          messages with their repair requests in ordinal order with respect to
          "object_transport_id" and "fec_payload_id" values. The
          "nack_payload" size SHALL NOT exceed the <em>NormSegmentSize</em>
          for the sender to which the <tt>NORM_NACK</tt> is
          destined.
</p>
<p><strong>NORM_NACK Content Examples:</strong>
</p>
<p>In these examples, a small block, systematic FEC code ("fec_id" =
          129) is assumed with a user data block length of 32 segments. In
          Example 1, a list of individual <tt>NORM_NACK_ITEMS</tt>
          repair requests is given. In Example 2, a list of <tt>NORM_NACK_RANGES</tt> requests AND a single <tt>NORM_NACK_ITEMS</tt> request are concatenated to
          illustrate the possible content of a <tt>NORM_NACK</tt>
          message. Note that FEC coding block erasure counts could also be
          provided in each case. However, the erasure counts are not really
          necessary since the sender can easily determine the erasure count
          while processing the NACK content. However, the erasure count option
          can be useful for operation with other FEC codes or for intermediate
          system purposes.
</p>
<p style='text-align: center'>Example 1: <tt>NORM_NACK</tt>
            "nack_payload" for: Object 12, Coding Block 3, Segments 2,5,and
            8
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   form = 1    | flags = 0x01  |       length  = 36            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  fec_id = 129 |   reserved    |    object_transport_id = 12   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    source_block_number = 3                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    source_block_length = 32   |    encoding_symbol_id = 2     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  fec_id = 129 |   reserved    |    object_transport_id = 12   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    source_block_number = 3                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    source_block_length = 32   |    encoding_symbol_id = 5     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  fec_id = 129 |   reserved    |    object_transport_id = 12   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    source_block_number = 3                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    source_block_length = 32   |    encoding_symbol_id = 8     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div>
<p style='text-align: center'>Example 2: <tt>NORM_NACK</tt>
            "nack_payload" for: Object 18, Coding Block 6, Segments 5, 6, 7,
            8, 9, 10; and Object 19 <tt>NORM_INFO</tt> and
            Coding Block 1, segment 3
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   form = 2    | flags = 0x01  |       length  = 24            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  fec_id = 129 |   reserved    |    object_transport_id = 18   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    source_block_number = 6                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    source_block_length = 32   |    encoding_symbol_id = 5     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  fec_id = 129 |   reserved    |    object_transport_id = 18   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    source_block_number = 6                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    source_block_length = 32   |    encoding_symbol_id = 10    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   form = 1    | flags = 0x05  |       length  = 12            |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  fec_id = 129 |   reserved    |    object_transport_id = 19   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    source_block_number = 1                    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    source_block_length = 32   |    encoding_symbol_id = 3     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div>
<a name="anchor23"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3.2"></a><h3>4.3.2.&nbsp;
NORM_ACK Message</h3>

<p>The <tt>NORM_ACK</tt> message is intended to
          be used primarily as part of NORM congestion control operation and
          round-trip timing measurement. The acknowledgment type <tt>NORM_ACK_CC</tt> is provided for this purpose as
          described in the <tt>NORM_CMD(ACK_REQ)</tt>
          message description. The generation of <tt>NORM_ACK(CC)</tt>
          messages for round-trip timing estimation and congestion-control
          operation is described in <a class='info' href='#GrttCollection'>Section&nbsp;5.5.1<span> (</span><span class='info'>Group Round-trip Time (GRTT) Collection</span><span>)</span></a> and
          <a class='info' href='#CongestionControl'>Section&nbsp;5.5.2<span> (</span><span class='info'>NORM Congestion Control Operation</span><span>)</span></a>, respectively. However,
          some multicast applications can benefit from some limited form of
          positive acknowledgment for certain functions. A simple, scalable
          positive acknowledgment scheme is defined in <a class='info' href='#PositiveAcknowledgment'>Section&nbsp;5.5.3<span> (</span><span class='info'>NORM Positive Acknowledgment Procedure</span><span>)</span></a> that can be leveraged by
          protocol implementations when appropriate. The <tt>NORM_CMD(FLUSH)</tt>
          can also be used for OPTIONAL collection of positive acknowledgment
          of reliable reception to a certain "watermark" transmission point
          from specific receivers using this mechanism. The <tt>NORM_ACK</tt> type <tt>NORM_ACK_FLUSH</tt>
          is provided for this purpose and the format of the "nack_payload"
          for this acknowledgment type is given below. Beyond that, a range of
          application-defined "ack_type" values is provided for use at the
          NORM application's discretion. Implementations making use of
          application-defined positive acknowledgments MAY also make use the
          "nack_payload" as needed, observing the constraint that the
          "nack_payload" field size be limited to a maximum of the <em>NormSegmentSize</em> for the sender to which the
          <tt>NORM_ACK</tt> is destined.
</p><br /><hr class="insert" />
<div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|version| type=5|    hdr_len    |          sequence             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           source_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                           server_id                           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           instance_id         |    ack_type  |     ack_id     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       grtt_response_sec                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       grtt_response_usec                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|               header extensions (if applicable)               |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                   ack_payload (if applicable)                 |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;NORM_ACK Message Format&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The NORM common message header fields serve their usual purposes.
          The value of the "hdr_len" field when no header extensions are
          present is 6.
</p>
<p>The "server_id", "instance_id", and "grtt_response" fields serve
          the same purpose as the corresponding fields in <tt>NORM_NACK</tt>
          messages. And header extensions can be applied to support congestion
          control feedback or other functions in the same manner.
</p>
<p>The "ack_type" field indicates the nature of the <tt>NORM_ACK</tt> message. This directly corresponds to
          the "ack_type" field of the <tt>NORM_CMD(ACK_REQ)</tt>
          message to which this acknowledgment applies.
</p>
<p>The "ack_id" field serves as a sequence number so the sender can
          verify a received <tt>NORM_ACK</tt> message
          actually applies to a current acknowledgment request. The "ack_id"
          field is not used in the case of the <tt>NORM_ACK_CC</tt>
          and <tt>NORM_ACK_FLUSH</tt> acknowledgment
          types.
</p>
<p>The "ack_payload" format is a function of the "ack_type". The
          <tt>NORM_ACK_CC</tt> message has no attached
          content. Only the <tt>NORM_ACK</tt> header
          applies. In the case of <tt>NORM_ACK_FLUSH</tt>,
          a specific "ack_payload" format is defined:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre> 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     fec_id    |   reserved    |      object_transport_id      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        fec_payload_id                         |
|                              ...                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</pre></div>
<p>The "object_transport_id" and "fec_payload_id" are used by the
          receiver to acknowledge applicable <tt>NORM_CMD(FLUSH)</tt>
          messages transmitted by the sender identified by the "server_id"
          field.
</p>
<p>The "ack_payload" of <tt>NORM_ACK</tt>
          messages for application-defined "ack_type" values is specific to
          the application but is limited in size to a maximum the <em>NormSegmentSize</em> of the sender referenced by the
          "server_id".
</p>
<a name="anchor24"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
General Purpose Messages</h3>

<p>Some additional message formats are defined for general purpose in
        NORM multicast sessions whether the participant is acting as a sender
        and/or receiver within the group.
</p>
<a name="anchor25"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4.1"></a><h3>4.4.1.&nbsp;
NORM_REPORT Message</h3>

<p>This is an OPTIONAL message generated by NORM participants. This
          message can be used for periodic performance reports from receivers
          in experimental NORM implementations. The format of this message is
          currently undefined. Experimental NORM implementations MAY define
          <tt>NORM_REPORT</tt> formats as needed for test
          purposes. These report messages SHOULD be disabled for
          interoperability testing between different compliant NORM
          implementations.
</p>
<a name="ProtocolDetails"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Detailed Protocol Operation</h3>

<p>This section describes the detailed interactions of senders and
      receivers participating in a NORM session. A simple synopsis of protocol
      operation is given here:
</p>
<p></p>
<ol class="text">
<li>The sender periodically transmits <tt>NORM_CMD(CC)</tt>
          messages as needed to initialize and collect round-trip timing and
          congestion control feedback from the receiver set.
</li>
<li>The sender transmits an ordinal set of <em>NormObjects</em>
          segmented in the form of <tt>NORM_DATA</tt>
          messages labeled with <em>NormTransportIds</em>
          and logically identified with FEC encoding block numbers and symbol
          identifiers. <tt>When applicable, NORM_INFO</tt>
          messages MAY optionally precede the transmission of data content for
          NORM transport objects.
</li>
<li>As receivers detect missing content from the sender, they
          initiate repair requests with <tt>NORM_NACK</tt>
          messages. The receivers track the sender's most recent <em>objectId::fecPayloadId</em> transmit position and
          NACK only for content that is ordinally prior to that current
          transmit position. The receivers schedule random backoff timeouts
          before generating <tt>NORM_NACK</tt> messages and
          wait an appropriate amount of time before repeating the <tt>NORM_NACK</tt> if their repair request is not
          satisfied.
</li>
<li>The sender aggregates repair requests from the receivers and
          logically "rewinds" its transmit position to send appropriate repair
          messages. The sender sends repairs for the earliest ordinal transmit
          position first and maintains this ordinal repair transmission
          sequence. FEC parity content not previously transmitted for the
          applicable FEC coding block is used for repair transmissions to the
          greatest extent possible. If the sender exhausts its available FEC
          parity content on multiple repair cycles for the same coding block,
          it resorts to an explicit repair strategy (possibly using parity
          content) to complete repairs. (The use of explicit repair is an
          exception in general protocol operation, but the possibility does
          exist for extreme conditions). The sender immediately assumes
          transmission of new content once it has sent pending repairs.
</li>
<li>The sender transmits <tt>NORM_CMD(FLUSH)</tt>
          messages when it reaches the end of enqueued transmit content and
          pending repairs. Receivers respond to the <tt>NORM_CMD(FLUSH)</tt>
          messages with <tt>NORM_NACK</tt> transmissions
          (following the same suppression backoff timeout strategy as for
          data) if they need further repair.
</li>
<li>The sender transmissions are subject to rate control limits
          determined by congestion control mechanisms. In the baseline NORM-CC
          operation, each sender in a <em>NormSession</em>
          maintains its own independent congestion control state. Receivers
          provide congestion control feedback in <tt>NORM_NACK</tt>
          and <tt>NORM_ACK</tt> messages. <tt>NORM_ACK</tt> feedback for congestion control
          purposes is governed using a suppression mechanism similar to that
          for <tt>NORM_NACK</tt> messages.
</li>
</ol>

<p>While this overall concept is relatively simple, there are details to
      each of these aspects that need to be addressed for successful,
      efficient, robust, and scalable NORM protocol operation.
</p>
<a name="anchor26"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Sender Initialization and Transmission</h3>

<p>Upon startup, the NORM sender immediately begins sending <tt>NORM_CMD(CC)</tt> messages to collect round trip
        timing and other information from the potential group. If NORM-CC
        congestion control operation is enabled, the NORM-CC Rate header
        extension MUST be included in these messages. Congestion control
        operation SHALL be observed at all times when not operating using
        dedicated resources, like in the general Internet. Even if congestion
        control operation is disabled at the sender, it can be desirable to
        use the <tt>NORM_CMD(CC)</tt> messaging to collect
        feedback from the group using the baseline NORM-CC feedback
        mechanisms. This proactive feedback collection can be used to
        establish a GRTT estimate prior to data transmission and potential
        NACK operation.
</p>
<p>In some cases, applications might need the sender to also proceed
        with data transmission immediately. In other cases, the sender might
        wish to defer data transmission until it has received some feedback or
        request from the receiver set indicating receivers are indeed present.
        Note, in some applications (e.g., web push), this indication MAY come
        out-of-band with respect to the multicast session via other means. As
        noted, the periodic transmission of <tt>NORM_CMD(CC)</tt>
        messages MAY precede actual data transmission in order to have an
        initial GRTT estimate.
</p>
<p>With inclusion of the OPTIONAL NORM FEC Object Transmission
        Information Header Extension (EXT_FTI), the NORM protocol sender
        message headers can contain all information necessary to prepare
        receivers for subsequent reliable reception. This includes FEC coding
        parameters, the sender <em>NormSegmentSize</em>,
        and other information. If this header extension is not used, it is
        presumed receivers have received the FEC Object Transmission
        Information via other means. Additionally, applications MAY leverage
        the use of <tt>NORM_INFO</tt> messages associated
        with the session data objects in the session to provide
        application-specific context information for the session and data
        being transmitted. These mechanisms allow for operation with minimal
        pre-coordination among the senders and receivers.
</p>
<p>The NORM sender begins segmenting application-enqueued data into
        <tt>NORM_DATA</tt> segments and transmitting it to
        the group. For objects of type <tt>NORM_OBJECT_DATA</tt>
        and <tt>NORM_OBJECT_FILE</tt>, the segmentation
        algorithm described in <a class='info' href='#RFC5052'>FEC Building
        Block<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052] is RECOMMENDED. For objects of type <tt>NORM_OBJECT_STREAM</tt>,
        segmentation will typically be into uniform FEC coding block sizes,
        with individual segment sizes controlled by the application. In most
        cases, the application and NORM implementation SHOULD strive to
        produce full-sized (<tt>NormSegmentSize</tt>)
        segments when possible. The rate of transmission is controlled via
        congestion control mechanisms or is a fixed rate if desired for closed
        network operations. The receivers participating in the multicast group
        provide feedback to the sender as needed. When the sender reaches the
        end of data it has enqueued for transmission or any pending repairs,
        it transmits a series of <tt>NORM_CMD(FLUSH)</tt>
        messages at a rate of one per <tt>2*GRTT_sender</tt>.
        Similar to end of each transmitted FEC coding block during
        transmission, receivers SHALL respond to these <tt>NORM_CMD(FLUSH)</tt>
        messages with additional repair requests as needed. A protocol
        parameter "<tt>NORM_ROBUST_FACTOR</tt>" determines
        the number of flush messages sent. If receivers request repair, the
        repair is provided and flushing occurs again at the end of repair
        transmission. The sender MAY attach an OPTIONAL "acking_node_list" to
        <tt>NORM_CMD(FLUSH)</tt> containing the <em>NormNodeIds</em> for receivers from which it expects
        explicit positive acknowledgment of reception. The <tt>NORM_CMD(FLUSH)</tt> message MAY be also used for this
        OPTIONAL purpose any time prior to the end of data enqueued for
        transmission with the <tt>NORM_CMD(FLUSH)</tt>
        messages multiplexed with ongoing data transmissions. The OPTIONAL
        NORM positive acknowledgment procedure is described in <a class='info' href='#PositiveAcknowledgment'>Section&nbsp;5.5.3<span> (</span><span class='info'>NORM Positive Acknowledgment Procedure</span><span>)</span></a>.
</p>
<a name="SegmentationAlgorithm"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1.1"></a><h3>5.1.1.&nbsp;
Object Segmentation Algorithm</h3>

<p>NORM senders and receivers MUST use a common algorithm for
          logically segmenting transport data into FEC encoding blocks and
          symbols so appropriate NACKs can be constructed to request repair of
          missing data. NORM FEC coding blocks are comprised of multi-byte
          symbols (segments) transmitted in the payload of <tt>NORM_DATA</tt> messages. Each <tt>NORM_DATA</tt>
          message will contain one or more source or encoding symbol(s)
          identified by the "fec_payload_id" field and the <em>NormSegmentSize</em> sender parameter defines the
          maximum size (in bytes) of the "payload_data" field containing the
          content (a "segment"). The FEC encoding type and associated
          parameters govern the source block size (number of source symbols
          per coding block, etc.). NORM senders and receivers use these FEC
          parameters, along with the <em>NormSegmentSize</em>
          and transport object size to compute the source block structure for
          transport objects. These parameters are provided in the FEC Object
          Transmission Information for each object. The block partitioning
          algorithm described in the <a class='info' href='#RFC5052'>FEC Building
          Block<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052] is RECOMMENDED for use to compute a source block
          structure such that all source blocks are as close to being equal
          length as possible. This helps avoid the performance disadvantages
          of "short" FEC blocks. Note this algorithm applies only to the
          statically-sized <tt>NORM_OBJECT_DATA</tt> and
          <tt>NORM_OBJECT_FILE</tt> transport object types
          where the object size is fixed and predetermined. For <tt>NORM_OBJECT_STREAM</tt> objects, the object is
          segmented according to the maximum source block length given in the
          FEC Transmission Information, unless the FEC Payload ID indicates an
          alternative size for a given block.
</p>
<a name="ReceiverInitialization"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Receiver Initialization and Reception</h3>

<p>For typical operation, NORM receivers will join a specified
        multicast group and listen on an specific port number for sender
        transmissions. As the NORM receiver receives <tt>NORM_DATA</tt>
        messages it will establish buffering state and provide content to its
        application as appropriate for the given data type. The NORM protocol
        allows receivers to join and leave the group at will although some
        applications might need receivers to be members of the group prior to
        start of data transmission. Thus, different NORM applications MAY use
        different policies to constrain the impact of new receivers joining
        the group in the middle of a session. For example, a useful
        implementation policy is for new receivers joining the group to limit
        or avoid repair requests for transport objects already in progress.
        The NORM sender implementation MAY impose additional constraints to
        limit the ability of receivers to disrupt reliable multicast
        performance by joining, leaving, and rejoining the group often.
        Different receiver "join policies" might be appropriate for different
        applications and/or scenarios. For general purpose operation, a
        default policy where receivers are allowed to request repair only for
        coding blocks with a <em>NormTransportId</em> and
        FEC coding block number greater than or equal to the first non-repair
        <tt>NORM_DATA</tt> or <tt>NORM_INFO</tt>
        message received upon joining the group is RECOMMENDED. For objects of
        type <tt>NORM_OBJECT_STREAM</tt> it is RECOMMENDED
        the join policy constrain receivers to start reliable reception at the
        current FEC coding block for which non-repair content is received.
</p>
<p>In some deployments, different multicast receivers might have
        differing quality of network connectivity. Some receivers may suffer
        significantly poorer performance with very limited goodput due to low
        connection rate or substantial packet loss. Similar to the "join
        policies" described above, a NORM sender implementation MAY choose to
        enforce different "service policies" to perhaps exclude exceptionally
        poor-performing (or otherwise badly-behaving) receivers from the
        group. The sender implementation could choose to ignore NACKs from
        such receivers and/or force advancement of its logical "repair window"
        (i.e. enforcing a minimal level of service) and use the <tt>NORM_CMD(SQUELCH)</tt> message to advise those poor
        performers of its advance. Note in some cases, the application may
        need to support the "weakest member" regardless of the time needed to
        achieve reliable delivery. When implemented, the protocol
        instantiation SHOULD expose controls to the set of "join" and/or
        "service" policies available to support the needs of different
        applications.
</p>
<a name="NackProcedure"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
Receiver NACK Procedure</h3>

<p>When the receiver detects it is missing data from a sender's NORM
        transmissions, it initiates its NACKing procedure. The NACKing
        procedure SHALL be initiated <em>only</em> at FEC
        coding block boundaries, <em>NormObject</em>
        boundaries, upon receipt of a <tt>NORM_CMD(FLUSH)</tt>
        message, or upon an "inactivity" timeout when <tt>NORM_DATA</tt>
        or <tt>NORM_INFO</tt> transmissions are no longer
        received from a previously active sender. The RECOMMENDED value of
        such an inactivity timeout is:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>T_inactivity = NORM_ROBUST_FACTOR * 2 * GRTT_sender</pre></div>
<p>where the "<tt>GRTT_sender</tt>" value
        corresponds to the GRTT estimate advertised in the "grtt" field of
        NORM sender messages. A minimum "<tt>T_inactivity</tt>"
        value of 1 second is RECOMMENDED. The NORM receiver SHOULD reset this
        inactivity timer and repeat NACK initiation upon timeout for up to
        <tt>NORM_ROBUST_FACTOR</tt> times or more depending
        upon the application's need for persistence by its receivers. It is
        also important receivers rescale the "<tt>T_inactivity</tt>"
        timeout as the sender's advertised GRTT changes.
</p>
<p>The NACKing procedure begins with a random backoff timeout. The
        duration of the backoff timeout is chosen using the "RandomBackoff"
        algorithm described in the <a class='info' href='#RFC5401'>Multicast NACK
        Building Block<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5401] using (<tt>K_sender*GRTT_sender</tt>)
        for the <tt>maxTime</tt> parameter and the sender
        advertised group size (<tt>GSIZEsender</tt>) as the
        <tt>groupSize</tt> parameter. NORM senders provide
        values for <tt>GRTT_sender</tt>, <tt>K_sender</tt> and <tt>GSIZE_sender</tt>
        via the "grtt", "backoff", and "gsize" fields of transmitted messages.
        The <tt>GRTT_sender</tt> value is determined by the
        sender based on feedback it has received from the group while the
        <tt>K_sender</tt> and <tt>GSIZE_sender</tt>
        values can be determined by application requirements and expectations
        or ancillary information. The backoff factor "<tt>K_sender</tt>"
        MUST be greater than <tt>one</tt> to provide for
        effective feedback suppression. A value of <tt>K_sender = 4</tt>
        is RECOMMENDED for the Any Source Multicast (ASM) model while a value
        of <tt>K_sender = 6</tt> is RECOMMENDED for Single
        Source Multicast (SSM) operation.
</p>
<p>Thus:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>T_backoff = RandomBackoff(K_sender*GRTT_sender, GSIZE_sender)</pre></div>
<p>To avoid the possibility of NACK implosion in the case of sender or
        network failure during SSM operation, the receiver SHALL automatically
        suppress its NACK and immediately enter the "holdoff" period described
        below when <tt>T_backoff</tt> is greater than
        <tt>(K_sender-1)*GRTT_sender</tt>. Otherwise, the
        backoff period is entered and the receiver MUST accumulate external
        pending repair state from <tt>NORM_NACK</tt>
        messages and <tt>NORM_CMD(REPAIR_ADV)</tt> messages
        received. At the end of the backoff time, the receiver SHALL generate
        a <tt>NORM_NACK</tt> message only if the following
        conditions are met:
</p>
<p></p>
<ol class="text">
<li>The sender's current transmit position (in terms of <em>objectId::fecPayloadId</em>) exceeds the earliest
            repair position of the receiver.
</li>
<li>The repair state accumulated from <tt>NORM_NACK</tt>
            and <tt>NORM_CMD(REPAIR_ADV)</tt> messages do
            not equal or supersede the receiver's repair needs up to the
            sender transmission position at the time the NACK procedure
            (backoff timeout) was initiated.
</li>
</ol>

<p>If these conditions are met, the receiver immediately generates a
        <tt>NORM_NACK</tt> message when the backoff timeout
        expires. Otherwise, the receiver's NACK is considered to be
        "suppressed" and the message is not sent. At this time, the receiver
        begins a "holdoff" period during which it constrains itself to not
        re-initiate the NACKing process. The purpose of this timeout is to
        allow the sender worst-case time to respond to the repair needs before
        the receiver requests repair again. The value of this "holdoff"
        timeout (<tt>T_rcvrHoldoff</tt>) as described in
        <a class='info' href='#RFC5401'>[RFC5401]<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> is:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>T_rcvrHoldoff =(K_sender+2)*GRTT_sender</pre></div>
<p>The <tt>NORM_NACK</tt> message contains repair
        request content beginning with lowest ordinal repair position of the
        receiver up through the coding block prior to the most recently heard
        ordinal transmission position for the sender. If the size of the
        <tt>NORM_NACK</tt> content exceeds the sender's
        <em>NormSegmentSize</em>, the NACK content is
        truncated so the receiver only generates a single <tt>NORM_NACK</tt>
        message per NACK cycle for a given sender. In summary, a single NACK
        message is generated containing the receiver's lowest ordinal repair
        needs.
</p>
<p>For each partially-received FEC coding block requiring repair, the
        receiver SHALL, on its FIRST repair attempt for the block, request the
        parity portion of the FEC coding block beginning with the lowest
        ordinal parity "encoding_symbol_id" (i.e., "encoding_symbol_id" =
        "source_block_len") and request the number of FEC symbols
        corresponding to its data segment erasure count for the block. On
        subsequent repair cycles for the same coding block, the receiver SHALL
        request only those repair symbols from the first set it has not yet
        received up to the remaining erasure count for that applicable coding
        block. Note the sender might have transmitted other different,
        additional parity segments for other receivers that could also be used
        to satisfy the local receiver's erasure-filling needs. In the case
        where the erasure count for a partially-received FEC coding block
        exceeds the maximum number of parity symbols available from the sender
        for the block (as indicated by the <tt>NORM_DATA</tt>
        "fec_num_parity" field), the receiver SHALL request all available
        parity segments plus the ordinally highest missing data segments
        needed to satisfy its total erasure needs for the block. The goal of
        this strategy is for the overall receiver set to request a lowest
        common denominator set of repair symbols for a given FEC coding block.
        This allows the sender to construct the most efficient repair
        transmission segment set and enables effective NACK suppression among
        the receivers even with uncorrelated packet loss. This approach also
        does not demand synchronization among the receiver set in their repair
        requests for the sender.
</p>
<p>For FEC coding blocks or <em>NormObjects</em>
        missed in their entirety, the NORM receiver constructs repair requests
        with <tt>NORM_NACK_BLOCK</tt> or <tt>NORM_NACK_OBJECT</tt> flags set as appropriate. The
        request for retransmission of <tt>NORM_INFO</tt> is
        accomplished by setting the <tt>NORM_NACK_INFO</tt>
        flag in a corresponding repair request.
</p>
<a name="anchor27"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Sender NACK Processing and Response</h3>

<p>The principle goal of the sender is to make forward progress in the
        transmission of data its application has enqueued. However, the sender
        will need to occasionally "rewind" its logical transmission point to
        satisfy the repair needs of receivers who have NACKed. Aggregation of
        multiple NACKs is used to determine an optimal repair strategy when a
        NACK event occurs. Since receivers initiate the NACK process on coding
        block or object boundaries, there is some loose degree of
        synchronization of the repair process even when receivers experience
        uncorrelated data loss.
</p>
<a name="anchor28"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.1"></a><h3>5.4.1.&nbsp;
Sender Repair State Aggregation</h3>

<p>When a sender is in its normal state of transmitting new data and
          receives a NACK, it begins a procedure to accumulate NACK repair
          state from <tt>NORM_NACK</tt> messages before
          beginning repair transmissions. Note this period of aggregating
          repair state does NOT interfere with its ongoing transmission of new
          data.
</p>
<p>As described in <a class='info' href='#RFC5401'>[RFC5401]<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a>, the period of
          time during which the sender aggregates <tt>NORM_NACK</tt>
          messages is equal to:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>T_sndrAggregate = (K_sender + 1) * GRTT_sender</pre></div>
<p>where "<tt>K_sender</tt>" is the backoff
          scaling value advertised to the receivers, and <tt>GRTT_sender</tt>
          is the sender's current estimate of the group's greatest round-trip
          time. Note, for NORM unicast sessions, the "<tt>T_sndrAggregate</tt>"
          time can be set to <tt>ZERO</tt> since there is
          only one receiver. Similarly, the "<tt>K_sender</tt>"
          value SHOULD be set to <tt>ZERO</tt> for NORM
          unicast sessions to minimize repair latency.
</p>
<p>When this period ends, the sender "rewinds" by incorporating the
          accumulated repair state into its pending transmission state and
          begins transmitting repair messages. After pending repair
          transmissions are completed, the sender continues with new
          transmissions of any enqueued data. Also, at this point in time, the
          sender begins a "holdoff" timeout during which time the sender
          constrains itself from initiating a new repair aggregation cycle,
          even if <tt>NORM_NACK</tt> messages arrive. As
          described in <a class='info' href='#RFC5401'>[RFC5401]<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a>, the value of this
          sender "holdoff" period is:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>T_sndrHoldoff = (1 * GRTT_sender)</pre></div>
<p>If additional <tt>NORM_NACK</tt> messages are
          received during this sender "holdoff" period, the sender will
          immediately incorporate these late-arriving messages into its
          pending transmission state if, and <em>only</em>
          if, the NACK content is ordinally greater than the sender's current
          transmission position. This "holdoff" time allows worst case time
          for the sender to propagate its current transmission sequence
          position to the group, thus avoiding redundant repair transmissions.
          After the holdoff timeout expires, a new NACK accumulation period
          can be begun (upon arrival of a NACK) in concert with the pending
          repair and new data transmission. Recall receivers are not to
          initiate the NACK repair process until the sender's logical
          transmission position exceeds the lowest ordinal position of their
          repair needs. With the new NACK aggregation period, the sender
          repeats the same process of incorporating accumulated repair state
          into its transmission plan and subsequently "rewinding" to transmit
          the lowest ordinal repair data when the aggregation period expires.
          Again, this is conducted in concert with ongoing new data and/or
          pending repair transmissions.
</p>
<a name="anchor29"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.2"></a><h3>5.4.2.&nbsp;
Sender FEC Repair Transmission Strategy</h3>

<p>The NORM sender SHOULD leverage transmission of FEC parity
          content for repair to the greatest extent possible. Recall that
          receivers use a strategy to request a lowest common denominator of
          explicit repair (including parity content) in the formation of their
          <tt>NORM_NACK</tt> messages. Before falling back
          to explicitly satisfying different receivers' repair needs, the
          sender can make use of the general erasure-filling capability of
          FEC-generated parity segments. The sender can determine the maximum
          erasure filling needs for individual FEC coding blocks from the
          <tt>NORM_NACK</tt> messages received during the
          repair aggregation period. Then, if the sender has a sufficient
          number (less than or equal to the maximum erasure count) of
          previously unsent parity segments available for the applicable
          coding blocks, the sender can transmit these in lieu of the specific
          packets the receiver set has requested. The sender SHOULD NOT resort
          to explicit transmission of the receiver set's repair needs until
          after exhausting its supply of "fresh" (unsent) parity segments for
          a given coding block. In general, if a sufficiently powerful FEC
          code is used, the need for explicit repair will be an exception, and
          the fulfillment of reliable multicast can be accomplished quite
          efficiently. However, the ability to resort to explicit repair
          allows the protocol to be continue to operate under even very
          extreme circumstances.
</p>
<p><tt>NORM_DATA</tt> messages sent as repair
          transmissions SHALL be flagged with the <tt>NORM_FLAG_REPAIR</tt>
          flag. This allows receivers to obey any policies limiting new
          receivers from joining the reliable transmission when only repair
          transmissions have been received. Additionally, the sender SHOULD
          additionally flag <tt>NORM_DATA</tt>
          transmissions sent as explicit repair with the <tt>NORM_FLAG_EXPLICIT</tt>
          flag.
</p>
<p>Although NORM end system receivers do not make use of the <tt>NORM_FLAG_EXPLICIT</tt> flag, this message
          transmission status could be leveraged by intermediate systems
          wishing to "assist" NORM protocol performance. If such systems are
          properly positioned with respect to reciprocal reverse-path
          multicast routing, they need to sub-cast only a sufficient count of
          non-explicit parity repairs to satisfy a multicast routing
          sub-tree's erasure filling needs for a given FEC coding block. When
          the sender has resorted to explicit repair, then the intermediate
          systems SHOULD sub-cast all of the explicit repair packets to those
          portions of the routing tree still requiring repair for a given
          coding block. Note the intermediate systems will need to conduct
          repair state accumulation for sub-routes in a manner similar to the
          sender's repair state accumulation in order to have sufficient
          information to perform the sub-casting. Additionally, the
          intermediate systems could perform additional <tt>NORM_NACK</tt>
          suppression/aggregation as it conducts this repair state
          accumulation for NORM repair cycles. The detail of this type of
          operation are beyond the scope of this document, but this
          information is provided for possible future consideration.
</p>
<a name="anchor30"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.3"></a><h3>5.4.3.&nbsp;
Sender NORM_CMD(SQUELCH) Generation</h3>

<p>If the sender receives a <tt>NORM_NACK</tt>
          message for repair of data it is no longer supporting, the sender
          generates a <tt>NORM_CMD(SQUELCH)</tt> message to
          advertise its repair window and squelch any receivers from
          additional NACKing of invalid data. The transmission rate of <tt>NORM_CMD(SQUELCH)</tt> messages is limited to once
          per <tt>2*GRTT_sender</tt>. The
          "invalid_object_list" (if applicable) of the <tt>NORM_CMD(SQUELCH)</tt>
          message SHALL begin with the lowest "object_transport_id" from the
          invalid <tt>NORM_NACK</tt> messages received
          since the last <tt>NORM_CMD(SQUELCH)</tt>
          transmission. The list includes as many lower ordinal invalid
          "object_transport_ids" that can fit for the <tt>NORM_CMD(SQUELCH)</tt>
          payload size to less than or equal to the sender's <em>NormSegmentSize</em> parameter.
</p>
<a name="anchor31"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4.4"></a><h3>5.4.4.&nbsp;
Sender NORM_CMD(REPAIR_ADV) Generation</h3>

<p>When a NORM sender receives <tt>NORM_NACK</tt>
          messages from receivers via unicast transmission, it uses <tt>NORM_CMD(REPAIR_ADV)</tt> messages to advertise its
          accumulated repair state to the receiver set since the receiver set
          is not directly sharing their repair needs via multicast
          communication. A NORM sender implementation MAY use a separate port
          number from the <em>NormSession</em> port number
          as the source port for its transmissions. Thus NORM receivers can
          direct any unicast feedback messages to this separate sender port
          number, distinct from the NORM session (or destination) port number.
          Then, the NORM sender implementation can discriminate unicast
          feedback messages from multicast feedback messages when there is a
          mix of multicast and unicast feedback receivers. The <tt>NORM_CMD(REPAIR_ADV)</tt> message is multicast to
          the receiver set by the sender. The payload portion of this message
          has content in the same format as the <tt>NORM_NACK</tt>
          receiver message payload. Receivers are then able to perform
          feedback suppression in the same manner as with <tt>NORM_NACK</tt>
          messages directly received from other receivers. Note the sender
          does not merely retransmit NACK content it receives, but instead
          transmits a representation of its aggregated repair state. The
          transmission of <tt>NORM_CMD(REPAIR_ADV)</tt>
          messages are subject to the sender transmit rate limit and <em>NormSegmentSize</em> limitation. When the <tt>NORM_CMD(REPAIR_ADV)</tt> message is of maximum
          size, receivers SHALL consider the maximum ordinal transmission
          position value embedded in the message as the senders current
          transmission position and implicitly suppress requests for ordinally
          higher repair. For congestion control operation, the sender will
          also need to provide any information needed so dynamic congestion
          control feedback can be suppressed among receivers. This document
          specifies the NORM-CC Feedback Header Extension that is applied for
          baseline NORM-CC operation. If other congestion control mechanisms
          are used within a NORM implementation, other header extensions MAY
          be defined. Whatever content format is used for this purpose SHOULD
          ensure that maximum possible suppression state is conveyed to the
          receiver set.
</p>
<a name="anchor32"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5"></a><h3>5.5.&nbsp;
Additional Protocol Mechanisms</h3>

<p>In addition to the principal function of data content transmission
        and repair, there are some other protocol mechanisms to help NORM to
        adapt to network conditions and play fairly with other coexistent
        protocols.
</p>
<a name="GrttCollection"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.1"></a><h3>5.5.1.&nbsp;
Group Round-trip Time (GRTT) Collection</h3>

<p>For NORM receivers to appropriately scale backoff timeouts and
          the senders to use proper corresponding timeouts, the participants
          need to use a common timeout basis. Each NORM sender monitors the
          round-trip time of active receivers and determines the greatest
          group round-trip time. The sender advertises this GRTT estimate in
          every message it transmits so receivers have this value available
          for scaling their timers. To measure the current GRTT, the sender
          periodically sends <tt>NORM_CMD(CC)</tt> messages
          containing a locally generated timestamp. Receivers are expected to
          record this timestamp along with the time the <tt>NORM_CMD(CC)</tt>
          message is received. Then, when the receivers generate feedback
          messages to the sender, an adjusted version of the sender timestamp
          is embedded in the feedback message (<tt>NORM_NACK</tt>
          or <tt>NORM_ACK</tt>). The adjustment adds the
          amount of time the receiver held the timestamp before generating its
          response. Upon receipt of this adjusted timestamp, the sender is
          able to calculate the round-trip time to that receiver.
</p>
<p>The round-trip time for each receiver is fed into an algorithm
          that weights and smoothes the values for a conservative estimate of
          the GRTT. The algorithm and methodology are described in the <a class='info' href='#RFC5401'>Multicast NACK Building Block<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5401] in the section
          entitled "One-to-Many Sender GRTT Measurement". A conservative
          estimate helps guarantee feedback suppression at a small cost in
          overall protocol repair delay. The sender's current estimate of GRTT
          is advertised in the "grtt" field found in all NORM sender messages.
          The advertised GRTT is also limited to a minimum of the nominal
          inter-packet transmission time given the sender's current
          transmission rate and system clock granularity. The reason for this
          additional limit is to keep the receiver somewhat event-driven by
          making sure the sender has had adequate time to generate any
          response to repair requests from receivers given transmit rate
          limitations due to congestion control or configuration.
</p>
<p>When the NORM-CC Rate header extension is present in <tt>NORM_CMD(CC)</tt> messages, the receivers respond to
          <tt>NORM_CMD(CC)</tt> messages as described in
          <a class='info' href='#CongestionControl'>Section&nbsp;5.5.2<span> (</span><span class='info'>NORM Congestion Control Operation</span><span>)</span></a>, "NORM Congestion Control
          Operation". The <tt>NORM_CMD(CC)</tt> messages
          are periodically generated by the sender as described for congestion
          control operation. This provides for proactive, but controlled,
          feedback from the group in the form of <tt>NORM_ACK</tt>
          messages. This provides for GRTT feedback even if no <tt>NORM_NACK</tt> messages are being sent. If operating
          without congestion control in a closed network, the <tt>NORM_CMD(CC)</tt> messages MAY be sent periodically
          without the NORM-CC Rate header extension. In this case, receivers
          will only provide GRTT measurement feedback when <tt>NORM_NACK</tt> messages are generated since no
          <tt>NORM_ACK</tt> messages are generated. In this
          case, the <tt>NORM_CMD(CC)</tt> messages MAY be
          sent less frequently, perhaps as little as once per minute, to
          conserve network capacity. Note the NORM-CC Rate header extension
          MAY also be used to proactively solicit RTT feedback from the
          receiver group per congestion control operation even when the sender
          is not conducting congestion control rate adjustment. NORM operation
          without congestion control SHOULD be considered only in closed
          networks.
</p>
<a name="CongestionControl"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.2"></a><h3>5.5.2.&nbsp;
NORM Congestion Control Operation</h3>

<p>This section describes baseline congestion control operation for
          the NORM protocol (NORM-CC). The supporting NORM message formats and
          approach described here are an adaptation of the equation-based
          TCP-Friendly Multicast Congestion Control (TFMCC) approach<a class='info' href='#RFC4654'>[RFC4654]<span> (</span><span class='info'>Widmer, J. and M. Handley, &ldquo;TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification,&rdquo; August&nbsp;2006.</span><span>)</span></a>. This congestion control scheme is REQUIRED
          for operation within the general Internet unless the NORM
          implementation is adapted to use another IETF-sanctioned reliable
          multicast congestion control mechanism. With this TFMCC-based
          approach, the transmissions of NORM senders are controlled in a
          rate-based manner as opposed to window-based congestion control
          algorithms as in TCP. However, it is possible the NORM protocol
          message set MAY alternatively be used to support a window-based
          multicast congestion control scheme such as PGMCC. The details of
          such an alternative MAY be described separately or in a future
          revision of this document. In either case (rate-based TFMCC or
          window-based PGMCC), successful control of sender transmission
          depends upon collection of sender-to-receiver packet loss estimates
          and RTTs to identify the congestion control bottleneck path(s)
          within the multicast topology and adjust the sender rate
          accordingly. The receiver with loss and RTT estimates corresponding
          to the lowest resulting calculated transmission rate is identified
          as the "current limiting receiver" (CLR). In the case of a tie
          (where candidate CLRs are within 10% of the same calculated rate),
          the receiver with the largest RTT value SHOULD be designated as the
          CLR.
</p>
<p>As described in <a class='info' href='#TcpModel'>[TcpModel]<span> (</span><span class='info'>Padhye,  J., Firoiu, V., Towsley, D., and J. Kurose, &ldquo;Modeling TCP Throughput: A Simple Model and its Empirical           Validation,&rdquo; 1998.</span><span>)</span></a>, a steady-state
          sender transmission rate, to be "friendly" with competing TCP flows
          can be calculated as:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>                                 S
Rsender = ----------------------------------------------------------
        T_rtt*(sqrt((2/3)*p) + 12*sqrt((3/8)*p) * p * (1 + 32*(p^2)))</pre></div>
<p>where
</p>
<p><tt>S</tt> = nominal transmitted packet size.
          (In NORM, the "nominal" packet size can be determined by the sender
          as an exponentially weighted moving average (EWMA) of transmitted
          packet sizes to account for variable message sizes).
</p>
<p><tt>T_rtt</tt> = RTT estimate of the current
          "current limiting receiver" (CLR).
</p>
<p><tt>p</tt> = loss event fraction of the
          CLR.
</p>
<p>To support congestion control feedback collection and operation,
          the NORM sender periodically transmits <tt>NORM_CMD(CC)</tt>
          command messages. <tt>NORM_CMD(CC)</tt> messages
          are multiplexed with NORM data and repair transmissions and serve
          several purposes:
</p>
<p></p>
<ol class="text">
<li>Stimulate explicit feedback from the general receiver set to
              collect congestion control information.
</li>
<li>Communicate state to the receiver set on the sender's current
              congestion control status including details of the CLR.
</li>
<li>Initiate rapid (immediate) feedback from the CLR in order to
              closely track the dynamics of congestion control for the current
              worst path in the group multicast topology.
</li>
</ol>

<p>The format of the <tt>NORM_CMD(CC)</tt>
          message is described in <a class='info' href='#NORM_CMD'>Section&nbsp;4.2.3<span> (</span><span class='info'>NORM_CMD Messages</span><span>)</span></a> of this
          document. The <tt>NORM_CMD(CC)</tt> message
          contains information to allow measurement of RTTs, to inform the
          group of the congestion control CLR, and to provide feedback of
          individual RTT measurements to the receivers in the group. The
          <tt>NORM_CMD(CC)</tt> also provides for exciting
          feedback from OPTIONAL "potential limiting receiver" (PLR) nodes
          that might be determined administratively or possibly
          algorithmically based upon congestion control feedback. PLR nodes
          are receivers that have been identified to have potential for
          (perhaps soon) becoming the CLR and thus immediate, up-to-date
          feedback is beneficial for congestion control performance. The PLR
          list MAY be populated with a small number of receivers the sender
          identifies as approaching the CLR loss and delay conditions based on
          feedback from the group.
</p>
<a name="anchor33"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.2.1"></a><h3>5.5.2.1.&nbsp;
NORM_CMD(CC) Transmission</h3>

<p>The <tt>NORM_CMD(CC)</tt> message is
            transmitted periodically by the sender along with its normal data
            transmission. Note the repeated transmission of <tt>NORM_CMD(CC)</tt> messages MAY be initiated some
            time before transmission of user data content at session startup.
            This can be done to collect some estimation of the current state
            of the multicast topology with respect to group and individual RTT
            and congestion control state.
</p>
<p>A <tt>NORM_CMD(CC)</tt> message is
            immediately transmitted at sender startup. The interval of
            subsequent <tt>NORM_CMD(CC)</tt> message
            transmission is determined as follows:
</p>
<p></p>
<ol class="text">
<li>By default, the interval is set according to the current
                sender GRTT estimate. A startup initial value of <tt>GRTT_sender  = 0.5</tt> seconds is RECOMMENDED
                when no feedback has yet been received from the group.
</li>
<li>Until a CLR has been identified (based on previous receiver
                feedback) or when no data transmission is pending, the <tt>NORM_CMD(CC)</tt> interval is doubled up from
                its current interval to a maximum of once per 30 seconds. This
                results in a low duty cycle for <tt>NORM_CMD(CC)</tt>
                probing when no CLR is identified or there is no pending data
                to transmit.
</li>
<li>When a CLR has been identified (based on receiver feedback)
                and data transmission is pending, the probing interval is set
                to the RTT between the sender and the CLR (<tt>RTT_clr</tt>).
</li>
<li>Additionally, when the data transmission rate is low with
                respect to the <tt>RTT_clr</tt> interval
                used for probing, the implementation SHOULD ensure no more
                than one <tt>NORM_CMD(CC)</tt> message is
                sent per <tt>NORM_DATA</tt> message when
                there is data pending transmission. This ensures the
                transmission of this control message is not done to the
                exclusion of user data transmission.
</li>
</ol>

<p>The <tt>NORM_CMD(CC)</tt> "cc_sequence"
            field is incremented with each transmission of a <tt>NORM_CMD(CC)</tt> command. The greatest
            "cc_sequence" recently received by receivers is included in their
            feedback to the sender. This allows the sender to determine the
            age of feedback to assist in congestion avoidance.
</p>
<p>The NORM-CC Rate Header Extension is applied to the <tt>NORM_CMD(CC)</tt> message and the sender
            advertises its current transmission rate in the "send_rate" field.
            The rate information is used by receivers to initialize loss
            estimation during congestion control startup or restart.
</p>
<p>The "cc_node_list" contains a list of entries identifying
            receivers and their current congestion control state (status
            "flags", "rtt" and "loss" estimates). The list will be empty if
            the sender has not yet received any feedback from the group. If
            the sender has received feedback, the list will minimally contain
            an entry identifying the CLR. A <tt>NORM_FLAG_CC_CLR</tt>
            flag value is provided for the "cc_flags" field to identify the
            CLR entry. It is RECOMMENDED the CLR entry be the first in the
            list for implementation efficiency. Additional entries in the list
            are used to provide sender-measured individual RTT estimates to
            receivers in the group. The number of additional entries in this
            list is dependent upon the percentage of control traffic the
            sender application is willing to send with respect to user data
            message transmissions. More entries in the list will allow the
            sender to be more responsive to congestion control dynamics. The
            length of the list can be dynamically determined according to the
            current transmission rate and scheduling of <tt>NORM_CMD(CC)</tt>
            messages. The maximum length of the list corresponds to the
            sender's <em>NormSegmentSize</em> parameter for
            the session. The inclusion of additional entries in the list based
            on receiver feedback are prioritized with following rules:
</p>
<p></p>
<ol class="text">
<li>Receivers that have not yet been provided a RTT measurement
                get first priority. Of these, those with the greatest loss
                fraction receive precedence for list inclusion.
</li>
<li>Secondly, receivers that have previously been provided a
                RTT measurement are included with receivers yielding the
                lowest calculated congestion rate getting precedence.
</li>
</ol>

<p>There are "cc_flag" values in addition to <tt>NORM_FLAG_CC_CLR</tt>
            used for other congestion control functions. The <tt>NORM_FLAG_CC_PLR</tt> flag value is used to mark
            additional receivers from which the sender would like to have
            immediate, non-suppressed feedback. These can be receivers the
            sender algorithmically identified as potential future CLRs or have
            been pre-configured as potential congestion control points in the
            network. The <tt>NORM_FLAG_CC_RTT</tt>
            indicates the validity of the "cc_rtt" field for the associated
            receiver node. Normally, this flag will be set since the receivers
            in the list will typically be receivers from which the sender has
            received feedback. However, in the case the NORM sender has been
            pre-configured with a set of PLR nodes, feedback from those
            receivers might not have yet been collected and thus the "cc_rtt"
            field does not contain a valid value when this flag is not set.
            Similarly, a value of <tt>ZERO</tt> for the
            "cc_rate" field here MUST be treated as an invalid value and be
            ignored for the purposes of feedback suppression, etc.
</p>
<a name="anchor34"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.2.2"></a><h3>5.5.2.2.&nbsp;
NORM_CMD(CC) Feedback Response</h3>

<p>Receivers explicitly respond to <tt>NORM_CMD(CC)</tt>
            messages in the form of a <tt>NORM_ACK(RTT)</tt>
            message. The goal of the congestion control feedback is to
            determine the receivers with the lowest congestion control rates.
            Receivers marked as CLR or PLR nodes in the <tt>NORM_CMD(CC)</tt>
            "cc_node_list" immediately provide feedback in the form of a
            <tt>NORM_ACK</tt> to this message. When a
            <tt>NORM_CMD(CC)</tt> is received, non-CLR or
            non-PLR nodes initiate random feedback backoff timeouts similar to
            that used when the receiver initiates a repair cycle (see <a class='info' href='#NackProcedure'>Section&nbsp;5.3<span> (</span><span class='info'>Receiver NACK Procedure</span><span>)</span></a>) in response to detection of data
            loss. The backoff timeout for the congestion control response is
            generated as follows:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>T_backoff = RandomBackoff(K_backoff * GRTT_sender, GSIZE_sender)</pre></div>
<p>The "<tt>RandomBackoff()</tt>" algorithm
            provides a truncated exponentially distributed random number and
            is described in the <a class='info' href='#RFC5401'>Multicast NACK Building
            Block<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5401]. The same backoff factor, <tt>K_backoff = K_sender</tt>,
            as used with <tt> NORM_NACK</tt> suppression is
            generally RECOMMENDED. However, in cases where the application
            purposefully specifies a very small <tt>K_sender</tt>
            backoff factor to minimize the NACK repair process latency
            (trading off group size scalability), it is RECOMMENDED a larger
            backoff factor for congestion control feedback be maintained,
            since there can be a larger volume of congestion control feedback
            than NACKs in many cases and some congestion control feedback
            latency might be tolerable where reliable delivery latency is not.
            As previously noted, a backoff factor value of <tt>K_sender = 4</tt> is generally RECOMMENDED for ASM
            operation and <tt>K_sender = 6</tt> for SSM
            operation. A receiver SHALL cancel the backoff timeout and thus
            its pending transmission of a <tt>NORM_ACK(RTT)</tt>
            message under the following conditions:
</p>
<p></p>
<ol class="text">
<li>The receiver generates another feedback message (<tt>NORM_NACK</tt> or other <tt>NORM_ACK</tt>)
                before the congestion control feedback timeout expires (these
                messages will convey the current congestion control feedback
                information),
</li>
<li>A <tt>NORM_CMD(CC)</tt> or other
                receiver feedback with an ordinally greater "cc_sequence"
                field value is received before the congestion control feedback
                timeout expires (this is similar to the TFMCC feedback round
                number),
</li>
<li>When the <tt>T_backoff</tt> is greater
                than <tt>1*GRTT_sender</tt>. This prevents
                NACK implosion in the event of sender or network failure,
</li>
<li>"Suppressing" congestion control feedback is heard from
                another receiver (in a <tt>NORM_ACK</tt> or
                <tt>NORM_NACK</tt>) or via a <tt>NORM_CMD(REPAIR_ADV)</tt> message from the
                sender. The local receiver's feedback is "suppressed" if the
                rate of the competing feedback (<tt>Rfb</tt>)
                is sufficiently close to or less than the local receiver's
                calculated rate (<tt>Rcalc</tt>). The local
                receiver's feedback is canceled when <tt>Rcalc &gt; (0.9 * Rfb)</tt>.
                Also note receivers that have not yet received an RTT
                measurement from the sender are suppressed only by other
                receivers that have not yet measured RTT. Additionally,
                receivers whose RTT estimate has aged considerably (i.e., they
                haven't been included in the <tt>NORM_CMD(CC)</tt>
                "cc_node_list" in a long time) might wish to compete as a
                receiver with no prior RTT measurement after some long term
                expiration period.
</li>
</ol>

<p>When the backoff timer expires, the receiver SHALL generate a
            <tt>NORM_ACK(RTT)</tt> message to provide
            feedback to the sender and group. This message MAY be multicast to
            the group for most effective suppression in ASM topologies or
            unicast to the sender depending upon how the NORM protocol is
            deployed and configured.
</p>
<p>Whenever any feedback is generated (including this <tt>NORM_ACK(RTT)</tt> message), receivers include an
            adjusted version of the sender timestamp from the most recently
            received <tt>NORM_CMD(CC)</tt> message and its
            "cc_sequence" value in the corresponding <tt>NORM_ACK</tt>
            or <tt>NORM_NACK</tt> message fields. For
            NORM-CC operation, any generated feedback message SHALL also
            contain the NORM-CC Feedback header extension. The receiver
            provides its current "cc_rate" estimate, "cc_loss" estimate,
            "cc_rtt" if known, and any applicable "cc_flags" via this header
            extension.
</p>
<p>During <em>slow start</em> (when the
            receiver has not yet detected loss from the sender), the receiver
            uses a value equal to two times its measured rate from the sender
            in the "cc_rate" field. For steady-state congestion control
            operation, the receiver "cc_rate" value is from the equation-based
            value using its current loss event estimate and
            sender&lt;-&gt;receiver RTT information. (The <tt>GRTT_sender</tt>
            is used when the receiver has not yet measured its individual
            RTT).
</p>
<p>The "cc_loss" field value reflects the receiver's current loss
            event estimate with respect to the sender in question.
</p>
<p>When the receiver has a valid individual RTT measurement, it
            SHALL include this value in the "cc_rtt" field. The <tt>NORM_FLAG_CC_RTT</tt> MUST be set when the
            "cc_rtt" field is valid.
</p>
<p>After a congestion control feedback message is generated or
            when the feedback is suppressed, a non-CLR receiver begins a
            "holdoff" timeout period during which it will restrain itself from
            providing congestion control feedback, even if <tt>NORM_CMD(CC)</tt> messages are received from the
            sender (unless the receive becomes marked as a CLR or PLR node).
            The value of this holdoff timeout (<tt>T_ccHoldoff</tt>)
            period is:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>T_ccHoldoff = (K_sender * GRTT_sender)</pre></div>
<p>Thus, non-CLR receivers are constrained to providing explicit
            congestion control feedback once per <tt>K_sender*GRTT_sender</tt>
            intervals. However, as the session progresses, different receivers
            will be responding to different <tt>NORM_CMD(CC)</tt>
            messages and there will be relatively continuous feedback of
            congestion control information while the sender is active.
</p>
<a name="anchor35"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.2.3"></a><h3>5.5.2.3.&nbsp;
Congestion Control Rate Adjustment</h3>

<p>During steady-state operation, the sender will directly adjust
            its transmission rate to the rate indicated by the feedback from
            its currently selected CLR. As noted in <a class='info' href='#TfmccPaper'>[TfmccPaper]<span> (</span><span class='info'>Widmer, J. and M. Handley, &ldquo;Extending Equation-Based Congestion Control to Multicast           Applications,&rdquo; August&nbsp;2001.</span><span>)</span></a>, the estimation of parameters (loss
            and RTT) for the CLR will generally constrain the rate changes
            possible within acceptable bounds. For rate increases, the sender
            SHALL observe a maximum rate of increase of one packet per RTT at
            all times during steady-state operation.
</p>
<p>The sender processes congestion control feedback from the
            receivers and selects the CLR based on the lowest rate receiver.
            Receiver rates are either determined directly from the <em>slow start</em> "cc_rate" provided by the receiver
            in the NORM-CC Feedback header extension or by performing the
            equation-based calculation using individual RTT and loss estimates
            ("cc_loss") as feedback is received.
</p>
<p>The sender can calculate a current RTT for a receiver (<tt>RTT_rcvrNew</tt>) using the "grtt_response"
            timestamp included in feedback messages. When the "cc_rtt" value
            in a response is not valid, the sender simply uses this <tt>RTT_rcvrNew</tt> value as the receiver's current
            RTT (<tt>RTT_rcvr</tt>). For non-CLR and
            non-PLR receivers, the sender can use the "cc_rtt" value provided
            in the NORM-CC Feedback header extension as the receiver's
            previous RTT measurement (<tt>RTT_rcvrPrev</tt>)
            to smooth according to:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>RTT_rcvr = 0.5 * RTT_rcvrPrev + 0.5 * RTT_rcvrNew</pre></div>
<p>For CLR receivers where feedback is received more regularly,
            the sender SHOULD maintain a more smoothed RTT estimate upon new
            feedback from the CLR where:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>RTT_clr = 0.9 * RTT_clr + 0.1 * RTT_clrNew</pre></div>
<p>"<tt>RTT_clrNew</tt>" is the new RTT
            calculated from the timestamp in the feedback message received
            from the CLR. The <tt>RTT_clr</tt> is
            initialized to <tt>RTT_clrNew</tt> on the first
            feedback message received. Note the same procedure is observed by
            the sender for PLR receivers, and if a PLR is "promoted" to CLR
            status, the smoothed estimate can be continued.
</p>
<p>There are some additional periods besides steady-state
            operation to be considered in NORM-CC operation. These periods
            are:
</p>
<p></p>
<ol class="text">
<li>during session startup,
</li>
<li>when no feedback is received from the CLR, and
</li>
<li>when the sender has a break in data transmission.
</li>
</ol>

<p>During session startup, the congestion control operation SHALL
            observe a "slow start" procedure to quickly approach its fair
            bandwidth share. An initial sender startup rate is assumed
            where:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>Rinit = MIN(NormSegmentSize/GRTT_sender, NormSegmentSize) bytes/sec</pre></div>
<p>The rate is increased only when feedback is received from the
            receiver set. The "slow start" phase proceeds until any receiver
            provides feedback indicating loss has occurred. Rate increase
            during <em>slow start</em> is applied as:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>Rnew = Rrecv_min</pre></div>
<p>where <tt>Rrecv_min</tt> is the minimum
            reported receiver rate in the "cc_rate" field of congestion
            control feedback messages received from the group. Note during
            <em>slow start</em>, receivers use two times
            their measured rate from the sender in the "cc_rate" field of
            their feedback. Rate increase adjustment is limited to once per
            GRTT during slow start.
</p>
<p>If the CLR or any receiver intends to leave the group, it will
            set the <tt>NORM_FLAG_CC_LEAVE</tt> in its
            congestion control feedback message as an indication the sender
            SHOULD NOT select it as the CLR. When the CLR changes to a lower
            rate receiver, the sender SHOULD immediately adjust to the new
            lower rate. The sender is limited to increasing its rate at one
            additional packet per RTT towards any new, higher CLR rate.
</p>
<p>The sender SHOULD also track the age of the feedback it has
            received from the CLR by comparing its current "cc_sequence" value
            (<tt>Seq_sender</tt>) to the last "cc_sequence"
            value received from the CLR (<tt>Seq_clr</tt>).
            As the age of the CLR feedback increases with no new feedback, the
            sender SHALL begin reducing its rate once per <tt>RTT_clr</tt>
            as a congestion avoidance measure. The following algorithm is used
            to determine the decrease in sender rate (Rsender bytes/sec) as
            the CLR feedback, unexpectedly, excessively ages:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>Age = Seq_sender - Seq_clr;
if (Age &gt; 4) Rsender = Rsender * 0.5;</pre></div>
<p>This rate reduction is limited to the lower bound on NORM
            transmission rate. After <tt>NORM_ROBUST_FACTOR</tt>
            consecutive <tt>NORM_CMD(CC)</tt> rounds
            without any feedback from the CLR, the sender SHOULD assume the
            CLR has left the group and pick the receiver with the next lowest
            rate as the new CLR. Note this assumes the sender does not have
            explicit knowledge the CLR intentionally left the group. If no
            receiver feedback is received, the sender MAY wish to withhold
            further transmissions of <tt>NORM_DATA</tt>
            segments and maintain <tt>NORM_CMD(CC)</tt>
            transmissions only until feedback is detected. After such a CLR
            timeout, the sender will be transmitting with a minimal rate and
            SHOULD return to slow start as described here for a break in data
            transmission.
</p>
<p>When the sender has a break in its data transmission, it can
            continue to probe the group with <tt>NORM_CMD(CC)</tt>
            messages to maintain RTT collection from the group. This will
            enable the sender to quickly determine an appropriate CLR upon
            data transmission restart. However, the sender SHOULD
            exponentially reduce its target rate to be used for transmission
            restart as time since the break elapses. The target rate SHOULD be
            recalculated once per <tt>RTT_clr</tt> as:
</p><div style='display: table; width: 0; margin-left: auto; margin-right: auto'><pre>Rsender = Rsender * 0.5;</pre></div>
<p>If the minimum NORM rate is reached, the sender SHOULD set the
            <tt>NORM_FLAG_START</tt> flag in its <tt>NORM_CMD(CC)</tt> messages upon restart and the
            group SHOULD observe <em>slow start</em>
            congestion control procedures until any receiver experiences a new
            loss event.
</p>
<a name="PositiveAcknowledgment"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.3"></a><h3>5.5.3.&nbsp;
NORM Positive Acknowledgment Procedure</h3>

<p>NORM provides options for the source application to request
          positive acknowledgment (ACK) of <tt>NORM_CMD(FLUSH)</tt>
          and <tt>NORM_CMD(ACK_REQ)</tt> messages from
          members of the group. There are some specific acknowledgment
          requests defined for the NORM protocol and a range of acknowledgment
          request types left to be defined by the application. One predefined
          acknowledgment type is the <tt>NORM_ACK_FLUSH</tt>
          type. This acknowledgment is used to determine if receivers have
          achieved completion of reliable reception up through a specific
          logical transmission point with respect to the sender's sequence of
          transmission. The <tt>NORM_ACK_FLUSH</tt>
          acknowledgment MAY be used to assist in application flow control
          when the sender has information on a portion of the receiver set.
          Another predefined acknowledgment type is <tt>NORM_ACK(CC)</tt>
          used to explicitly provide congestion control feedback in response
          to <tt>NORM_CMD(CC)</tt> messages transmitted by
          the sender for NORM-CC operation. Note the <tt>NORM_ACK(CC)</tt>
          response does NOT follow the positive acknowledgment procedure
          described here. The <tt>NORM_CMD(ACK_REQ)</tt>
          and <tt>NORM_ACK</tt> messages contain an
          "ack_type" field to identify the type of acknowledgment requested
          and provided. A range of "ack_type" values is provided for
          application-defined use. While the application is responsible for
          initiating the acknowledgment request and interprets
          application-defined "ack_type" values, the acknowledgment procedure
          SHOULD be conducted within the protocol implementation to take
          advantage of timing and transmission scheduling information
          available to the NORM transport.
</p>
<p>The NORM positive acknowledgment procedure uses polling by the
          sender to query the receiver group for response. Note this polling
          procedure is not intended to scale to very large receiver groups,
          but could be used in large group setting to query a critical subset
          of the group. Either the <tt>NORM_CMD(ACK_REQ)</tt>,
          or when applicable, the <tt>NORM_CMD(FLUSH)</tt>
          message is used for polling and contains a list of <em>NormNodeIds</em> of the receivers expected to
          respond to the command. The list of receivers providing
          acknowledgment is determined by the source application with <em>a priori</em> knowledge of participating nodes or
          via some other application-level mechanism.
</p>
<p>The ACK process is initiated by the sender generating <tt>NORM_CMD(FLUSH)</tt> or <tt>NORM_CMD(ACK_REQ)</tt>
          messages in periodic rounds. For <tt>NORM_ACK_FLUSH</tt>
          requests, the <tt>NORM_CMD(FLUSH)</tt> contain a
          "object_transport_id" and "fec_payload_id" denoting the watermark
          transmission point for which acknowledgment is requested. This
          watermark transmission point is echoed in the corresponding fields
          of the <tt>NORM_ACK(FLUSH)</tt> message sent by
          the receiver in response. <tt>NORM_CMD(ACK_REQ)</tt>
          messages contain an "ack_id" field that is similarly echoed in
          response so the sender can match the response to the appropriate
          request.
</p>
<p>In response to the <tt>NORM_CMD(ACK_REQ)</tt>,
          the listed receivers randomly, with a uniform distribution, transmit
          <tt>NORM_ACK</tt> messages over a time window of
          (<tt>1*GRTT_sender</tt>). These <tt>NORM_ACK</tt> messages are typically unicast to the
          sender. (Note <tt>NORM_ACK(CC)</tt> messages
          SHALL be multicast or unicast in the same manner as <tt>NORM_NACK</tt> messages).
</p>
<p>The ACK process is self-limiting and avoids ACK implosion
          because:
</p>
<p></p>
<ol class="text">
<li>Only a single <tt>NORM_CMD(ACK_REQ)</tt>
              message is generated once per (<tt>2*GRTT_sender</tt>),
              and,
</li>
<li>The size of the "acking_node_list" of <em>NormNodeIds</em>
              from which acknowledgment is requested is limited to a maximum
              of the sender <em>NormSegmentSize</em>
              setting per round of the positive acknowledgment process.
</li>
</ol>

<p>Because the size of the included list is limited to the sender's
          <em>NormSegmentSize</em> setting, multiple <tt>NORM_CMD(ACK_REQ)</tt> rounds will sometimes be
          necessary to achieve responses from all receivers specified. The
          content of the attached <em>NormNodeId</em> list
          will be dynamically updated as this process progresses and <tt>NORM_ACK</tt> responses are received from the
          specified receiver set. As the sender receives valid responses
          (i.e., matching watermark point or "ack_id") from receivers, it
          SHALL eliminate those receivers from the subsequent <tt>NORM_CMD(ACK_REQ)</tt> message "acking_node_list"
          and add in any pending receiver <em>NormNodeIds</em>
          while keeping within the <em>NormSegmentSize</em>
          limitation of the list size. Each receiver is queried a maximum
          number of times (<tt>NORM_ROBUST_FACTOR</tt>, by
          default). Receivers not responding within this number of repeated
          requests are removed from the payload list to make room for other
          potential receivers pending acknowledgment. The transmission of the
          <tt>NORM_CMD(ACK_REQ)</tt> is repeated until no
          further responses are needed or until the repeat threshold is
          exceeded for all pending receivers. The transmission of <tt>NORM_CMD(ACK_REQ)</tt> or <tt>NORM_CMD(FLUSH)</tt>
          messages to conduct the positive acknowledgment process is
          multiplexed with ongoing sender data transmissions. However, the
          <tt>NORM_CMD(FLUSH)</tt> positive acknowledgment
          process MAY be interrupted in response to negative acknowledgment
          repair requests (NACKs) received from receivers during the
          acknowledgment period. The <tt>NORM_CMD(FLUSH)</tt>
          positive acknowledgment process is restarted for receivers pending
          acknowledgment once any the repairs have been transmitted.
</p>
<p>In the case of <tt>NORM_CMD(FLUSH)</tt>
          commands with an attached "acking_node_list", receivers will not ACK
          until they have received complete transmission of all data up to and
          including the given watermark transmission point. All receivers
          SHALL interpret the watermark point provided in the request NACK for
          repairs if needed as for <tt>NORM_CMD(FLUSH)</tt>
          commands with no attached "acking_node_list".
</p>
<a name="anchor36"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.5.4"></a><h3>5.5.4.&nbsp;
Group Size Estimate</h3>

<p>NORM sender messages contain a "gsize" field that is a
          representation of the group size and is used in scaling random
          backoff timer ranges. The use of the group size estimate within the
          NORM protocol does not demand a precise estimation and works
          reasonably well if the estimate is within an order of magnitude of
          the actual group size. By default, the NORM sender group size
          estimate MAY be administratively configured. Also, given the
          expected scalability of the NORM protocol for general use, a default
          value of 10,000 is RECOMMENDED for use as the group size estimate.
          It is also possible the group size MAY be algorithmically
          approximated from the volume of congestion control feedback messages
          based on the exponentially weighted random backoff. However, the
          specification of such an algorithm is currently beyond the scope of
          this document.
</p>
<a name="anchor37"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Configurable Elements</h3>

<p>The NORM protocol supports a modest number of configurable parameters
      that control operation. Most of these need only be set at NORM sender(s)
      and the configuration information is communicated to the receiver set in
      NORM header and/or header extension fields. A notable exception to this
      is the <tt>NORM_ROBUST_FACTOR</tt> that is presumed
      to be a common value preset among senders and receivers for a given NORM
      session. The following table summarizes these configurable elements:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left" width="25%"><col align="left" width="75%">
<tr><th align="left">Configurable Element</th><th align="left">Purpose</th></tr>
<tr>
<td align="left">Sender Initial GRTT Estimate (<tt>GRTT_sender</tt>)</td>
<td align="left">Sender's Initial estimate of greatest group round trip time.
        Affects timing of feedback suppression and sender command
        transmissions at sender startup.</td>
</tr>
<tr>
<td align="left">Backoff Factor (<tt>K_sender</tt>)</td>
<td align="left">Sender's scaling factor used for timer-based feedback
        suppression.</td>
</tr>
<tr>
<td align="left">Group Size Estimate (<tt>GSIZE_sender</tt>)</td>
<td align="left">Sender's rough estimate of receiver group size used in generation
        of random feedback backoff timeout.</td>
</tr>
<tr>
<td align="left"><tt>NORM_ROBUST_FACTOR</tt>&nbsp;</td>
<td align="left">Integer factor determining how persistently (i.e. robust) senders
        transmit repeated control messages and receivers self-initiate
        timeout-based NACKing in absence of sender activity.</td>
</tr>
<tr>
<td align="left">FEC Type ("fec_id")</td>
<td align="left">Sender FEC encoding type.</td>
</tr>
<tr>
<td align="left">Sender segment size (<tt>NormSegmentSize</tt>)</td>
<td align="left">Maximum size (in bytes) of the payload portion of <tt>NORM_DATA</tt> and other messages.</td>
</tr>
<tr>
<td align="left"><em>NormNodeId</em>&nbsp;</td>
<td align="left">Unique identifiers pre-assigned to all NORM session
        participants.</td>
</tr>
</table>
<br clear="all" />

<p>The sender-controlled GRTT estimate (referred to as <tt>GRTT_sender</tt> in this document) is used to set and
      scale various timers associated with NORM protocol operation. During
      steady-state operation, the sender probes the receiver set, adapts to
      the group round trip timing state, and advertises its estimate to the
      receiver set in "grtt" field of relevant NORM protocol messages.
      However, an initial value must be assumed at sender startup. A large
      initial estimate is conservative and safer with regards to preventing
      feedback implosion and starting up congestion control operation, but
      requires the sender and receivers to allocate more buffering resources
      for a given transmission rate (i.e. larger effective delay*bandwidth
      product) to maintain efficient operation. A default initial value of
      <tt>GRTT_sender = 0.5</tt> seconds is
      RECOMMENDED.
</p>
<p>The sender-controlled Backoff Factor (referred to a <tt>K_sender</tt> in this document) is used to scale
      protocol timers and contributes to the generation of the random backoff
      timeout value that facilitates timer-based feedback suppression. The
      sender advertises its configured Backoff Factor to the receiver set in
      the "backoff" field of applicable NORM messages and thus no receiver
      configuration is necessary. For ASM operation a default value of <tt>K_sender = 4</tt> is RECOMMENDED while for SSM operation
      a default value of <tt>K_sender = 6</tt> is
      RECOMMENDED. 
</p>
<p>The sender estimate of session Group Size (referred to as <tt>GSIZE_sender</tt> in this document) also plays a role in
      the random selection of feedback suppression timeout values. The sender
      advertises its configured Group Size estimate to the receiver set in the
      "gsize" field of applicable NORM messages and thus no receiver
      configuration is necessary. Only a rough estimate (i.e.
      "order-of-magnitude") is needed for effective feedback suppression and a
      default value of <tt>GSIZE_sender = 10,000</tt> is
      RECOMMENDED as a conservative estimate for most uses. 
</p>
<p>The <tt>NORM_ROBUST_FACTOR</tt> is an integer
      parameter that determines how persistently NORM senders transmit control
      message (<tt>NORM_CMD</tt> messages) such as
      end-of-transmission flushing, OPTIONAL positive acknowledgement
      requests, etc. Additionally, the receivers use their knowledge of <tt>NORM_ROBUST_FACTOR</tt> to determine when to consider a
      NORM sender inactive and MAY use the factor in determining how
      persistently to self-initiate repeated NACK repair requests upon such
      timeouts. This parameter is NOT communication in NORM protocol message
      headers and is presumed to be preset to a consistent value among sender
      and receivers for a given NORM session. A default value of <tt>NORM_ROBUST_FACTOR = 20</tt> is RECOMMENDED.
</p>
<p>Another NORM sender configuration element is the FEC Type used to
      encode <tt>NORM_DATA</tt> message content. The FEC
      type is communicated from the sender to the receiver set in the "fec_id"
      field of relevant NORM message headers. The "fec_id" value corresponds
      to an IANA-assigned value identifying the FEC encoding type as described
      in the <a class='info' href='#RFC5052'>FEC Building Block<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052]. Typically, a
      sender SHOULD use a consistent FEC encoding for its participation in a
      session to simply receiver state allocation and maintenance, but it
      implementations MAY vary the FEC encoding type on a per-object basis if
      necessary.
</p>
<p>The sender <em>NormSegmentSize</em> setting
      determines the maximum size of the payload portion of <tt>NORM_DATA</tt> and other messages that the sender
      transmits. Additionally the payload size of feedback messages from
      receivers to a given sender is limited to that sender's <em>NormSegmentSize</em>. The <em>NormSegmentSize</em>
      SHOULD be configured to be compatible with expected network MTU
      limitations, given the added overhead of NORM, UDP, and IP protocol
      message headers. Additionally, MTU Discovery MAY be employed by the
      sender to determine an appropriate <em>NormSegmentSize</em>.
      The <em>NormSegmentSize</em> for a given sender can
      be determined by receivers from the FEC Object Transmission Information
      (FTI) provided either in applied EXT_FTI header extensions or
      pre-configured session information.
</p>
<p>Although it is not technically a configurable element, the receivers
      MUST have FEC Object Transmission Information for transmitted <em>NormObjects</em> to properly buffer, decode, and
      reassemble the original content. For loosely organized NORM protocol
      sessions, the sender MAY apply the <tt>EXT_FTI</tt>
      Header Extension to <tt>NORM_DATA</tt> and <tt>NORM_INFO</tt> (if applicable) messages so that
      receivers can get this information without prior coordination. An
      implementation MAY also apply the <tt>EXT_FTI</tt>
      only to <tt>NORM_INFO</tt> messages for reduced
      overhead. Or, finally, applications MAY also provide the FTI out-of-band
      prior to sender transmission.
</p>
<p>Each participant in a NORM protocol session MUST be configured with a
      unique <em>NormNodeId</em> value. The <em>NormNodeId</em> value is used by receivers to identify
      the sender to which their NACK or other feedback messages are addressed
      and senders use the <em>NormNodeId</em> to
      differentiate receivers for purposes of congestion control and OPTIONAL
      positive acknowledgement collection. Assignment of unique <em>NormNodeId</em> values can be done via <em>a priori</em> coordination and/or use of a deconfliction
      mechanism external to the NORM protocol itself. The values of <tt>NORM_NODE_NONE = 0x00000000</tt> and <tt>NORM_NODE_ANY = 0xffffffff</tt> are reserved and MUST
      NOT be assigned to NORM participants.
</p>
<a name="anchor38"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Security Considerations</h3>

<p>The same security considerations that apply to the <a class='info' href='#RFC5401'>Multicast NACK<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Multicast Negative-Acknowledgment (NACK) Building Blocks,&rdquo; November&nbsp;2008.</span><span>)</span></a> [RFC5401], <a class='info' href='#RFC4654'>TFMCC<span> (</span><span class='info'>Widmer, J. and M. Handley, &ldquo;TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification,&rdquo; August&nbsp;2006.</span><span>)</span></a> [RFC4654], and <a class='info' href='#RFC5052'>FEC<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052]
      Building Blocks also apply to the NORM protocol. In addition to the
      vulnerabilities to which any IP and IP multicast protocol implementation
      are subject, malicious hosts might engage in excessive NACKing in an
      attempt to prevent the NORM sender(s) from making forward progress in
      reliable transmission. Receiver "join" and "service" policy enforcement
      as described in <a class='info' href='#ReceiverInitialization'>Section&nbsp;5.2<span> (</span><span class='info'>Receiver Initialization and Reception</span><span>)</span></a> can be
      applied if such activity is detected. The use of cryptographic
      authentication and/or confidentiality measures can be used to provide a
      more effective degree of protection from objectionable transmissions
      from unauthorized hosts. But in some cases, even with authentication,
      the NACK-based feedback of NORM can be exploited by replay attacks
      forcing the NORM sender to unnecessarily transmit repair information.
      This MAY be addressed in part with network layer IP security
      implementations that guard against this potential security exploitation
      or alternatively with a security mechanism using the <tt>EXT_AUTH</tt> header extension for similar purposes.
      Such security mechanisms SHOULD be deployed and used when available.
</p>
<p>The NORM protocol is compatible with the use of <a class='info' href='#RFC4301'>IP security (IPsec)<span> (</span><span class='info'>Kent, S. and K. Seo, &ldquo;Security Architecture for the Internet Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> [RFC4301] and the IPsec Encapsulating
      Security Payload (ESP) protocol or Authentication Header (AF) extension
      can be used to secure IP packets transmitted by NORM participants. A
      baseline approach to secure NORM operation using IPsec is described
      below. Compliant implementations of this specification are REQUIRED to
      be compatible with IPsec usage as described in <a class='info' href='#NormIPsec'>Section&nbsp;7.1<span> (</span><span class='info'>Baseline Secure NORM Operation</span><span>)</span></a>.
</p>
<p>Additionally, the <tt>EXT_AUTH</tt> header
      extension (HET = 1) is reserved for use by security mechanisms to
      provide an alternative form of authentication and/or encryption of NORM
      messages. The format of this header extension and its processing is
      outside the scope of this document and is to be communicated out-of-band
      as part of the session description. It is possible an <tt>EXT_AUTH</tt> implementation of MAY also provide for
      encryption of NORM message payloads as well as authentication. The use
      of this approach as compared to IPsec can allow for header compression
      techniques to be applied jointly to IP and NORM protocol headers. In
      cases where security analysis deems encryption of NORM protocol header
      content is beneficial or necessary, the aforementioned use of IPsec ESP
      might be more appropriate. If <tt>EXT_AUTH</tt> is
      present, whatever packet authentication checks that can be performed
      immediately upon reception of the packet MUST be performed before
      accepting the packet and performing any congestion control-related
      action on it. Some packet authentication schemes impose a delay of
      several seconds between when a packet is received and when the packet
      can be fully authenticated. Any appropriate congestion control related
      action MUST NOT be postponed by any such full packet authentication
      (i.e. authentication mechanisms MUST NOT result in poor congestion
      control behavior).
</p>
<p>Consideration MUST also be given to the potential for replay-attacks
      that would transplant authenticated packets from one NORM session to
      another to disrupt service. To avoid this potential, unique keys SHOULD
      be assigned on a per-session basis or NORM sender nodes SHOULD be
      configured to use unique "instance_id" identifiers managed as part of
      the security association for the sessions.
</p>
<p>Note NORM implementations can use the "sequence" field from the NORM
      Common Message Header to detect replay attacks. This can be accomplished
      if the NORM sender maintains state on actively NACKing receivers. A
      cache of such receiver state can be used to provide protection against
      NACK replay attacks. NORM receivers MUST also maintain similar state for
      protection against possible replay of other receiver messages in ASM
      operation as well. For example, a receiver could be suppressed from
      providing NACK or congestion control feedback by replay of certain
      receiver messages. For these reasons, authentication of NORM messages
      (e.g., via IPsec) SHOULD be applied for protection against similar
      attacks that use fabricated messages. Also, encryption of messages to
      provide confidentiality of application data and protect privacy of users
      MAY also be applied using IPsec or similar mechanisms.
</p>
<p>When applicable security measures are used, automated key management
      mechanisms such as those described in the <a class='info' href='#RFC3547'>Group
      Domain of Interpretation (GDOI)<span> (</span><span class='info'>Baugher, M., Weis, B., Hardjono, T., and H. Harney, &ldquo;The Group Domain of Interpretation,&rdquo; July&nbsp;2003.</span><span>)</span></a> [RFC3547], <a class='info' href='#RFC3830'>Multimedia Internet KEYing (MIKEY)<span> (</span><span class='info'>Arkko, J., Carrara, E., Lindholm, F., Naslund, M., and K. Norrman, &ldquo;MIKEY: Multimedia Internet KEYing,&rdquo; August&nbsp;2004.</span><span>)</span></a> [RFC3830] or <a class='info' href='#RFC4535'>Group Secure Association Key Management Protocol
      (GSAKMP)<span> (</span><span class='info'>Harney, H., Meth, U., Colegrove, A., and G. Gross, &ldquo;GSAKMP: Group Secure Association Key Management Protocol,&rdquo; June&nbsp;2006.</span><span>)</span></a> [RFC4535] specifications SHOULD be applied.
</p>
<p>While NORM does leverage FEC-based repair for scalability, this alone
      does not guarantee integrity of received data. Application-level
      integrity-checking of received data content is highly RECOMMENDED.
</p>
<a name="NormIPsec"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1"></a><h3>7.1.&nbsp;
Baseline Secure NORM Operation</h3>

<p>This section describes a baseline mode of secure NORM protocol
        operation based on application of the IPsec security protocol. This
        approach is documented here to provide a reference, interoperable
        secure mode of operation. Additional approaches to NORM security,
        including other forms of IPsec application, MAY be specified in the
        future. For example, the use of the EXT_AUTH header extension could
        enable NORM-specific authentication or security encapsulation headers
        similar to those of IPsec to be specified and inserted into the NORM
        protocol message headers. This would allow header compression
        techniques to be applied to IP and NORM protocol headers when needed
        in a similar fashion to <a class='info' href='#RFC3550'>RTP<span> (</span><span class='info'>Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;RTP: A Transport Protocol for Real-Time Applications,&rdquo; July&nbsp;2003.</span><span>)</span></a> [RFC3550] and as
        preserved in the specification for <a class='info' href='#RFC3711'>Secure Real
        Time Protocol (SRTP)<span> (</span><span class='info'>Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;The Secure Real-time Transport Protocol (SRTP),&rdquo; March&nbsp;2004.</span><span>)</span></a> [RFC3711].
</p>
<p>The baseline approach described is applicable to NORM operation
        configured for SSM (or SSM-like) operation where there is a single
        sender and the receivers are providing unicast feedback. This form of
        NORM operation allows for IPsec to be used with a manageable number of
        security associations (SA).
</p>
<a name="anchor39"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.1"></a><h3>7.1.1.&nbsp;
IPsec Approach</h3>

<p>For NORM one-to-many SSM operation with unicast feedback from
          receivers, each node SHALL be configured with two transport mode
          IPsec security associations and corresponding Security Policy
          Database (SPD) entries. One entry will be used for sender-to-group
          multicast packet authentication and optionally encryption while the
          other entry will be used to provide security for the unicast
          feedback messaging from the receiver(s) to the sender.
</p>
<p>The NORM sender SHALL use an IPsec SA configured for <a class='info' href='#RFC4303'>ESP protocol<span> (</span><span class='info'>Kent, S., &ldquo;IP Encapsulating Security Payload (ESP),&rdquo; December&nbsp;2005.</span><span>)</span></a> [RFC4303] operation with the option for
          data origination authentication enabled. It is also RECOMMENDED this
          IPsec ESP SA be also configured to provide confidentiality
          protection for IP packets containing NORM protocol messages. This is
          suggested to make the realization of complex replay attacks much
          more difficult. The encryption key for this SA SHALL be preplaced at
          the sender and receiver(s) prior to NORM protocol operation. Use of
          automated key management is RECOMMENDED as a rekey SHALL be REQUIRED
          prior to expiration of the sequence space for the SA. This is
          necessary so receivers can use the built-in IPsec replay attack
          protection possible for an IPsec SA with a single source (the NORM
          sender). Thus the receivers SHALL enable replay attack protection
          for this SA used to secure NORM sender traffic. An IPsec SPD entry
          MUST be configured to process outbound packets to the session
          (destination) address and UDP port number of the applicable (<em>NormSession</em>).
</p>
<p>The NORM receiver(s) MUST be configured with the SA and SPD entry
          to properly process the IPsec-secured packets from the sender. The
          NORM receiver(s) SHALL also use a common, second IPsec SA (common
          Security Parameter Index (SPI) and encryption key) configured for
          ESP operation with the option for data origination authentication
          enabled. Similar to the NORM sender, is RECOMMENDED this IPsec ESP
          SA be also configured to provide confidentiality protection for IP
          packets containing NORM protocol messages. The receivers MUST have
          an IPsec SPD entry configured to process outbound NORM/UDP packets
          directed to the NORM sender source address and port number using
          this second SA. To support NORM unicast feedback, the sender's
          transmission port number SHOULD be selected to be distinct from the
          multicast session port number to allow discrimination between
          unicast and multicast feedback messages when access to the IP
          destination address is not possible (e.g., a user-space NORM
          implementation). For processing of packets from receivers, the NORM
          sender SHALL be configured with this common, second SA (and the
          corresponding SPD entry needed) in order to properly process
          messages from the receiver.
</p>
<p>Multiple receivers using a common IPsec SA for traffic directed
          to the NORM sender (i.e., many-to-one) typically prevents the use of
          built-in IPsec replay attack protection by the NORM sender with
          current IPsec implementations. Thus the built-in IPsec replay attack
          protection for this second SA at the sender MUST be disabled unless
          the particular IPsec implementation manages its replay protection on
          a per-source basis. So, to support a fully secure mode of operation,
          the NORM sender implementation MUST provide replay attack protection
          based upon the "sequence" field of NORM protocol messages from
          receivers. This can be accomplished with high assurance of security,
          even with the limited size (16-bits) of this field, because
</p>
<p></p>
<ol class="text">
<li>NORM receiver NACK and non-CLR ACK feedback messages are
              sparse.
</li>
<li>The more frequent <tt>NORM_ACK</tt>
              feedback from CLR or PLR nodes are only a small set of receivers
              for which the sender needs to keep more persistent replay attack
              state.
</li>
<li><tt>NORM_NACK</tt> feedback messages
              preceding the sender's current repair window do not
              significantly impact protocol operation (generation of <tt>NORM_CMD(SQUELCH)</tt> is limited) and could be
              in fact ignored. This means the sender can prune any replay
              attack state that precedes the current repair window.
</li>
<li><tt>NORM_ACK</tt> messages correspond to
              either a specific sender "ack_id", the sender "cc_sequence" for
              ACKs sent in response to <tt>NORM_CMD(CC)</tt>,
              or the sender's current repair window in the case of ACKs sent
              in response to <tt>NORM_CMD(FLUSH)</tt>.
              Thus, the sender can prune any replay attack state for receivers
              that precede the current applicable sequence or repair window
              space.
</li>
</ol>

<p>The use of ESP confidentiality for secure NORM protocol operation
          makes it more difficult for adversaries to conduct any form of
          replay attacks. Additionally, a NORM sender implementation with
          access to the full ESP protocol header could also use the ESP
          sequence information to make replay attack protection even more
          robust by maintaining per-source sequence state. The design of this
          baseline security approach for NORM intentionally places any more
          complex processing state or processing (e.g. replay attack
          protection given multiple receivers) at the NORM sender since NORM
          receiver implementations might often need to be less complex.
</p>
<p>This baseline approach can be used for NORM protocol sessions
          with multiple senders if the SA pairs described are established for
          each sender. For small-sized groups, it is even possible
          many-to-many (ASM) IPsec configuration could be achieved where each
          participant uses a unique SA (with a unique SPI). This does not
          scale to larger group sizes given the complex set of SA and SPD
          entries each participant would need to maintain.
</p>
<p>It is anticipated in early deployments of this baseline approach
          to NORM security that key management will be conducted out-of-band
          with respect to NORM protocol operation. In the case of one-to-many
          NORM operation, it is possible receivers will retrieve keying
          information from a central server as needed or otherwise conduct
          group key updates with a similar centralized approach.
          Alternatively, it is possible with some key management schemes for
          rekey messages to be transmitted to the group as a message or
          transport object within the NORM reliable transfer session.
          Similarly, for group-wise communication sessions it is possible for
          potential group participants to request keying and/or rekeying as
          part of NORM communications. Additional specification is necessary
          to define an in-band key management scheme for NORM sessions perhaps
          using the mechanisms of the automated group key management
          specifications cited in this document.
</p>
<a name="anchor40"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.2"></a><h3>7.1.2.&nbsp;
IPsec Requirements</h3>

<p>In order to implement this secure mode of NORM protocol
          operation, the following IPsec capabilities are REQUIRED.
</p>
<a name="anchor41"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.2.1"></a><h3>7.1.2.1.&nbsp;
Selectors</h3>

<p>The implementation MUST be able to use the source address,
            destination address, protocol (UDP), and UDP port numbers as
            selectors in the SPD.
</p>
<a name="anchor42"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.2.2"></a><h3>7.1.2.2.&nbsp;
Mode</h3>

<p>IPsec in transport mode MUST be supported. The use of <a class='info' href='#RFC4301'>IPsec<span> (</span><span class='info'>Kent, S. and K. Seo, &ldquo;Security Architecture for the Internet Protocol,&rdquo; December&nbsp;2005.</span><span>)</span></a> [RFC4301] processing for secure NORM traffic
            MUST be configured such that unauthenticated packets are not
            received by the NORM protocol implementation.
</p>
<a name="anchor43"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.2.3"></a><h3>7.1.2.3.&nbsp;
Key Management</h3>

<p>An automated key management scheme for group key distribution
            and rekeying such as <a class='info' href='#RFC3547'>GDOI<span> (</span><span class='info'>Baugher, M., Weis, B., Hardjono, T., and H. Harney, &ldquo;The Group Domain of Interpretation,&rdquo; July&nbsp;2003.</span><span>)</span></a> [RFC3547], <a class='info' href='#RFC4535'>GSAKMP<span> (</span><span class='info'>Harney, H., Meth, U., Colegrove, A., and G. Gross, &ldquo;GSAKMP: Group Secure Association Key Management Protocol,&rdquo; June&nbsp;2006.</span><span>)</span></a> [RFC4535], or <a class='info' href='#RFC3830'>MIKEY<span> (</span><span class='info'>Arkko, J., Carrara, E., Lindholm, F., Naslund, M., and K. Norrman, &ldquo;MIKEY: Multimedia Internet KEYing,&rdquo; August&nbsp;2004.</span><span>)</span></a> [RFC3830] is RECOMMENDED for use. Relatively
            short-lived NORM sessions MAY be able to use Manual Keying with a
            single, preplaced key, particularly if <a class='info' href='#RFC4303'>Extended Sequence Numbering (ESN)<span> (</span><span class='info'>Kent, S., &ldquo;IP Encapsulating Security Payload (ESP),&rdquo; December&nbsp;2005.</span><span>)</span></a> [RFC4303] is
            available in the IPsec implementation used. Note it is possible
            for key update messages (e.g., the GDOI GROUPKEY-PUSH message) to
            be included as part of the NORM application reliable data
            transmission if appropriate interfaces are available between the
            NORM application and the key management daemon.
</p>
<a name="anchor44"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.2.4"></a><h3>7.1.2.4.&nbsp;
Security Policy</h3>

<p>Receivers MUST accept protocol messages only from the
            designated, authorized sender(s). Appropriate key management will
            provide encryption keys only to receivers authorized to
            participate in a designated session. The approach outlined here
            allows receiver sets to be controlled on a per-sender basis.
</p>
<a name="anchor45"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.2.5"></a><h3>7.1.2.5.&nbsp;
Authentication and Encryption</h3>

<p>Large NORM group sizes will necessitate some form of key
            management that does rely upon shared secrets. The GDOI and GSAKMP
            protocols mentioned here allow for certificate-based
            authentication. It is RECOMMENDED these certificates use IP
            addresses for authentication.
</p>
<a name="anchor46"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7.1.2.6"></a><h3>7.1.2.6.&nbsp;
Availability</h3>

<p>The IPsec requirements profile outlined here is commonly
            available on many potential NORM hosts. Configuration and
            operation of IPsec typically requires privileged user
            authorization. Automated key management implementations are
            typically configured with the privileges necessary to effect
            system IPsec configuration needed.
</p>
<a name="anchor47"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
IANA Considerations</h3>

<p>Values of NORM Header Extension Types, Stream Control Codes, and
      <tt>NORM_CMD</tt> message sub-types are subject to
      IANA registration. They are in the registry named "Reliable Multicast
      Transport (RMT) NORM Protocol Parameters" located at time of publication
      at:
</p>
<p><a href='http://www.iana.org/assignments/norm-parameters'>http://www.iana.org/assignments/norm-parameters</a>
</p>
<p>Note the reliable multicast building block components used by this
      specification also have their respective IANA considerations and those
      documents SHOULD be consulted accordingly. In particular, the FEC
      Building Block used by NORM does REQUIRE IANA registration of the FEC
      codecs used. The registration instructions for FEC codecs are provided
      in <a class='info' href='#RFC5052'>RFC 5052<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a>. It is possible
      additional extensions of the NORM protocol might be specified in the
      future (e.g., additional NORM message types) and additional registries
      be established at that time with appropriate IETF standards action.
</p>
<a name="anchor48"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1"></a><h3>8.1.&nbsp;
Explicit IANA Assignment Guidelines</h3>

<p>This document introduces three registries for the NORM Header
        Extension Types, Stream Control Codes and <tt>NORM_CMD</tt>
        Message sub-types. This section describes explicit IANA assignment
        guidelines for each of these.
</p>
<a name="anchor49"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1.1"></a><h3>8.1.1.&nbsp;
NORM Header Extension Types</h3>

<p>This document defines a registry for NORM Header Extensions named
          "NORM Header Extension Types".
</p>
<p>The NORM Header Extension Type field is an 8-bit value. The
          values of this field identify extended header content allowing the
          protocol functionality to be expanded to include additional features
          and operating modes. The values that can be assigned within the
          "NORM Header Extensions" registry are numeric indexes in the range
          {0, 255}, boundaries included. Values in the range {0,127} indicate
          variable length extended header fields while values in the range
          {128,255} indicate extensions of a fixed 4-byte length. This
          specification registers the following NORM Header Extension
          Types:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">Value</th><th align="left">Name</th><th align="left">Reference</th></tr>
<tr>
<td align="left">1</td>
<td align="left"><tt>EXT_AUTH</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><tt>EXT_CC</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">64</td>
<td align="left"><tt>EXT_FTI</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">128</td>
<td align="left"><tt>EXT_RATE</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
</table>
<br clear="all" />

<p>Requests for assignment of additional NORM Header Extension Type
          values are granted on a "Specification Required" basis as defined by
          <a class='info' href='#RFC5226'>IANA Guidelines<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a> [RFC5226]. Any such header
          extension specifications MUST include a description of protocol
          actions to be taken when the extension type is encountered by a
          protocol implementation not supporting that specific option. For
          example, it is often possible for protocol implementations to ignore
          unknown header extensions.
</p>
<a name="anchor50"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1.2"></a><h3>8.1.2.&nbsp;
NORM Stream Control Codes</h3>

<p>This document defines a registry for NORM Stream Control Codes
          named "NORM Stream Control Codes".
</p>
<p>NORM Stream Control Codes are 16-bit values that can be inserted
          within a <tt>NORM_OBJECT_STREAM</tt> delivery
          object to convey sequenced, out-of-band (with respect to the stream
          data) control signaling applicable to the referenced stream object.
          These control codes are to be delivered to the application or
          protocol implementation with reliable delivery, in-order with
          respect to the their inserted position within the stream. This
          specification registers the following NORM Stream Control Code:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">Value</th><th align="left">Name</th><th align="left">Reference</th></tr>
<tr>
<td align="left">0</td>
<td align="left"><tt>NORM_STREAM_END</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
</table>
<br clear="all" />

<p>Additional NORM Stream Control Code value assignment requests are
          granted on a "Specification Required" basis as defined by <a class='info' href='#RFC5226'>IANA Guidelines<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a> [RFC5226]. The full 16-bit space
          outside of the value assigned in this specification are available
          for future assignment. In addition to describing the control code's
          expected interpretation, such specifications MUST include a
          description of protocol actions to be taken when the control code is
          encountered by a protocol implementation not supporting that
          specific option.
</p>
<a name="anchor51"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8.1.3"></a><h3>8.1.3.&nbsp;
NORM_CMD Message Sub-types</h3>

<p>This document defines a registry for <tt>NORM_CMD</tt>
          message sub-types named "NORM Command Message Sub-types".
</p>
<p>The <tt>NORM_CMD</tt> message "sub-type" field
          is an 8-bit value with valid values in the range of 1-255. Note the
          value 0 is reserved to indicate an invalid <tt>NORM_CMD</tt>
          message sub-type. The current specification defines a number of
          <tt>NORM_CMD</tt> message sub-types senders can
          use to signal the receivers in various aspects of NORM protocol
          operation. This specification registers the following <tt>NORM_CMD</tt> Message Sub-types:
</p><table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">Value</th><th align="left">Name</th><th align="left">Reference</th></tr>
<tr>
<td align="left">0</td>
<td align="left">reserved</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left"><tt>NORM_CMD(FLUSH)</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><tt>NORM_CMD(EOT)</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><tt>NORM_CMD(SQUELCH)</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><tt>NORM_CMD(CC)</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><tt>NORM_CMD(REPAIR_ADV)</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><tt>NORM_CMD(ACK_REQ)</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><tt>NORM_CMD(APPLICATION)</tt>&nbsp;</td>
<td align="left">This specification</td>
</tr>
</table>
<br clear="all" />

<p>Future specifications extending NORM MAY define additional <tt>NORM_CMD</tt> messages to enhance protocol
          functionality. <tt>NORM_CMD</tt> message sub-type
          value assignment requests are granted on a "Specification Required"
          basis as defined by <a class='info' href='#RFC5226'>IANA Guidelines<span> (</span><span class='info'>Narten, T. and H. Alvestrand, &ldquo;Guidelines for Writing an IANA Considerations Section in RFCs,&rdquo; May&nbsp;2008.</span><span>)</span></a> [RFC5226].
          In addition to describing the command sub-type's expected
          interpretation, specifications MUST include a description of
          protocol actions to be taken when the command is encountered by a
          protocol implementation not supporting that specific option.
</p>
<p>This specification already defines an "application-defined"
          <tt>NORM_CMD</tt> message sub-type for use at the
          discretion of individual applications using NORM for transport.
          These "application-defined" commands are suitable for many
          application-specific purposes and do not involve standards action.
          In any case, such additional messages SHALL be subject to the same
          congestion control constraints as the existing NORM sender message
          set.
</p>
<a name="anchor52"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Suggested Use</h3>

<p>The present NORM protocol is seen as useful tool for the reliable
      data transfer over generic IP multicast services. It is not the
      intention of the authors to suggest it is suitable for supporting all
      envisioned multicast reliability requirements. NORM provides a simple
      and flexible framework for multicast applications with a degree of
      concern for network traffic implosion and protocol overhead efficiency.
      NORM-like protocols have been successfully demonstrated within the MBone
      for bulk data dissemination applications, including weather satellite
      compressed imagery updates servicing a large group of receivers and a
      generic web content reliable "push" application.
</p>
<p>In addition, this framework approach has some design features making
      it attractive for bulk transfer in asymmetric and wireless internetwork
      applications. NORM is capable of successfully operating independent of
      network structure and in environments with high packet loss, delay, and
      out-of-order delivery. Hybrid proactive/reactive FEC-based repairing
      improve protocol performance in some multicast scenarios. A sender-only
      repair approach often makes additional engineering sense in asymmetric
      networks. NORM's unicast feedback capability is suitable for use in
      asymmetric networks or in networks where only unidirectional multicast
      routing/delivery service exists. Asymmetric architectures supporting
      multicast delivery are likely to make up an important portion of the
      future Internet structure (e.g., direct broadcast satellite (DBS) or
      cable and public-switched telephone network (PSTN) hybrids, etc) and
      efficient, reliable bulk data transfer will be an important capability
      for servicing large groups of subscribed receivers.
</p>
<a name="ProtocolChanges"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.10"></a><h3>10.&nbsp;
Changes from RFC3940</h3>

<p>This section lists the changes between the Experimental version of
      this specification, <a class='info' href='#RFC3940'>RFC
      3940<span> (</span><span class='info'>Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol,&rdquo; November&nbsp;2004.</span><span>)</span></a>, and this version:
</p>
<p></p>
<ol class="text">
<li>Removal of the <tt>NORM_FLAG_MSG_START</tt>
          for <tt>NORM_OBJECT_STREAM</tt>, replacing it
          with the "payload_msg_start" field in the FEC-encoded preamble of
          the <tt>NORM_OBJECT_STREAM NORM_DATA</tt>
          payload,
</li>
<li>Definition of IANA registry for header extension and other
          assignments,
</li>
<li>Removal of file blocking scheme description now specified in the
          <a class='info' href='#RFC5052'>FEC Building Block document<span> (</span><span class='info'>Watson, M., Luby, M., and L. Vicisano, &ldquo;Forward Error Correction (FEC) Building Block,&rdquo; August&nbsp;2007.</span><span>)</span></a> [RFC5052],
</li>
<li>Removal of restriction of NORM receiver feedback message rate to
          local NORM sender rate (This caused congestion control failures in
          high speed operation. The extremely low feedback rate of the NORM
          protocol as compared to TCP avoids any resultant impact to the
          network as shown in <a class='info' href='#Mdpcc'>[Mdpcc]<span> (</span><span class='info'>Adamson,  B. and J. Macker, &ldquo;A TCP-Friendly, Rate-based Mechanism for NACK-Oriented           Reliable Multicast Congestion Control,&rdquo; November&nbsp;2001.</span><span>)</span></a>),
</li>
<li>Correction of errors in some message format descriptions, and
</li>
<li>Correction of inconsistency in specification of the inactivity
          timeout.
</li>
<li>Addition of IPsec secure mode description with IPsec
          requirements.
</li>
<li>Addition of the EXT_AUTH header extension definition.
</li>
<li>Clarification of interpretation of "Source Block Length" when FEC
          codes are arbitrarily shortened by the sender.
</li>
</ol>

<a name="anchor53"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.11"></a><h3>11.&nbsp;
Acknowledgments</h3>

<p>(and these are not Negative)
</p>
<p>The authors would like to thank Rick Jones, Vincent Roca, Rod Walsh,
      Toni Paila, Michael Luby, and Joerg Widmer for their valuable input and
      comments on this document. The authors would also like to thank the RMT
      working group chairs, Roger Kermode and Lorenzo Vicisano, for their
      support in development of this specification, and Sally Floyd for her
      early input into this document.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.12"></a><h3>12.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC1112">[RFC1112]</a></td>
<td class="author-text"><a href="mailto:deering@PESCADERO.STANFORD.EDU">Deering, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc1112">Host extensions for IP multicasting</a>,&rdquo; STD&nbsp;5, RFC&nbsp;1112, August&nbsp;1989 (<a href="http://www.rfc-editor.org/rfc/rfc1112.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4301">[RFC4301]</a></td>
<td class="author-text">Kent, S. and K. Seo, &ldquo;<a href="http://tools.ietf.org/html/rfc4301">Security Architecture for the Internet Protocol</a>,&rdquo; RFC&nbsp;4301, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4301.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4303">[RFC4303]</a></td>
<td class="author-text">Kent, S., &ldquo;<a href="http://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>,&rdquo; RFC&nbsp;4303, December&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc4303.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4607">[RFC4607]</a></td>
<td class="author-text">Holbrook, H. and B. Cain, &ldquo;<a href="http://tools.ietf.org/html/rfc4607">Source-Specific Multicast for IP</a>,&rdquo; RFC&nbsp;4607, August&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4607.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4654">[RFC4654]</a></td>
<td class="author-text">Widmer, J. and M. Handley, &ldquo;<a href="http://tools.ietf.org/html/rfc4654">TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification</a>,&rdquo; RFC&nbsp;4654, August&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4654.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5052">[RFC5052]</a></td>
<td class="author-text">Watson, M., Luby, M., and L. Vicisano, &ldquo;<a href="http://tools.ietf.org/html/rfc5052">Forward Error Correction (FEC) Building Block</a>,&rdquo; RFC&nbsp;5052, August&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc5052.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5226">[RFC5226]</a></td>
<td class="author-text">Narten, T. and H. Alvestrand, &ldquo;<a href="http://tools.ietf.org/html/rfc5226">Guidelines for Writing an IANA Considerations Section in RFCs</a>,&rdquo; BCP&nbsp;26, RFC&nbsp;5226, May&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5226.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5401">[RFC5401]</a></td>
<td class="author-text">Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;<a href="http://tools.ietf.org/html/rfc5401">Multicast Negative-Acknowledgment (NACK) Building Blocks</a>,&rdquo; RFC&nbsp;5401, November&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5401.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>12.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="FecHybrid">[FecHybrid]</a></td>
<td class="author-text">Gossink, D. and <a href="mailto:">J. Macker</a>, &ldquo;Reliable Multicast and Integrated Parity Retransmission with
          Channel Estimation,&rdquo; IEEE Globecomm &nbsp;, 1998.</td></tr>
<tr><td class="author-text" valign="top"><a name="McastFeedback">[McastFeedback]</a></td>
<td class="author-text">Nonnenmacher, J. and <a href="mailto:">E. Biersack</a>, &ldquo;Optimal Multicast Feedback,&rdquo; IEEE INFOCOM, &nbsp;p. 964, March/April&nbsp;1998.</td></tr>
<tr><td class="author-text" valign="top"><a name="MdpToolkit">[MdpToolkit]</a></td>
<td class="author-text">Macker,  J. and <a href="mailto:">B. Adamson</a>, &ldquo;The Multicast Dissemination Protocol (MDP) Toolkit,&rdquo; Proc. IEEE MILCOM&nbsp;, October&nbsp;1999.</td></tr>
<tr><td class="author-text" valign="top"><a name="Mdpcc">[Mdpcc]</a></td>
<td class="author-text">Adamson,  B. and <a href="mailto:">J. Macker</a>, &ldquo;A TCP-Friendly, Rate-based Mechanism for NACK-Oriented
          Reliable Multicast Congestion Control,&rdquo; Proc. IEEE GLOBECOMM&nbsp;, November&nbsp;2001.</td></tr>
<tr><td class="author-text" valign="top"><a name="NormFeedback">[NormFeedback]</a></td>
<td class="author-text"><a href="mailto:">Adamson, B.</a> and J. Macker, &ldquo;Quantitative Prediction of NACK-Oriented Reliable Multicast
          (NORM) Feedback,&rdquo; IEEE MILCOM&nbsp;, October&nbsp;2002.</td></tr>
<tr><td class="author-text" valign="top"><a name="PgmccPaper">[PgmccPaper]</a></td>
<td class="author-text">Rizzo, L., &ldquo;pgmcc: A TCP-Friendly Single-Rate Multicast Congestion
          Control Scheme,&rdquo; ACM SIGCOMM&nbsp;, August&nbsp;2000.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2357">[RFC2357]</a></td>
<td class="author-text"><a href="mailto:mankin@isi.edu">Mankin, A.</a>, <a href="mailto:allyn@mci.net">Romanov, A.</a>, <a href="mailto:sob@harvard.edu">Bradner, S.</a>, and <a href="mailto:vern@ee.lbl.gov">V. Paxson</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2357">IETF Criteria for Evaluating Reliable Multicast Transport and Application Protocols</a>,&rdquo; RFC&nbsp;2357, June&nbsp;1998 (<a href="http://www.rfc-editor.org/rfc/rfc2357.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2357.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2357.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2974">[RFC2974]</a></td>
<td class="author-text">Handley, M., Perkins, C., and E. Whelan, &ldquo;<a href="http://tools.ietf.org/html/rfc2974">Session Announcement Protocol</a>,&rdquo; RFC&nbsp;2974, October&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2974.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3048">[RFC3048]</a></td>
<td class="author-text">Whetten, B., Vicisano, L., Kermode, R., Handley, M., Floyd, S., and M. Luby, &ldquo;<a href="http://tools.ietf.org/html/rfc3048">Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer</a>,&rdquo; RFC&nbsp;3048, January&nbsp;2001 (<a href="http://www.rfc-editor.org/rfc/rfc3048.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3269">[RFC3269]</a></td>
<td class="author-text">Kermode, R. and L. Vicisano, &ldquo;<a href="http://tools.ietf.org/html/rfc3269">Author Guidelines for Reliable Multicast Transport (RMT) Building Blocks and Protocol Instantiation documents</a>,&rdquo; RFC&nbsp;3269, April&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3269.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3453">[RFC3453]</a></td>
<td class="author-text">Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, &ldquo;<a href="http://tools.ietf.org/html/rfc3453">The Use of Forward Error Correction (FEC) in Reliable Multicast</a>,&rdquo; RFC&nbsp;3453, December&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3453.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3547">[RFC3547]</a></td>
<td class="author-text">Baugher, M., Weis, B., Hardjono, T., and H. Harney, &ldquo;<a href="http://tools.ietf.org/html/rfc3547">The Group Domain of Interpretation</a>,&rdquo; RFC&nbsp;3547, July&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3547.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3550">[RFC3550]</a></td>
<td class="author-text">Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, &ldquo;<a href="http://tools.ietf.org/html/rfc3550">RTP: A Transport Protocol for Real-Time Applications</a>,&rdquo; STD&nbsp;64, RFC&nbsp;3550, July&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3550.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc3550.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc3550.pdf">PDF</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3711">[RFC3711]</a></td>
<td class="author-text">Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, &ldquo;<a href="http://tools.ietf.org/html/rfc3711">The Secure Real-time Transport Protocol (SRTP)</a>,&rdquo; RFC&nbsp;3711, March&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3711.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3830">[RFC3830]</a></td>
<td class="author-text">Arkko, J., Carrara, E., Lindholm, F., Naslund, M., and K. Norrman, &ldquo;<a href="http://tools.ietf.org/html/rfc3830">MIKEY: Multimedia Internet KEYing</a>,&rdquo; RFC&nbsp;3830, August&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3830.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3940">[RFC3940]</a></td>
<td class="author-text">Adamson, B., Bormann, C., Handley, M., and J. Macker, &ldquo;<a href="http://tools.ietf.org/html/rfc3940">Negative-acknowledgment (NACK)-Oriented Reliable Multicast (NORM) Protocol</a>,&rdquo; RFC&nbsp;3940, November&nbsp;2004 (<a href="http://www.rfc-editor.org/rfc/rfc3940.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4535">[RFC4535]</a></td>
<td class="author-text">Harney, H., Meth, U., Colegrove, A., and G. Gross, &ldquo;<a href="http://tools.ietf.org/html/rfc4535">GSAKMP: Group Secure Association Key Management Protocol</a>,&rdquo; RFC&nbsp;4535, June&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4535.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4566">[RFC4566]</a></td>
<td class="author-text">Handley, M., Jacobson, V., and C. Perkins, &ldquo;<a href="http://tools.ietf.org/html/rfc4566">SDP: Session Description Protocol</a>,&rdquo; RFC&nbsp;4566, July&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4566.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5445">[RFC5445]</a></td>
<td class="author-text">Watson, M., &ldquo;<a href="http://tools.ietf.org/html/rfc5445">Basic Forward Error Correction (FEC) Schemes</a>,&rdquo; RFC&nbsp;5445, March&nbsp;2009 (<a href="http://www.rfc-editor.org/rfc/rfc5445.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RmComparison">[RmComparison]</a></td>
<td class="author-text">Pingali, S., <a href="mailto:">Towsley, D.</a>, and <a href="mailto:">J. Kurose</a>, &ldquo;A Comparison of Sender-Initiated and Receiver-Initiated
          Reliable Multicast Protocols,&rdquo; Proc. INFOCOMM,&nbsp;San Francisco CA, October&nbsp;1993.</td></tr>
<tr><td class="author-text" valign="top"><a name="TcpModel">[TcpModel]</a></td>
<td class="author-text">Padhye,  J., Firoiu, V., Towsley, D., and J. Kurose, &ldquo;Modeling TCP Throughput: A Simple Model and its Empirical
          Validation,&rdquo; ACM SIGCOMM&nbsp;, 1998.</td></tr>
<tr><td class="author-text" valign="top"><a name="TfmccPaper">[TfmccPaper]</a></td>
<td class="author-text">Widmer, J. and <a href="mailto:">M. Handley</a>, &ldquo;Extending Equation-Based Congestion Control to Multicast
          Applications,&rdquo; ACM SIGCOMM&nbsp;, August&nbsp;2001.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Brian Adamson</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Naval Research Laboratory</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Washington, DC  20375</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:adamson@itd.nrl.navy.mil">adamson@itd.nrl.navy.mil</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Carsten Bormann</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Universitaet Bremen TZI</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Postfach 330440</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">D-28334 Bremen</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Germany</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:cabo@tzi.org">cabo@tzi.org</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Mark Handley</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">University College London</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Gower Street</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">London  WC1E 6BT</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">UK</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:M.Handley@cs.ucl.ac.uk">M.Handley@cs.ucl.ac.uk</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Joe Macker</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Naval Research Laboratory</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Washington, DC  20375</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:macker@itd.nrl.navy.mil">macker@itd.nrl.navy.mil</a></td></tr>
</table>
</body></html>
