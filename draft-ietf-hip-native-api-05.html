<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Basic Socket Interface Extensions for Host Identity Protocol (HIP)</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Basic Socket Interface Extensions for Host Identity Protocol (HIP)">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Host Identity Protocol</td><td class="header">M. Komu</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Helsinki Institute for Information</td></tr>
<tr><td class="header">Intended status: Experimental</td><td class="header">Technology</td></tr>
<tr><td class="header">Expires: January 15, 2009</td><td class="header"> Henderson</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">The Boeing Company</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">July 14, 2008</td></tr>
</table></td></tr></table>
<h1><br />Basic Socket Interface Extensions for Host Identity Protocol (HIP)<br />draft-ietf-hip-native-api-05</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.
This document may not be modified,
and derivative works of it may not be created,
except to publish it as an RFC and to translate it into languages other
than English.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on January 15, 2009.</p>

<h3>Abstract</h3>

<p>This document defines extensions to the current sockets API for
     Host Identity Protocol (HIP). The extensions focus on the use of
     public-key based identifiers discovered via DNS resolution, but
     define also interfaces for manual bindings between HITs and
     locators.  With the extensions, the application can also support
     more relaxed security models where the communication can be
     non-HIP based, according to local policies. The extensions in
     document are experimental and provide basic tools for
     futher experimentation with policies.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#sec:intro">1.</a>&nbsp;
Introduction<br />
<br />
<a href="#sec:terminology">2.</a>&nbsp;
Terminology<br />
<br />
<a href="#sec:api_overview">3.</a>&nbsp;
API Overview<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:resolver">3.1.</a>&nbsp;
Interaction with the Resolver<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:no-resolver">3.2.</a>&nbsp;
Interaction without a Resolver<br />
<br />
<a href="#sec:syntax">4.</a>&nbsp;
API Syntax and Semantics<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:sock">4.1.</a>&nbsp;
Socket Family and Address Structure Extensions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:getaddrinfo">4.2.</a>&nbsp;
Extensions to Resolver Data Structures<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:resolver_usage">4.2.1.</a>&nbsp;
Resolver Usage<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:getsock">4.3.</a>&nbsp;
The Use of getsockname and getpeername Functions<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:validate">4.4.</a>&nbsp;
Validating HITs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor1">4.5.</a>&nbsp;
Source HIT Selection by the System<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:explicit">4.6.</a>&nbsp;
Explicit Handling of Locators<br />
<br />
<a href="#anchor2">5.</a>&nbsp;
Summary of New Definitions<br />
<br />
<a href="#sec:iana">6.</a>&nbsp;
IANA Considerations<br />
<br />
<a href="#sec:security">7.</a>&nbsp;
Security Considerations<br />
<br />
<a href="#anchor3">8.</a>&nbsp;
Contributors<br />
<br />
<a href="#sec:acknowledgements">9.</a>&nbsp;
Acknowledgements<br />
<br />
<a href="#rfc.references1">10.</a>&nbsp;
Normative References<br />
<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="sec:intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
This document defines C-based sockets Application Programming
Interface (API) extensions for handling HIP-based identifiers
explicitly in HIP-aware applications. It is up to the applications, or
high-level programming languages or libraries, to manage the
identifiers. The extensions in this document are mainly related to the
use case in which a DNS resolution step has occurred prior to the
creation of a new socket, and assumes that the system has cached
or is otherwise able to resolve identifiers to locators (IP addresses).
The DNS extensions for HIP are described in <a class='info' href='#RFC5205'>[RFC5205]<span> (</span><span class='info'>Nikander, P. and J. Laganier, &ldquo;Host Identity Protocol (HIP) Domain Name System (DNS) Extensions,&rdquo; April&nbsp;2008.</span><span>)</span></a>.
The extensions also cover the case in which an application may want
to explicitly provide suggested locators with the identifiers, including
supporting the opportunistic case in which the system does not know
the peer host identity.

</p>
<p>The Host Identity Protocol (HIP) <a class='info' href='#RFC4423'>[RFC4423]<span> (</span><span class='info'>Moskowitz, R. and P. Nikander, &ldquo;Host Identity Protocol (HIP) Architecture,&rdquo; May&nbsp;2006.</span><span>)</span></a> proposes
a new cryptographic namespace by separating the roles of end-point
identifiers and locators by introducing a new namespace to the
TCP/IP stack. SHIM6 <a class='info' href='#I-D.ietf-shim6-proto'>[I&#8209;D.ietf&#8209;shim6&#8209;proto]<span> (</span><span class='info'>Nordmark, E. and M. Bagnulo, &ldquo;Shim6: Level 3 Multihoming Shim Protocol for IPv6,&rdquo; February&nbsp;2009.</span><span>)</span></a> is another
protocol based on identity-locator split.
Note that the APIs specified in this document are specific to HIP. However,
the APIs here have been designed as much as possible so
as not to preclude its use with other protocols. The use of these APIs with
other protocols is, nevertheless, for further study.

</p>
<p>
Applications can observe the HIP layer and its identifiers in the
networking stacks with varying degrees of visibility. <a class='info' href='#I-D.ietf-hip-applications'>[I&#8209;D.ietf&#8209;hip&#8209;applications]<span> (</span><span class='info'>Henderson, T., Nikander, P., and M. Komu, &ldquo;Using the Host Identity Protocol with Legacy Applications,&rdquo; July&nbsp;2008.</span><span>)</span></a> discusses the lowest levels
of visibility in which applications are completely unaware of
the underlying HIP layer. Such HIP-unaware applications in some circumstances use HIP-based
identifiers, such as LSIs or HITs, instead of IPv4 or IPv6 addresses
and cannot observe the identifier-locator bindings.

</p>
<p>
This document specifies extensions to <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a> to
define a new socket address family, AF_HIP. The macro AF_HIP is used
as an alias for PF_HIP in this document because the distinction
between AF and PF has been lost in practice.  The extensions also
describe a new socket address structure for sockets using Host
Identity Tags (HITs) explicitly and describe how the socket calls
in <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a> are adapted or extended as a result.

</p>
<p>Some applications may accept incoming communications from any
identifier. Other applications may initiate outgoing communications
without the knowledge of the peer identifier in Opportunistic Mode <a class='info' href='#RFC5201'>[RFC5201]<span> (</span><span class='info'>Moskowitz, R., Nikander, P., Jokela, P., and T. Henderson, &ldquo;Host Identity Protocol,&rdquo; April&nbsp;2008.</span><span>)</span></a> by just relying on a peer locator.  This
document describes how to address both situations using "wildcards"
as described later in this document.

</p>
<p>There are two related API documents. Multihoming and explicit
   locator-handling related APIs are defined in <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a>. IPsec related policy
   attributes and channel bindings APIs are defined in <a class='info' href='#I-D.ietf-btns-c-api'>[I&#8209;D.ietf&#8209;btns&#8209;c&#8209;api]<span> (</span><span class='info'>Richardson, M., Williams, N., Komu, M., and S. Tarkoma, &ldquo;C-Bindings for IPsec Application Programming Interfaces,&rdquo; March&nbsp;2009.</span><span>)</span></a>. Most of the extensions defined in this
   document can be used independently of the two mentioned related API
   documents.

</p>
<p>
The identity-locator split introduced by HIP introduces some policy
related challenges with datagram oriented sockets, opportunistic mode,
and manual bindings between HITs and locators.  The extensions in this
document are of experimental nature and provide basic tools for
experimenting with policies. Policy related issues are left for
further experimentation.

</p>
<p>
To recap, the extensions in this document have three goals. The first goal
is to allow HIP-aware applications to open sockets to other hosts based on
the HITs alone, presuming that the underlying system can resolve the HITs
to addresses used for initial contact.  The second
goal is that applications can explicitly initiate communications
with unknown peer identifiers.  The third goal is to define how HIP-aware
applications may provide suggested initial contact addresses along
with the HITs.

</p>
<a name="sec:terminology"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Terminology</h3>

<p>The terms used in this document are summarized in <a class='info' href='#tbl:terms'>Table&nbsp;1</a>.
</p><br /><hr class="insert" />
<a name="tbl:terms"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Term</th><th align="left">Explanation</th></tr>
<tr>
<td align="left">HIP</td>
<td align="left">Host Identity Protocol</td>
</tr>
<tr>
<td align="left">HIT</td>
<td align="left">Host Identity Tag, a 100-bit hash of a public key with a 28 bit prefix</td>
</tr>
<tr>
<td align="left">LSI</td>
<td align="left">Local Scope Identifier, a local, 32-bit descriptor for a given 
          public key.</td>
</tr>
<tr>
<td align="left">Locator</td>
<td align="left">Routable IPv4 or IPv6 address used at the lower layers</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="sec:api_overview"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
API Overview</h3>

<p>This section provides an overview of how the API can be used.  First,
       the case in which a resolver is involved in name resolution is
       described, and then the case in which no resolver is involved
       is described.
    
</p>
<a name="sec:resolver"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
Interaction with the Resolver</h3>

<p>Before an application can establish network communications with
       the entity named by a given FQDN or relative host name, the
       application must translate the name into the corresponding
       identifier(s).  DNS-based hostname-to-identifier translation is
       illustrated in <a class='info' href='#fig:resolver_path'>Figure&nbsp;1</a>. The
       application calls the resolver in step a  to resolve an FQDN
       step b. The DNS server responds with a list of HITs and a
       set of locators step c.  Optionally in step d, the
       resolver caches the HIT to locator mapping to the HIP
       module. The resolver returns the HITs to the application
       step e. Finally, the application selects one HIT and uses it in
       a socket call such as connect() in step f.
    
</p><br /><hr class="insert" />
<a name="fig:resolver_path"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                                           +----------+
                                           |          |
                                           |   DNS    |
                                           |          |
                                           +----------+
                                               ^  |
                                     b. &lt;FQDN&gt; |  | c. &lt;HITs+locators
                                               |  v      = HITs+locs&gt;
    +-------------+ a. getaddrinfo(&lt;FQDN&gt;)  +----------+
    |             |------------------------&gt;|          |
    | Application |                         | Resolver |
    |             |&lt;------------------------|          |
    +-------------+        e. &lt;HITs&gt;        +----------+
            |                                    |
            |                                    |
            | f. connect(&lt;HIT&gt;)                  | d. &lt;HITs+locs&gt;
            v                                    v
     +----------+                           +----------+
     |          |                           |          |
     |  TCP/IP  |                           |   HIP    |
     |  Stack   |                           |          |
     +----------+                           +----------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
In practice, the resolver functionality can be implemented in different
ways. For example, it may be implemented in existing resolver
libraries or as a DNS proxy.

</p>
<a name="sec:no-resolver"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Interaction without a Resolver</h3>

<p>
The extensions in this document focus on the use of the resolver to
map host names to HITs and locators in HIP-aware applications. The
resolver associates implicitly the HIT with the
locator(s) by e.g. communicating the HIT-to-IP mapping to the HIP daemon. 
However, it is possible that an application operates
directly on a peer HIT without interacting with the resolver. In
such a case, the application may resort to the system to map the peer
HIT to an IP address. Alternatively, the application can explicitly
map the HIT to an IP address using socket options as specified in <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a>. Full support for all of
the extensions defined in this draft requires shim socket options
to be implemented by the system.

</p>
<a name="sec:syntax"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
API Syntax and Semantics</h3>

<p>In this section, we describe the native HIP APIs using the
       syntax of the C programming language. We limit the description
       to the interfaces and data structures that are either modified
       or completely new, because the native HIP APIs are otherwise
       identical to the sockets API <a class='info' href='#POSIX'>[POSIX]<span> (</span><span class='info'>Institute of Electrical and Electronics Engineers, &ldquo;IEEE Std. 1003.1-2001 Standard for Information Technology -                Portable Operating System Interface (POSIX),&rdquo; Dec&nbsp;2001.</span><span>)</span></a>.
       
</p>
<a name="sec:sock"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Socket Family and Address Structure Extensions</h3>

<p>The sockets API extensions define a new protocol family, PF_HIP, and
        a new address family, AF_HIP.   The AF_HIP and PF_HIP are aliases to
        each other.  These definition shall be defined as a result of including
        &lt;sys/socket.h&gt;.
</p>
<p>The use of the PF_HIP constant is mandatory with the socket()
        function when an application uses the native HIP APIs.  The
        application gives the PF_HIP constant as the first argument (domain)
        to the socket() function.  The system returns a positive integer
	representing a socket descriptor when the system supports HIP.
	Otherwise, the system returns -1 and sets errno to EAFNOSUPPORT.
</p>
<p><a class='info' href='#fig:sockaddr_hip'>Figure&nbsp;2</a> shows socket address
        structure for HIP.
</p><br /><hr class="insert" />
<a name="fig:sockaddr_hip"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        #include &lt;netinet/in.h&gt;

        typedef struct in6_addr hip_hit_t;

        struct sockaddr_hip {
                  sa_family_t    ship_family;
                  in_port_t      ship_port;
                  uint32_t       ship_pad;
                  uint64_t       ship_flags;
                  hip_hit_t      ship_hit;
                  uint8_t        ship_reserved[16];
        };
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p><a class='info' href='#fig:sockaddr_hip'>Figure&nbsp;2</a> is in in 4.3BSD format.  The family of the socket, ship_family, is
       set to AF_HIP.  The port number ship_port is two octets in network byte
       order. and the ship_hit is 16 octets in network byte order.
       An implementation may have extra member(s) in this structure.
</p>
<p>
        The application usually sets the ship_hit field using the
        resolver. However, the application can use three special
        wildcard macros to set a value directly into the ship_hit
        field. The macros are HIP_HIT_ANY, HIP_HIT_ANY_PUB,
        HIP_HIT_ANY_TMP and HIP_ADDR_ANY. The first three equal to a
        HIT value associated with a wildcard HIT of any, public, or
        anonymous type. The fourth macro, HIP_ADDR_ANY, denotes both
        HIP_HIT_ANY or any IPv4 or IPv6 address. The HIP_HIT_ANY equals to
        HIP_HIT_ANY_PUB or HIP_HIT_ANY_TMP. The anonymous identifiers
        refer to the use anonymous identifiers as specified in <a class='info' href='#RFC4423'>[RFC4423]<span> (</span><span class='info'>Moskowitz, R. and P. Nikander, &ldquo;Host Identity Protocol (HIP) Architecture,&rdquo; May&nbsp;2006.</span><span>)</span></a>. The system may designate anonymous
        identifiers as meta data associated with a HIT depending on
        whether it has been published or not. However,
        there is no difference in the classes of HITs
        from the HIP protocol perspective,
     
</p>
<p>The application can use the HIP_HIT_ANY_* and HIP_ADDR_ANY
        macros to accept incoming communications to all of the HITs of
        the local host. Incoming communications refers here to the
        functions such as bind(), recvfrom() and recvmsg(). The
        HIP_HIT_* macros are similar to the sockets API macros
        INADDR_ANY and IN6ADDR_ANY_INIT, but they are applicable to HITs only.
        After initial contact with the peer, the
        application can discover the local and peer HITs
        using getsockname() and getpeername() calls in the context of
        connection oriented sockets. The difference between the use of
        the HIP_HIT_* and HIP_ADDR_ANY macros here is that the former
        allows only HIP-based communications but the latter also
        allows communications without HIP.
        
</p>
<p>The application also uses the HIP_HIT_ANY macro in ship_hit
        field to establish outgoing communications in Opportunistic
        mode <a class='info' href='#RFC5201'>[RFC5201]<span> (</span><span class='info'>Moskowitz, R., Nikander, P., Jokela, P., and T. Henderson, &ldquo;Host Identity Protocol,&rdquo; April&nbsp;2008.</span><span>)</span></a>, i.e., when the
        application knows the remote peer locator but not the
        HIT. Outgoing communications refers here to the use of
        functions such as connect(), sendto() and sendmsg(). However,
        the application must first associate the socket with at least
        one IP address of the peer using SHIM_LOCLIST_PEER_PREF socket
        option.
     
</p>
<p>The use of HIP_ADDR_ANY macro in the context of outgoing
         communications is left for further experimentation. It could
         be used for establishing a non-HIP based connectivity when HIP-based
         connectivity was unsuccessful.
      
</p>
<p>Some applications rely on system level access control, either
        implicit or explicit (such as accept_filter() function found on
        BSD-based systems), but such discussion is out of scope.
        Other applications implement access control
        themselves by using the HITs. In such a case, the application
        can compare two HITs using memcmp() or similar function. It
        should be noticed that different connection attempts between
        the same two hosts can result in different HITs because a host
        is allowed to have multiple HITs.
     
</p>
<a name="sec:getaddrinfo"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Extensions to Resolver Data Structures</h3>

<p>The HIP APIs introduce a new addrinfo flag,
         HIP_PREFER_ORCHID, to be used by application to query for
         both HIT and locator information via the getaddrinfo()
         resolver function <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a>.  The
         getaddrinfo() function uses a data structure used for both
         input to and output from the resolver. The data structure is
         illustrated in <a class='info' href='#fig:addrinfo'>Figure&nbsp;3</a>.
      
</p><br /><hr class="insert" />
<a name="fig:addrinfo"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
       #include &lt;netdb.h&gt;

       struct addrinfo {
           int       ai_flags;          /* e.g. AI_EXTFLAGS */
           int       ai_family;         /* e.g. AF_HIP */
           int       ai_socktype;       /* e.g. SOCK_STREAM */
           int       ai_protocol;       /* 0 or IPPROTO_HIP */
           socklen_t ai_addrlen;        /* size of *ai_addr  */
           struct    sockaddr *ai_addr; /* sockaddr_hip */
           char     *ai_canonname;     /* canon. name of the host */
           struct    addrinfo *ai_next; /* next endpoint */
           int       ai_eflags;         /* RFC5014 extension */
       };
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>Application must set both the flag AI_EXTFLAGS <a class='info' href='#RFC5014'>[RFC5014]<span> (</span><span class='info'>Nordmark, E., Chakrabarti, S., and J. Laganier, &ldquo;IPv6 Socket API for Source Address Selection,&rdquo; September&nbsp;2007.</span><span>)</span></a> in ai_flags and HIP_PREFER_ORCHID in the
         ai_eflags, or otherwise the resolver does not return
         sockaddr_hip data structures. The resolver returns
         EAI_BADFLAGS when it does not support HIP_PREFER_ORCHID or
         AI_EXTFLAGS flags.
      
</p>
<p>
         Application denotes its preference for public and anonymous
         types of HITs using HIP_PREFER_SRC_PUBLIC and
         HIP_PREFER_SRC_TMP flags in the ai_eflags field. If the
         application sets neither of the flags, the resolver returns
         both public and anonymous HITs.
      
</p>
<p>The simultaneous use of both HIP_PREFER_ORCHID and
         HIP_PREFER_PASSIVE_* flags produces a single sockaddr_hip
         structure containing a wildcard address that the application
         can use either for incoming (node argument is NULL in
         getaddrinfo) or outgoing communications (node argument is
         non-NULL). For example, HIP_PREFER_PASSIVE_HIT_TMP flag
         produces one sockaddr_hip structure that contains a
         HIP_HIT_ANY_TMP in the ship_hit field.
</p>
<p>The resolver sets the ai_family field to AF_HIP in the addrinfo structure
         when ai_addr points to a sockaddr_hip structure.
</p>
<p>
         When ai_protocol field is set to zero, the resolver also
         returns locators in sockaddr_in and sockaddr_in6 structures
         in addition to sockaddr_hip structures. The resolver returns
         only sockaddr_hip structures when the application has set the
         ai_protocol field to IPPROTO_HIP or a sockaddr_hip structure is
         given as the hint argument to the resolver.
      
</p>
<a name="sec:resolver_usage"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2.1"></a><h3>4.2.1.&nbsp;
Resolver Usage</h3>

<p>A HIP-aware application creates the sockaddr_hip structures
	 explicitly or obtains them from the resolver. The explicit
	 configuration of locators is described in <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a>. This document
	 defines "automated" resolver extensions for getaddrinfo()
	 resolver <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a>.
</p><br /><hr class="insert" />
<a name="fig:getaddrinfo"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
        #include &lt;netdb.h&gt;

        int getaddrinfo(const char *nodename,
                        const char *servname,
                        const struct addrinfo *hints,
                        struct addrinfo **res)
        void free_addrinfo(struct addrinfo *res)
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>As described in <a class='info' href='#RFC3493'>[RFC3493]<span> (</span><span class='info'>Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;Basic Socket Interface Extensions for IPv6,&rdquo; February&nbsp;2003.</span><span>)</span></a>, the getaddrinfo
           function takes the nodename, servname, and hints as its
           input arguments. It places the result of the query into the
           res argument. The return value is zero on success, or a
           non-zero error value on error. The nodename argument
           specifies the host name to be resolved; a NULL argument
           denotes the local host. The servname parameter declares the
           port number to be set in the socket addresses in the res
           output argument. Both the nodename and servname cannot be
           NULL.
</p>
<p>The input argument "hints" acts like a filter that defines
           the attributes required from the resolved endpoints. A NULL
           hints argument indicates that any kind of endpoints are
           acceptable.
</p>
<p>The output argument "res" is dynamically allocated by the
           resolver.  The application frees res argument with the
           free_addrinfo function. The res argument contains a linked
           list of the resolved endpoints. The linked list contains
           sockaddr_hip structures only when the input argument has
           the HIP_PREFER_ORCHID flag set in ai_eflags. The resolver
           inserts HITs before any locators. When the
           HIP_PREFER_ORCHID flag is set, the resolver does not return
           LSIs or HITs encapsulated into sockaddr_in or sockaddr_in6
           data structures as described in <a class='info' href='#I-D.ietf-hip-applications'>[I&#8209;D.ietf&#8209;hip&#8209;applications]<span> (</span><span class='info'>Henderson, T., Nikander, P., and M. Komu, &ldquo;Using the Host Identity Protocol with Legacy Applications,&rdquo; July&nbsp;2008.</span><span>)</span></a>.
        
</p>
<p>Resolver can return a HIT which maps to multiple
           locators. The resolver may cache the locator mappings to
           the HIP module. The HIP module manages the multiple
           locators according to system policies of the host.  The
           multihoming document <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a> describes how
           an application can override system default policies.
        
</p>
<p>
           It should be noticed that the application can
           configure the HIT explicitly without setting the locator or
           the resolver can fail to resolve any locator. In this
           scenario, the application relies on the system to map the
           HIT to an IP address. When the system fails to provide the
           mapping, it returns -1 in the called sockets API
           function to the application and sets errno to EADDRNOTAVAIL.
       
</p>
<a name="sec:getsock"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
The Use of getsockname and getpeername Functions</h3>

<p>The application usually discovers the local or peer HITs from
       the sockaddr_hip structures returned by getaddrinfo(). However,
       the sockaddr_hip structure does not contain a HIT when the
       application uses the HIP_HIT_ANY_* macros. In such a case, the
       application discovers the local and peer HITs using the
       getsockname() and getpeername() functions. The functions return
       sockaddr_hip structures when the family of the socket is AF_HIP.
    
</p>
<a name="sec:validate"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Validating HITs</h3>

<p>An application that uses the HIP_ADDR_ANY macro may want to
        check if the local or peer address is an orchid-based HIT
        <a class='info' href='#RFC4843'>[RFC4843]<span> (</span><span class='info'>Nikander, P., Laganier, J., and F. Dupont, &ldquo;An IPv6 Prefix for Overlay Routable Cryptographic Hash Identifiers (ORCHID),&rdquo; April&nbsp;2007.</span><span>)</span></a>. Also, the application may want
        to verify whether a HIT is public or anonymous. The
        application accomplishes these using a new function called
        sockaddr_is_srcaddr() which is illustrated in <a class='info' href='#fig:sockaddr_is_srcaddr'>Figure&nbsp;5</a>.
     
</p><br /><hr class="insert" />
<a name="fig:sockaddr_is_srcaddr"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
      #include &lt;netinet/in.h&gt;

      short sockaddr_is_srcaddr(struct sockaddr *srcaddr
                                uint64_t flags);
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The sockaddr_is_srcaddr() function operates in the same way as
        inet6_is_srcaddr() function <a class='info' href='#RFC5014'>[RFC5014]<span> (</span><span class='info'>Nordmark, E., Chakrabarti, S., and J. Laganier, &ldquo;IPv6 Socket API for Source Address Selection,&rdquo; September&nbsp;2007.</span><span>)</span></a> which
        can be used to verify the type of an address belonging to the
        localhost. The difference is that sockaddr_is_srcaddr()
        function handles sockaddr_hip structures in addition to
        sockaddr_in6, and possibly some other socket structures in
        further extensions. The function has also 64 bit flags instead
        of 32 bits. This new function handles the same flags as
        defined in <a class='info' href='#RFC5014'>[RFC5014]<span> (</span><span class='info'>Nordmark, E., Chakrabarti, S., and J. Laganier, &ldquo;IPv6 Socket API for Source Address Selection,&rdquo; September&nbsp;2007.</span><span>)</span></a> in addition to some
        HIP-specific flags listed in <a class='info' href='#tbl:sockaddr_is_src_addr'>Table&nbsp;2</a>.
     
</p><br /><hr class="insert" />
<a name="tbl:sockaddr_is_src_addr"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Flag</th><th align="left">Purpose</th></tr>
<tr>
<td align="left">HIP_PREFER_ORCHID</td>
<td align="left">The identifier is a HIT </td>
</tr>
<tr>
<td align="left">HIP_PREFER_SRC_TMP</td>
<td align="left">Anonymous HIT</td>
</tr>
<tr>
<td align="left">HIP_PREFER_SRC_PUBLIC</td>
<td align="left">Public HIT</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 2&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Source HIT Selection by the System</h3>

<p>Some applications initiate communications by specifying
            only the destination identifier and let the underlying system specify
            the source. When the system selects the source HIT, the system
            should apply the rules specified in <a class='info' href='#RFC3484'>[RFC3484]<span> (</span><span class='info'>Draves, R., &ldquo;Default Address Selection for Internet Protocol version 6 (IPv6),&rdquo; February&nbsp;2003.</span><span>)</span></a> according to the default policy table for HITs shown in
            <a class='info' href='#tbl:policy_table'>Table&nbsp;3</a>.

</p><br /><hr class="insert" />
<a name="tbl:policy_table"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left"><col align="left">
<tr><th align="left">HIT Type</th><th align="left">Precedence</th><th align="left">Label</th></tr>
<tr>
<td align="left">Anonymous DSA</td>
<td align="left">110</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">Anonymous RSA</td>
<td align="left">120</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">Public DSA</td>
<td align="left">130</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">Public RSA</td>
<td align="left">140</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left"><a class='info' href='#RFC3484'>[RFC3484]<span> (</span><span class='info'>Draves, R., &ldquo;Default Address Selection for Internet Protocol version 6 (IPv6),&rdquo; February&nbsp;2003.</span><span>)</span></a> rules</td>
<td align="left">50-100</td>
<td align="left">7</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 3&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
When application using a AF_HIP-based socket does not specify the
source identifier, the system selects the source identifier on the
behalf of the application according to the precedence in the above
table. For example, the system prefers public (published) keys before
anonymous keys because they work better for referral
purposes. RSA-based keys are preferred over DSA based because RSA is
the default algorithm in HIP.

</p>
<p>
When system provides multiple keys of same type, but with different
key lengths, the longer keys should have a higher preference. As
example, system providing two public RSA keys of different size would
give the smaller key preference value 140 and 145 for the larger.  The
preference value should not exceed 150. Systems supporting more than
10 keys of same key size may use digits to further fragment the
precedence namespace.  IPv6 addresses have the lowest precedence value
to denote that HITs have a higher precedence when operating on
AF_HIP-based sockets.

</p>
<p><a class='info' href='#RFC5014'>[RFC5014]<span> (</span><span class='info'>Nordmark, E., Chakrabarti, S., and J. Laganier, &ldquo;IPv6 Socket API for Source Address Selection,&rdquo; September&nbsp;2007.</span><span>)</span></a> specifies flags for the
            getaddrinfo resolver and socket options for
            Mobile IPv6. The resolver, operating under
            HIP_PREFER_ORCHID flag, or the socket handler, operating
            on a AF_HIP-based socket, may encounter such flags or
            options.  In such a case the resolver or socket handler
            should silenty ignore the flags or options without
            returning an error. However, a HIP-aware application may
            use the HIP-specific flags HIP_PREFER_ORCHID,
            HIP_PREFER_SRC_TMP or HIP_PREFER_SRC_PUBLIC in
            getsockopt(), setsockopt(), getaddrinfo() calls and in the
            anchillary data of datagram packets as specified in <a class='info' href='#RFC5014'>[RFC5014]<span> (</span><span class='info'>Nordmark, E., Chakrabarti, S., and J. Laganier, &ldquo;IPv6 Socket API for Source Address Selection,&rdquo; September&nbsp;2007.</span><span>)</span></a>. The level of the socket options
            should be set to SOL_SHIM <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a> and the
            option name should be HIP_HIT_PREFERENCES.
        
</p>
<a name="sec:explicit"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6"></a><h3>4.6.&nbsp;
Explicit Handling of Locators</h3>

<p>
         The system resolver, or the HIP module, maps HITs to locators
         implicitly. However, some applications may want to specify
         initial locator mappings explicitly. In such a case, the
         application first creates a socket with AF_HIP as the domain
         argument. Second, the application may set locator information
         with one of the following shim socket options
         as defined in the multihoming extensions in <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a>: 
         
</p><br /><hr class="insert" />
<a name="fig:socket_opts"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
+-----------------------------+-----+-----+-----------------+-------+
| optname                     | get | set | description     | dtype |
+-----------------------------+-----+-----+-----------------+-------+
| SHIM_LOC_LOCAL_PREF         | o   | o   | Get or set the  | *1    |
|                             |     |     | preferred       |       |
|                             |     |     | locator on the  |       |
|                             |     |     | local side for  |       |
|                             |     |     | the context     |       |
|                             |     |     | associated with |       |
|                             |     |     | the socket.     |       |
| SHIM_LOC_PEER_PREF          | o   | o   | Get or set the  | *1    |
|                             |     |     | preferred       |       |
|                             |     |     | locator on the  |       |
|                             |     |     | remote side for |       |
|                             |     |     | the context     |       |
|                             |     |     | associated with |       |
|                             |     |     | the socket.     |       |
| SHIM_LOCLIST_LOCAL          | o   | o   | Get or set a    | *2    |
|                             |     |     | list of         |       |
|                             |     |     | locators        |       |
|                             |     |     | associated with |       |
|                             |     |     | the local EID.  |       |
| SHIM_LOCLIST_PEER           | o   | o   | Get or set a    | *2    |
|                             |     |     | list of         |       |
|                             |     |     | locators        |       |
|                             |     |     | associated with |       |
|                             |     |     | the peer's EID. |       |
| SHIM_LOC_LOCAL_SEND         | o   | o   | Request use of  | *2    |
|                             |     |     | specific        |       |
|                             |     |     | locator as      |       |
|                             |     |     | source locator  |       |
|                             |     |     | of outgoing IP  |       |
|                             |     |     | packets.        |       |
| SHIM_LOC_PEER_SEND          | o   | o   | Request use of  | *2    |
|                             |     |     | specific        |       |
|                             |     |     | locator as      |       |
|                             |     |     | destination     |       |
|                             |     |     | locator of      |       |
|                             |     |     | outgoing IP     |       |
|                             |     |     | packets.        |       |
+-----------------------------+-----+-----+-----------------+-------+
*1: Pointer to a shim_locator which is defined in Section 7 of
draft-ietf-shim6-multihome-shim-api.
*2: Pointer to an array of shim_locator.
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
         Finally, the application creates a valid sockaddr_hip
         structure and associates the socket
         also with the sockaddr_hip structure by calling some
         socket-related function, such as connect() or bind().
</p>
<p>
The usage and semantics for typical use cases are as follows:

</p>
<p>An application that initiates a connection using a connection
oriented socket to a particular host at a known address or set of
addresses can invoke SHIM_LOCLIST_PEER socket option.  The HIP module
uses the first address (if multiple are provided, or else the
application can override this by setting SHIM_LOC_PEER_PREF to one of
the addresses in SHIM_LOCLIST_PEER. The application later provides a
specific HIT in the ship_hit field of the sockaddr_hip in the
connect() system call.  If the application provides one or more
addresses in SHIM_LOCLIST_PEER setsockopt call, the system should not
connect to the host via another destination address, in case the
application intends to restrict the range of addresses permissible as
a policy choice.  If the system cannot reach the provided HIT at one
of the addresses provided, the outbound socket API functions (connect,
sendmsg, etc.)  return -1 and set errno to EINVALIDLOCATOR.

</p>
<p>
Another common use case is to set up an association in opportunistic
mode, when the destination HIT is specified as a wildcard.  This can
be accomplished by setting one or more destination addresses using the
SHIM_LOCLIST_PEER socket option as described above and then calling
connect() with the wildcard HIT. The connect() call returns -1 and
sets errno to EADDRNOTAVAIL when the application connects to a
wildcard without specifying any destination address.

</p>
<p>
Applications may also choose to associate local addresses with
sockets.  The procedures specified in <a class='info' href='#I-D.ietf-shim6-multihome-shim-api'>[I&#8209;D.ietf&#8209;shim6&#8209;multihome&#8209;shim&#8209;api]<span> (</span><span class='info'>Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;Socket Application Program Interface (API) for Multihoming Shim,&rdquo; February&nbsp;2010.</span><span>)</span></a> are followed in this
case.

</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Summary of New Definitions</h3>

<p>
<a class='info' href='#tbl:defs'>Table&nbsp;4</a> summarizes the new macro and
structures defined in this document.

</p><br /><hr class="insert" />
<a name="tbl:defs"></a>
<table class="full" align="center" border="0" cellpadding="2" cellspacing="2">
<col align="left"><col align="left">
<tr><th align="left">Header</th><th align="left">Definition</th></tr>
<tr>
<td align="left">&lt;sys/socket.h&gt;</td>
<td align="left">AF_HIP</td>
</tr>
<tr>
<td align="left">&lt;sys/socket.h&gt;</td>
<td align="left">PF_HIP</td>
</tr>
<tr>
<td align="left">&lt;netinet/in.h&gt;</td>
<td align="left">IPPROTO_HIP</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">HIP_HIT_ANY</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">HIP_HIT_ANY_PUB</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">HIP_HIT_ANY_TMP</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">HIP_ADDR_ANY</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">HIP_HIT_PREFERENCES</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">hip_hit_t</td>
</tr>
<tr>
<td align="left">&lt;netdb.h&gt;</td>
<td align="left">HIP_PREFER_ORCHID</td>
</tr>
<tr>
<td align="left">&lt;netdb.h&gt;</td>
<td align="left">HIP_PREFER_SRC_TMP</td>
</tr>
<tr>
<td align="left">&lt;netdb.h&gt;</td>
<td align="left">HIP_PREFER_SRC_PUBLIC</td>
</tr>
<tr>
<td align="left">&lt;netdb.h&gt;</td>
<td align="left">HIP_PREFER_PASSIVE_HIT_TMP</td>
</tr>
<tr>
<td align="left">&lt;netdb.h&gt;</td>
<td align="left">HIP_PREFER_PASSIVE_HIT_PUB</td>
</tr>
<tr>
<td align="left">&lt;netdb.h&gt;</td>
<td align="left">HIP_PREFER_PASSIVE_HIT_ANY</td>
</tr>
<tr>
<td align="left">&lt;netdb.h&gt;</td>
<td align="left">HIP_PREFER_PASSIVE_ADDR_ANY</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">sockaddr_hip</td>
</tr>
<tr>
<td align="left">&lt;netinet/hip.h&gt;</td>
<td align="left">sockaddr_is_srcaddr</td>
</tr>
</table>
<br clear="all" />
<table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Table 4&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="sec:iana"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
IANA Considerations</h3>

<p>No IANA considerations.
</p>
<a name="sec:security"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Security Considerations</h3>

<p>No security considerations currently.
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
Contributors</h3>

<p>Thanks for Jukka Ylitalo and Pekka Nikander for their original
    contribution, time and effort to the native HIP APIs. Thanks for
    Yoshifuji Hideaki for his contributions to this document.
    
</p>
<a name="sec:acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Acknowledgements</h3>

<p>
    Kristian Slavov, Julien Laganier, Jaakko Kangasharju, Mika Kousa,
    Jan Melen, Andrew McGregor, Sasu Tarkoma, Lars Eggert, Joe Touch,
    Antti Jrvinen, Anthony Joseph, Teemu Koponen, Jari Arkko, Ari
    Kernen, Juha-Matti Tapio, Shinta Sugimoto, Philip Matthews, Jan
    Melen and Gonzalo Camarillo have also provided valuable ideas or
    feedback. Thanks also for the APPS area folks, including Stephane
    Bortzmeyer, Chris Newman, Tony Finch, "der Mouse" and Keith Moore.
    
</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-btns-c-api">[I-D.ietf-btns-c-api]</a></td>
<td class="author-text">Richardson, M., Williams, N., Komu, M., and S. Tarkoma, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-btns-c-api-04.txt">C-Bindings for IPsec Application Programming Interfaces</a>,&rdquo; draft-ietf-btns-c-api-04 (work in progress), March&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-btns-c-api-04.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-hip-applications">[I-D.ietf-hip-applications]</a></td>
<td class="author-text">Henderson, T., Nikander, P., and M. Komu, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-hip-applications-04.txt">Using the Host Identity Protocol with Legacy Applications</a>,&rdquo; draft-ietf-hip-applications-04 (work in progress), July&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-hip-applications-04.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-shim6-multihome-shim-api">[I-D.ietf-shim6-multihome-shim-api]</a></td>
<td class="author-text">Komu, M., Bagnulo, M., Slavov, K., and S. Sugimoto, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-shim6-multihome-shim-api-13.txt">Socket Application Program Interface (API) for Multihoming Shim</a>,&rdquo; draft-ietf-shim6-multihome-shim-api-13 (work in progress), February&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-shim6-multihome-shim-api-13.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-shim6-proto">[I-D.ietf-shim6-proto]</a></td>
<td class="author-text">Nordmark, E. and M. Bagnulo, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-shim6-proto-12.txt">Shim6: Level 3 Multihoming Shim Protocol for IPv6</a>,&rdquo; draft-ietf-shim6-proto-12 (work in progress), February&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-shim6-proto-12.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="POSIX">[POSIX]</a></td>
<td class="author-text">Institute of Electrical and Electronics Engineers, &ldquo;IEEE Std. 1003.1-2001 Standard for Information Technology -
               Portable Operating System Interface (POSIX),&rdquo; Dec&nbsp;2001.</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3484">[RFC3484]</a></td>
<td class="author-text">Draves, R., &ldquo;<a href="http://tools.ietf.org/html/rfc3484">Default Address Selection for Internet Protocol version 6 (IPv6)</a>,&rdquo; RFC&nbsp;3484, February&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3484.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3493">[RFC3493]</a></td>
<td class="author-text">Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, &ldquo;<a href="http://tools.ietf.org/html/rfc3493">Basic Socket Interface Extensions for IPv6</a>,&rdquo; RFC&nbsp;3493, February&nbsp;2003 (<a href="http://www.rfc-editor.org/rfc/rfc3493.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4423">[RFC4423]</a></td>
<td class="author-text">Moskowitz, R. and P. Nikander, &ldquo;<a href="http://tools.ietf.org/html/rfc4423">Host Identity Protocol (HIP) Architecture</a>,&rdquo; RFC&nbsp;4423, May&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4423.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4843">[RFC4843]</a></td>
<td class="author-text">Nikander, P., Laganier, J., and F. Dupont, &ldquo;<a href="http://tools.ietf.org/html/rfc4843">An IPv6 Prefix for Overlay Routable Cryptographic Hash Identifiers (ORCHID)</a>,&rdquo; RFC&nbsp;4843, April&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc4843.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5014">[RFC5014]</a></td>
<td class="author-text">Nordmark, E., Chakrabarti, S., and J. Laganier, &ldquo;<a href="http://tools.ietf.org/html/rfc5014">IPv6 Socket API for Source Address Selection</a>,&rdquo; RFC&nbsp;5014, September&nbsp;2007 (<a href="http://www.rfc-editor.org/rfc/rfc5014.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5201">[RFC5201]</a></td>
<td class="author-text">Moskowitz, R., Nikander, P., Jokela, P., and T. Henderson, &ldquo;<a href="http://tools.ietf.org/html/rfc5201">Host Identity Protocol</a>,&rdquo; RFC&nbsp;5201, April&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5201.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5205">[RFC5205]</a></td>
<td class="author-text">Nikander, P. and J. Laganier, &ldquo;<a href="http://tools.ietf.org/html/rfc5205">Host Identity Protocol (HIP) Domain Name System (DNS) Extensions</a>,&rdquo; RFC&nbsp;5205, April&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5205.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Miika Komu</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Helsinki Institute for Information Technology</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Metsnneidonkuja 4</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Helsinki</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Finland</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+358503841531</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text">+35896949768</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:miika@iki.fi">miika@iki.fi</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.iki.fi/miika/">http://www.iki.fi/miika/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Thomas Henderson</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">The Boeing Company</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">P.O. Box 3707</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Seattle, WA</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">USA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:thomas.r.henderson@boeing.com">thomas.r.henderson@boeing.com</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2008).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
