person = {
                               age: int,
                               name: tstr,
                               employer: tstr,
pii = (
                               age: int,
                               name: tstr,
                               employer: tstr,
person = {
                                  pii
person = {(
                               age: int,
                               name: tstr,
                               employer: tstr,
person = {
                            age: int,
                            name: tstr,
                            employer: tstr,
dog = {
                            age: int,
                            name: tstr,
                            leash-length: float,
person = {
                            identity,
                            employer: tstr,
dog = {
                            identity,
                            leash-length: float,
identity = (
                            age: int,
                            name: tstr,
attire = "bow tie" / "necktie" / "Internet attire"
protocol = 6 / 17

address = { delivery }

delivery = (
city = (
device-address = byte
max-byte = 255
byte = 0..max-byte ; inclusive range
first-non-byte = 256
byte1 = 0...first-non-byte ; byte1 is equivalent to byte

int-range = 0..10 ; only integers match
float-range = 0.0..10.0 ; only floats match
BAD-range1 = 0..10.0 ; NOT DEFINED
BAD-range2 = 0.0..10 ; NOT DEFINED
numeric-range = int-range / float-range

terminal-color = &basecolors
basecolors = (
                black: 0, red: 1,  green: 2,  yellow: 3,
                blue: 4,  magenta: 5,  cyan: 6,  white: 7,
extended-color = &(
                basecolors,
                orange: 8,  pink: 9,  purple: 10,  brown: 11,
my_breakfast = #6.55799(breakfast)   ; cbor-any is too general!
breakfast = cereal / porridge
cereal = #6.998(tstr)
porridge = #6.999([liquid, solid])
liquid = milk / water
milk = 0
water = 1
solid = tstr

person = { g }

g = (
                      "name": tstr,
                      age: int,  ; "age" is a bareword
apartment = {
     kitchen: size,
     * bedroom: size,
size = float ; in m2
unlimited-people = [* person]
one-or-two-people = [1*2 person]
at-least-two-people = [2* person]
person = (
                         name: tstr,
                         age: uint,
Geography = [
         city           : tstr,
         gpsCoordinates : GpsCoordinates,
GpsCoordinates = {
         longitude      : uint,            ; degrees, scaled by 10^7
         latitude       : uint,            ; degreed, scaled by 10^7
located-samples = {
                             sample-point: int,
                             samples: [+ float],
located-samples = {
                           "sample-point" => int,
                           "samples" => [+ float],
located-samples = {
               sample-point: int,
               samples: [+ float],
               * equipment-type => equipment-tolerances,
equipment-type = [name: tstr, manufacturer: tstr]
equipment-tolerances = [+ [float, float]]

PersonalData = {
                            ? displayName: tstr,
                            NameComponents,
                            ? age: uint,
NameComponents = (
                            ? firstName: tstr,
                            ? familyName: tstr,
PersonalData = {
                            ? displayName: tstr,
                            NameComponents,
                            ? age: uint,
                            * tstr => any
NameComponents = (
                            ? firstName: tstr,
                            ? familyName: tstr,
square-roots = {* x => y}
x = int
y = float

tostring = {* mynumber => tstr}
mynumber = int / float

labeled-values = {
     ? fritz: number,
     * label => value
label = text
value = number

do-not-do-this = {
int => int,
int => 6,
extensible-map-example = {
                          ? "optional-key" => int,
                          * tstr => any
extensible-map-example = {
                         ? "optional-key" ^ => int,
                         * tstr => any
extensible-map-example = {
                          ? "optional-key": int,
                          * tstr => any
extensible-map-example = {
                          ? optional-key: int,
                          * tstr => any
biguint = #6.2(bstr)

buuid = #6.37(bstr)

my_uri = #6.32(tstr) / tstr
basic-header-group = (
     field1: int,
     field2: text,
basic-header = [ basic-header-group ]

advanced-header = [
     basic-header-group,
     field3: bytes,
     field4: number, ; as in the tagged type "time"
basic-header = [
     field1: int,
     field2: text,
advanced-header = [
     ~basic-header,
     field3: bytes,
     field4: ~time,
full-address = [[+ label], ip4, ip6]
ip4 = bstr .size 4
ip6 = bstr .size 16
label = bstr .size (1..63)

                    Figure 8: Control for size in bytes

audio_sample = uint .size 3 ; 24-bit, equivalent to 0...16777216

                Figure 9: Control for integer size in bytes

tcpflagbytes = bstr .bits flags
flags = &(
                        fin: 8,
                        syn: 9,
                        rst: 10,
                        psh: 11,
                        ack: 12,
                        urg: 13,
                        ece: 14,
                        cwr: 15,
                        ns: 0,
rwxbits = uint .bits rwx
rwx = &(r: 2, w: 1, x: 0)

nai = tstr .regexp "[A-Za-z0-9]+@[A-Za-z0-9]+(\\.[A-Za-z0-9]+)+"

                   Figure 11: Control with an XSD regexp

message = $message .within message-structure
message-structure = [message_type, *message_option]
message_type = 0..255
message_option = any

speed = number .ge 0  ; unit: m/s

timer = {
     time: uint,
     ? displayed-step: (number .gt 0) .default 1
tcp-header = {seq: uint, ack: uint, * $$tcp-option}

PersonalData = {
                       ? displayName: tstr,
                       NameComponents,
                       ? age: uint,
                       * $$personaldata-extensions
NameComponents = (
                       ? firstName: tstr,
                       ? familyName: tstr,
messages = message<"reboot", "now"> / message<"sleep", 1..100>
parameter = argument).

t = [group1]
group1 = (a / b // c / d)
a = 1 b = 2 c = 3 d = 4

t = {group2}
group2 = (? ab: a / b // cd: c / d)
a = 1 b = 2 c = 3 d = 4

t = [group3]
group3 = (+ a / b / c)
a = 1 b = 2 c = 3

t = [group4]
group4 = (+ a // b / c)
a = 1 b = 2 c = 3
t = [group4a]
group4a = ((+ a) // (b / c))
a = 1 b = 2 c = 3

A = "a" "b" / "a"    (1)

A = "a" / "a" "b"    (2)

cddl = S 1*(rule S)
rule = typename [genericparm] S assignt S type
          / groupname [genericparm] S assigng S grpent

typename = id
groupname = id

assignt = "=" / "/="
assigng = "=" / "//="

genericparm = "<" S id S *("," S id S ) ">"
genericarg = "<" S type1 S *("," S type1 S ) ">"

type = type1 *(S "/" S type1)

type1 = type2 [S (rangeop / ctlop) S type2]
type2 = value
           / typename [genericarg]
           / "(" S type S ")"
           / "{" S group S "}"
           / "[" S group S "]"
           / "~" S typename [genericarg]
           / "&" S "(" S group S ")"
           / "&" S groupname [genericarg]
           / "#" "6" ["." uint] "(" S type S ")"
           / "#" DIGIT ["." uint]                ; major/ai
           / "#"                                 ; any

rangeop = "..." / ".."

ctlop = "." id

group = grpchoice *(S "//" S grpchoice)

grpchoice = *(grpent optcom)

grpent = [occur S] [memberkey S] type
            / [occur S] groupname [genericarg]  ; preempted by above
            / [occur S] "(" S group S ")"

memberkey = type1 S ["^" S] "=>"
               / bareword S ":"
               / value S ":"

bareword = id

optcom = S ["," S]

occur = [uint] "*" [uint]
           / "+"
           / "?"

uint = DIGIT1 *DIGIT
          / "0x" 1*HEXDIG
          / "0b" 1*BINDIG
          / "0"

value = number
           / text
           / bytes

int = ["-"] uint

number = hexfloat / (int ["." fraction] ["e" exponent ])
hexfloat = "0x" 1*HEXDIG ["." 1*HEXDIG] "p" exponent
fraction = 1*DIGIT
exponent = ["+"/"-"] 1*DIGIT

text = %x22 *SCHAR %x22
SCHAR = %x20-21 / %x23-5B / %x5D-7E / %x80-10FFFD / SESC
SESC = "\" (%x20-7E / %x80-10FFFD)

bytes = [bsqual] %x27 *BCHAR %x27
BCHAR = %x20-26 / %x28-5B / %x5D-10FFFD / SESC / CRLF
bsqual = "h" / "b64"

id = EALPHA *(*("-" / ".") (EALPHA / DIGIT))
ALPHA = %x41-5A / %x61-7A
EALPHA = ALPHA / "@" / "_" / "$"
DIGIT = %x30-39
DIGIT1 = %x31-39
HEXDIG = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
BINDIG = %x30-31
S = *WS
WS = SP / NL
SP = %x20
NL = COMMENT / CRLF
COMMENT = ";" *PCHAR CRLF
PCHAR = %x20-7E / %x80-10FFFD
CRLF = %x0A / %x0D.0A

                           Figure 13: CDDL ABNF

cddl = S 1*(rule S)

rule = typename [genericparm] S assignt S type
        / groupname [genericparm] S assigng S grpent

typename = id
groupname = id
assignt = "=" / "/="
assigng = "=" / "//="

genericparm = "<" S id S *("," S id S ) ">"
genericarg = "<" S type1 S *("," S type1 S ) ">"

type = type1 *(S "/" S type1)

type1 = type2 [S (rangeop / ctlop) S type2]
type2 = value

rangeop = "..." / ".."

ctlop = "." id

group = grpchoice *(S "//" S grpchoice)

grpchoice = *(grpent optcom)

grpent = [occur S] [memberkey S] type

memberkey = type1 S ["^" S] "=>"
             / bareword S ":"
             / value S ":"

bareword = id

optcom = S ["," S]

occur = [uint] "*" [uint]
         / "+"
         / "?"

any = #

uint = #0
nint = #1
int = uint / nint

bstr = #2
bytes = bstr
tstr = #3
text = tstr

tdate = #6.0(tstr)
time = #6.1(number)
number = int / float
biguint = #6.2(bstr)
bignint = #6.3(bstr)
bigint = biguint / bignint
integer = int / bigint
unsigned = uint / biguint
decfrac = #6.4([e10: int, m: integer])
bigfloat = #6.5([e2: int, m: integer])
eb64url = #6.21(any)
eb64legacy = #6.22(any)
eb16 = #6.23(any)
encoded-cbor = #6.24(bstr)
uri = #6.32(tstr)
b64url = #6.33(tstr)
b64legacy = #6.34(tstr)
regexp = #6.35(tstr)
mime-message = #6.36(tstr)
cbor-any = #6.55799(any)

float16 = #7.25
float32 = #7.26
float64 = #7.27
float16-32 = float16 / float32
float32-64 = float32 / float64
float = float16-32 / float64

false = #7.20
true = #7.21
bool = false / true
nil = #7.22
null = nil
undefined = #7.23


                          Figure 14: CDDL Prelude
any = #

uint = #0
nint = #1
int = uint / nint

tstr = #3
text = tstr

number = int / float

float16 = #7.25
float32 = #7.26
float64 = #7.27
float16-32 = float16 / float32
float32-64 = float32 / float64
float = float16-32 / float64

false = #7.20
true = #7.21
bool = false / true
nil = #7.22
null = nil


ij-uint = 0..9007199254740991
ij-nint = -9007199254740991..-1
ij-int = -9007199254740991..9007199254740991

biguint = #6.2(bstr)
bignint = #6.3(bstr)
bigint = biguint / bignint
integer = int / bigint
unsigned = uint / biguint

reputation-object = {
                   reputation-context,
                   reputon-list
reputation-context = (
                   application: text
reputon-list = (
                   reputons: reputon-array
reputon-array = [* reputon]

reputon = {
                   rater-value,
                   assertion-value,
                   rated-value,
                   rating-value,
                   ? conf-value,
                   ? normal-value,
                   ? sample-value,
                   ? gen-value,
                   ? expire-value,
                   * ext-value,
rater-value = ( rater: text )
assertion-value = ( assertion: text )
rated-value = ( rated: text )
rating-value = ( rating: float16 )
conf-value = ( confidence: float16 )
normal-value = ( normal-rating: float16 )
sample-value = ( sample-size: uint )
gen-value = ( generated: uint )
expire-value = ( expires: uint )
ext-value = ( text => any )

reputation-object = {
                          application: text
                          reputons: [* reputon]
reputon = {
                          rater: text
                          assertion: text
                          rated: text
                          rating: float16
                          ? confidence: float16
                          ? normal-rating: float16
                          ? sample-size: uint
                          ? generated: uint
                          ? expires: uint
                          * text => any
root = [2*2 {
                              precision: text,
                              Latitude: float,
                              Longitude: float,
                              Address: text,
                              City: text,
                              State: text,
                              Zip: text,
                              Country: text
root = { image }

image = (
                               Image: {
                                 size,
                                 Title: text,
                                 thumbnail,
                                 IDs: [* int]
                               }
size = (
                               Width: 0..1280
                               Height: 0..1024
thumbnail = (
                               Thumbnail: {
                                 size,
                                 Url: ~uri
                               }
root = {
                      Image: {
                        size, Title: text,
                        Thumbnail: { size, Url: ~uri },
                        IDs: [* int]
                      }
size = (
                      Width: 0..1280,
                      Height: 0..1024,
