

                                                                        
    
                                                   
Internet Draft                                     L. Dusseault, Xythos 
Document: draft-ietf-webdav-rfc2518bis-04.txt      J. Crawford, IBM 
Expires: Oct 2003 
 
 
      HTTP Extensions for Distributed Authoring - WebDAV RFC2518 bis 
 
 
Status of this Memo 
    
   This document is an Internet-Draft and is in full conformance 
   with all provisions of Section 10 of RFC2026. 
    
   Internet-Drafts are working documents of the Internet Engineering 
   Task Force (IETF), its areas, and its working groups.  Note that 
   other groups may also distribute working documents as Internet-
   Drafts. 
   Internet-Drafts are draft documents valid for a maximum of six 
   months and may be updated, replaced, or obsoleted by other documents 
   at any time.  It is inappropriate to use Internet-Drafts as 
   reference material or to cite them other than as "work in progress." 
    
   The list of current Internet-Drafts can be accessed at 
        http://www.ietf.org/ietf/1id-abstracts.txt 
    
   The list of Internet-Draft Shadow Directories can be accessed at 
        http://www.ietf.org/shadow.html. 
    
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", 
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this 
   document are to be interpreted as described in RFC 2119 [RFC2119]. 
    
Abstract 
    
   WebDAV consists of a set of methods, headers, and content-types 
   ancillary to HTTP/1.1 for the management of resource properties, 
   creation and management of resource collections, namespace 
   manipulation, and resource locking (collision avoidance). 
    
   RFC2518 was published in February 1998, and this draft makes minor 
   revisions mostly due to interoperability experience. 
    
Table of Contents 
    
   1  Introduction...................................................6 
   2  Notational Conventions.........................................7 
   3  Terminology....................................................7 
   4  Data Model for Resource Properties.............................8 
     
                           Expires Aug 2002                          1 

                         WebDAV (RFC2518) bis                June 2003 
    
   4.1  The Resource Property Model..................................8 
   4.2  Existing Metadata Proposals..................................8 
   4.3  Properties and HTTP Headers..................................9 
   4.4  XML Usage....................................................9 
   4.5  Property Values.............................................10 
   4.6  Property Names..............................................11 
   5  Collections of Web Resources..................................11 
   5.1  HTTP URL Namespace Model....................................12 
   5.2  Collection Resources........................................12 
   5.3  Source Resources and Output Resources.......................13 
   6  Locking.......................................................14 
   6.1  Exclusive Vs. Shared Locks..................................14 
   6.2  Required Support............................................15 
   6.3  Lock Tokens.................................................16 
   6.4  opaquelocktoken Lock Token URI Scheme.......................16 
   6.5  Lock Capability Discovery...................................17 
   6.6  Active Lock Discovery.......................................17 
   6.7  Usage Considerations........................................17 
   7  Write Lock....................................................18 
   7.1  Methods Restricted by Write Locks...........................18 
   7.2  Write Locks and Lock Tokens.................................19 
   7.3  Write Locks and Properties..................................19 
   7.4  Write Locks and Unmapped URLs...............................19 
   7.5  Write Locks and Collections.................................21 
   7.6  Write Locks and the If Request Header.......................21 
   7.7  Write Locks and COPY/MOVE...................................22 
   7.8  Refreshing Write Locks......................................23 
   8  HTTP Methods for Distributed Authoring........................23 
   8.1  General request and response handling.......................23 
   8.1.1 Use of XML.................................................23 
   8.1.2 Required Bodies in Requests................................24 
   8.1.3 Use of Location header in responses........................24 
   8.1.4 Required Response Headers: Date............................24 
   8.1.5 ETag.......................................................24 
   8.1.6 Including error response bodies............................25 
   8.2  PROPFIND....................................................26 
   8.2.1 Example - Retrieving Named Properties......................28 
   8.2.2 Example - Retrieving Named and Dead Properties.............29 
   8.2.3 Example - Using propname to Retrieve all Property Names....30 
   8.2.4 PROPFIND Request Errors....................................31 
   8.3  PROPPATCH...................................................32 
   8.3.1 Status Codes for use with 207 (Multi-Status)...............32 
   8.3.2 Example - PROPPATCH........................................33 
   8.4  MKCOL Method................................................34 
   8.4.1 Example - MKCOL............................................35 
     
                           Expires Oct 2003                          2 

                         WebDAV (RFC2518) bis                June 2003 
    
   8.5  GET, HEAD for Collections...................................35 
   8.6  POST for Collections........................................36 
   8.7  DELETE......................................................36 
   8.7.1 Example - DELETE...........................................37 
   8.8  PUT.........................................................37 
   8.9  COPY Method.................................................38 
   8.9.1 COPY for Collections.......................................39 
   8.9.2 COPY and the Overwrite Header..............................40 
   8.9.3 Status Codes...............................................40 
   8.9.4 Example - COPY with Overwrite..............................41 
   8.10  MOVE Method................................................42 
   8.10.1  MOVE for Properties......................................43 
   8.10.2  MOVE for Collections.....................................43 
   8.10.3  MOVE and the Overwrite Header............................44 
   8.10.4  Status Codes.............................................44 
   8.10.5  Example - MOVE of a Non-Collection.......................45 
   8.11  LOCK Method................................................46 
   8.11.1  Example - Simple Lock Request............................50 
   8.11.2  Example - Refreshing a Write Lock........................51 
   8.11.3  Example - Multi-Resource Lock Request....................52 
   8.12  UNLOCK Method..............................................54 
   8.12.1  Example - UNLOCK.........................................54 
   9  HTTP Headers for Distributed Authoring........................55 
   9.1  DAV Header..................................................55 
   9.2  Depth Header................................................55 
   9.3  Destination Header..........................................57 
   9.4  Force-Authentication Header.................................57 
   9.5  If Header...................................................57 
   9.5.1 No-tag-list Production.....................................58 
   9.5.2 Example - No-tag-list If Header............................58 
   9.5.3 Tagged-list Production.....................................59 
   9.5.4 Example - Tagged List If header............................59 
   9.5.5 Not Production.............................................59 
   9.5.6 Matching Function..........................................60 
   9.5.7 If Header and Non-DAV Aware Proxies........................60 
   9.6  Lock-Token Header...........................................60 
   9.7  Overwrite Header............................................60 
   9.8  Status-URI Response Header..................................61 
   9.9  Timeout Request Header......................................61 
   10 Status Code Extensions to HTTP/1.1............................62 
   10.1  102 Processing.............................................62 
   10.2  207 Multi-Status...........................................63 
   10.3  422 Unprocessable Entity...................................63 
   10.4  423 Locked.................................................63 
   10.5  424 Failed Dependency......................................63 
     
                           Expires Oct 2003                          3 

                         WebDAV (RFC2518) bis                June 2003 
    
   10.6  507 Insufficient Storage...................................63 
   11 Use of HTTP Status Codes......................................63 
   11.1  301 Moved Permanently......................................63 
   11.2  302 Found..................................................64 
   11.3  400 Bad Request............................................64 
   11.4  403 Forbidden..............................................64 
   11.5  409 Conflict...............................................64 
   11.6  414 Request-URI Too Long...................................64 
   12 Multi-Status Response.........................................64 
   12.1  Responses requiring Location in Multi-Status...............65 
   13 XML Element Definitions.......................................65 
   13.1  activelock XML Element.....................................65 
   13.2  depth XML Element..........................................66 
   13.3  locktoken XML Element......................................66 
   13.4  lockroot XML Element.......................................66 
   13.5  timeout XML Element........................................66 
   13.6  collection XML Element.....................................67 
   13.7  href XML Element...........................................67 
   13.8  lockentry XML Element......................................67 
   13.9  lockinfo XML Element.......................................67 
   13.10 lockscope XML Element......................................67 
   13.11 exclusive XML Element......................................68 
   13.12 shared XML Element.........................................68 
   13.13 locktype XML Element.......................................68 
   13.14 write XML Element..........................................68 
   13.15 multistatus XML Element....................................68 
   13.16 response XML Element.......................................69 
   13.17 propstat XML Element.......................................69 
   13.18 status XML Element.........................................70 
   13.19 responsedescription XML Element............................70 
   13.20 owner XML Element..........................................70 
   13.21 prop XML element...........................................70 
   13.22 propertyupdate XML element.................................70 
   13.23 remove XML element.........................................71 
   13.24 set XML element............................................71 
   13.25 propfind XML Element.......................................71 
   13.26 allprop XML Element........................................72 
   13.27 propname XML Element.......................................72 
   13.28 deadprops XML Element......................................72 
   14 DAV Properties................................................72 
   14.1  creationdate Property......................................73 
   14.2  displayname Property.......................................73 
   14.3  getcontentlanguage Property................................74 
   14.4  getcontentlength Property..................................74 
   14.5  getcontenttype Property....................................74 
     
                           Expires Oct 2003                          4 

                         WebDAV (RFC2518) bis                June 2003 
    
   14.6  getetag Property...........................................75 
   14.7  getlastmodified Property...................................75 
   14.8  lockdiscovery Property.....................................76 
   14.8.1  Example - Retrieving the lockdiscovery Property..........76 
   14.9  resourcetype Property......................................77 
   14.10 supportedlock Property.....................................78 
   14.10.1 Example - Retrieving the supportedlock Property..........78 
   15 Instructions for Processing XML in DAV........................79 
   16 DAV Compliance Classes........................................80 
   16.1  Class 1....................................................80 
   16.2  Class 2....................................................80 
   16.3  Class "bis"................................................80 
   17 Internationalization Considerations...........................81 
   18 Security Considerations.......................................82 
   18.1  Authentication of Clients..................................82 
   18.2  Denial of Service..........................................83 
   18.3  Security through Obscurity.................................83 
   18.4  Privacy Issues Connected to Locks..........................83 
   18.5  Privacy Issues Connected to Properties.....................84 
   18.6  Implications of XML External Entities......................84 
   18.7  Risks Connected with Lock Tokens...........................85 
   19 IANA Considerations...........................................85 
   20 Intellectual Property.........................................86 
   21 Acknowledgements..............................................86 
   22 References....................................................88 
   22.1  Normative References.......................................88 
   22.2  Informational References...................................89 
   23 Authors' Addresses............................................90 
   24 Appendices....................................................91 
   24.1  Appendix 1 - WebDAV Document Type Definition...............91 
   24.2  Appendix 3 - Notes on Processing XML Elements..............92 
   24.2.1  Notes on Empty XML Elements..............................92 
   24.2.2  Notes on Illegal XML Processing..........................92 
   24.2.3  Example - XML Syntax Error...............................93 
   24.2.4  Example - Unknown XML Element............................93 
   24.3  Appendix 4: UUID Node Generation...........................94 
   25 Full Copyright Statement......................................96 









     
                           Expires Oct 2003                          5 

                         WebDAV (RFC2518) bis                June 2003 
    
    
1  Introduction 
    
   This document describes an extension to the HTTP/1.1 protocol that 
   allows clients to perform remote web content authoring operations.  
   This extension provides a coherent set of methods, headers, request 
   entity body formats, and response entity body formats that provide 
   operations for: 
    
   Properties: The ability to create, remove, and query information 
   about Web pages, such as their authors, creation dates, etc. Also, 
   the ability to link pages of any media type to related pages. 
    
   Collections: The ability to create sets of documents and to retrieve 
   a hierarchical membership listing (like a directory listing in a 
   file system). 
    
   Locking: The ability to keep more than one person from working on a 
   document at the same time. This prevents the "lost update problem", 
   in which modifications are lost as first one author then another 
   writes changes without merging the other author's changes. 
    
   Namespace Operations: The ability to instruct the server to copy and 
   move Web resources. 
    
   Requirements and rationale for these operations are described in a 
   companion document, "Requirements for a Distributed Authoring and 
   Versioning Protocol for the World Wide Web" [RFC2291]. 
    
   This standard does not specify the versioning operations suggested 
   by [RFC2291]. That work was done in a separate document, "Versioning 
   Extensions to WebDAV" [RFC3253]. 
    
   The sections below provide a detailed introduction to resource 
   properties (section 4), collections of resources (section 5), and 
   locking operations (section 6).  These sections introduce the 
   abstractions manipulated by the WebDAV-specific HTTP methods 
   described in section 8. Section 9 describes the new HTTP headers 
   used with WebDAV methods. 
    
   While the status codes provided by HTTP/1.1 are sufficient to 
   describe most error conditions encountered by WebDAV methods, there 
   are some errors that do not fall neatly into the existing 
   categories.  New status codes developed for the WebDAV methods are 
   defined in section 10, and existing HTTP status codes as used in 
   WebDAV are described in section Error! Reference source not found..  
   Since some WebDAV methods may operate over many resources, the 
   Multi-Status response has been introduced to return status 
   information for multiple resources.  The Multi-Status response is 
   described in section 12. 
    
     
                           Expires Oct 2003                          6 

                         WebDAV (RFC2518) bis                June 2003 
    
   WebDAV uses XML to marshal complicated request and response 
   information, as well as to express metadata. XML elements used in 
   this specification are defined in section 13. An informational DTD 
   is provided in Appendix 1.  Section 15 explains how to process XML 
   appearing in WebDAV so that it truly is extensible. 
    
   WebDAV employs the property mechanism to store information about the 
   current state of the resource.  For example, when a lock is taken 
   out on a resource, a lock information property describes the current 
   state of the lock. Section 13.28 defines the properties used within 
   the WebDAV specification. 
    
   Finishing off the specification are sections on what it means to be 
   compliant with this specification (section 16), on 
   internationalization support (section 17), and on security (section 
   18). 
    
    
2  Notational Conventions 
    
   Since this document describes a set of extensions to the HTTP/1.1 
   protocol, the augmented BNF used herein to describe protocol 
   elements is exactly the same as described in section 2.1 of 
   [RFC2616], including the rules about implied linear white-space.  
   Since this augmented BNF uses the basic production rules provided in 
   section 2.2 of [RFC2616], these rules apply to this document as 
   well. 
    
   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", 
   "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in 
   this document are to be interpreted as described in RFC 2119 
   [RFC2119]. 
    
    
3  Terminology 
    
   URI/URL - A Uniform Resource Identifier and Uniform Resource 
   Locator, respectively. These terms (and the distinction between 
   them) are defined in [RFC2396]. 
    
   Collection - A resource that contains a set of URLs, which identify 
   and locate member resources and which meet the requirements in 
   section 5 of this specification. 
     
   Member URL - A URL which is a member of the set of URLs contained by 
   a collection. 
    
   Internal Member URL - A Member URL that is immediately relative to 
   the URL of the collection (the definition of immediately relative is 
   given in section 5.2). 
    
     
                           Expires Oct 2003                          7 

                         WebDAV (RFC2518) bis                June 2003 
    
   Property - A name/value pair that contains descriptive information 
   about a resource. 
    
   Live Property - A property whose semantics and syntax are enforced 
   by the server.  For example, the live "getcontentlength" property 
   has its value, the length of the entity returned by a GET request, 
   automatically calculated by the server. 
     
   Dead Property - A property whose semantics and syntax are not 
   enforced by the server.  The server only records the value of a dead 
   property; the client is responsible for maintaining the consistency 
   of the syntax and semantics of a dead property. 
    
 
4  Data Model for Resource Properties 
    
4.1 The Resource Property Model 
    
   Properties are pieces of data that describe the state of a resource.  
   Properties are data about data. 
    
   Properties are used in distributed authoring environments to provide 
   for efficient discovery and management of resources.  For example, a 
   'subject' property might allow for the indexing of all resources by 
   their subject, and an 'author' property might allow for the 
   discovery of what authors have written which documents. 
    
   The DAV property model consists of name/value pairs.  The name of a 
   property identifies the property's syntax and semantics, and 
   provides an address by which to refer to its syntax and semantics. 
    
   There are two categories of properties: "live" and "dead".  A live 
   property has its syntax and semantics enforced by the server. Live 
   properties include cases where a) the value of a property is read-
   only, maintained by the server, and b) the value of the property is 
   maintained by the client, but the server performs syntax checking on 
   submitted values. All instances of a given live property MUST comply 
   with the definition associated with that property name.  A dead 
   property has its syntax and semantics enforced by the client; the 
   server merely records the value of the property verbatim. 
    
4.2 Existing Metadata Proposals 
    
   Properties have long played an essential role in the maintenance of 
   large document repositories, and many current proposals contain some 
   notion of a property, or discuss web metadata more generally.  These 
   include PICS [REC-PICS], PICS-NG, XML, Web Collections, and several 
   proposals on representing relationships within HTML. Work on PICS-NG 
   and Web Collections has been subsumed by the Resource Description 
   Framework (RDF) metadata activity of the World Wide Web Consortium. 

     
                           Expires Oct 2003                          8 

                         WebDAV (RFC2518) bis                June 2003 
    
   RDF consists of a network-based data model and an XML representation 
   of that model. 
    
   Some proposals come from a digital library perspective.  These 
   include the Dublin Core [RFC2413] metadata set and the Warwick 
   Framework [WF], a container architecture for different metadata 
   schemas.  The literature includes many examples of metadata, 
   including MARC [USMARC], a bibliographic metadata format, and a 
   technical report bibliographic format employed by the Dienst system 
   [RFC1807]. Additionally, the proceedings from the first IEEE 
   Metadata conference describe many community-specific metadata sets. 
    
   Participants of the 1996 Metadata II Workshop in Warwick, UK [WF], 
   noted that "new metadata sets will develop as the networked 
   infrastructure matures" and "different communities will propose, 
   design, and be responsible for different types of metadata." These 
   observations can be corroborated by noting that many community-
   specific sets of metadata already exist, and there is significant 
   motivation for the development of new forms of metadata as many 
   communities increasingly make their data available in digital form, 
   requiring a metadata format to assist data location and cataloging. 
    
4.3 Properties and HTTP Headers 
    
   Properties already exist, in a limited sense, in HTTP message 
   headers.  However, in distributed authoring environments a 
   relatively large number of properties are needed to describe the 
   state of a resource, and setting/returning them all through HTTP 
   headers is inefficient.  Thus a mechanism is needed which allows a 
   principal to identify a set of properties in which the principal is 
   interested and to set or retrieve just those properties. 
    
4.4 XML Usage 
    
   In HTTP/1.1, method parameter information was exclusively encoded in 
   HTTP headers. Unlike HTTP/1.1, WebDAV encodes method parameter 
   information either in an Extensible Markup Language (XML) [REC-XML] 
   request entity body, or in an HTTP header.  The use of XML to encode 
   method parameters was motivated by the ability to add extra XML 
   elements to existing structures, providing extensibility; and by 
   XML's ability to encode information in ISO 10646 character sets, 
   providing internationalization support. As a rule of thumb, 
   parameters are encoded in XML entity bodies when they have unbounded 
   length, or when they may be shown to a human user and hence require 
   encoding in an ISO 10646 character set.  Otherwise, parameters are 
   encoded within HTTP headers.   
    
   In addition to encoding method parameters, XML is used in WebDAV to 
   encode the responses from methods, providing the extensibility and 
   internationalization advantages of XML for method output, as well as 
   input. 
     
                           Expires Oct 2003                          9 

                         WebDAV (RFC2518) bis                June 2003 
    
    
   An XML DTD is included in an appendix for all the XML elements 
   defined in this specification. However, legal XML will not be valid 
   according to this DTD due to namespace usage and extension rules, so 
   the DTD is only informational. 
    
   The XML namespace extension is also used in this specification in 
   order to allow for new XML elements to be added without fear of 
   colliding with other element names. Although WebDAV request and 
   response bodies can be extended by arbitrary XML elements, which can 
   be ignored by the message recipient, an XML element in the "DAV:" 
   namespace SHOULD NOT be used in the request or response body unless 
   that XML element is explicitly defined in an IETF RFC reviewed by a 
   WebDAV working group. 
    
   Note that ôDAV:ö is a top-level URI identifier that was defined 
   solely to provide a namespace for WebDAV XML elements and property 
   names.  This practice is discouraged in part because registration of 
   top-level URI identifiers is difficult. "DAV:" was defined as the 
   WebDAV namespace before standard best practices emerged, and this 
   namespace is kept and still used because of significant existing 
   deployments, but this should not be emulated. 
    
4.5 Property Values 
    
   The value of a property is always a (wellformed) XML fragment. 
    
   XML has been chosen because it is a flexible, self-describing, 
   structured data format that supports rich schema definitions, and 
   because of its support for multiple character sets.  XML's self-
   describing nature allows any property's value to be extended by 
   adding new elements.  Older clients will not break when they 
   encounter extensions because they will still have the data specified 
   in the original schema and will ignore elements they do not 
   understand.  XML's support for multiple character sets allows any 
   human-readable property to be encoded and read in a character set 
   familiar to the user.  XML's support for multiple human languages, 
   using the "xml:lang" attribute, handles cases where the same 
   character set is employed by multiple human languages. Note that 
   xml:lang scope is recursive, so a xml:lang attribute on any element 
   containing a property name element applies to the property value 
   unless it has been overridden by a more locally scoped attribute. 
    
   A property is always represented in XML with an XML element 
   consisting of the property name. The simplest example is an empty 
   property, which is different from a property that does not exist. 
    
     <R:title xmlns:R="http://www.example.com/ns/"></R:title> 
    
   The value of a property appears inside the property name element.  
   The value may be any kind of well-formed XML content, including both 
     
                           Expires Oct 2003                         10 

                         WebDAV (RFC2518) bis                June 2003 
    
   text-only and mixed content.  When the property value contains 
   further XML elements, namespaces that are in scope for that part of 
   the XML document apply within the property value as well, and MUST 
   be preserved in server storage for retransmission later. Namespace 
   prefixes need not be preserved due to the rules of prefix 
   declaration in XML. 
    
   Attributes on the property name element may convey information about 
   the property, but are not considered part of the value. However, 
   when language information appears in the 'xml:lang' attribute on the 
   property name element, the language information MUST be preserved in 
   server storage for retransmission later. 
    
   The XML attribute xml:space MUST NOT be used to change white space 
   handling.  White space in property values is significant.  
    
4.6 Property Names 
    
   A property name is a universally unique identifier that is 
   associated with a schema that provides information about the syntax 
   and semantics of the property. 
    
   Because a property's name is universally unique, clients can depend 
   upon consistent behavior for a particular property across multiple 
   resources, on the same and across different servers, so long as that 
   property is "live" on the resources in question, and the 
   implementation of the live property is faithful to its definition. 
    
   The XML namespace mechanism, which is based on URIs [RFC2396], is 
   used to name properties because it prevents namespace collisions and 
   provides for varying degrees of administrative control. 
    
   The property namespace is flat; that is, no hierarchy of properties 
   is explicitly recognized.  Thus, if a property A and a property A/B 
   exist on a resource, there is no recognition of any relationship 
   between the two properties.  It is expected that a separate 
   specification will eventually be produced which will address issues 
   relating to hierarchical properties. 
    
   Finally, it is not possible to define the same property twice on a 
   single resource, as this would cause a collision in the resource's 
   property namespace. 
    
    
5  Collections of Web Resources 
    
   This section provides a description of a new type of Web resource, 
   the collection, and discusses its interactions with the HTTP URL 
   namespace. The purpose of a collection resource is to model 
   collection-like objects (e.g., file system directories) within a 
   server's namespace. 
     
                           Expires Oct 2003                         11 

                         WebDAV (RFC2518) bis                June 2003 
    
    
   All DAV compliant resources MUST support the HTTP URL namespace 
   model specified herein. 
    
5.1 HTTP URL Namespace Model 
    
   The HTTP URL namespace is a hierarchical namespace where the 
   hierarchy is delimited with the "/" character.    
    
   An HTTP URL namespace is said to be consistent if it meets the 
   following conditions: for every URL in the HTTP hierarchy there 
   exists a collection that contains that URL as an internal member. 
   The root, or top-level collection of the namespace under 
   consideration is exempt from the previous rule. 
    
   Neither HTTP/1.1 nor WebDAV require that the entire HTTP URL 
   namespace be consistent.  However, certain WebDAV methods are 
   prohibited from producing results that cause namespace 
   inconsistencies. 
    
   Although implicit in [RFC2616] and [RFC2396], any resource, 
   including collection resources, MAY be identified by more than one 
   URI. For example, a resource could be identified by multiple HTTP 
   URLs. 
    
5.2 Collection Resources 
    
   A collection is a resource whose state consists of at least a list 
   of internal member URLs and a set of properties, but which may have 
   additional state such as entity bodies returned by GET.  An internal 
   member URL MUST be immediately relative to a base URL of the 
   collection.  That is, the internal member URL is equal to a 
   containing collection's URL plus an additional segment for non-
   collection resources, or additional segment plus trailing slash "/" 
   for collection resources, where segment is defined in section 3.3 of 
   [RFC2396].  
    
   Any given internal member URL MUST only belong to the collection 
   once, i.e., it is illegal to have multiple instances of the same URL 
   in a collection.  Properties defined on collections behave exactly 
   as do properties on non-collection resources.  
    
   For all WebDAV compliant resources A and B, identified by URLs U and 
   V, for which U is immediately relative to V, B MUST be a collection 
   that has U as an internal member URL. So, if the resource with URL 
   http://example.com/bar/blah is WebDAV compliant and if the resource 
   with URL http://example.com/bar/ is WebDAV compliant then the 
   resource with URL http://example.com/bar/ must be a collection and 
   must contain URL http://example.com/bar/blah as an internal member. 
    

     
                           Expires Oct 2003                         12 

                         WebDAV (RFC2518) bis                June 2003 
    
   Collection resources MAY list the URLs of non-WebDAV compliant 
   children in the HTTP URL namespace hierarchy as internal members but 
   are not required to do so. For example, if the resource with URL 
   http://example.com/bar/blah is not WebDAV compliant and the URL 
   http://example.com/bar/ identifies a collection then URL 
   http://example.com/bar/blah may or may not be an internal member of 
   the collection with URL http://example.com/bar/. 
    
   If a WebDAV compliant resource has no WebDAV compliant children in 
   the HTTP URL namespace hierarchy then the WebDAV compliant resource 
   is not required to be a collection. 
    
   There is a standing convention that when a collection is referred to 
   by its name without a trailing slash, the server MAY handle the 
   request as if the trailing slash were present.  In this case it 
   SHOULD return a Content-Location header in the response, pointing to 
   the URL ending with the "/".  For example, if a client invokes a 
   method on http://example.bar/blah (no trailing slash), the server 
   may respond as if the operation were invoked on 
   http://example.com/blah/ (trailing slash), and should return a 
   Content-Location header with the value http://example.bar/blah/. 
   Wherever a server produces a URL referring to a collection, the 
   server MUST include the trailing slash. In general clients SHOULD 
   use the "/" form of collection names.   
    
   A resource MAY be a collection but not be WebDAV compliant.  That 
   is, the resource may comply with all the rules set out in this 
   specification regarding how a collection is to behave without 
   necessarily supporting all methods that a WebDAV compliant resource 
   is required to support.  In such a case the resource may return the 
   DAV:resourcetype property with the value DAV:collection but MUST NOT 
   return a DAV header containing the value "1" on an OPTIONS response.   
    
   Clients MUST be able to support the case where WebDAV resources are 
   contained inside non-WebDAV resources.  For example, if a OPTIONS 
   response from "http://example.com/servlet/dav/collection" indicates 
   WebDAV support, the client cannot assume that 
   "http://example.com/servlet/dav/" or its parent necessarily are 
   WebDAV collections. 
    
5.3 Source Resources and Output Resources 
    
   For many resources, the entity returned by a GET method exactly 
   matches the persistent state of the resource, for example, a GIF 
   file stored on a disk.  For this simple case, the URL at which a 
   resource is accessed is identical to the URL at which the source 
   (the persistent state) of the resource is accessed.  This is also 
   the case for HTML source files that are not processed by the server 
   prior to transmission. 
    

     
                           Expires Oct 2003                         13 

                         WebDAV (RFC2518) bis                June 2003 
    
   However, the server can sometimes process HTML resources before they 
   are transmitted as a return entity body.  For example, a server-
   side-include directive within an HTML file might instruct a server 
   to replace the directive with another value, such as the current 
   date.  In this case, what is returned by GET (HTML plus date) 
   differs from the persistent state of the resource (HTML plus 
   directive).  Typically there is no way to access the HTML resource 
   containing the unprocessed directive. 
    
   Sometimes the entity returned by GET is the output of a data-
   producing process that is described by one or more source resources 
   (that may not even have a location in the URI namespace).  A single 
   data-producing process may dynamically generate the state of a 
   potentially large number of output resources.  An example of this is 
   a CGI script that describes a "finger" gateway process that maps 
   part of the namespace of a server into finger requests, such as 
   http://finger.example.com/finger_gateway/user@host. 
                     
   Although this problem would usefully be solved, interoperable WebDAV 
   implementations have been widely deployed without actually solving 
   this problem. Thus, the source vs. output problem is not solved in 
   this specification, and has been deferred to a separate document. 
    
    
6  Locking 
    
   The ability to lock a resource provides a mechanism for serializing 
   access to that resource.  Using a lock, an authoring client can 
   provide a reasonable guarantee that another principal will not 
   modify a resource while it is being edited.  In this way, a client 
   can prevent the "lost update" problem. 
    
   This specification allows locks to vary over two client-specified 
   parameters, the number of principals involved (exclusive vs. shared) 
   and the type of access to be granted. This document defines locking 
   for only one access type, write. However, the syntax is extensible, 
   and permits the eventual specification of locking for other access 
   types. 
    
6.1 Exclusive Vs. Shared Locks 
    
   The most basic form of lock is an exclusive lock.  Only one 
   exclusive lock may exist on any resource, whether it is directly or 
   indirectly locked (see 7.5).  Exclusive locks avoid having to merge 
   results, without requiring any coordination other than the methods 
   described in this specification. 
    
   However, there are times when the goal of a lock is not to exclude 
   others from exercising an access right but rather to provide a 
   mechanism for principals to indicate that they intend to exercise 
   their access rights.  Shared locks are provided for this case.  A 
     
                           Expires Oct 2003                         14 

                         WebDAV (RFC2518) bis                June 2003 
    
   shared lock allows multiple principals to receive a lock.  Hence any 
   principal with appropriate access can get the lock. 
    
   With shared locks there are two trust sets that affect a resource.  
   The first trust set is created by access permissions.  Principals 
   who are trusted, for example, may have permission to write to the 
   resource.  Among those who have access permission to write to the 
   resource, the set of principals who have taken out a shared lock 
   also must trust each other, creating a (typically) smaller trust set 
   within the access permission write set. 
    
   Starting with every possible principal on the Internet, in most 
   situations the vast majority of these principals will not have write 
   access to a given resource.  Of the small number who do have write 
   access, some principals may decide to guarantee their edits are free 
   from overwrite conflicts by using exclusive write locks.  Others may 
   decide they trust their collaborators will not overwrite their work 
   (the potential set of collaborators being the set of principals who 
   have write permission) and use a shared lock, which informs their 
   collaborators that a principal may be working on the resource. 
    
   The WebDAV extensions to HTTP do not need to provide all of the 
   communications paths necessary for principals to coordinate their 
   activities.  When using shared locks, principals may use any out of 
   band communication channel to coordinate their work (e.g., face-to-
   face interaction, written notes, post-it notes on the screen, 
   telephone conversation, Email, etc.)  The intent of a shared lock is 
   to let collaborators know who else may be working on a resource. 
    
   Shared locks are included because experience from web distributed 
   authoring systems has indicated that exclusive locks are often too 
   rigid.  An exclusive lock is used to enforce a particular editing 
   process: take out an exclusive lock, read the resource, perform 
   edits, write the resource, release the lock.  This editing process 
   has the problem that locks are not always properly released, for 
   example when a program crashes, or when a lock owner leaves without 
   unlocking a resource.  While both timeouts and administrative action 
   can be used to remove an offending lock, neither mechanism may be 
   available when needed; the timeout may be long or the administrator 
   may not be available. 
    
6.2 Required Support 
    
   A WebDAV compliant resource is not required to support locking in 
   any form.  If the resource does support locking it may choose to 
   support any combination of exclusive and shared locks for any access 
   types. 
    
   The reason for this flexibility is that locking policy strikes to 
   the very heart of the resource management and versioning systems 
   employed by various storage repositories.  These repositories 
     
                           Expires Oct 2003                         15 

                         WebDAV (RFC2518) bis                June 2003 
    
   require control over what sort of locking will be made available.  
   For example, some repositories only support shared write locks while 
   others only provide support for exclusive write locks while yet 
   others use no locking at all.  As each system is sufficiently 
   different to merit exclusion of certain locking features, this 
   specification leaves locking as the sole axis of negotiation within 
   WebDAV. 
    
6.3 Lock Tokens 
    
   A lock token is a type of state token, represented as a URI, which 
   identifies a particular lock.  A lock token is returned in the Lock-
   Token header in the response to a successful LOCK operation. The 
   lock token also appears in the value of the lockdiscovery property, 
   the value of which is returned in the body of the response to a 
   successful LOCK operation (this property also includes the tokens of 
   other current locks on the resource).  Finally, the lockdiscovery 
   property can be queried using PROPFIND and the token can be 
   discovered that way. Each lock has only one unique lock token.  
    
   Lock token URIs MUST be unique across all resources for all time. 
   This uniqueness constraint allows lock tokens to be submitted across 
   resources and servers without fear of confusion. 
    
   This specification provides a lock token URI scheme called 
   opaquelocktoken that meets the uniqueness requirements.  However 
   resources are free to return any URI scheme so long as it meets the 
   uniqueness requirements. 
    
   Having a lock token provides no special access rights. Anyone can 
   find out anyone else's lock token by performing lock discovery. 
   Locks MUST be enforced based upon whatever authentication mechanism 
   is used by the server, not based on the secrecy of the token values. 
    
6.4 opaquelocktoken Lock Token URI Scheme 
    
   The opaquelocktoken URI scheme is designed to be unique across all 
   resources for all time.  Due to this uniqueness quality, a client 
   may submit an opaque lock token in an If header on a resource other 
   than the one that returned it. 
    
   In order to guarantee uniqueness across all resources for all time 
   the opaquelocktoken requires the use of the Universal Unique 
   Identifier (UUID) mechanism, as described in [ISO-11578]. 
    
   Opaquelocktoken generators, however, have a choice of how they 
   create these tokens.  They can either generate a new UUID for every 
   lock token they create or they can create a single UUID  and then 
   add extension characters.  If the second method is selected then the 
   program generating the extensions MUST guarantee that the same 
   extension will never be used twice with the associated UUID. 
     
                           Expires Oct 2003                         16 

                         WebDAV (RFC2518) bis                June 2003 
    
    
   OpaqueLockToken-URI = "opaquelocktoken:" UUID [Extension]  ; The 
   UUID production is the string representation of a UUID, as defined 
   in [ISO-11578]. Note that white space (LWS) is not allowed between 
   elements of this production. 
    
   Extension = path  ; path is defined in section 3.2.1 of [RFC2616] 
    
6.5 Lock Capability Discovery 
    
   Since server lock support is optional, a client trying to lock a 
   resource on a server can either try the lock and hope for the best, 
   or perform some form of discovery to determine what lock 
   capabilities the server supports.  This is known as lock capability 
   discovery.  Lock capability discovery differs from discovery of 
   supported access control types, since there may be access control 
   types without corresponding lock types.  A client can determine what 
   lock types the server supports by retrieving the supportedlock 
   property. 
    
   Any DAV compliant resource that supports the LOCK method MUST 
   support the supportedlock property. 
    
6.6 Active Lock Discovery 
    
   If another principal locks a resource that a principal wishes to 
   access, it is useful for the second principal to be able to find out 
   who the first principal is.  For this purpose the lockdiscovery 
   property is provided.  This property lists all outstanding locks, 
   describes their type, and where available, provides their lock 
   token. 
    
   Any DAV compliant resource that supports the LOCK method MUST 
   support the lockdiscovery property. 
    
6.7 Usage Considerations 
    
   Although the locking mechanisms specified here provide some help in 
   preventing lost updates, they cannot guarantee that updates will 
   never be lost.  Consider the following scenario: 
    
   Two clients A and B are interested in editing the resource 
   'index.html'.  Client A is an HTTP client rather than a WebDAV 
   client, and so does not know how to perform locking. 
    
   Client A doesn't lock the document, but does a GET and begins 
   editing. 
   Client B does LOCK, performs a GET and begins editing. 
   Client B finishes editing, performs a PUT, then an UNLOCK. 
   Client A performs a PUT, overwriting and losing all of B's changes. 
     

                         WebDAV (RFC2518) bis                June 2003 
    
    
   There are several reasons why the WebDAV protocol itself cannot 
   prevent this situation.  First, it cannot force all clients to use 
   locking because it must be compatible with HTTP clients that do not 
   comprehend locking.  Second, it cannot require servers to support 
   locking because of the variety of repository implementations, some 
   of which rely on reservations and merging rather than on locking.  
   Finally, being stateless, it cannot enforce a sequence of operations 
   like LOCK / GET / PUT / UNLOCK.  
    
   WebDAV servers that support locking can reduce the likelihood that 
   clients will accidentally overwrite each other's changes by 
   requiring clients to lock resources before modifying them.  Such 
   servers would effectively prevent HTTP 1.0 and HTTP 1.1 clients from 
   modifying resources. 
    
   WebDAV clients can be good citizens by using a lock / retrieve / 
   write /unlock sequence of operations (at least by default) whenever 
   they interact with a WebDAV server that supports locking. 
    
   HTTP 1.1 clients can be good citizens, avoiding overwriting other 
   clients' changes, by using entity tags in If-Match headers with any 
   requests that would modify resources.  
    
   Information managers may attempt to prevent overwrites by 
   implementing client-side procedures requiring locking before 
   modifying WebDAV resources. 
    
    
7  Write Lock 
    
   This section describes the semantics specific to the write lock 
   type.  The write lock is a specific instance of a lock type, and is 
   the only lock type described in this specification. 
    
   Write locks prevent unauthorized changes to resources. In general 
   terms, changes affected by write locks include changes to: 
    - the content of the resource 
    - any dead property of the resource 
    - any live property defined to be lockable (all properties defined 
   in this specification are lockable) 
    - the direct membership of the resource, if it is a collection 
    - the URL/location of a resource 
    
   The next few sections describe in more specific terms how write 
   locks interact with various operations. 
    
7.1 Methods Restricted by Write Locks 
    
   A write lock MUST prevent a principal without the lock from 
   successfully executing a PUT, POST, PROPPATCH, LOCK, UNLOCK, MOVE, 
     
                           Expires Oct 2003                         18 

                         WebDAV (RFC2518) bis                June 2003 
    
   DELETE, or MKCOL on the locked resource.  All other current methods, 
   GET in particular, function independently of the lock. 
    
   Note, however, that as new methods are created it will be necessary 
   to specify how they interact with a write lock. 
    
7.2 Write Locks and Lock Tokens 
    
   A successful request for an exclusive or shared write lock MUST 
   result in the generation of a unique lock token associated with the 
   requesting principal.  Thus if five principals have a shared write 
   lock on the same resource there will be five lock tokens, one for 
   each principal. 
    
7.3 Write Locks and Properties 
    
   While those without a write lock may not alter a property on a 
   resource it is still possible for the values of live properties to 
   change, even while locked, due to the requirements of their schemas.  
   Only dead properties and live properties defined to respect locks 
   are guaranteed not to change while write locked. 
    
7.4 Write Locks and Unmapped URLs 
    
   It is possible to lock an unmapped URL in order to lock the name for 
   use.  This is a simple way to avoid the lost-update problem on the 
   creation of a new resource (another way is to use If-None-Match 
   header specified in HTTP 1.1).  It has the side benefit of locking 
   the new resource immediately for use of the creator.   
    
   The lost-update problem is not an issue for collections because 
   MKCOL can only be used to create a collection, not to overwrite an 
   existing collection.  In order to immediately lock a collection upon 
   creation, clients may attempt to pipeline the MKCOL and LOCK 
   requests together.   
    
   A lock request to an unmapped URL should result in the creation of a 
   resource that is locked.  A subsequent PUT request with the correct 
   lock token should normally succeed, and provides the content, 
   content-type, content-language and other information as appropriate.  
    
   In this situation, a WebDAV server that was implemented from RFC2518 
   MAY create "lock-null" resources which are special and unusual 
   resources.  Historically, a lock-null resource: 
    
   -  Responds with a 404 or 405 to any DAV method except for PUT, 
     MKCOL, OPTIONS, PROPFIND, LOCK, UNLOCK. 
   -  Appears as a member of its parent collection. 
   -  Disappears (becomes once more an unmapped URL) if its lock goes 
     away before it is converted to a regular resource.  (This must 
     
                           Expires Oct 2003                         19 

                         WebDAV (RFC2518) bis                June 2003 
    
     also happen if it is renamed or moved, or if any parent collection 
     is renamed or moved, because locks are tied to URLs). 
   -  May be turned into a regular resource when a PUT request to the 
     URL is successful. Ceases to be a lock-null resource. 
   -  May be turned into a collection when a MKCOL request to the URL 
     is successful.  Ceases to be a lock-null resource 
   -  Has defined values for lockdiscovery and supportedlock 
     properties. 
    
   However, interoperability and compliance problems have been found 
   with lock-null resources.  Therefore, they are deprecated.  WebDAV 
   servers SHOULD create regular locked empty resources, which are and 
   behave in every way as normal resources.  A locked empty resource: 
    
   -  Can be read, deleted, moved, copied, and in all ways behave as a 
     regular resource, not a lock-null resource. 
   -  Appears as a member of its parent collection. 
   -  SHOULD NOT disappear when its lock goes away (clients must 
     therefore be responsible for cleaning up their own mess, as with 
     any other operation) 
   -  SHOULD default to having no content type. 
   -  MAY NOT have values for properties like getcontentlanguage which 
     havenÆt been specified yet by the client. 
   -  May have content added with a PUT request.  MUST be able to 
     change content type. 
   -  MUST NOT be turned into a collection.  A MKCOL request must fail 
     as it would to any existing resource. 
   -  MUST have defined values for lockdiscovery and supportedlock 
     properties. 
   -  The response MUST indicate that a resource was created, by use of 
     the "201 Created" response code (a LOCK request to an existing 
     resource instead will result in 200 OK).  The body must still 
     include the lockdiscovery property, as with a LOCK request to an 
     existing resource. 
    
   The client is expected to update the locked empty resource shortly 
   after locking it, using PUT and possibly PROPPATCH.  When the client 
   uses PUT to overwrite a locked empty resource the client MUST supply 
   a Content-Type if any is known.  If the client supplies a Content-
   Type value the server MUST set that value (this requirement actually 
   applies to any resource that is overwritten but is particularly 
   necessary for locked empty resources which are initially created 
   with no Content-Type.   
    
   Clients can easily interoperate both with servers that support the 
   deprecated lock-null resources and servers that support simpler 

     
                           Expires Oct 2003                         20 

                         WebDAV (RFC2518) bis                June 2003 
    
   locked empty resources by only attempting PUT after a LOCK to an 
   unmapped URL, not MKCOL or GET. 
    
7.5 Write Locks and Collections 
    
   A write lock on a collection, whether created by a "Depth: 0" or 
   "Depth: infinity" lock request, prevents the addition or removal of 
   member URLs of the collection by non-lock owners.   
    
   A zero-depth lock on a collection affects changes to the direct 
   membership of that collection.  When a principal issues a PUT or 
   POST request to create a new resource in a write locked collection, 
   or issues a DELETE to remove a resource which has a URL which is an 
   existing internal member URL of a write locked collection, this 
   request MUST fail if the principal does not provide the correct lock 
   token for the locked collection. 
    
   In addition, a depth-infinity lock affects all write operations to 
   all descendents of the locked collection.  With a depth-infinity 
   lock, the root of the lock is directly locked, and all its 
   descendants are indirectly locked.   
    - Any new resource added as a descendent of a depth-infinity locked 
   collection becomes indirectly locked.   
    - Any indirectly locked resource moved out of the locked collection 
   into an unlocked collection is thereafter unlocked. 
    - Any indirectly locked resource moved out of a locked source 
   collection into a depth-infinity locked target collection remains 
   indirectly locked but is now within the scope of the lock on the 
   target collection (the target collection's lock token will 
   thereafter be required to make further changes). 
    
   If a depth-infinity write LOCK request is issued to a collection 
   containing member URLs identifying resources that are currently 
   locked in a manner which conflicts with the write lock, the request 
   MUST fail with a 423 (Locked) status code. 
    
   If a lock owner causes the URL of a resource to be added as an 
   internal member URL of a depth-infinity locked collection then the 
   new resource MUST be automatically added to the lock.  This is the 
   only mechanism that allows a resource to be added to a write lock.  
   Thus, for example, if the collection /a/b/ is write locked and the 
   resource /c is moved to /a/b/c then resource /a/b/c will be added to 
   the write lock. 
    
7.6 Write Locks and the If Request Header 
    
   If a user agent is not required to have knowledge about a lock when 
   requesting an operation on a locked resource, the following scenario 
   might occur.  Program A, run by User A, takes out a write lock on a 
   resource.  Program B, also run by User A, has no knowledge of the 
   lock taken out by Program A, yet performs a PUT to the locked 
     
                           Expires Oct 2003                         21 

                         WebDAV (RFC2518) bis                June 2003 
    
   resource.  In this scenario, the PUT succeeds because locks are 
   associated with a principal, not a program, and thus program B, 
   because it is acting with principal AÆs credential, is allowed to 
   perform the PUT.  However, had program B known about the lock, it 
   would not have overwritten the resource, preferring instead to 
   present a dialog box describing the conflict to the user.  Due to 
   this scenario, a mechanism is needed to prevent different programs 
   from accidentally ignoring locks taken out by other programs with 
   the same authorization. 
    
   In order to prevent these collisions a lock token MUST be submitted 
   by an authorized principal for all locked resources that a method 
   may change or the method MUST fail.  A lock token is submitted when 
   it appears in an If header.  For example, if a resource is to be 
   moved and both the source and destination are locked then two lock 
   tokens must be submitted in the if header, one for the source and 
   the other for the destination. 
    
Example - Write Lock 
    
   >>Request 
    
     COPY /~fielding/index.html HTTP/1.1 
     Host: www.ics.uci.edu 
     Destination: http://www.ics.uci.edu/users/f/fielding/index.html 
     If: <http://www.ics.uci.edu/users/f/fielding/index.html> 
         (<opaquelocktoken:f81d4fae-7dec-11d0-a765-00a0c91e6bf6>) 
      
    
   >>Response 
    
     HTTP/1.1 204 No Content 
      
      
   In this example, even though both the source and destination are 
   locked, only one lock token must be submitted, for the lock on the 
   destination.  This is because the source resource is not modified by 
   a COPY, and hence unaffected by the write lock. In this example, 
   user agent authentication has previously occurred via a mechanism 
   outside the scope of the HTTP protocol, in the underlying transport 
   layer. 
    
7.7 Write Locks and COPY/MOVE 
    
   A COPY method invocation MUST NOT duplicate any write locks active 
   on the source.  However, as previously noted, if the COPY copies the 
   resource into a collection that is locked with "Depth: infinity", 
   then the resource will be added to the lock. 
    
     
                           Expires Oct 2003                         22 

                         WebDAV (RFC2518) bis                June 2003 
    
   A successful MOVE request on a write locked resource MUST NOT move 
   the write lock with the resource. However, the resource is subject 
   to being added to an existing lock at the destination, as specified 
   in section 7.5. For example, if the MOVE makes the resource a child 
   of a collection that is locked with "Depth: infinity", then the 
   resource will be added to that collection's lock. Additionally, if a 
   resource locked with "Depth: infinity" is moved to a destination 
   that is within the scope of the same lock (e.g., within the 
   namespace tree covered by the lock), the moved resource will again 
   be a added to the lock. In both these examples, as specified in 
   section 7.6, an If header must be submitted containing a lock token 
   for both the source and destination.  
    
7.8 Refreshing Write Locks 
    
   A client MUST NOT submit the same write lock request twice.  Note 
   that a client is always aware it is resubmitting the same lock 
   request because it must include the lock token in the If header in 
   order to make the request for a resource that is already locked. 
    
   However, a client may submit a LOCK method with an If header but 
   without a body.  This form of LOCK MUST only be used to "refresh" a 
   lock.  Meaning, at minimum, that any timers associated with the lock 
   MUST be re-set. 
    
   A server may return a Timeout header with a lock refresh that is 
   different than the Timeout header returned when the lock was 
   originally requested.  Additionally clients may submit Timeout 
   headers of arbitrary value with their lock refresh requests.  
   Servers, as always, may ignore Timeout headers submitted by the 
   client. Note that timeout is measured in seconds remaining until 
   expiration. 
    
   If an error is received in response to a refresh LOCK request the 
   client MUST NOT assume that the lock was refreshed. 
    
8  HTTP Methods for Distributed Authoring 
    
8.1 General request and response handling 
    
8.1.1   Use of XML 
    
   Some of the following new HTTP methods use XML as a request and 
   response format.  All DAV compliant clients and resources MUST use 
   XML parsers that are compliant with [REC-XML] and [REC-XMLNS].  All 
   XML used in either requests or responses MUST be, at minimum, well 
   formed and use namespaces correctly.  If a server receives ill-
   formed XML in a request it MUST reject the entire request with a 400 
   (Bad Request).  If a client receives ill-formed XML in a response 
   then it MUST NOT assume anything about the outcome of the executed 
   method and SHOULD treat the server as malfunctioning. 
     
                           Expires Oct 2003                         23 

                         WebDAV (RFC2518) bis                June 2003 
    
    
8.1.2   Required Bodies in Requests 
    
   Some of these new methods do not define bodies.  Servers MUST 
   examine all requests for a body, even when a body was not expected.  
   In cases where a request body is present but would be ignored by a 
   server, the server MUST reject the request with 415 (Unsupported 
   Media Type).  This informs the client (which may have been 
   attempting to use an extension) that the body could not be processed 
   as they intended. 
    
8.1.3   Use of Location header in responses 
    
   When the Location header is used in a response, it is used by the 
   server to indicate the preferred address for the target resource of 
   the request.  Whenever the server has a preferred address, it should 
   use that address consistently.  This means that when a response 
   contains a Location header, all the URLs in the response body (e.g. 
   a Multi-Status) should be consistent (most importantly, should use 
   the same host and port). 
    
8.1.4   Required Response Headers: Date 
    
     Note that HTTP 1.1 requires the Date header in all responses if 
     possible. 
    
8.1.5   ETag 
    
   HTTP 1.1 suggests the use of the ETag header in responses to GET and 
   PUT requests. Correct use of ETags is even more important in a 
   distributed authoring environment, because ETags are necessary along 
   with locks to avoid the lost-update problem.  A client might fail to 
   renew a lock, for example when the lock times out and the client is 
   accidentally offline or in the middle of a long upload.  When a 
   client fails to renew the lock, it's quite possible the resource can 
   still be relocked and the user can go on editing, as long as no 
   changes were made in the meantime. ETags are required for the client 
   to be able to distinguish this case. Otherwise, the client is forced 
   to ask the user whether to overwrite the resource on the server 
   without even being able to tell the user whether it has changed. 
   Timestamps do not solve this problem nearly as well as ETags. 
    
   WebDAV servers SHOULD support strong ETags for all resources that 
   may be PUT.  If ETags are supported for a resource, the server MUST 
   return the ETag header in all PUT and GET responses to that 
   resource, as well as provide the same value for the 'getetag' 
   property.  
    
   Because clients may be forced to prompt users or throw away changed 
   content if the ETag changes, a WebDAV server MUST not change the 
   ETag (or getlastmodified value) for a resource when only its 
     
                           Expires Oct 2003                         24 

                         WebDAV (RFC2518) bis                June 2003 
    
   property values change. The ETag represents the state of the body or 
   contents of the resource. There is no similar way to tell if 
   properties have changed. 
 
8.1.6   Including error response bodies 
 
   HTTP and WebDAV did not use the bodies of most error responses for 
   machine-parsable information until DeltaV introduced a mechanism to 
   include more specific information in the body of an error response 
   (section 1.6 of [RFC3253]). The mechanism is appropriate to use with 
   any error response that may take a body but does not already have a 
   body defined. The mechanism is particularly appropriate when a 
   status code can mean many things (for example, 400 Bad Request can 
   mean required headers are missing, headers are incorrectly 
   formatted, or much more).  
    
   This mechanism does not take the place of using a correct numeric 
   error code as defined here or in HTTP, because the client MUST 
   always be able to take a reasonable course of action based only on 
   the numeric error.  However, it does remove the need to define new 
   numeric error codes, avoiding the confusion of who is allowed to 
   define such new codes. The codes used in this mechanism are XML 
   elements in a namespace, so naturally any group defining a new error 
   code can use their own namespace. As always, the "DAV:" namespace is 
   reserved for use by IETF-chartered WebDAV working groups. 
 
   A server supporting "bis" SHOULD include a specific XML error code 
   in a "DAV:error" response body element, when a specific XML error 
   code is defined in this document. The ôDAV:errorö element may 
   contain multiple elements describing specific errors. For error 
   conditions not specified in this document, the server MAY simply 
   choose an appropriate numeric status and leave the response body 
   blank. 
    
     HTTP/1.1 403 Conflict 
     Content-Type: text/xml; charset="utf-8" 
     Content-Length: xxxx 
    
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:error xmlns:D="DAV:"> 
       <D:forbid-external-entities/> 
     </D:error> 
    
   In this specification, both the numeric and the XML error code are 
   defined for some failure situations, in which case the XML error 
   code must have the "DAV:" namespace, appear in the "error" root 
   element, and be returned in a body with the numeric error code 
   specified. 
    
   Status codes are specified in this document with the convention of 
   following the numeric error code with the XML error code. E.g. 
     
                           Expires Oct 2003                         25 

                         WebDAV (RFC2518) bis                June 2003 
    
    
     403/DAV:forbid-external-entities - response codes when the server  
     refuses to accept external XML entities in XML request bodies. 
    
8.2 PROPFIND 
    
   The PROPFIND method retrieves properties defined on the resource 
   identified by the Request-URI, if the resource does not have any 
   internal members, or on the resource identified by the Request-URI 
   and potentially its member resources, if the resource is a 
   collection that has internal member URLs.  All DAV compliant 
   resources MUST support the PROPFIND method and the propfind XML 
   element (section 13.25) along with all XML elements defined for use 
   with that element. 
    
   A client may submit a Depth header with a value of "0", "1", or 
   "infinity" with a PROPFIND on a collection resource with internal 
   member URLs.  Servers MUST support the "0", "1" and "infinity" 
   behaviors on WebDAV-compliant resources. By default, the PROPFIND 
   method without a Depth header MUST act as if a "Depth: infinity" 
   header was included. 
    
   A client may submit a propfind XML element in the body of the 
   request method describing what information is being requested.  It 
   is possible to request: 
    
    - Request particular property values, by naming the properties 
     desired within the 'prop' element 
    - Request all dead property values, by using 'deadprops' element.  
     This can be combined with retrieving specific live properties 
     named as above.  Servers advertising support for RFC2518bis MUST 
     support this feature. 
    - Request property values for those properties defined in this 
     specification plus dead properties, by using æallpropÆ element 
    - Request a list of names of all the properties defined on the 
     resource, by using the æpropnameÆ element.   
    
   A client may choose not to submit a request body.  An empty PROPFIND 
   request body MUST be treated as if it were an æallpropÆ request.   
    
   Note that æallpropÆ does not return values for all live properties. 
   WebDAV servers increasingly have expensively-calculated or lengthy 
   properties (see [RFC3253] and [TODO: ref ACL RFC when available]) 
   and do not return all properties already.  Instead, WebDAV clients 
   can use propname requests to discover what live properties exist, 
   and request named properties when retrieving values.  A WebDAV 
   server MAY omit certain live properties from other specifications 
   when responding to an allprop request from an older client, and MAY 

     
                           Expires Oct 2003                         26 

                         WebDAV (RFC2518) bis                June 2003 
    
   return only custom (dead) properties and those defined in this 
   specification. 
    
    
   All servers MUST support returning a response of content type 
   text/xml or application/xml that contains a multistatus XML element 
   that describes the results of the attempts to retrieve the various 
   properties. 
    
   If there is an error retrieving a property then a proper error 
   result MUST be included in the response.  A request to retrieve the 
   value of a property which does not exist is an error and MUST be 
   noted, if the response uses a multistatus XML element, with a 
   response XML element which contains a 404 (Not Found) status value. 
    
   Consequently, the multistatus XML element for a collection resource 
   with member URLs MUST include a response XML element for each member 
   URL of the collection, to whatever depth was requested. Each 
   response XML element MUST contain an href XML element that gives the 
   URL of the resource on which the properties in the prop XML element 
   are defined.  URLs for collections appearing in the results MUST end 
   in a slash character.  Results for a PROPFIND on a collection 
   resource with internal member URLs are returned as a flat list whose 
   order of entries is not significant. 
 
   A server enumerating the members of a collection using absolute URLs 
   in a PROPFIND response MUST use a common prefix in those URLs, and 
   that prefix MUST be the absolute URL used in the response to refer 
   to the parent collection.  
    
   Unless otherwise notified, clients may expect that the URL for the 
   parent collection in the PROPFIND response will be the same URL that 
   was used to refer to the parent collection in the PROPFIND request.  
   Servers MAY use an alternate URL for the parent collection in a 
   PROPFIND response, but in this case the server MUST include a 
   Content-Location header whose value is the fully-qualified URL used 
   by the server to refer to the parent collection in this response.   
    
   Clients expect the fully-qualified URLs of members of a collection 
   to have a common prefix which is the fully-qualified URL of the 
   parent collection itself.   
    
   URLs in a PROPFIND response body MAY be represented as fully-
   qualified URLs, in which case they must all contain the full parent 
   collection URL (scheme, host, port, and absolute path).  
   Alternatively, these URLs MAY be absolute paths (not containing 
   scheme, host or port), but in this case they must all still contain 
   the full parent collection path. 
    
   If a server allows resource names to include characters that arenÆt 
   legal in HTTP URL paths, these characters must be URI-escaped on the 
     
                           Expires Oct 2003                         27 

                         WebDAV (RFC2518) bis                June 2003 
    
   wire. For example, it is illegal to use a space character or double-
   quote in a URI [RFC2396].  URIs appearing in PROPFIND or PROPPATCH 
   XML bodies (or other XML marshalling defined in this specification) 
   must also be legal URIs. 
    
   Properties may be subject to access control. In the case of allprop 
   and propname, if a principal does not have the right to know whether 
   a particular property exists then the property should be silently 
   excluded from the response. 
    
   The results of this method SHOULD NOT be cached. 
    
8.2.1   Example - Retrieving Named Properties 
    
   >>Request 
    
     PROPFIND  /file HTTP/1.1 
     Host: www.example.com 
     Content-type: text/xml; charset="utf-8" 
     Content-Length: xxxx 
      
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:propfind xmlns:D="DAV:"> 
      <D:prop xmlns:R="http://www.example.com/boxschema/"> 
        <R:bigbox/> 
        <R:author/> 
        <R:DingALing/> 
        <R:Random/> 
      </D:prop> 
     </D:propfind> 
    
   >>Response 
    
     HTTP/1.1 207 Multi-Status 
     Content-Type: text/xml; charset="utf-8" 
     Content-Length: xxxx 
      
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:multistatus xmlns:D="DAV:"> 
      <D:response xmlns:R="http://www.example.com/boxschema/"> 
        <D:href>http://www.example.com/file</D:href> 
        <D:propstat> 
          <D:prop> 
            <R:bigbox> 
              <R:BoxType>Box type A</R:BoxType> 
            </R:bigbox> 
            <R:author> 
     
                           Expires Oct 2003                         28 

                         WebDAV (RFC2518) bis                June 2003 
    
              <R:Name>J.J. Johnson</R:Name> 
            </R:author> 
          </D:prop> 
          <D:status>HTTP/1.1 200 OK</D:status> 
        </D:propstat> 
        <D:propstat> 
          <D:prop><R:DingALing/><R:Random/></D:prop> 
          <D:status>HTTP/1.1 403 Forbidden</D:status> 
          <D:responsedescription> The user does not have access to the 
     DingALing property. 
          </D:responsedescription> 
        </D:propstat> 
      </D:response> 
      <D:responsedescription> There has been an access violation error.
      </D:responsedescription> 
     </D:multistatus> 
      
   In this example, PROPFIND is executed on a non-collection resource 
   http://www.example.com/file.  The propfind XML element specifies the 
   name of four properties whose values are being requested. In this 
   case only two properties were returned, since the principal issuing 
   the request did not have sufficient access rights to see the third 
   and fourth properties. 
    
8.2.2   Example - Retrieving Named and Dead Properties 
    
   >>Request 
    
     PROPFIND /mycol/ HTTP/1.1 
     Host: www.example.com 
     Depth: 1 
     Content-type: text/xml; charset="utf-8" 
     Content-Length: xxxx 
      
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:propfind xmlns:D="DAV:"> 
      <D:prop> 
        <D:creationdate/> 
        <D:getlastmodified/> 
      </D:prop> 
      <D:deadprops/> 
     </D:propfind> 
    
   In this example, PROPFIND is executed on a collection resource 
   http://www.example.com/mycol/.  The client requests the values of 


     
                           Expires Oct 2003                         29 

                         WebDAV (RFC2518) bis                June 2003 
    
   two specific live properties plus all dead properties (names and 
   values). The response is not shown. 
    
8.2.3   Example - Using propname to Retrieve all Property Names 
    
   >>Request 
    
     PROPFIND  /container/ HTTP/1.1 
     Host: www.example.com 
     Content-Type: text/xml; charset="utf-8" 
     Content-Length: xxxx 
      
     <?xml version="1.0" encoding="utf-8" ?> 
     <propfind xmlns="DAV:"> 
      <propname/> 
     </propfind> 
    
   >>Response 
    
     HTTP/1.1 207 Multi-Status 
     Content-Type: text/xml; charset="utf-8" 
     Content-Length: xxxx 
      
     <?xml version="1.0" encoding="utf-8" ?> 
     <multistatus xmlns="DAV:"> 
      <response> 
        <href>http://www.example.com/container/</href> 
        <propstat> 
          <prop xmlns:R="http://www.example.com/boxschema/"> 
            <R:bigbox/> 
            <R:author/> 
            <creationdate/> 
            <displayname/> 
            <resourcetype/> 
            <supportedlock/> 
          </prop> 
          <status>HTTP/1.1 200 OK</status> 
        </propstat> 
      </response> 
      <response> 
        <href>http://www.example.com/container/front.html</href> 
        <propstat> 
          <prop xmlns:R="http://www.example.com/boxschema/"> 
            <R:bigbox/> 
            <creationdate/> 
            <displayname/> 
     
                           Expires Oct 2003                         30 

                         WebDAV (RFC2518) bis                June 2003 
    
            <getcontentlength/> 
            <getcontenttype/> 
            <getetag/> 
            <getlastmodified/> 
            <resourcetype/> 
            <supportedlock/> 
          </prop> 
          <status>HTTP/1.1 200 OK</status> 
        </propstat> 
      </response> 
     </multistatus> 
    
    
   In this example, PROPFIND is invoked on the collection resource 
   http://www.example.com/container/, with a propfind XML element 
   containing the propname XML element, meaning the name of all 
   properties should be returned.  Since no Depth header is present, it 
   assumes its default value of "infinity", meaning the name of the 
   properties on the collection and all its descendents should be 
   returned. 
    
   Consistent with the previous example, resource 
   http://www.example.com/container/ has six properties defined on it: 
   bigbox and author in the "http://www.example.com/boxschema/" 
   namespace, and creationdate, displayname, resourcetype, and 
   supportedlock in the "DAV:" namespace.   
    
   The resource http://www.example.com/container/index.html, a member 
   of the "container" collection, has nine properties defined on it, 
   bigbox in the "http://www.example.com/boxschema/" namespace and, 
   creationdate, displayname, getcontentlength, getcontenttype, 
   getetag, getlastmodified, resourcetype, and supportedlock in the 
   "DAV:" namespace. 
    
   This example also demonstrates the use of XML namespace scoping and 
   the default namespace.  Since the "xmlns" attribute does not contain 
   a prefix, the namespace applies by default to all enclosed elements.  
   Hence, all elements which do not explicitly state the namespace to 
   which they belong are members of the "DAV:" namespace schema. 
    
8.2.4   PROPFIND Request Errors 
    
   PROPFIND requests may also fail entirely, before the server even 
   gets a chance to evaluate individual properties. 404 (Not Found) and 
   401 (Unauthorized) are possible as with every request. These are 
   some other notable errors. 
    


     
                           Expires Oct 2003                         31 

                         WebDAV (RFC2518) bis                June 2003 
    
   403/DAV:propfind-infinite-depth-forbidden  - A server MAY reject all 
   PROPFIND requests on collections with depth header of "Infinity", in 
   which case it should use this error. 
    
8.3 PROPPATCH 
    
   The PROPPATCH method processes instructions specified in the request 
   body to set and/or remove properties defined on the resource 
   identified by the Request-URI. 
    
   All DAV compliant resources MUST support the PROPPATCH method and 
   MUST process instructions that are specified using the 
   propertyupdate, set, and remove XML elements.  Execution of the 
   directives in this method is, of course, subject to access control 
   constraints.  DAV compliant resources SHOULD support the setting of 
   arbitrary dead properties. 
    
   The request message body of a PROPPATCH method MUST contain the 
   propertyupdate XML element.  Instruction processing MUST occur in 
   document order. Instructions MUST either all be executed or none 
   executed. Thus if any error occurs during processing all executed 
   instructions MUST be undone and a proper error result returned. 
   Instruction processing details can be found in the definition of the 
   set and remove instructions in sections 13.23 and section 13.24. 
    
8.3.1   Status Codes for use with 207 (Multi-Status) 
    
   The following are examples of response codes one would expect to be 
   used in a 207 (Multi-Status) response for this method.  Note, 
   however, that unless explicitly prohibited any 2/3/4/5xx series 
   response code may be used in a 207 (Multi-Status) response. 
    
   200 (OK) - The command succeeded.  As there can be a mixture of sets 
   and removes in a body, a 201 (Created) seems inappropriate. 
    
   403 (Forbidden) - The client, for reasons the server chooses not to 
   specify, cannot alter one of the properties. 
    
   403/DAV:read-only-property: The client has attempted to set a read-
   only property, such as getetag. 
    
   409 (Conflict) - The client has provided a value whose semantics are 
   not appropriate for the property.   
    
   423 (Locked) - The specified resource is locked and the client 
   either is not a lock owner or the lock type requires a lock token to 
   be submitted and the client did not submit it. 
    
   507 (Insufficient Storage) - The server did not have sufficient 
   space to record the property. 
    
     
                           Expires Oct 2003                         32 

                         WebDAV (RFC2518) bis                June 2003 
    
8.3.2   Example - PROPPATCH 
    
   >>Request 
    
     PROPPATCH /bar.html HTTP/1.1 
     Host: www.example.com 
     Content-Type: text/xml; charset="utf-8" 
     Content-Length: xxxx 
      
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:propertyupdate xmlns:D="DAV:"   
     xmlns:Z="http://www.w3.com/standards/z39.50/"> 
      <D:set> 
        <D:prop> 
          <Z:authors> 
            <Z:Author>Jim Whitehead</Z:Author> 
            <Z:Author>Roy Fielding</Z:Author> 
          </Z:authors> 
        </D:prop> 
      </D:set> 
      <D:remove> 
        <D:prop><Z:Copyright-Owner/></D:prop> 
      </D:remove> 
     </D:propertyupdate> 
    
   >>Response 
    
     HTTP/1.1 207 Multi-Status 
     Content-Type: text/xml; charset="utf-8" 
     Content-Length: xxxx 
      
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:multistatus xmlns:D="DAV:" 
     xmlns:Z="http://www.w3.com/standards/z39.50"> 
      <D:response> 
        <D:href>http://www.example.com/bar.html</D:href> 
        <D:propstat> 
          <D:prop><Z:Authors/></D:prop> 
          <D:status>HTTP/1.1 424 Failed Dependency</D:status> 
        </D:propstat> 
        <D:propstat> 
          <D:prop><Z:Copyright-Owner/></D:prop> 
          <D:status>HTTP/1.1 409 Conflict</D:status> 
        </D:propstat> 


     
                           Expires Oct 2003                         33 

                         WebDAV (RFC2518) bis                June 2003 
    
        <D:responsedescription> Copyright Owner can not be deleted or 
     altered.</D:responsedescription> 
      </D:response> 
     </D:multistatus> 
    
   In this example, the client requests the server to set the value of 
   the "Authors" property in the "http://www.w3.com/standards/z39.50/" 
   namespace, and to remove the property "Copyright-Owner" in the 
   "http://www.w3.com/standards/z39.50/" namespace.  Since the 
   Copyright-Owner property could not be removed, no property 
   modifications occur.  The 424 (Failed Dependency) status code for 
   the Authors property indicates this action would have succeeded if 
   it were not for the conflict with removing the Copyright-Owner 
   property. 
    
8.4 MKCOL Method 
    
   The MKCOL method is used to create a new collection. All WebDAV 
   compliant resources MUST support the MKCOL method. 
    
   MKCOL creates a new collection resource at the location specified by 
   the Request-URI.  If the resource identified by the Request-URI is 
   non-null then the MKCOL MUST fail.  During MKCOL processing, a 
   server MUST make the Request-URI a member of its parent collection, 
   unless the Request-URI is "/".  If no such ancestor exists, the 
   method MUST fail.  When the MKCOL operation creates a new collection 
   resource, all ancestors MUST already exist, or the method MUST fail 
   with a 409 (Conflict) status code.  For example, if a request to 
   create collection /a/b/c/d/ is made, and neither /a/b/ nor /a/b/c/ 
   exists, the request must fail. 
    
   When MKCOL is invoked without a request body, the newly created 
   collection SHOULD have no members. 
    
   A MKCOL request message may contain a message body.  The behavior of 
   a MKCOL request when the body is present is limited to creating 
   collections, members of a collection, bodies of members and 
   properties on the collections or members.  If the server receives a 
   MKCOL request entity type it does not support or understand it MUST 
   respond with a 415 (Unsupported Media Type) status code.  If the 
   server decides to reject the request based on the presence of an 
   entity or the type of an entity, it should use the 415 (Unsupported 
   Media Type) status code.  The exact behavior of MKCOL for various 
   request media types is undefined in this document, and will be 
   specified in separate documents. 
    
Status Codes 
    
   Responses from a MKCOL request MUST NOT be cached as MKCOL has non-
   idempotent semantics. 
     
                           Expires Oct 2003                         34 

                         WebDAV (RFC2518) bis                June 2003 
    
    
   201 (Created) - The collection or structured resource was created in 
   its entirety. 
    
   403 (Forbidden) - This indicates at least one of two conditions: 1) 
   the server does not allow the creation of collections at the given 
   location in its namespace, or 2) the parent collection of the 
   Request-URI exists but cannot accept members. 
    
   405 (Method Not Allowed) - MKCOL can only be executed on a 
   deleted/non-existent resource. 
    
   409 (Conflict) - A collection cannot be made at the Request-URI 
   until one or more intermediate collections have been created.  The 
   server MUST NOT create those intermediate collections automatically. 
    
   415 (Unsupported Media Type) - The server does not support the 
   request type of the body. 
    
   507 (Insufficient Storage) - The resource does not have sufficient 
   space to record the state of the resource after the execution of 
   this method. 
    
8.4.1   Example - MKCOL 
    
   This example creates a collection called /webdisc/xfiles/ on the 
   server www.example.com. 
    
   >>Request 
    
     MKCOL /webdisc/xfiles/ HTTP/1.1 
     Host: www.example.com 
    
   >>Response 
    
     HTTP/1.1 201 Created 
      
    
8.5 GET, HEAD for Collections 
    
   The semantics of GET are unchanged when applied to a collection, 
   since GET is defined as, "retrieve whatever information (in the form 
   of an entity) is identified by the Request-URI" [RFC2616].  GET when 
   applied to a collection may return the contents of an "index.html" 
   resource, a human-readable view of the contents of the collection, 
   or something else altogether. Hence it is possible that the result 
   of a GET on a collection will bear no correlation to the membership 
   of the collection. 
    

     
                           Expires Oct 2003                         35 

                         WebDAV (RFC2518) bis                June 2003 
    
   Similarly, since the definition of HEAD is a GET without a response 
   message body, the semantics of HEAD are unmodified when applied to 
   collection resources. 
    
8.6 POST for Collections 
    
   Since by definition the actual function performed by POST is 
   determined by the server and often depends on the particular 
   resource, the behavior of POST when applied to collections cannot be 
   meaningfully modified because it is largely undefined.  Thus the 
   semantics of POST are unmodified when applied to a collection. 
    
8.7 DELETE 
    
DELETE for Non-Collection Resources 
    
   When a client issues a DELETE request to a Request-URI mapping to a 
   non-collection resource, if the operation is successful the server 
   MUST remove that mapping.  Thus, after a successful DELETE operation 
   (and in the absence of other actions) a subsequent GET/HEAD/PROPFIND 
   request to the target Request-URI would return 404 (Not Found). 
    
DELETE for Collections 
    
   The DELETE method on a collection MUST act as if a "Depth: infinity" 
   header was used on it.  A client MUST NOT submit a Depth header with 
   a DELETE on a collection with any value but infinity. 
    
   DELETE instructs that the collection specified in the Request-URI 
   and all resources identified by its internal member URLs are to be 
   deleted. 
    
   If any resource identified by a member URL cannot be deleted then 
   all of the member's ancestors MUST NOT be deleted, so as to maintain 
   namespace consistency.        
    
   Any headers included with DELETE MUST be applied in processing every 
   resource to be deleted. 
    
   When the DELETE method has completed processing it MUST result in a 
   consistent namespace. 
    
   If an error occurs deleting an internal resource (a resource other 
   than the resource identified in the Request-URI) then the response 
   can be a 207 (Multi-Status). Multi-Status is used here to indicate 
   which internal resources could NOT be deleted, including an error 
   code which should help the client understand which resources caused 
   the failure.  For example, the Multi-Status body could include a 
   response with status 423 (Locked) if an internal resource was 
   locked.   
     
                           Expires Oct 2003                         36 

                         WebDAV (RFC2518) bis                June 2003 
    
    
   The server MAY return a 4xx status response, rather than a Multi-
   Status, if the entire DELETE request failed and it canÆt identify 
   the internal resources that caused the DELETE to fail. 
    
   424 (Failed Dependency) errors SHOULD NOT be in the 207 (Multi-
   Status).  They can be safely left out because the client will know 
   that the ancestors of a resource could not be deleted when the 
   client receives an error for the ancestor's progeny.  Additionally 
   204 (No Content) errors SHOULD NOT be returned in the 207 (Multi-
   Status).  The reason for this prohibition is that 204 (No Content) 
   is the default success code. 
    
8.7.1   Example - DELETE 
    
   >>Request 
    
     DELETE  /container/ HTTP/1.1 
     Host: www.example.com 
    
   >>Response 
    
     HTTP/1.1 207 Multi-Status 
     Content-Type: text/xml; charset="utf-8" 
     Content-Length: xxxx 
      
     <?xml version="1.0" encoding="utf-8" ?> 
     <d:multistatus xmlns:d="DAV:"> 
      <d:response> 
        <d:href>http://www.example.com/container/resource3</d:href> 
        <d:status>HTTP/1.1 423 Locked</d:status> 
      </d:response> 
     </d:multistatus> 
      
   In this example the attempt to delete 
   http://www.example.com/container/resource3 failed because it is 
   locked, and no lock token was submitted with the request. 
   Consequently, the attempt to delete 
   http://www.example.com/container/ also failed. Thus the client knows 
   that the attempt to delete http://www.example.com/container/ must 
   have also failed since the parent can not be deleted unless its 
   child has also been deleted.  Even though a Depth header has not 
   been included, a depth of infinity is assumed because the method is 
   on a collection. 
    
8.8 PUT 
    
PUT for Non-Collection Resources 
    
     
                           Expires Oct 2003                         37 

                         WebDAV (RFC2518) bis                June 2003 
    
   A PUT performed on an existing resource replaces the GET response 
   entity of the resource.  Properties defined on the resource may be 
   recomputed during PUT processing but are not otherwise affected.  
   For example, if a server recognizes the content type of the request 
   body, it may be able to automatically extract information that could 
   be profitably exposed as properties. 
    
   A PUT that would result in the creation of a resource without an 
   appropriately scoped parent collection MUST fail with a 409 
   (Conflict). 
    
PUT for Collections 
    
   As defined in [RFC2616], the "PUT method requests that the enclosed 
   entity be stored under the supplied Request-URI."  Since submission 
   of an entity representing a collection would implicitly encode 
   creation and deletion of resources, this specification intentionally 
   does not define a transmission format for creating a collection 
   using PUT.  Instead, the MKCOL method is defined to create 
   collections. 
    
8.9 COPY Method 
    
   The COPY method creates a duplicate of the source resource, 
   identified by the Request-URI, in the destination resource, 
   identified by the URI in the Destination header.  The Destination 
   header MUST be present.  The exact behavior of the COPY method 
   depends on the type of the source resource. 
    
   All WebDAV compliant resources MUST support the COPY method.  
   However, support for the COPY method does not guarantee the ability 
   to copy a resource. For example, separate programs may control 
   resources on the same server.  As a result, it may not be possible 
   to copy a resource to a location that appears to be on the same 
   server. 
    
COPY for HTTP/1.1 resources 
    
   When the source resource is not a collection the result of the COPY 
   method is the creation of a new resource at the destination whose 
   state and behavior match that of the source resource as closely as 
   possible.  After a successful COPY invocation, all properties on the 
   source resource MUST be duplicated on the destination resource, 
   subject to modifying headers and XML elements, following the 
   definition for copying properties.  Since the environment at the 
   destination may be different than at the source due to factors 
   outside the scope of control of the server, such as the absence of 
   resources required for correct operation, it may not be possible to 
   completely duplicate the behavior of the resource at the 
   destination. Subsequent alterations to the destination resource will 
     
                           Expires Oct 2003                         38 

                         WebDAV (RFC2518) bis                June 2003 
    
   not modify the source resource.  Subsequent alterations to the 
   source resource will not modify the destination resource. 
    
COPY for Properties 
    
   Live properties described in this document SHOULD be duplicated as 
   identically behaving live properties at the destination resource, 
   but not necessarily with the same values.  If a property cannot be 
   copied live, then its value MUST be duplicated, octet-for-octet, in 
   an identically named, dead property on the destination resource. 
    
   A COPY operation creates a new resource, much like a PUT operation 
   does.  Live properties which are related to resource creation (such 
   as creationdate) should have their values set accordingly. 
    
   Dead properties must be duplicated exactly. 
    
8.9.1   COPY for Collections 
    
   The COPY method on a collection without a Depth header MUST act as 
   if a Depth header with value "infinity" was included.  A client may 
   submit a Depth header on a COPY on a collection with a value of "0" 
   or "infinity".  Servers MUST support the "0" and "infinity" Depth 
   header behaviors on WebDAV-compliant resources. 
    
   A COPY of depth infinity instructs that the collection resource 
   identified by the Request-URI is to be copied to the location 
   identified by the URI in the Destination header, and all its 
   internal member resources are to be copied to a location relative to 
   it, recursively through all levels of the collection hierarchy. 
    
   A COPY of "Depth: 0" only instructs that the collection and its 
   properties but not resources identified by its internal member URLs, 
   are to be copied. 
    
   Any headers included with a COPY MUST be applied in processing every 
   resource to be copied with the exception of the Destination header. 
    
   The Destination header only specifies the destination URI for the 
   Request-URI. When applied to members of the collection identified by 
   the Request-URI the value of Destination is to be modified to 
   reflect the current location in the hierarchy.  So, if the Request-
   URI is /a/ with Host header value http://fun.com/ and the 
   Destination is http://fun.com/b/ then when http://fun.com/a/c/d is 
   processed it must use a Destination of http://fun.com/b/c/d. 
    
   When the COPY method has completed processing it MUST have created a 
   consistent namespace at the destination (see section 5.1 for the 
   definition of namespace consistency).  However, if an error occurs 
   while copying an internal collection, the server MUST NOT copy any 

     
                           Expires Oct 2003                         39 

                         WebDAV (RFC2518) bis                June 2003 
    
   resources identified by members of this collection (i.e., the server 
   must skip this subtree), as this would create an inconsistent 
   namespace. After detecting an error, the COPY operation SHOULD try 
   to finish as much of the original copy operation as possible (i.e., 
   the server should still attempt to copy other subtrees and their 
   members, that are not descendents of an error-causing collection).  
   So, for example, if an infinite depth copy operation is performed on 
   collection /a/, which contains collections /a/b/ and /a/c/, and an 
   error occurs copying /a/b/, an attempt should still be made to copy 
   /a/c/. Similarly, after encountering an error copying a non-
   collection resource as part of an infinite depth copy, the server 
   SHOULD try to finish as much of the original copy operation as 
   possible. 
    
   If an error in executing the COPY method occurs with a resource 
   other than the resource identified in the Request-URI then the 
   response MUST be a 207 (Multi-Status), and the URL of the resource 
   causing the failure MUST appear with the specific error.  
    
   The 424 (Failed Dependency) status code SHOULD NOT be returned in 
   the 207 (Multi-Status) response from a COPY method.  These responses 
   can be safely omitted because the client will know that the progeny 
   of a resource could not be copied when the client receives an error 
   for the parent.  Additionally 201 (Created)/204 (No Content) status 
   codes SHOULD NOT be returned as values in 207 (Multi-Status) 
   responses from COPY methods.  They, too, can be safely omitted 
   because they are the default success codes. 
    
8.9.2   COPY and the Overwrite Header 
    
   If a resource exists at the destination and the Overwrite header is 
   "T" then prior to performing the copy the server MUST perform a 
   DELETE with "Depth: infinity" on the destination resource.  If the 
   Overwrite header is set to "F" then the operation will fail. 
    
8.9.3   Status Codes 
    
   201 (Created) - The source resource was successfully copied.  The 
   copy operation resulted in the creation of a new resource. 
    
   204 (No Content) - The source resource was successfully copied to a 
   pre-existing destination resource. 
    
   207 (Multi-Status) - Multiple resources were to be affected by the 
   COPY, but errors on some of them prevented the operation from taking 
   place.  Specific error messages, together with the most appropriate 
   of the source and destination URLs, appear in the body of the multi-
   status response. E.g. if a destination resource was locked and could 
   not be overwritten, then the destination resource URL appears with 
   the 423 (Locked) status. 
    
     
                           Expires Oct 2003                         40 

                         WebDAV (RFC2518) bis                June 2003 
    
   403 (Forbidden) - The operation is forbidden.  Possibly this is 
   because the source and destination resources are the same resource. 
    
   409 (Conflict) - A resource cannot be created at the destination 
   until one or more intermediate collections have been created.  The 
   server MUST NOT create those intermediate collections automatically. 
    
   412 (Precondition Failed) - A precondition failed, e.g. the 
   Overwrite header is "F" and the state of the destination resource is 
   non-null. 
    
   423 (Locked) - The destination resource was locked. 
    
   502 (Bad Gateway) - This may occur when the destination is on 
   another server, repository or context.  Either the source context 
   does not support copying to the destination context, or the 
   destination context refuses to accept the resource. The client may 
   wish to try GET/PUT and PROPFIND/PROPPATCH instead. 
    
   507 (Insufficient Storage) - The destination resource does not have 
   sufficient space to record the state of the resource after the 
   execution of this method. 
    
8.9.4   Example - COPY with Overwrite 
    
   This example shows resource 
   http://www.ics.uci.edu/~fielding/index.html being copied to the 
   location http://www.ics.uci.edu/users/f/fielding/index.html.  The 
   204 (No Content) status code indicates the existing resource at the 
   destination was overwritten. 
    
   >>Request 
    
     COPY /~fielding/index.html HTTP/1.1 
     Host: www.ics.uci.edu 
     Destination: http://www.ics.uci.edu/users/f/fielding/index.html 
    
   >>Response 
    
     HTTP/1.1 204 No Content 
      
Example - COPY with No Overwrite 
    
   The following example shows the same copy operation being performed, 
   but with the Overwrite header set to "F."  A response of 412 
   (Precondition Failed) is returned because the destination resource 
   has a non-null state. 
    
   >>Request 
    
     
                           Expires Oct 2003                         41 

                         WebDAV (RFC2518) bis                June 2003 
    
     COPY /~fielding/index.html HTTP/1.1 
     Host: www.ics.uci.edu 
     Destination: http://www.ics.uci.edu/users/f/fielding/index.html 
     Overwrite: F 
    
   >>Response 
    
     HTTP/1.1 412 Precondition Failed 
      
Example - COPY of a Collection 
    
   >>Request 
    
     COPY /container/ HTTP/1.1 
     Host: www.example.com 
     Destination: http://www.example.com/othercontainer/ 
     Depth: infinity 
      
   >>Response 
    
     HTTP/1.1 207 Multi-Status 
     Content-Type: text/xml; charset="utf-8" 
     Content-Length: xxxx 
      
     <?xml version="1.0" encoding="utf-8" ?> 
      
     <d:multistatus xmlns:d="DAV:"> 
      <d:response> 
        <d:href>http://www.example.com/othercontainer/R2/</d:href> 
        <d:status>HTTP/1.1 423 Locked</d:status> 
      </d:response> 
     </d:multistatus> 
    
   The Depth header is unnecessary as the default behavior of COPY on a 
   collection is to act as if a "Depth: infinity" header had been 
   submitted.  In this example most of the resources, along with the 
   collection, were copied successfully. However the collection R2 
   failed because the destination R2 is locked.  Because there was an 
   error copying R2, none of R2's members were copied.  However no 
   errors were listed for those members due to the error minimization 
   rules. 
    
8.10    MOVE Method 
    
   The MOVE operation on a non-collection resource is the logical 
   equivalent of a copy (COPY), followed by consistency maintenance 
   processing, followed by a delete of the source, where all three 

     
                           Expires Oct 2003                         42 

                         WebDAV (RFC2518) bis                June 2003 
    
   actions are performed atomically.  The consistency maintenance step 
   allows the server to perform updates caused by the move, such as 
   updating all URLs other than the Request-URI which identify the 
   source resource, to point to the new destination resource.  
   Consequently, the Destination header MUST be present on all MOVE 
   methods and MUST follow all COPY requirements for the COPY part of 
   the MOVE method.  All WebDAV compliant resources MUST support the 
   MOVE method.  However, support for the MOVE method does not 
   guarantee the ability to move a resource to a particular 
   destination.  
    
   For example, separate programs may actually control different sets 
   of resources on the same server.  Therefore, it may not be possible 
   to move a resource within a namespace that appears to belong to the 
   same server. 
    
   If a resource exists at the destination, the destination resource 
   will be DELETEd as a side-effect of the MOVE operation, subject to 
   the restrictions of the Overwrite header. 
    
8.10.1  MOVE for Properties 
 
    
   Live properties described in this document MUST be moved along with 
   the resource, such that the resource has identically behaving live 
   properties at the destination resource, but not necessarily with the 
   same values.  If the live properties will not work the same way at 
   the destination, the server MUST fail the request (the client can 
   perform COPY then DELETE if it wants a MOVE to work that badly). 
   This can mean that the server removes a live property if that's the 
   most appropriate behavior for that live property at the destination. 
    
   A MOVE can be a rename operation, so it's not appropriate to reset 
   live properties which are set at resource creation. For example, the 
   creationdate property value SHOULD remain the same. 
    
   Dead properties must be moved along with the resource. 
   . 
    
8.10.2  MOVE for Collections 
    
   A MOVE with "Depth: infinity" instructs that the collection 
   identified by the Request-URI be moved to the address specified in 
   the Destination header, and all resources identified by its internal 
   member URLs are to be moved to locations relative to it, recursively 
   through all levels of the collection hierarchy. 
    
   The MOVE method on a collection MUST act as if a "Depth: infinity" 
   header was used on it.  A client MUST NOT submit a Depth header on a 
   MOVE on a collection with any value but "infinity". 
    
     
                           Expires Oct 2003                         43 

                         WebDAV (RFC2518) bis                June 2003 
    
   Any headers included with MOVE MUST be applied in processing every 
   resource to be moved with the exception of the Destination header. 
    
   The behavior of the Destination header is the same as given for COPY 
   on collections.  
    
   When the MOVE method has completed processing it MUST have created a 
   consistent namespace at both the source and destination (see section 
   5.1 for the definition of namespace consistency). However, if an 
   error occurs while moving an internal collection, the server MUST 
   NOT move any resources identified by members of the failed 
   collection (i.e., the server must skip the error-causing subtree), 
   as this would create an inconsistent namespace. In this case, after 
   detecting the error, the move operation SHOULD try to finish as much 
   of the original move as possible (i.e., the server should still 
   attempt to move other subtrees and the resources identified by their 
   members, that are not descendents of an error-causing collection).  
   So, for example, if an infinite depth move is performed on 
   collection /a/, which contains collections /a/b/ and /a/c/, and an 
   error occurs moving /a/b/, an attempt should still be made to try 
   moving /a/c/. Similarly, after encountering an error moving a non-
   collection resource as part of an infinite depth move, the server 
   SHOULD try to finish as much of the original move operation as 
   possible. 
    
   If an error occurs with a resource other than the resource 
   identified in the Request-URI then the response MUST be a 207 
   (Multi-Status), and the errored resource's URL MUST appear with the 
   specific error. 
    
   The 424 (Failed Dependency) status code SHOULD NOT be returned in 
   the 207 (Multi-Status) response from a MOVE method.  These errors 
   can be safely omitted because the client will know that the progeny 
   of a resource could not be moved when the client receives an error 
   for the parent.  Additionally 201 (Created)/204 (No Content) 
   responses SHOULD NOT be returned as values in 207 (Multi-Status) 
   responses from a MOVE.  These responses can be safely omitted 
   because they are the default success codes. 
    
8.10.3  MOVE and the Overwrite Header 
    
   If a resource exists at the destination and the Overwrite header is 
   "T" then prior to performing the move the server MUST perform a 
   DELETE with "Depth: infinity" on the destination resource.  If the 
   Overwrite header is set to "F" then the operation will fail. 
    
8.10.4  Status Codes 
    
   201 (Created) - The source resource was successfully moved, and a 
   new resource was created at the destination. 
    
     
                           Expires Oct 2003                         44 

                         WebDAV (RFC2518) bis                June 2003 
    
   204 (No Content) - The source resource was successfully moved to a 
   pre-existing destination resource. 
    
   207 (Multi-Status) - Multiple resources were to be affected by the 
   MOVE, but errors on some of them prevented the operation from taking 
   place.  Specific error messages, together with the most appropriate 
   of the source and destination URLs, appear in the body of the multi-
   status response. E.g. if a source resource was locked and could not 
   be moved, then the source resource URL appears with the 423 (Locked) 
   status. 
    
   403 (Forbidden) û The source and destination resources are the same. 
    
   409 (Conflict) û A resource cannot be created at the destination 
   until one or more intermediate collections have been created.  The 
   server MUST NOT create those intermediate collections automatically. 
    
    
   412 (Precondition Failed) û A condition failed, e.g. the Overwrite 
   header is "F" and the state of the destination resource is non-null. 
    
   423 (Locked) - The source or the destination resource was locked. 
    
   500/DAV:live-properties-not-preserved - The server was unable to 
   preserve the behavior of the live properties and still move the 
   resource to the destination.   
    
   502 (Bad Gateway) - This may occur when the destination is on 
   another server and the destination server refuses to accept the 
   resource. 
    
8.10.5  Example - MOVE of a Non-Collection 
    
   This example shows resource 
   http://www.ics.uci.edu/~fielding/index.html being moved to the 
   location http://www.ics.uci.edu/users/f/fielding/index.html. The 
   contents of the destination resource would have been overwritten if 
   the destination resource had been non-null.  In this case, since 
   there was nothing at the destination resource, the response code is 
   201 (Created). 
    
   >>Request 
    
     MOVE /~fielding/index.html HTTP/1.1 
     Host: www.ics.uci.edu 
     Destination: http://www.ics.uci.edu/users/f/fielding/index.html 
    
   >>Response 
    
     HTTP/1.1 201 Created 
     
                           Expires Oct 2003                         45 

                         WebDAV (RFC2518) bis                June 2003 
    
     Location: http://www.ics.uci.edu/users/f/fielding/index.html 
      
      
Example - MOVE of a Collection 
    
   >>Request 
    
     MOVE /container/ HTTP/1.1 
     Host: www.example.com 
     Destination: http://www.example.com/othercontainer/ 
     Overwrite: F 
     If: (<opaquelocktoken:fe184f2e-6eec-41d0-c765-01adc56e6bb4>) 
         (<opaquelocktoken:e454f3f3-acdc-452a-56c7-00a5c91e4b77>) 
      
    
   >>Response 
    
     HTTP/1.1 207 Multi-Status 
     Content-Type: text/xml; charset="utf-8" 
     Content-Length: xxxx 
      
     <?xml version="1.0" encoding="utf-8" ?> 
     <d:multistatus xmlns:d='DAV:'> 
      <d:response> 
        <d:href>http://www.example.com/othercontainer/C2/</d:href> 
        <d:status>HTTP/1.1 423 Locked</d:status> 
      </d:response> 
     </d:multistatus> 
    
   In this example the client has submitted a number of lock tokens 
   with the request.  A lock token will need to be submitted for every 
   resource, both source and destination, anywhere in the scope of the 
   method, that is locked.  In this case the proper lock token was not 
   submitted for the destination 
   http://www.example.com/othercontainer/C2/. This means that the 
   resource /container/C2/ could not be moved.  Because there was an 
   error moving /container/C2/, none of /container/C2's members were 
   moved.  However no errors were listed for those members due to the 
   error minimization rules.  User agent authentication has previously 
   occurred via a mechanism outside the scope of the HTTP protocol, in 
   an underlying transport layer. 
    
8.11    LOCK Method 
    
   The following sections describe the LOCK method, which is used to 
   take out a lock of any access type and to refresh an existing lock.  
   These sections on the LOCK method describe only those semantics that 

     
                           Expires Oct 2003                         46 

                         WebDAV (RFC2518) bis                June 2003 
    
   are specific to the LOCK method and are independent of the access 
   type of the lock being requested. 
    
   Any resource which supports the LOCK method MUST, at minimum, 
   support the XML request and response formats defined herein. 
    
Operation 
    
   A LOCK method invocation creates the lock specified by the lockinfo 
   XML element on the resource indicated by the Request-URI, which 
   becomes the root of the lock.  Lock method requests to create a new 
   lock MUST have a XML request body which contains an owner XML 
   element for this lock request. The server MUST preserve the 
   information provided by the client in the owner field when the lock 
   information is requested.  The LOCK request MAY have a Timeout 
   header. 
    
   Clients MUST assume that locks may arbitrarily disappear at any 
   time, regardless of the value given in the Timeout header.  The 
   Timeout header only indicates the behavior of the server if 
   "extraordinary" circumstances do not occur.  For example, a 
   sufficiently privileged user may remove a lock at any time or the 
   system may crash in such a way that it loses the record of the 
   lock's existence. The response MUST contain the value of the 
   lockdiscovery property in a prop XML element. 
    
   In order to indicate the lock token associated with a newly created 
   lock, a Lock-Token response header MUST be included in the response 
   for every successful LOCK request for a new lock.  Note that the 
   Lock-Token header would not be returned in the response for a 
   successful refresh LOCK request because a new lock was not created. 
    
Refreshing Locks 
    
   A lock is refreshed by sending a new LOCK request to the resource 
   which is the root of the lock. A LOCK request to refresh a lock must 
   specify which lock to refresh by using the Lock-Token header with a 
   single lock token (only one lock may be refreshed at a time).  This 
   request does not contain a body, but it may contain a Timeout 
   header.  A server MAY accept the Timeout header to change the 
   duration remaining on the lock to the new value.  
    
   If the resource has other (shared) locks, those locks are unaffected 
   by a lock refresh.  Additionally, those locks do not prevent the 
   named lock from being refreshed. 
    
   Note that in RFC2518, clients were indicated through the example in 
   the text to use the If header to specify what lock to refresh 
   (rather than the Lock-Token header). Servers are encouraged to 
   continue to support this as well as the Lock-Token header. 
     
                           Expires Oct 2003                         47 

                         WebDAV (RFC2518) bis                June 2003 
    
    
 
The Effect of Locks on Properties and Collections 
    
   The scope of a lock is the entire state of the resource, including 
   its body and associated properties.  As a result, a lock on a 
   resource MUST also lock the resource's properties. 
    
   For collections, a lock also affects the ability to add or remove 
   members.  The nature of the effect depends upon the type of access 
   control involved.  This means that if a collection is locked, its 
   lock-token is required in all these cases: 
    - DELETE a collectionÆs direct  internal member 
    - MOVE a member out of the collection 
    - MOVE a member into the collection, unless it overwrites a pre-
      existing member 
    - MOVE to rename it within a collection, 
    - COPY a member into a collection, unless it overwrites a pre-
      existing member 
    - PUT or MKCOL request which would create a new member.   
   The collectionÆs lock token is required in addition to the lock 
   token on the internal member itself, if it exists. 
    
Locking Replicated Resources 
    
   A resource may be made available through more than one URI. However 
   locks apply to resources, not URIs. Therefore a LOCK request on a 
   resource MUST NOT succeed if can not be honored by all the URIs 
   through which the resource is addressable. 
    
Depth and Locking 
    
   The Depth header may be used with the LOCK method.  Values other 
   than 0 or infinity MUST NOT be used with the Depth header on a LOCK 
   method.  All resources that support the LOCK method MUST support the 
   Depth header. 
    
   A Depth header of value 0 means to just lock the resource specified 
   by the Request-URI. 
    
   If the Depth header is set to infinity then the resource specified 
   in the Request-URI along with all its internal members, all the way 
   down the hierarchy, are to be locked.  A successful result MUST 
   return a single lock token which represents all the resources that 
   have been locked.  If an UNLOCK is successfully executed on this 
   token, all associated resources are unlocked.  If the lock cannot be 
   granted to all resources, a 409 (Conflict) status code MUST be 
   returned with a response entity body containing a multistatus XML 
   element describing which resource(s) prevented the lock from being 

     
                           Expires Oct 2003                         48 

                         WebDAV (RFC2518) bis                June 2003 
    
   granted.  Hence, partial success is not an option.  Either the 
   entire hierarchy is locked or no resources are locked. 
    
   If no Depth header is submitted on a LOCK request then the request 
   MUST act as if a "Depth:infinity" had been submitted. 
    
Interaction with other Methods 
    
   The interaction of a LOCK with various methods is dependent upon the 
   lock type.  However, independent of lock type, a successful DELETE 
   of a resource MUST cause all of its direct locks to be removed. 
    
Locking Unmapped URLs 
    
   A successful LOCK method MUST result in the creation of an empty 
   resource which is locked (and which is not a collection), when a 
   resource did not previously exist at that URL.  Later on, the lock 
   may go away but the empty resource remains.  Empty resources MUST 
   then appear in PROPFIND responses including that URL in the response 
   scope.  A server MUST respond successfully to a GET request to an 
   empty resource, either by using a 204 No Content response, or by 
   using 200 OK with a Content-Length header indicating zero length and 
   no Content-Type. 
    
Lock Compatibility Table 
    
   The table below describes the behavior that occurs when a lock 
   request is made on a resource. 
    
     Current State   Shared Lock Request   Exclusive Lock Request 
   -------------------------------------------------------------------- 
     None            True                  True 
     Shared Lock     True                  False 
     Exclusive Lock  False                 False* 
    
    
   Legend: True = lock may be granted.  False = lock MUST NOT be 
   granted. *=It is illegal for a principal to request the same lock 
   twice. 
    
   The current lock state of a resource is given in the leftmost 
   column, and lock requests are listed in the first row.  The 
   intersection of a row and column gives the result of a lock request.  
   For example, if a shared lock is held on a resource, and an 
   exclusive lock is requested, the table entry is "false", indicating 
   the lock must not be granted. 
    
Status Codes 
    

     
                           Expires Oct 2003                         49 

                         WebDAV (RFC2518) bis                June 2003 
    
   200 (OK) - The lock request succeeded and the value of the 
   lockdiscovery property is included in the body. 
                
   409 (Conflict) û A resource cannot be created at the destination 
   until one or more intermediate collections have been created.  The 
   server MUST NOT create those intermediate collections automatically. 
    
   412 (Precondition Failed) - The included lock token was not 
   enforceable on this resource or the server could not satisfy the 
   request in the lockinfo XML element. 
    
   423 (Locked) - The resource is locked, so the method has been 
   rejected.  
    
8.11.1  Example - Simple Lock Request 
    
   >>Request 
    
     LOCK /workspace/webdav/proposal.doc HTTP/1.1 
     Host: example.com 
     Timeout: Infinite, Second-4100000000 
     Content-Type: text/xml; charset="utf-8" 
     Content-Length: xxxx 
     Authorization: Digest username="ejw", 
        realm="ejw@example.com", nonce="...", 
        uri="/workspace/webdav/proposal.doc", 
        response="...", opaque="..." 
      
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:lockinfo xmlns:D='DAV:'> 
      <D:lockscope><D:exclusive/></D:lockscope> 
      <D:locktype><D:write/></D:locktype> 
      <D:owner> 
        <D:href>http://www.ics.uci.edu/~ejw/contact.html</D:href> 
      </D:owner> 
     </D:lockinfo> 
    
   >>Response 
    
     HTTP/1.1 200 OK 
     Lock-Token: <opaquelocktoken:e71d4fae-5dec-22d6-fea5-00a0c91e6be4> 
     Content-Type: text/xml; charset="utf-8" 
     Content-Length: xxxx 
      
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:prop xmlns:D="DAV:"> 
      <D:lockdiscovery> 
     
                           Expires Oct 2003                         50 

                         WebDAV (RFC2518) bis                June 2003 
    
        <D:activelock> 
          <D:locktype><D:write/></D:locktype> 
          <D:lockscope><D:exclusive/></D:lockscope> 
          <D:depth>infinity</D:depth> 
          <D:owner> 
            <D:href> 
              http://www.ics.uci.edu/~ejw/contact.html 
            </D:href> 
          </D:owner> 
          <D:timeout>Second-604800</D:timeout> 
          <D:locktoken> 
            <D:href>opaquelocktoken:e71d4fae-5dec-22d6-fea5-
     00a0c91e6be4</D:href> 
          </D:locktoken> 
          <D:lockroot> 
            <D:href>http://example.com/workspace/webdav 
              /proposal.doc</D:href> 
          </D:lockroot> 
        </D:activelock> 
      </D:lockdiscovery> 
     </D:prop> 
      
   This example shows the successful creation of an exclusive write 
   lock on resource http://example.com/workspace/webdav/proposal.doc.  
   The resource http://www.ics.uci.edu/~ejw/contact.html contains 
   contact information for the owner of the lock.  The server has an 
   activity-based timeout policy in place on this resource, which 
   causes the lock to automatically be removed after 1 week (604800 
   seconds).  Note that the nonce, response, and opaque fields have not 
   been calculated in the Authorization request header. 
    
   Note that the locktoken and lockroot href elements would not contain 
   any whitespace.  The line return appearing in this document is only 
   for formatting. 
    
8.11.2  Example - Refreshing a Write Lock 
    
   >>Request 
    
     LOCK /workspace/webdav/proposal.doc HTTP/1.1 
     Host: example.com 
     Timeout: Infinite, Second-4100000000 
     Lock-Token: <opaquelocktoken:e71d4fae-5dec-22d6-fea5-00a0c91e6be4> 
     Authorization: Digest username="ejw", 
        realm="ejw@example.com", nonce="...", 
        uri="/workspace/webdav/proposal.doc", 
        response="...", opaque="..." 
     
                           Expires Oct 2003                         51 

                         WebDAV (RFC2518) bis                June 2003 
    
    
   >>Response 
    
     HTTP/1.1 200 OK 
     Content-Type: text/xml; charset="utf-8" 
     Content-Length: xxxx 
      
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:prop xmlns:D="DAV:"> 
      <D:lockdiscovery> 
        <D:activelock> 
          <D:locktype><D:write/></D:locktype> 
          <D:lockscope><D:exclusive/></D:lockscope> 
          <D:depth>infinity</D:depth> 
          <D:owner> 
            <D:href> 
            http://www.ics.uci.edu/~ejw/contact.html 
            </D:href> 
          </D:owner> 
          <D:timeout>Second-604800</D:timeout> 
          <D:locktoken> 
            <D:href>opaquelocktoken:e71d4fae-5dec-22d6-fea5-
     00a0c91e6be4</D:href> 
          </D:locktoken> 
          <D:lockroot> 
            <D:href>http://example.com/workspace/webdav 
              /proposal.doc</D:href> 
          </D:lockroot> 
        </D:activelock> 
      </D:lockdiscovery> 
     </D:prop> 
    
   This request would refresh the lock, attempting to reset the timeout 
   to the new value specified in the timeout header.  Notice that the 
   client asked for an infinite time out but the server choose to 
   ignore the request. In this example, the nonce, response, and opaque 
   fields have not been calculated in the Authorization request header. 
    
8.11.3  Example - Multi-Resource Lock Request 
    
   >>Request 
    
     LOCK /webdav/ HTTP/1.1 
     Host: example.com 
     Timeout: Infinite, Second-4100000000 
     Depth: infinity 

     
                           Expires Oct 2003                         52 

                         WebDAV (RFC2518) bis                June 2003 
    
     Content-Type: text/xml; charset="utf-8" 
     Content-Length: xxxx 
     Authorization: Digest username="ejw", 
        realm="ejw@example.com", nonce="...", 
        uri="/workspace/webdav/proposal.doc", 
        response="...", opaque="..." 
      
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:lockinfo xmlns:D="DAV:"> 
      <D:locktype><D:write/></D:locktype> 
      <D:lockscope><D:exclusive/></D:lockscope> 
      <D:owner> 
        <D:href>http://www.ics.uci.edu/~ejw/contact.html</D:href> 
      </D:owner> 
     </D:lockinfo> 
    
   >>Response 
    
     HTTP/1.1 207 Multi-Status 
     Content-Type: text/xml; charset="utf-8" 
     Content-Length: xxxx 
      
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:multistatus xmlns:D="DAV:"> 
      <D:response> 
        <D:href>http://example.com/webdav/secret</D:href> 
        <D:status>HTTP/1.1 403 Forbidden</D:status> 
      </D:response> 
      <D:response> 
        <D:href>http://example.com/webdav/</D:href> 
        <D:propstat> 
          <D:prop><D:lockdiscovery/></D:prop> 
          <D:status>HTTP/1.1 424 Failed Dependency</D:status> 
        </D:propstat> 
      </D:response> 
     </D:multistatus> 
      
   This example shows a request for an exclusive write lock on a 
   collection and all its children.  In this request, the client has 
   specified that it desires an infinite length lock, if available, 
   otherwise a timeout of 4.1 billion seconds, if available. The 
   request entity body contains the contact information for the 
   principal taking out the lock, in this case a web page URL. 
    
   The error is a 403 (Forbidden) response on the resource 
   http://example.com/webdav/secret.  Because this resource could not 
     
                           Expires Oct 2003                         53 

                         WebDAV (RFC2518) bis                June 2003 
    
   be locked, none of the resources were locked.  Note also that the 
   lockdiscovery property for the Request-URI has been included as 
   required.  In this example the lockdiscovery property is empty which 
   means that there are no outstanding locks on the resource. 
    
   In this example, the nonce, response, and opaque fields have not 
   been calculated in the Authorization request header. 
    
8.12    UNLOCK Method 
    
   The UNLOCK method removes the lock identified by the lock token in 
   the Lock-Token request header from the Request-URI and all other 
   resources included in the lock.  The root of the lock MUST be named 
   by the Request-URI, not any other resource within the scope of the 
   lock.  Servers SHOULD redirect the UNLOCK request to the lock root.  
   Failing that, servers MAY fail an UNLOCK request to a resource that 
   is not directly locked (not the root of the lock) with error code 
   400 (Bad Request). 
    
   If all resources which have been locked under the submitted lock 
   token can not be unlocked then the UNLOCK request MUST fail. 
    
   A successful response to an UNLOCK method does not mean that the 
   resource is necessarily unlocked.  It means that the specific lock 
   corresponding to the specified token no longer exists. 
    
   Any DAV compliant resource which supports the LOCK method MUST 
   support the UNLOCK method. 
    
Status Codes 
    
   204 (No Content) û Normal success response 
    
   400 (Bad Request) û No lock token was provided, or request was not 
   made to lock root. 
                
   412 (Precondition Failed) - The resource was not locked. 
 
 
8.12.1  Example - UNLOCK 
    
   >>Request 
    
     UNLOCK /workspace/webdav/info.doc HTTP/1.1 
     Host: example.com 
     Lock-Token: <opaquelocktoken:a515cfa4-5da4-22e1-f5b5-00a0451e6bf7> 
     Authorization: Digest username="ejw", 
        realm="ejw@example.com", nonce="...", 
        uri="/workspace/webdav/proposal.doc", 

     
                           Expires Oct 2003                         54 

                         WebDAV (RFC2518) bis                June 2003 
    
        response="...", opaque="..." 
    
   >>Response 
    
     HTTP/1.1 204 No Content 
      
      
   In this example, the lock identified by the lock token 
   "opaquelocktoken:a515cfa4-5da4-22e1-f5b5-00a0451e6bf7" is 
   successfully removed from the resource 
   http://example.com/workspace/webdav/info.doc.  If this lock included 
   more than just one resource, the lock is removed from all resources 
   included in the lock.  The 204 (No Content) status code is used 
   instead of 200 (OK) because there is no response entity body. 
    
   In this example, the nonce, response, and opaque fields have not 
   been calculated in the Authorization request header. 
    
    
    
9  HTTP Headers for Distributed Authoring 
    
   All DAV headers follow the same basic formatting rules as HTTP 
   headers. This includes rules like line continuation and how to 
   combine (or separate) multiple instances of the same header using 
   commas. 
    
9.1 DAV Header 
    
   DAV             = "DAV" ":" #( compliance-code ) 
   compliance-code = ( "1" | "2" | "bis" | extend ) 
   extend          = Coded-URL | token 
    
   This header indicates that the resource supports the DAV schema and 
   protocol as specified. All DAV compliant resources MUST return the 
   DAV header on all OPTIONS responses. 
    
   The value is a comma-separated list of all compliance class 
   identifiers that the resource supports.  Class identifiers may be 
   Coded-URLs or tokens (as defined by [RFC2616]). Identifiers can 
   appear in any order. 
    
   A resource must show class 1 compliance if it shows class 2 or "bis" 
   compliance. In general, support for one compliance class does not 
   entail support for any other.  Please refer to section 16 for more 
   details on compliance classes defined in this specification. 
    
9.2 Depth Header 
    

     
                           Expires Oct 2003                         55 

                         WebDAV (RFC2518) bis                June 2003 
    
   Depth = "Depth" ":" ("0" | "1" | "infinity") 
    
   The Depth header is used with methods executed on resources which 
   could potentially have internal members to indicate whether the 
   method is to be applied only to the resource ("Depth: 0"), to the 
   resource and its immediate children, ("Depth: 1"), or the resource 
   and all its progeny ("Depth: infinity"). 
    
   The Depth header is only supported if a method's definition 
   explicitly provides for such support. 
    
   The following rules are the default behavior for any method that 
   supports the Depth header. A method may override these defaults by 
   defining different behavior in its definition. 
    
   Methods which support the Depth header may choose not to support all 
   of the header's values and may define, on a case by case basis, the 
   behavior of the method if a Depth header is not present. For 
   example, the MOVE method only supports "Depth: infinity" and if a 
   Depth header is not present will act as if a "Depth: infinity" 
   header had been applied. 
    
   Clients MUST NOT rely upon methods executing on members of their 
   hierarchies in any particular order or on the execution being atomic 
   unless the particular method explicitly provides such guarantees. 
    
   Upon execution, a method with a Depth header will perform as much of 
   its assigned task as possible and then return a response specifying 
   what it was able to accomplish and what it failed to do. 
    
   So, for example, an attempt to COPY a hierarchy may result in some 
   of the members being copied and some not. 
    
   Any headers on a method that has a defined interaction with the 
   Depth header MUST be applied to all resources in the scope of the 
   method except where alternative behavior is explicitly defined. For 
   example, an If-Match header will have its value applied against 
   every resource in the method's scope and will cause the method to 
   fail if the header fails to match. 
    
   If a resource, source or destination, within the scope of the method 
   with a Depth header is locked in such a way as to prevent the 
   successful execution of the method, then the lock token for that 
   resource MUST be submitted with the request in the If request 
   header. 
    
   The Depth header only specifies the behavior of the method with 
   regards to internal children.  If a resource does not have internal 
   children then the Depth header MUST be ignored. 
    

     
                           Expires Oct 2003                         56 

                         WebDAV (RFC2518) bis                June 2003 
    
   Please note, however, that it is always an error to submit a value 
   for the Depth header that is not allowed by the method's definition.  
   Thus submitting a "Depth: 1" on a COPY, even if the resource does 
   not have internal members, will result in a 400 (Bad Request). The 
   method should fail not because the resource doesn't have internal 
   members, but because of the illegal value in the header. 
    
9.3 Destination Header 
    
   Destination = "Destination" ":" ( absoluteURI | abs_path ) 
    
   The Destination header specifies the URI which identifies a 
   destination resource for methods such as COPY and MOVE, which take 
   two URIs as parameters.  Note that the absoluteURI and abs_path 
   production are defined in [RFC2396].  If abs_path is used, the 
   scheme, host and port of the destination are the same as those for 
   the Request-URI (note the Host header, which must be present on 
   requests, contains the host and port). 
    
   If the Destination value is an absolute URI, it may name a different 
   server (or different port or scheme). If the source server cannot 
   attempt a copy to the remote server, it MUST fail the request with a 
   502 (Bad Gateway) response.  
    
    
    
9.4 Force-Authentication Header 
    
   Force-Authentication = "Force-Authentication" ":" Method 
    
   The Force-Authentication header is used with the OPTIONS method to 
   specify that the client wants to be challenged for authentication 
   credentials to the resource identified by the Request-URI.  If 
   present on a request to a WebDAV-compliant resource, the server MUST 
   respond with either 401 (Unauthorized) or 501 (Not Implemented) 
   status code. The Method value is used for the client to indicate 
   what method it intends to use first on the resource identified in 
   the Request-URI.  
    
9.5 If Header 
    
   If = "If" ":" ( 1*No-tag-list | 1*Tagged-list) 
   No-tag-list = List 
   Tagged-list = Resource 1*List 
   Resource = Coded-URL 
   List = "(" 1*(["Not"](State-token | "[" entity-tag "]")) ")" 
   State-token = Coded-URL | "<DAV:no-lock>" 
   Coded-URL = "<" absoluteURI ">" 
    
     
                           Expires Oct 2003                         57 

                         WebDAV (RFC2518) bis                June 2003 
    
   The If header is intended to have similar functionality to the If-
   Match header defined in section 14.24 of [RFC2616].  However the If 
   header is intended for use with any URI which represents state 
   information, referred to as a state token, about a resource as well 
   as ETags.  A typical example of a state token is a lock token, and 
   lock tokens are the only state tokens defined in this specification. 
   The <DAV:no-lock> state token is a token that must never match an 
   actual valid lock token. The purpose of this is described in section 
   9.5.5. 
    
   The If header's purpose is to describe a series of state lists.  If 
   the state of the resource to which the header is applied does not 
   match any of the specified state lists then the request MUST fail 
   with a 412 (Precondition Failed).  If one of the described state 
   lists matches the state of the resource then the request may 
   succeed. 
    
   The server must parse the If header when it appears on any request, 
   evaluate all the clauses, and if the conditional evaluates to false, 
   fail the request.  
    
   Note that the absoluteURI production is defined in [RFC2396]. 
    
   RFC2518 originally defined the If header without comma separators. 
   This oversight meant that the If header couldn't be divided up among 
   multiple lines according to the HTTP header manipulation rules. 
   Servers supporting "bis" MUST be able to accept commas in If header 
   values. If the header has commas between tokens or clauses, the 
   header can be evaluated simply by removing the commas and proceeding 
   with the evaluation rules. 
    
9.5.1   No-tag-list Production 
    
   The No-tag-list production describes a series of state tokens and 
   ETags.  If multiple No-tag-list productions are used then one only 
   needs to match the state of the resource for the method to be 
   allowed to continue.  All untagged tokens apply to the resource 
   identified in the Request-URI. 
    
9.5.2   Example - No-tag-list If Header 
    
     If: (<opaquelocktoken:a-write-lock-token> ["I am an ETag"]), (["I 
     am another ETag"]) 
    
   The previous header would require that the resource identified in 
   the Request-URI be locked with the specified lock token and in the 
   state identified by the "I am an ETag" ETag or in the state 
   identified by the second ETag "I am another ETag".  To put the 
   matter more plainly one can think of the previous If header as being 

     
                           Expires Oct 2003                         58 

                         WebDAV (RFC2518) bis                June 2003 
    
   in the form (or (and <opaquelocktoken:a-write-lock-token> ["I am an 
   ETag"]) (and ["I am another ETag"])). 
    
9.5.3   Tagged-list Production 
    
   The tagged-list production scopes a list production.  That is, it 
   specifies that the lists following the resource specification only 
   apply to the specified resource.  The scope of the resource 
   production begins with the list production immediately following the 
   resource production and ends with the next resource production, if 
   any.  All clauses must be evaluated. 
    
 
   The same URI MUST NOT appear more than once in a resource production 
   in an If header. 
    
9.5.4   Example - Tagged List If header 
    
     COPY /resource1 HTTP/1.1 
     Host: www.example.com 
     Destination: http://www.example.com/resource2 
     If: <http://www.example.com/resource1> (<locktoken:a-write-lock-
     token> [W/"A weak ETag"]), (["strong ETag"]), 
     <http://www.bar.bar/random>(["another strong ETag"]) 
    
   In this example http://www.example.com/resource1 is being copied to 
   http://www.example.com/resource2.  When the method is first applied 
   to http://www.example.com/resource1, resource1 must be in the state 
   specified by "(<locktoken:a-write-lock-token> [W/"A weak ETag"]) 
   (["strong ETag"])", that is, it either must be locked with a lock 
   token of "locktoken:a-write-lock-token" and have a weak entity tag 
   W/"A weak ETag" or it must have a strong entity tag "strong ETag". 
    
   That is the only success condition since the resource 
   http://www.bar.bar/random never has the method applied to it (the 
   only other resource listed in the If header) and 
   http://www.example.com/resource2 is not listed in the If header. 
    
9.5.5   Not Production 
    
   Every state token or ETag is either current, and hence describes the 
   state of a resource, or is not current, and does not describe the 
   state of a resource. The boolean operation of matching a state token 
   or ETag to the current state of a resource thus resolves to a true 
   or false value.  The æNotÆ production is used to reverse that value.  
   The scope of the not production is the state-token or entity-tag 
   immediately following it. 
    
     If: (Not <locktoken:write1> <locktoken:write2>) 
    
     
                           Expires Oct 2003                         59 

                         WebDAV (RFC2518) bis                June 2003 
    
   When submitted with a request, this If header requires that all 
   operand resources must not be locked with locktoken:write1 and must 
   be locked with locktoken:write2. 
    
   The Not production is particularly useful with the "<DAV:no-lock>" 
   state token defined. The clause "Not <DAV:no-lock>" must evaluate to 
   true. Thus, any "OR" statement containing the clause "Not <DAV:no-
   lock> must also evaluate to true.  
    
9.5.6   Matching Function 
    
   When performing If header processing, the definition of a matching 
   state token or entity tag is as follows. 
    
   Matching entity tag: Where the entity tag matches an entity tag 
   associated with that resource. 
    
   Matching state token: Where there is an exact match between the 
   state token in the If header and any state token on the resource. 
 
9.5.7   If Header and Non-DAV Aware Proxies 
    
   Non-DAV aware proxies will not honor the If header, since they will 
   not understand the If header, and HTTP requires non-understood 
   headers to be ignored.  When communicating with HTTP/1.1 proxies, 
   the "Cache-Control: no-cache" request header MUST be used so as to 
   prevent the proxy from improperly trying to service the request from 
   its cache.  When dealing with HTTP/1.0 proxies the "Pragma: no-
   cache" request header MUST be used for the same reason. 
    
9.6 Lock-Token Header 
    
   Lock-Token = "Lock-Token" ":" Coded-URL 
    
   The Lock-Token request header is used with the UNLOCK method to 
   identify the lock to be removed.  The lock token in the Lock-Token 
   request header MUST identify a lock that contains the resource 
   identified by Request-URI as a member. 
    
   The Lock-Token response header is used with the LOCK method to 
   indicate the lock token created as a result of a successful LOCK 
   request to create a new lock. 
    
9.7 Overwrite Header 
    
   Overwrite = "Overwrite" ":" ("T" | "F") 
    
   The Overwrite header specifies whether the server should overwrite 
   the state of a non-null destination resource during a COPY or MOVE.  
   A value of "F" states that the server must not perform the COPY or 
     
                           Expires Oct 2003                         60 

                         WebDAV (RFC2518) bis                June 2003 
    
   MOVE operation if the state of the destination resource is non-null. 
   If the overwrite header is not included in a COPY or MOVE request 
   then the resource MUST treat the request as if it has an overwrite 
   header of value "T". While the Overwrite header appears to duplicate 
   the functionality of the If-Match: * header of HTTP/1.1, If-Match 
   applies only to the Request-URI, and not to the Destination of a 
   COPY or MOVE. 
    
   If a COPY or MOVE is not performed due to the value of the Overwrite 
   header, the method MUST fail with a 412 (Precondition Failed) status 
   code. 
    
   All DAV compliant resources MUST support the Overwrite header. 
    
9.8 Status-URI Response Header 
    
   The Status-URI response header may be used with the 102 (Processing) 
   status code to inform the client as to the status of a method. 
    
   Status-URI = "Status-URI" ":" *(Status-Code Coded-URL) ; Status-Code 
   is defined in 6.1.1 of [RFC2616] 
    
   The URIs listed in the header are source resources which have been 
   affected by the outstanding method.  The status code indicates the 
   resolution of the method on the identified resource.  So, for 
   example, if a MOVE method on a collection is outstanding and a 102 
   (Processing) response with a Status-URI response header is returned, 
   the included URIs will indicate resources that have had move 
   attempted on them and what the result was. 
    
9.9 Timeout Request Header 
    
   TimeOut = "Timeout" ":" 1#TimeType 
   TimeType = ("Second-" DAVTimeOutVal | "Infinite") 
   DAVTimeOutVal = 1*digit 
    
   Clients may include Timeout headers in their LOCK requests.  
   However, the server is not required to honor or even consider these 
   requests.  Clients MUST NOT submit a Timeout request header with any 
   method other than a LOCK method. 
    
   Timeout response values MUST use a Second value or Infinite. 
    
   The "Second" TimeType specifies the number of seconds that will 
   elapse between granting of the lock at the server, and the automatic 
   removal of the lock.  The timeout value for TimeType "Second" MUST 
   NOT be greater than 2^32-1. 
    
     
                           Expires Oct 2003                         61 

                         WebDAV (RFC2518) bis                June 2003 
    
   The timeout counter MUST be restarted if a refresh LOCK request is 
   successful.  The timeout counter SHOULD NOT be restarted at any 
   other time.   
    
   If the timeout expires then the lock may be lost.  Specifically, if 
   the server wishes to harvest the lock upon time-out, the server 
   SHOULD act as if an UNLOCK method was executed by the server on the 
   resource using the lock token of the timed-out lock, performed with 
   its override authority. Thus logs should be updated with the 
   disposition of the lock, notifications should be sent, etc., just as 
   they would be for an UNLOCK request. 
    
   Servers are advised to pay close attention to the values submitted 
   by clients, as they will be indicative of the type of activity the 
   client intends to perform.  For example, an applet running in a 
   browser may need to lock a resource, but because of the instability 
   of the environment within which the applet is running, the applet 
   may be turned off without warning.  As a result, the applet is 
   likely to ask for a relatively small timeout value so that if the 
   applet dies, the lock can be quickly harvested.  However, a document 
   management system is likely to ask for an extremely long timeout 
   because its user may be planning on going off-line. 
    
   A client MUST NOT assume that just because the time-out has expired 
   the lock has been lost. Likewise, a client MUST NOT assume that just 
   because the time-out has not expired, the lock still exists (and for 
   this reason, clients are strongly advised to use ETags as well). 
    
10 Status Code Extensions to HTTP/1.1 
    
   The following status codes are added to those defined in HTTP/1.1 
   [RFC2616]. 
    
10.1    102 Processing 
    
   The 102 (Processing) status code is an interim response used to 
   inform the client that the server has accepted the complete request, 
   but has not yet completed it.  This status code SHOULD only be sent 
   when the server has a reasonable expectation that the request will 
   take significant time to complete. As guidance, if a method is 
   taking longer than 20 seconds (a reasonable, but arbitrary value) to 
   process the server SHOULD return a 102 (Processing) response. The 
   server MUST send a final response after the request has been 
   completed. 
    
   Methods can potentially take a long period of time to process, 
   especially methods that support the Depth header.  In such cases the 
   client may time-out the connection while waiting for a response.  To 
     
                           Expires Oct 2003                         62 

                         WebDAV (RFC2518) bis                June 2003 
    
   prevent this the server may return a 102 (Processing) status code to 
   indicate to the client that the server is still processing the 
   method. 
    
10.2    207 Multi-Status 
    
   The 207 (Multi-Status) status code provides status for multiple 
   independent operations (see section 12 for more information). 
    
10.3    422 Unprocessable Entity 
    
   The 422 (Unprocessable Entity) status code means the server 
   understands the content type of the request entity (hence a 
   415(Unsupported Media Type) status code is inappropriate), and the 
   syntax of the request entity is correct (thus a 400 (Bad Request) 
   status code is inappropriate) but was unable to process the 
   contained instructions.  For example, this error condition may occur 
   if an XML request body contains well-formed (i.e., syntactically 
   correct), but semantically erroneous XML instructions. 
    
10.4    423 Locked 
    
   The 423 (Locked) status code means the source or destination 
   resource of a method is locked. 
    
10.5    424 Failed Dependency 
    
   The 424 (Failed Dependency) status code means that the method could 
   not be performed on the resource because the requested action 
   depended on another action and that action failed.  For example, if 
   a command in a PROPPATCH method fails then, at minimum, the rest of 
   the commands will also fail with 424 (Failed Dependency). 
    
10.6    507 Insufficient Storage 
    
   The 507 (Insufficient Storage) status code means the method could 
   not be performed on the resource because the server is unable to 
   store the representation needed to successfully complete the 
   request.  This condition is considered to be temporary.  If the 
   request which received this status code was the result of a user 
   action, the request MUST NOT be repeated until it is requested by a 
   separate user action. 
    
    
11 Use of HTTP Status Codes 
    
11.1    301 Moved Permanently 
    
   Any WebDAV request may be redirected using this status code. 

     
                           Expires Oct 2003                         63 

                         WebDAV (RFC2518) bis                June 2003 
    
11.2    302 Found 
    
   Any WebDAV request may be redirected using this status code. 
    
11.3    400 Bad Request 
    
   This code may be used if: 
    - the Host header is missing in any request 
    - The protocol version is HTTP/1.0 
    - Any header is improperly formatted  
    - The request method line is improperly formatted 
    
11.4    403 Forbidden 
    
   Uses: 
    - The server does not ever accept this method on this kind of 
   resource. For example, if a PUT is not accepted on a collection. 
    
11.5    409 Conflict 
    
   The 409 Conflict is most typically returned when a method that 
   attempts to create a new resource must fail, because one of the 
   collections that resource depends on does not exist.  However, other 
   types of conflicts are defined in specifications extending RFC2518.  
   Therefore, this can be returned in response to all methods. 
    
    
11.6    414 Request-URI Too Long 
    
   This status code is used in HTTP 1.1 only for Request-URIs, because 
   full URIs arenÆt used in other headers. WebDAV specifies full URLs 
   in other headers, therefore this error may be used if the URI is too 
   long in other locations as well. This status code may be used in 
   response to any method in this specification. 

12 Multi-Status Response 
    
   The default 207 (Multi-Status) response body is a text/xml or 
   application/xml HTTP entity that contains a single XML element 
   called multistatus, which contains a set of XML elements called 
   response which contain 200, 300, 400, and 500 series status codes 
   generated during the method invocation.  100 series status codes 
   SHOULD NOT be recorded in a response XML element.  The 207 status 
   code itself MUST NOT be considered a success response, it is only 
   completely successful if all response elements inside contain 
   success status codes. 
    
   The body of a 207 Multi-Status response MUST contain a URL 
   associated with each specific status code, so that the client can 
     
                           Expires Oct 2003                         64 

                         WebDAV (RFC2518) bis                June 2003 
    
   tell whether the error occurred with the source resource, 
   destination resource or some other resource in the scope of the 
   request. URLs for collections appearing in the results SHOULD end in 
   a æ/Æ character.   
    
   When a Multi-Status response does not have a clear scope (e.g. in 
   response to MOVE or COPY when the scope could be either the source 
   or the destination), URLs appearing in the response body SHOULD be 
   absolute and fully-qualified URLs.   
    
   When a Multi-Status response does have a clear scope, especially in 
   response to a PROPFIND request when all URLs appearing in the body 
   must be inside the collection named in the request-URI, the URLs MAY 
   be absolute or MAY be relative.   
    - If the URLs are absolute, then the server MUST ensure that the 
   URLs have the same prefix (scheme, host, port, and path) as the URL 
   of the requested collection (which may be the same as the Request-
   URI or may be the corrected in the response Location header). 
    - If the URLs are relative, they MUST be resolved against the 
   Location header, if present, or as second choice against the 
   Request-URI. 
    
12.1    Responses requiring Location in Multi-Status 
    
   The 300-303, 305 and 307 responses defined in HTTP 1.1 normally take 
   a Location header to indicate where the client should make the 
   request.  The Multi-Status response syntax does not allow for the 
   Location header information to be included in an unambiguous way, so 
   servers MAY choose not to use these status codes in Multi-Status 
   responses. If a clients receives this status code in Multi-Status, 
   the client MAY reissue the request to the individual resource, so 
   that the server can issue a response with a Location header for each 
   resource.  

13 XML Element Definitions 
    
   In the section below, the final line of each section gives the 
   element type declaration using the format defined in [REC-XML]. The 
   "Value" field, where present, specifies further restrictions on the 
   allowable contents of the XML element using BNF (i.e., to further 
   restrict the values of a PCDATA element). 
    
   All of the elements defined here may be extended by the addition of 
   attributes and child elements not defined in this specification.  
    
13.1    activelock XML Element 
    
   Name:    activelock 
   Namespace:   DAV: 
     
                           Expires Oct 2003                         65 

                         WebDAV (RFC2518) bis                June 2003 
    
   Purpose: Describes a lock on a resource. 
    
   <!ELEMENT activelock ANY> 
   ANY value: Any number of elements, including one of each of 
   (lockscope, locktype, depth, owner, timeout, locktoken, lockroot)  
    
13.2    depth XML Element 
    
   Name:    depth 
   Namespace:   DAV: 
   Purpose: The value of the Depth header. 
   Value:   "0" | "1" | "infinity"    
    
   <!ELEMENT depth (#PCDATA) > 
    
13.3    locktoken XML Element 
    
   Name:    locktoken 
   Namespace:   DAV: 
   Purpose: The lock token associated with a lock. 
   Description:         The href contains a single lock token URI which 
            refers to the lock (i.e., the OpaqueLockToken-URI 
            production in section 6.4). 
    
   <!ELEMENT locktoken (href) > 
    
13.4    lockroot XML Element 
    
   Name:    lockroot 
   Namespace:   DAV: 
   Purpose: The resource where the lock is ôrootedö, which is the 
            resource that was addressed in the LOCK request. 
   Description: The href contains a URL with the address of the root of 
            the lock. The server SHOULD include this in all 
            lockdiscovery property values and the response to LOCK 
            requests. 
    
   <!ELEMENT lockroot (href) > 
    
13.5    timeout XML Element 
    
   Name:    timeout 
   Namespace:   DAV: 
   Purpose: The number of seconds remaining before a lock expires. 
   Value:   TimeType ;Defined in section 9.9. 

     
                           Expires Oct 2003                         66 

                         WebDAV (RFC2518) bis                June 2003 
    
   <!ELEMENT timeout (#PCDATA) > 
    
13.6    collection XML Element 
    
   Name:    collection 
   Namespace:   DAV: 
   Purpose: Identifies the associated resource as a collection. The 
            resourcetype property of a collection resource MUST have 
            this value.  It is normally empty but extensions may add 
            sub-elements. 
    
   <!ELEMENT collection EMPTY > 
    
13.7    href XML Element 
    
   Name:    href 
   Namespace:   DAV: 
   Purpose: Identifies the content of the element as a URI. 
   Value:   URI ; See section 3.2.1 of [RFC2616] 
    
   <!ELEMENT href (#PCDATA)> 
    
    
13.8    lockentry XML Element 
    
   Name:    lockentry 
   Namespace:   DAV: 
   Purpose: Defines the types of locks that can be used with the 
            resource. 
    
   <!ELEMENT lockentry ANY > 
   ANY value: any number of elements, including one of each of 
   (lockscope, locktype) 
    
13.9    lockinfo XML Element 
    
   Name:    lockinfo 
   Namespace:   DAV: 
   Purpose: The lockinfo XML element is used with a LOCK method to 
            specify the type of lock the client wishes to have created. 
    
   <!ELEMENT lockinfo ANY > 
   ANY value: any number of elements, including one of each of 
   (lockscope, locktype), and optionally including the owner element. 
    
13.10   lockscope XML Element 
    
     
                           Expires Oct 2003                         67 

                         WebDAV (RFC2518) bis                June 2003 
    
   Name:    lockscope 
   Namespace:   DAV: 
   Purpose: Specifies whether a lock is an exclusive lock, or a shared 
            lock. 
    
   <!ELEMENT lockscope (exclusive | shared) > 
    
13.11   exclusive XML Element 
    
   Name:    exclusive 
   Namespace:   DAV: 
   Purpose: Specifies an exclusive lock 
    
   <!ELEMENT exclusive EMPTY > 
    
13.12   shared XML Element 
    
   Name:    shared 
   Namespace:   DAV: 
   Purpose: Specifies a shared lock 
    
   <!ELEMENT shared EMPTY > 
    
13.13   locktype XML Element 
    
   Name:    locktype 
   Namespace:   DAV: 
   Purpose: Specifies the access type of a lock.  At present, this 
            specification only defines one lock type, the write lock. 
    
   <!ELEMENT locktype ANY > 
   ANY value: Any element meaning a lock type. The only such element 
   defined in this document is the write element. 
    
13.14   write XML Element 
    
   Name:    write 
   Namespace:   DAV: 
   Purpose: Specifies a write lock. 
    
   <!ELEMENT write EMPTY > 
    
13.15   multistatus XML Element 
    
   Name:    multistatus 
   Namespace:   DAV: 
   Purpose: Contains multiple response messages. 
     
                           Expires Oct 2003                         68 

                         WebDAV (RFC2518) bis                June 2003 
    
   Description:         The responsedescription at the top level is 
            used to provide a general message describing the 
            overarching nature of the response.  If this value is 
            available an application may use it instead of presenting 
            the individual response descriptions contained within the 
            responses. 
    
   <!ELEMENT multistatus ANY > 
   ANY value: At least one response element, and zero or more 
   responsedescription elements. 
    
13.16   response XML Element 
    
   Name:    response 
   Namespace:   DAV: 
   Purpose: Holds a single response describing the effect of a method 
            on resource and/or its properties. 
   Description:         A particular href MUST NOT appear more than 
            once as the child of a response XML element under a 
            multistatus XML element.  This requirement is necessary in 
            order to keep processing costs for a response to linear 
            time.  Essentially, this prevents having to search in order 
            to group together all the responses by href.  There are, 
            however, no requirements regarding ordering based on href 
            values. 
    
   <!ELEMENT response ANY > 
   ANY value: MUST contain an href element.  MUST contain a status 
   element or a propstat element.  MAY contain a responsedescription 
   element.  
    
13.17   propstat XML Element 
    
   Name:    propstat 
   Namespace:   DAV: 
   Purpose: Groups together a prop and status element that is 
            associated with a particular href element.  
   Description:         The propstat XML element MUST contain one prop 
            XML element and one status XML element.  The contents of 
            the prop XML element MUST only list the names of properties 
            to which the result in the status element applies. 
    
   <!ELEMENT propstat ANY > 
   ANY value: Contains one of each of (prop, status) and may contain a 
   responsedescription element.  
    
     
                           Expires Oct 2003                         69 

                         WebDAV (RFC2518) bis                June 2003 
    
13.18   status XML Element 
    
   Name:    status 
   Namespace:   DAV: 
   Purpose: Holds a single HTTP status-line 
   Value:   status-line   ;status-line defined in [RFC2616] 
    
   <!ELEMENT status (#PCDATA) > 
    
13.19   responsedescription XML Element 
    
   Name:    responsedescription 
   Namespace:   DAV: 
   Purpose: Contains a message that can be displayed to the user 
            explaining the nature of the response. 
   Description:         This XML element provides information suitable 
            to be presented to a user. 
    
   <!ELEMENT responsedescription (#PCDATA) > 
    
13.20   owner XML Element 
    
   Name:    owner 
   Namespace:   DAV: 
   Purpose: Provides information about the principal taking out a lock. 
   Description:         The owner XML element provides information 
            sufficient for either directly contacting a principal (such 
            as a telephone number or Email URI), or for discovering the 
            principal (such as the URL of a homepage) who owns a lock. 
    
   <!ELEMENT owner ANY> 
    
13.21   prop XML element 
    
   Name:    prop 
   Namespace:   DAV: 
   Purpose: Contains properties related to a resource. 
   Description:         The prop XML element is a generic container for 
            properties defined on resources.  All elements inside a 
            prop XML element MUST define properties related to the 
            resource.  No other elements may be used inside of a prop 
            element. 
    
   <!ELEMENT prop ANY> 
    
13.22   propertyupdate XML element 
    
     
                           Expires Oct 2003                         70 

                         WebDAV (RFC2518) bis                June 2003 
    
   Name:    propertyupdate 
   Namespace:   DAV: 
   Purpose: Contains a request to alter the properties on a resource. 
   Description:         This XML element is a container for the 
            information required to modify the properties on the 
            resource.  This XML element is multi-valued. 
    
   <!ELEMENT propertyupdate ANY > 
   ANY value: Must contain at least one remove or set element. May 
   contain any number of remove and set elements.  
    
13.23   remove XML element 
    
   Name:    remove 
   Namespace:   DAV: 
   Purpose: Lists the DAV properties to be removed from a resource. 
   Description:         Remove instructs that the properties specified 
            in prop should be removed.  Specifying the removal of a 
            property that does not exist is not an error.  All the XML 
            elements in a prop XML element inside of a remove XML 
            element MUST be empty, as only the names of properties to 
            be removed are required. 
    
   <!ELEMENT remove (prop) > 
    
13.24   set XML element 
    
   Name:    set 
   Namespace:   DAV: 
   Purpose: Lists the DAV property values to be set for a resource. 
   Description: The set XML element MUST contain only a prop XML 
            element.  The elements contained by the prop XML element 
            inside the set XML element MUST specify the name and value 
            of properties that are set on the resource identified by 
            Request-URI.  If a property already exists then its value 
            is replaced. Language tagging information appearing in the 
            scope of the prop element (in the "xml:lang" attribute, if 
            present) MUST be persistently stored along with the 
            property, and MUST be subsequently retrievable using 
            PROPFIND. 
    
   <!ELEMENT set (prop) > 
    
13.25   propfind XML Element 
    
   Name:    propfind 
     
                           Expires Oct 2003                         71 

                         WebDAV (RFC2518) bis                June 2003 
    
   Namespace:   DAV: 
   Purpose: Specifies the properties to be returned from a PROPFIND 
            method.  Four special elements are specified for use with 
            propfind: prop, deadprops, allprop and propname.  If prop 
            is used inside propfind it MUST NOT contain property 
            values. 
    
   <!ELEMENT propfind ANY > 
   ANY value: MUST contain one and only one of (allprop | propname | 
   prop).   
    
13.26   allprop XML Element 
    
   Name:    allprop 
   Namespace:   DAV: 
   Purpose: The allprop XML element specifies that all names and values 
            of dead properties and the live properties defined by this 
            document existing on the resource are to be returned. 
    
   <!ELEMENT allprop EMPTY > 
    
13.27   propname XML Element 
    
   Name:    propname 
   Namespace:   DAV: 
   Purpose: The propname XML element specifies that only a list of 
            property names on the resource is to be returned. 
    
   <!ELEMENT propname EMPTY > 
    
13.28   deadprops XML Element 
    
   Name:    deadprops 
   Namespace:   DAV: 
   Purpose: The deadprops XML element specifies that all dead 
            properties, names and values, should be returned in the 
            response. 
    
   <!ELEMENT deadprops EMPTY > 
    
14 DAV Properties 
    
   For DAV properties, the name of the property is also the same as the 
   name of the XML element that contains its value. In the section 
   below, the final line of each section gives the element type 
   declaration using the format defined in [REC-XML]. The "Value" 
   field, where present, specifies further restrictions on the 
     
                           Expires Oct 2003                         72 

                         WebDAV (RFC2518) bis                June 2003 
    
   allowable contents of the XML element using BNF (i.e., to further 
   restrict the values of a PCDATA element).  Note that a resource may 
   have only one value for a property of a given name, so the property 
   may only show up once in PROPFIND responses or PROPPATCH requests. 
    
   The value of a protected property may not be changed even by a user 
   with permission to edit other properties.  Some property values are 
   calculated by the server and it is not appropriate to allow client 
   changes. This specification mentions which properties may be 
   protected in order to set client expectations. 
    
14.1    creationdate Property 
    
   Name:    creationdate 
   Namespace:   DAV: 
   Purpose:     Records the time and date the resource was created. 
   Value:   date-time   
   COPY/MOVE behaviour: This property value SHOULD be kept during a 
            MOVE operation, but is re-initialized when a resource is 
            created with a COPY. It should not be set in a remote COPY. 
   Description: The creationdate property should be defined on all DAV 
            compliant resources.  If present, it contains a timestamp 
            of the moment when the resource was created (i.e., the 
            moment it had non-null state).  This property is live and 
            protected. The Internet date-time format is defined in 
            [RFC3339], see the ABNF in section 5.6. 
    
   <!ELEMENT creationdate (#PCDATA) > 
    
14.2    displayname Property 
    
   Name:    displayname 
   Namespace:   DAV: 
   Purpose: Provides a name for the resource that is suitable for 
            presentation to a user. 
   COPY/MOVE behaviour: This property value SHOULD be preserved in 
            local COPY and MOVE operations. It MAY be attempted to be 
            set in remote COPY operation. 
   Description:         The displayname property should be defined on 
            all DAV compliant resources.  If present, the property 
            contains a description of the resource that is suitable for 
            presentation to a user. This property is live and MAY be 
            protected. 
    
   <!ELEMENT displayname (#PCDATA) > 

     
                           Expires Oct 2003                         73 

                         WebDAV (RFC2518) bis                June 2003 
    
14.3    getcontentlanguage Property 
    
   Name:    getcontentlanguage 
   Namespace:   DAV: 
   Purpose: Contains the Content-Language header returned by a GET 
            without accept headers 
   COPY/MOVE behaviour: This property value SHOULD be preserved in 
            local COPY and MOVE operations. It should be attempted to 
            be set in remote COPY operation. 
   Description:         The getcontentlanguage property MUST be defined 
            on any DAV compliant resource that returns the Content-
            Language header on a GET.  This property is live and MAY be 
            protected. 
   Value:   language-tag   ;language-tag is defined in section 14.13 of 
            [RFC2616] 
    
   <!ELEMENT getcontentlanguage (#PCDATA) > 
    
14.4    getcontentlength Property 
    
   Name:    getcontentlength 
   Namespace:   DAV: 
   Purpose: Contains the Content-Length header returned by a GET 
            without accept headers. 
   Description:         The getcontentlength property MUST be defined 
            on any DAV compliant resource that returns the Content-
            Length header in response to a GET.  This property is live 
            and protected. 
   COPY/MOVE behaviour: This property value is dependent on the size of 
            the destination resource, not the value of the property on 
            the source resource. 
   Value:   content-length ; see section 14.14 of [RFC2616] 
    
   <!ELEMENT getcontentlength (#PCDATA) > 
    
14.5    getcontenttype Property 
    
   Name:    getcontenttype 
   Namespace:   DAV: 
   Purpose: Contains the Content-Type header returned by a GET without 
            accept headers. 
   COPY/MOVE behaviour: This property value SHOULD be preserved in 
            local COPY and MOVE operations. In a remote COPY operation 
            that is implemented through a GET request, the GET request 
            must have the appropriate Content-Type header. 

     
                           Expires Oct 2003                         74 

                         WebDAV (RFC2518) bis                June 2003 
    
   Description:         This getcontenttype property MUST be defined on 
            any DAV compliant resource that returns the Content-Type 
            header in response to a GET. This property is live and MAY 
            be protected. 
   Value:   media-type   ; defined in section 3.7 of [RFC2616] 
    
   <!ELEMENT getcontenttype (#PCDATA) > 
    
14.6    getetag Property 
    
   Name:    getetag 
   Namespace:   DAV: 
   Purpose: Contains the ETag header returned by a GET without accept 
            headers. 
   COPY/MOVE behaviour: This property value is dependent on the final 
            state of the destination resource, not the value of the 
            property on the source resource. It MUST NOT be set in 
            PROPPATCH during a cross-server copy. 
   Description:         The getetag property MUST be defined on any DAV 
            compliant resource that returns the Etag header.  Refer to 
            RFC2616 for a complete definition of the semantics of an 
            ETag.  Note that changes in properties or lock state MUST 
            not cause a resourceÆs ETag to change This property is live 
            and protected. 
   Value:   entity-tag  ; defined in section 3.11 of [RFC2616] 
    
   <!ELEMENT getetag (#PCDATA) > 
    
14.7    getlastmodified Property 
    
   Name:    getlastmodified 
   Namespace:   DAV: 
   Purpose: Contains the Last-Modified header returned by a GET method 
            without accept headers. 
   COPY/MOVE behaviour: This property value is dependent on the last 
            modified date of the destination resource, not the value of 
            the property on the source resource. 
   Description: Note that the last-modified date on a resource SHOULD 
            only reflect changes in the body (the GET responses) of the 
            resource.  A change in a property SHOULD NOT cause the 
            last-modified date to change, because clients MAY rely on 
            the last-modified date to know when to overwrite the 
            existing body. The getlastmodified property MUST be defined 
            on any DAV compliant resource that returns the Last-


     
                           Expires Oct 2003                         75 

                         WebDAV (RFC2518) bis                June 2003 
    
            Modified header in response to a GET. This property is live 
            and protected.  
   Value:   HTTP-date  ; defined in section 3.3.1 of [RFC2616] 
    
   <!ELEMENT getlastmodified (#PCDATA) > 
    
14.8    lockdiscovery Property 
    
   Name:    lockdiscovery 
   Namespace:   DAV: 
   Purpose: Describes the active locks on a resource 
   COPY/MOVE behaviour: The value of this property depends on the lock 
            state of the destination, not on the locks of the source 
            resource.  Recall that locks are not moved in a MOVE 
            operation. 
   Description: The lockdiscovery property returns a listing of who has 
            a lock, what type of lock he has, the timeout type and the 
            time remaining on the timeout, and the associated lock 
            token.  If there are no locks, but the server supports 
            locks, the property will be present but contain zero 
            æactivelockÆ elements.  If there is one or more lock, an 
            æactivelockÆ element appears for each lock on the resource. 
            This property is live and protected. 
    
   <!ELEMENT lockdiscovery ANY > 
   ANY value: MAY contain zero or more activelock elements. MAY contain 
   additional elements not defined in this document. 
    
14.8.1  Example - Retrieving the lockdiscovery Property 
    
   >>Request 
    
     PROPFIND /container/ HTTP/1.1 
     Host: www.example.com 
     Content-Length: xxxx 
     Content-Type: text/xml; charset="utf-8" 
      
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:propfind xmlns:D='DAV:'> 
      <D:prop><D:lockdiscovery/></D:prop> 
     </D:propfind> 
    
   >>Response 
    
     HTTP/1.1 207 Multi-Status 
     Content-Type: text/xml; charset="utf-8" 
     
                           Expires Oct 2003                         76 

                         WebDAV (RFC2518) bis                June 2003 
    
     Content-Length: xxxx 
      
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:multistatus xmlns:D='DAV:'> 
      <D:response> 
        <D:href>http://www.example.com/container/</D:href> 
        <D:propstat> 
          <D:prop> 
            <D:lockdiscovery> 
             <D:activelock> 
              <D:locktype><D:write/></D:locktype> 
              <D:lockscope><D:exclusive/></D:lockscope> 
              <D:depth>0</D:depth> 
              <D:owner>Jane Smith</D:owner> 
              <D:timeout>Infinite</D:timeout> 
              <D:locktoken> 
                <D:href>opaquelocktoken:f81de2ad-7f3d-a1b2-4f3c-
     00a0c91a9d76</D:href> 
              </D:locktoken> 
              <D:lockroot> 
                <D:href>http://www.example.com/container/</D:href> 
              </D:lockroot> 
              </D:activelock> 
            </D:lockdiscovery> 
          </D:prop> 
          <D:status>HTTP/1.1 200 OK</D:status> 
        </D:propstat> 
      </D:response> 
     </D:multistatus> 
      
   This resource has a single exclusive write lock on it, with an 
   infinite timeout. 
    
14.9    resourcetype Property 
    
   Name:    resourcetype 
   Namespace:   DAV: 
   Purpose: Specifies the nature of the resource. 
   COPY/MOVE behaviour: Generally a COPY/MOVE of a resource results in 
            the same type of resource at the destination. In a remote 
            COPY, the source server SHOULD NOT attempt to set this 
            property. 
   Description:         The resourcetype property MUST be defined on 
            all DAV compliant resources.  The default value is empty. 
            This property is live and protected. 
     
                           Expires Oct 2003                         77 

                         WebDAV (RFC2518) bis                June 2003 
    
    
   <!ELEMENT resourcetype ANY > 
    
   Example: (fictional example to show extensibility) 
            <x:resourcetype xmlns:x="DAV:"><x:collection/> 
                <f:search-results xmlns:f="http://www.example.com/ns"/> 
            </x:resourcetype> 
    
14.10   supportedlock Property 
    
   Name:    supportedlock 
   Namespace:   DAV: 
   Purpose: To provide a listing of the lock capabilities supported by 
            the resource. 
   COPY/MOVE behaviour: This property value is dependent on the kind of 
            locks supported at the destination, not on the value of the 
            property at the source resource. It should not be attempted 
            to be set on a remote COPY. 
   Description:         The supportedlock property of a resource 
            returns a listing of the combinations of scope and access 
            types which may be specified in a lock request on the 
            resource.  Note that the actual contents are themselves 
            controlled by access controls so a server is not required 
            to provide information the client is not authorized to see. 
            This property is live and protected. 
    
   <!ELEMENT supportedlock ANY > 
    
14.10.1 Example - Retrieving the supportedlock Property 
    
   >>Request 
    
     PROPFIND  /container/ HTTP/1.1 
     Host: www.example.com 
     Content-Length: xxxx 
     Content-Type: text/xml; charset="utf-8" 
      
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:propfind xmlns:D="DAV:"> 
      <D:prop><D:supportedlock/></D:prop> 
     </D:propfind> 
    
   >>Response 
    
     HTTP/1.1 207 Multi-Status 
     Content-Type: text/xml; charset="utf-8" 
     
                           Expires Oct 2003                         78 

                         WebDAV (RFC2518) bis                June 2003 
    
     Content-Length: xxxx 
      
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:multistatus xmlns:D="DAV:"> 
      <D:response> 
        <D:href>http://www.example.com/container/</D:href> 
        <D:propstat> 
          <D:prop> 
            <D:supportedlock> 
              <D:lockentry> 
                <D:lockscope><D:exclusive/></D:lockscope> 
                <D:locktype><D:write/></D:locktype> 
              </D:lockentry> 
              <D:lockentry> 
                <D:lockscope><D:shared/></D:lockscope> 
                <D:locktype><D:write/></D:locktype> 
              </D:lockentry> 
            </D:supportedlock> 
          </D:prop> 
          <D:status>HTTP/1.1 200 OK</D:status> 
        </D:propstat> 
      </D:response> 
     </D:multistatus> 
      
      
15 Instructions for Processing XML in DAV  
    
   All DAV compliant resources MUST ignore any unknown XML element and 
   all its children encountered while processing a DAV method that uses 
   XML as its command language. 
    
   This restriction also applies to the processing, by clients, of DAV 
   property values where unknown XML elements SHOULD be ignored unless 
   the property's schema declares otherwise. 
    
   This restriction does not apply to setting dead DAV properties on 
   the server where the server MUST record unknown XML elements. 
    
   Additionally, this restriction does not apply to the use of XML 
   where XML happens to be the content type of the entity body, for 
   example, when used as the body of a PUT. 
     
   Since XML can be transported as text/xml or application/xml, a DAV 
   server MUST accept DAV method requests with XML parameters 
   transported as either text/xml or application/xml, and DAV client 
   MUST accept XML responses using either text/xml or application/xml. 
    
     
                           Expires Oct 2003                         79 

                         WebDAV (RFC2518) bis                June 2003 
    
    
16 DAV Compliance Classes 
    
   A DAV compliant resource can advertise several classes of 
   compliance.  A client can discover the compliance classes of a 
   resource by executing OPTIONS on the resource, and examining the 
   "DAV" header which is returned.  Note particularly that resources 
   are spoken of as being compliant, rather than servers. That is 
   because theoretically some resources on a server could support 
   different feature sets.  E.g. a server could have a sub-repository 
   where an advanced feature like server was supported, even if that 
   feature was not supported on all servers. 
    
   Since this document describes extensions to the HTTP/1.1 protocol, 
   minimally all DAV compliant resources, clients, and proxies MUST be 
   compliant with [RFC2616]. 
    
   A resource that is class 2 compliant must also be class 1 compliant, 
   and a resource that is compliant with "bis" must also be class 1 
   compliant.   
    
16.1    Class 1 
    
   A class 1 compliant resource MUST meet all "MUST" requirements in 
   all sections of this document. 
    
   Class 1 compliant resources MUST return, at minimum, the value "1" 
   in the DAV header on all responses to the OPTIONS method. 
    
16.2    Class 2 
    
   A class 2 compliant resource MUST meet all class 1 requirements and 
   support the LOCK method, the supportedlock property, the 
   lockdiscovery property, the Time-Out response header and the Lock-
   Token request header.  A class "2" compliant resource SHOULD also 
   support the Time-Out request header and the owner XML element. 
    
   Class 2 compliant resources MUST return, at minimum, the values "1" 
   and "2" in the DAV header on all responses to the OPTIONS method. 
    
16.3    Class "bis" 
    
   A resource can explicitly advertise its support for the revisions to 
   RFC2518 made in this document. In particular, this allows clients to 
   use the Force-Authentication header on requests.  Class 1 must be 
   supported as well. Class 2 MAY be supported.   
    
   A resource that supports bis MUST support: 
    - the Force-Authentication header.  
    - Any behavior that it supports, in the manner specified in this 
   document, rather than in the manner specified in RFC2518, for all 
     
                           Expires Oct 2003                         80 

                         WebDAV (RFC2518) bis                June 2003 
    
   client requests.  A server MAY use an older behavior for specific 
   clients that are discovered to have interoperability problems with 
   the requirements of this specification, but MUST NOT use an older 
   behavior indiscriminately. 
    
   Example: 
    
        DAV: 1, bis 
    
    
17 Internationalization Considerations 
    
   In the realm of internationalization, this specification complies 
   with the IETF Character Set Policy [RFC2277]. In this specification, 
   human-readable fields can be found either in the value of a 
   property, or in an error message returned in a response entity body.  
   In both cases, the human-readable content is encoded using XML, 
   which has explicit provisions for character set tagging and 
   encoding, and requires that XML processors read XML elements 
   encoded, at minimum, using the UTF-8 [UTF-8] and UTF-16 encodings of 
   the ISO 10646 multilingual plane.  XML examples in this 
   specification demonstrate use of the charset parameter of the 
   Content-Type header, as defined in [RFC2376], as well as the XML 
   declarations which provide charset identification information for 
   MIME and XML processors. 
    
   XML also provides a language tagging capability for specifying the 
   language of the contents of a particular XML element.  The 
   "xml:lang" attribute appears on an XML element to identify the 
   language of its content and attributes. See [REC-XML] for 
   definitions of values and scoping. 
    
   WebDAV applications MUST support the character set tagging, 
   character set encoding, and the language tagging functionality of 
   the XML specification.  Implementors of WebDAV applications are 
   strongly encouraged to read "XML Media Types" [RFC2376] for 
   instruction on which MIME media type to use for XML transport, and 
   on use of the charset parameter of the Content-Type header. 
    
   Names used within this specification fall into three categories: 
   names of protocol elements such as methods and headers, names of XML 
   elements, names of properties, and names of conditions.  Naming of 
   protocol elements follows the precedent of HTTP, using English names 
   encoded in USASCII for methods and headers.  Since these protocol 
   elements are not visible to users, and are simply long token 
   identifiers, they do not need to support multiple languages.  
   Similarly, the names of XML elements used in this specification are 
   not visible to the user and hence do not need to support multiple 
   languages. 

     
                           Expires Oct 2003                         81 

                         WebDAV (RFC2518) bis                June 2003 
    
   WebDAV property names are qualified XML names (pairs of XML 
   namespace name and local name).  Although some applications (e.g., a 
   generic property viewer) will display property names directly to 
   their users, it is expected that the typical application will use a 
   fixed set of properties, and will provide a mapping from the 
   property name URI to a human-readable field when displaying the 
   property name to a user.  It is only in the case where the set of 
   properties is not known ahead of time that an application need 
   display a property name URI to a user. We recommend that 
   applications provide human-readable property names wherever 
   feasible. 
    
   For error reporting, we follow the convention of HTTP/1.1 status 
   codes, including with each status code a short, English description 
   of the code (e.g., 423 (Locked)).  While the possibility exists that 
   a poorly crafted user agent would display this message to a user, 
   internationalized applications will ignore this message, and display 
   an appropriate message in the user's language and character set. 
    
   Since interoperation of clients and servers does not require locale 
   information, this specification does not specify any mechanism for 
   transmission of this information. 
    
    
18 Security Considerations 
    
   This section is provided to detail issues concerning security 
   implications of which WebDAV applications need to be aware. 
    
   All of the security considerations of HTTP/1.1 (discussed in 
   [RFC2616]) and XML (discussed in [RFC2376]) also apply to WebDAV. In 
   addition, the security risks inherent in remote authoring require 
   stronger authentication technology, introduce several new privacy 
   concerns, and may increase the hazards from poor server design. 
   These issues are detailed below. 
    
    
18.1    Authentication of Clients 
    
   Due to their emphasis on authoring, WebDAV servers need to use 
   authentication technology to protect not just access to a network 
   resource, but the integrity of the resource as well.  Furthermore, 
   the introduction of locking functionality requires support for 
   authentication. 
    
   A password sent in the clear over an insecure channel is an 
   inadequate means for protecting the accessibility and integrity of a 
   resource as the password may be intercepted.  Since Basic 
   authentication for HTTP/1.1 performs essentially clear text 
   transmission of a password, Basic authentication MUST NOT be used to 
   authenticate a WebDAV client to a server unless the connection is 
     
                           Expires Oct 2003                         82 

                         WebDAV (RFC2518) bis                June 2003 
    
   secure. Furthermore, a WebDAV server MUST NOT send Basic 
   authentication credentials in a WWW-Authenticate header unless the 
   connection is secure.  Examples of secure connections include a 
   Transport Layer Security (TLS) connection employing a strong cipher 
   suite with mutual authentication of client and server, or a 
   connection over a network which is physically secure, for example, 
   an isolated network in a building with restricted access. 
    
   WebDAV applications MUST support the Digest authentication scheme 
   [RFC2069]. Since Digest authentication verifies that both parties to 
   a communication know a shared secret, a password, without having to 
   send that secret in the clear, Digest authentication avoids the 
   security problems inherent in Basic authentication while providing a 
   level of authentication which is useful in a wide range of 
   scenarios. 
    
18.2    Denial of Service 
    
   Denial of service attacks are of special concern to WebDAV servers.  
   WebDAV plus HTTP enables denial of service attacks on every part of 
   a system's resources. 
    
   The underlying storage can be attacked by PUTting extremely large 
   files. 
    
   Asking for recursive operations on large collections can attack 
   processing time. 
    
   Making multiple pipelined requests on multiple connections can 
   attack network connections. 
    
   WebDAV servers need to be aware of the possibility of a denial of 
   service attack at all levels. 
    
18.3    Security through Obscurity 
    
   WebDAV provides, through the PROPFIND method, a mechanism for 
   listing the member resources of a collection.  This greatly 
   diminishes the effectiveness of security or privacy techniques that 
   rely only on the difficulty of discovering the names of network 
   resources.  Users of WebDAV servers are encouraged to use access 
   control techniques to prevent unwanted access to resources, rather 
   than depending on the relative obscurity of their resource names. 
    
18.4    Privacy Issues Connected to Locks 
    
   When submitting a lock request a user agent may also submit an owner 
   XML field giving contact information for the person taking out the 
   lock (for those cases where a person, rather than a robot, is taking 
   out the lock). This contact information is stored in a lockdiscovery 
   property on the resource, and can be used by other collaborators to 
     
                           Expires Oct 2003                         83 

                         WebDAV (RFC2518) bis                June 2003 
    
   begin negotiation over access to the resource.  However, in many 
   cases this contact information can be very private, and should not 
   be widely disseminated.  Servers SHOULD limit read access to the 
   lockdiscovery property as appropriate.  Furthermore, user agents 
   SHOULD provide control over whether contact information is sent at 
   all, and if contact information is sent, control over exactly what 
   information is sent. 
    
18.5    Privacy Issues Connected to Properties 
    
   Since property values are typically used to hold information such as 
   the author of a document, there is the possibility that privacy 
   concerns could arise stemming from widespread access to a resource's 
   property data.  To reduce the risk of inadvertent release of private 
   information via properties, servers are encouraged to develop access 
   control mechanisms that separate read access to the resource body 
   and read access to the resource's properties.  This allows a user to 
   control the dissemination of their property data without overly 
   restricting access to the resource's contents. 
    
    
18.6    Implications of XML External Entities  
    
   XML supports a facility known as "external entities", defined in 
   section 4.2.2 of [REC-XML], which instruct an XML processor to 
   retrieve and include additional XML. An external XML entity can be 
   used to append or modify the document type declaration (DTD) 
   associated with an XML document.  An external XML entity can also be 
   used to include XML within the content of an XML document.  For non-
   validating XML, such as the XML used in this specification, 
   including an external XML entity is not required by [REC-XML]. 
   However, [REC-XML] does state that an XML processor may, at its 
   discretion, include the external XML entity. 
    
   External XML entities have no inherent trustworthiness and are 
   subject to all the attacks that are endemic to any HTTP GET request.  
   Furthermore, it is possible for an external XML entity to modify the 
   DTD, and hence affect the final form of an XML document, in the 
   worst case significantly modifying its semantics, or exposing the 
   XML processor to the security risks discussed in [RFC2376]. 
   Therefore, implementers must be aware that external XML entities 
   should be treated as untrustworthy.  If a server implementor chooses 
   not to handle external XML entities, it SHOULD respond to requests 
   containing external entities with an error (403 Forbidden, with the 
   'forbid-external-entities' element in the error body). 
    
   There is also the scalability risk that would accompany a widely 
   deployed application which made use of external XML entities.  In 
   this situation, it is possible that there would be significant 
   numbers of requests for one external XML entity, potentially 

     
                           Expires Oct 2003                         84 

                         WebDAV (RFC2518) bis                June 2003 
    
   overloading any server which fields requests for the resource 
   containing the external XML entity. 
    
18.7    Risks Connected with Lock Tokens 
    
   This specification, in section 6.4, requires the use of Universal 
   Unique Identifiers (UUIDs) for lock tokens, in order to guarantee 
   their uniqueness across space and time.  UUIDs, as defined in [ISO-
   11578], contain a "node" field which "consists of the IEEE address, 
   usually the host address.  For systems with multiple IEEE 802 nodes, 
   any available node address can be used."  Since a WebDAV server will 
   issue many locks over its lifetime, the implication is that it will 
   also be publicly exposing its IEEE 802 address. 
    
   There are several risks associated with exposure of IEEE 802 
   addresses.  Using the IEEE 802 address: 
    
   * It is possible to track the movement of hardware from subnet to 
   subnet. 
    
   * It may be possible to identify the manufacturer of the hardware 
   running a WebDAV server. 
    
   * It may be possible to determine the number of each type of 
   computer running WebDAV. 
   Section 24.3 of this specification details an alternate mechanism 
   for generating the "node" field of a UUID without using an IEEE 802 
   address, which alleviates the risks associated with exposure of IEEE 
   802 addresses by using an alternate source of uniqueness. 
    
    
19 IANA Considerations 
    
   This document defines two namespaces, the namespace of property 
   names, and the namespace of WebDAV-specific XML elements used within 
   property values.   
    
   The use of XML namespaces means that unique WebDAV property names 
   and XML elements can be quickly defined by any WebDAV user or 
   application, without requiring IANA action.   
    
   This specification defines a distinguished set of property names and 
   XML elements that are understood by all WebDAV applications.  The 
   property names and XML elements in this specification are all in the 
   "DAV:" namespace. In natural language, a property like the 
   "creationdate" property in the "DAV:" namespace is sometimes 
   referred to as "DAV:creationdate" for brevity. 
    
   This specification also defines a URI scheme for the encoding of 
   lock tokens, the opaquelocktoken URI scheme described in section 
   6.4. 
     
                           Expires Oct 2003                         85 

                         WebDAV (RFC2518) bis                June 2003 
    
    
   To ensure correct interoperation based on this specification, IANA 
   must reserve the URI namespaces starting with "DAV:" and with 
   "opaquelocktoken:" for use by this specification, its revisions, and 
   related WebDAV specifications. 
    
    
20 Intellectual Property 
    
   The following notice is copied from RFC 2026 [RFC2026], section 
   10.4, and describes the position of the IETF concerning intellectual 
   property claims made against this document. 
    
   The IETF takes no position regarding the validity or scope of any 
   intellectual property or other rights that might be claimed to 
   pertain to the implementation or use other technology described in 
   this document or the extent to which any license under such rights 
   might or might not be available; neither does it represent that it 
   has made any effort to identify any such rights.  Information on the 
   IETF's procedures with respect to rights in standards-track and 
   standards-related documentation can be found in BCP-11.  Copies of 
   claims of rights made available for publication and any assurances 
   of licenses to be made available, or the result of an attempt made 
   to obtain a general license or permission for the use of such 
   proprietary rights by implementors or users of this specification 
   can be obtained from the IETF Secretariat. 
    
   The IETF invites any interested party to bring to its attention any 
   copyrights, patents or patent applications, or other proprietary 
   rights which may cover technology that may be required to practice 
   this standard.  Please address the information to the IETF Executive 
   Director. 
    
    
21 Acknowledgements 
    
   A specification such as this thrives on piercing critical review and 
   withers from apathetic neglect.  The authors gratefully acknowledge 
   the contributions of the following people, whose insights were so 
   valuable at every stage of our work. 
    
   Contributors to RFC2518 
    
   Terry Allen, Harald Alvestrand, Jim Amsden, Becky Anderson, Alan 
   Babich, Sanford Barr, Dylan Barrell, Bernard Chester, Tim Berners-
   Lee, Dan Connolly, Jim Cunningham, Ron Daniel, Jr., Jim Davis, Keith 
   Dawson, Mark Day, Brian Deen, Martin Duerst, David Durand, Lee 
   Farrell, Chuck Fay, Wesley Felter, Roy Fielding, Mark Fisher, Alan 
   Freier, George Florentine, Jim Gettys, Phill Hallam-Baker, Dennis 
   Hamilton, Steve Henning, Mead Himelstein, Alex Hopmann, Andre van 
   der Hoek, Ben Laurie, Paul Leach, Ora Lassila, Karen MacArthur, 
     
                           Expires Oct 2003                         86 

                         WebDAV (RFC2518) bis                June 2003 
    
   Steven Martin, Larry Masinter, Michael Mealling, Keith Moore, Thomas 
   Narten, Henrik Nielsen, Kenji Ota, Bob Parker, Glenn Peterson, Jon 
   Radoff, Saveen Reddy, Henry Sanders, Christopher Seiwald, Judith 
   Slein, Mike Spreitzer, Einar Stefferud, Greg Stein, Ralph Swick, 
   Kenji Takahashi, Richard N. Taylor, Robert Thau, John Turner, Sankar 
   Virdhagriswaran, Fabio Vitali, Gregory Woodhouse, and Lauren Wood. 
    
   Two from this list deserve special mention.  The contributions by 
   Larry Masinter have been invaluable, both in helping the formation 
   of the working group and in patiently coaching the authors along the 
   way.  In so many ways he has set high standards we have toiled to 
   meet. The contributions of Judith Slein in clarifying the 
   requirements, and in patiently reviewing draft after draft, both 
   improved this specification and expanded our minds on document 
   management. 
    
   We would also like to thank John Turner for developing the XML DTD. 
    
   The authors of RFC2518 were Yaron Goland, Jim Whitehead, A. Faizi, 
   Steve Carter and D. Jensen.  Although their names had to be removed 
   due to IETF author count restrictions they can take credit for the 
   majority of the design of WebDAV. 
    
   Additional Contributors to This Specification 
    
   Valuable contributions to RFC2518 bis came from some already named. 
   New contributors must also be gratefully acknowledged. Julian 
   Reschke, Geoff Clemm, Joel Soderberg, and Dan Brotsky hashed out 
   specific text on the list or in meetings. Ilya Kirnos supplied text 
   for Force-Authentication header. 
    


                           Expires Oct 2003                         87 

                         WebDAV (RFC2518) bis                June 2003 
    
22 References 
    
22.1    Normative References 
    
    
   [RFC2277] H. T. Alvestrand, "IETF Policy on Character Sets and 
          Languages." RFC 2277, BCP 18, January 1998. 
    
   [RFC2119] S. Bradner, "Key words for use in RFCs to Indicate 
          Requirement Levels."  RFC 2119, BCP 14, March 1997. 
    
   [RFC2396] T. Berners-Lee, R. Fielding, L. Masinter, "Uniform 
          Resource Identifiers (URI): Generic Syntax." RFC 2396, August 
          1998. 
    
   [REC-XML] T. Bray, J. Paoli, C. M. Sperberg-McQueen, "Extensible 
          Markup Language (XML)." World Wide Web Consortium 
          Recommendation REC-xml-20001006. 
          http://www.w3.org/TR/2000/REC-xml-20001006, February 1998. 
    
   [REC-XML-NAMES] T. Bray, D. Hollander, A. Layman, "Name Spaces in 
          XML" World Wide Web Consortium Recommendation REC-xml-names. 
          http://www.w3.org/TR/REC-xml-names-19990114, January 1999. 
    
   [RFC2069] J. Franks, P. Hallam-Baker, J. Hostetler, P. Leach, A. 
          Luotonen, E. Sink, and L. Stewart. "An Extension to HTTP : 
          Digest Access Authentication" RFC 2069, January 1997. 
    
   [RFC2616] R. Fielding, J. Gettys, J. Mogul, H. Frystyk, L. Masinter, 
          P. Leach, T. Berners-Lee, "Hypertext Transfer Protocol -- 
          HTTP/1.1." RFC 2616, June 1999.  
    
    
   [ISO-11578] ISO (International Organization for Standardization). 
          ISO/IEC 11578:1996. "Information technology - Open Systems 
          Interconnection - Remote Procedure Call (RPC)" 
    
   [RFC2141] R. Moats, "URN Syntax." RFC 2141, May 1997. 
    
   [RFC3339] G. Klyne, C. Newman, ôDate and Time on the Internet: 
          Timestamps.ö RFC3339, July 2002. 
    
   [UTF-8] F. Yergeau, "UTF-8, a transformation format of Unicode and 
          ISO 10646." RFC 2279, January 1998. 

     
                           Expires Oct 2003                         88 

                         WebDAV (RFC2518) bis                June 2003 
    
22.2    Informational References 
    
   [RFC2026] S. Bradner, "The Internet Standards Process - Revision 3."  
          RFC 2026, BCP 9, October 1996. 
    
   [RFC1807] R. Lasher, D. Cohen, "A Format for Bibliographic Records," 
          RFC 1807, June 1995. 
    
   [WF]   C. Lagoze, "The Warwick Framework: A Container Architecture 
          for Diverse Sets of Metadata", D-Lib Magazine, July/August 
          1996. http://www.dlib.org/dlib/july96/lagoze/07lagoze.html. 
    
   [USMARC] Network Development and MARC Standards, Office, ed. 1994. 
          "USMARC Format for Bibliographic Data", 1994. Washington, DC: 
          Cataloging Distribution Service, Library of Congress. 
    
   [REC-PICS] J. Miller, T. Krauskopf, P. Resnick, W. Treese, "PICS 
          Label Distribution Label Syntax and Communication Protocols" 
          Version 1.1, World Wide Web Consortium Recommendation REC-
          PICS-labels-961031. http://www.w3.org/pub/WWW/TR/REC-PICS-
          labels-961031.html. 
    
   [RFC2291] J. A. Slein, F. Vitali, E. J. Whitehead, Jr., D. Durand, 
          "Requirements for Distributed Authoring and Versioning 
          Protocol for the World Wide Web." RFC 2291, February 1998. 
    
   [RFC2413] S. Weibel, J. Kunze, C. Lagoze, M. Wolf, "Dublin Core 
          Metadata for Resource Discovery." RFC 2413, September 1998. 
    
   [RFC2376] E. Whitehead, M. Murata, "XML Media Types." RFC 2376, July 
          1998. 
    
   [RFC3253]  G. Clemm, J. Amsden, T. Ellison, C. Kaler, J. Whitehead, 
          "Versioning Extensions to WebDAV (Web Distributed Authoring 
          and Versioning)", RFC 3253, March 2002. 
    


                           Expires Oct 2003                         89 

                         WebDAV (RFC2518) bis                June 2003 
    
23 Authors' Addresses 
    
   Editors of RFC2518 
    
   Y. Y. Goland 
   Microsoft Corporation 
   One Microsoft Way 
   Redmond, WA 98052-6399 
   Email: yarong@microsoft.com 
    
   E. J. Whitehead, Jr. 
   Dept. Of Information and Computer Science 
   University of California, Irvine 
   Irvine, CA 92697-3425 
   Email: ejw@ics.uci.edu 
    
   A. Faizi 
   Netscape 
   685 East Middlefield Road 
   Mountain View, CA 94043 
   Email: asad@netscape.com 
    
   S. R. Carter 
   Novell 
   1555 N. Technology Way 
   M/S ORM F111 
   Orem, UT 84097-2399 
   Email: srcarter@novell.com 
    
   D. Jensen 
   Novell 
   1555 N. Technology Way 
   M/S ORM F111 
   Orem, UT 84097-2399 
   Email: dcjensen@novell.com 
    
   Current Editors 
    
   L. Dusseault 
   Xythos Software, Inc. 
   25 Maiden Lane, 6th floor 
   San Francisco 
   Email: lisa@xythos.com 
    
   Jason L Crawford 
   P.O.Box 704 
   Yorktown Heights, NY 10598 
   Phone: 914-784-7569 
   Email: nnjason8451@smallcue.com 


     
                           Expires Oct 2003                         90 

                         WebDAV (RFC2518) bis                June 2003 
    
24 Appendices 
    
24.1    Appendix 1 - WebDAV Document Type Definition 
    
   This section provides a document type definition, following the 
   rules in [REC-XML], for the XML elements used in the protocol stream 
   and in the values of properties. It collects the element definitions 
   given in sections 13 and 13.28. 
    
   The DTD is informational only, because legal XML in WebDAV bodies 
   can not be validated according to this DTD. There are two reasons 
   for this:  
    - the DTD syntax does not specify namespace usage 
    - additional elements may appear according to the XML extensibility 
   rules outlined in section 15. 
    
   <!DOCTYPE webdav-1.0 [ 
    
   <!--============ XML Elements from Section 13 ==================--> 
    
   <!-- General-use Elements --> 
   <!ELEMENT href (#PCDATA) > 
   <!ELEMENT prop ANY > 
    
   <!-- Property Elements for 'lockdiscovery' and 'supportedlock' --> 
   <!ELEMENT activelock ANY> 
    
   <!ELEMENT lockentry ANY > 
   <!ELEMENT lockinfo ANY > 
   <!ELEMENT locktype ANY > 
   <!ELEMENT write EMPTY > 
    
   <!ELEMENT lockscope (exclusive | shared) > 
   <!ELEMENT exclusive EMPTY > 
   <!ELEMENT shared EMPTY > 
    
   <!ELEMENT depth (#PCDATA) > 
   <!ELEMENT owner ANY > 
   <!ELEMENT timeout (#PCDATA) > 
   <!ELEMENT locktoken (href) > 
   <!ELEMENT lockroot (href) > 
    
    
   <!-- Multi-Status Response Body Elements --> 
   <!ELEMENT multistatus ANY > 
   <!ELEMENT response ANY > 

     
                           Expires Oct 2003                         91 

                         WebDAV (RFC2518) bis                June 2003 
    
   <!ELEMENT status (#PCDATA) > 
   <!ELEMENT propstat ANY > 
   <!ELEMENT responsedescription (#PCDATA) > 
    
   <!-- PROPPATCH Request Body Elements --> 
   <!ELEMENT propertyupdate ANY > 
   <!ELEMENT remove (prop) > 
   <!ELEMENT set (prop) > 
    
   <!-- PROPFIND Request Body Elements --> 
   <!ELEMENT propfind ANY > 
   <!ELEMENT allprop EMPTY > 
   <!ELEMENT propname EMPTY > 
    
   <!-- Property Elements for 'resourcetype' --> 
   <!ELEMENT collection EMPTY > 
    
   <!--========= Property Name Elements from Section 13.28 
   ============--> 
   <!ELEMENT creationdate (#PCDATA) > 
   <!ELEMENT displayname (#PCDATA) > 
   <!ELEMENT getcontentlanguage (#PCDATA) > 
   <!ELEMENT getcontentlength (#PCDATA) > 
   <!ELEMENT getcontenttype (#PCDATA) > 
   <!ELEMENT getetag (#PCDATA) > 
   <!ELEMENT getlastmodified (#PCDATA) > 
   <!ELEMENT lockdiscovery ANY > 
   <!ELEMENT resourcetype ANY > 
   <!ELEMENT supportedlock ANY > 
   ]> 
    
24.2    Appendix 3 - Notes on Processing XML Elements 
    
24.2.1   Notes on Empty XML Elements 
    
   XML supports two mechanisms for indicating that an XML element does 
   not have any content.  The first is to declare an XML element of the 
   form <A></A>.  The second is to declare an XML element of the form 
   <A/>.  The two XML elements are semantically identical. 
    
 
24.2.2   Notes on Illegal XML Processing 
    
   XML is a flexible data format that makes it easy to submit data that 
   appears legal but in fact is not.  The philosophy of "Be flexible in 
   what you accept and strict in what you send" still applies, but it 
   must not be applied inappropriately.  XML is extremely flexible in 
     
                           Expires Oct 2003                         92 

                         WebDAV (RFC2518) bis                June 2003 
    
   dealing with issues of white space, element ordering, inserting new 
   elements, etc.  This flexibility does not require extension, 
   especially not in the area of the meaning of elements. 
    
   There is no kindness in accepting illegal combinations of XML 
   elements.  At best it will cause an unwanted result and at worst it 
   can cause real damage. 
    
24.2.3  Example - XML Syntax Error 
    
   The following request body for a PROPFIND method is illegal. 
    
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:propfind xmlns:D="DAV:"> 
      <D:allprop/> 
      <D:propname/> 
     </D:propfind> 
    
   The definition of the propfind element only allows for the allprop 
   or the propname element, not both.  Thus the above is an error and 
   must be responded to with a 400 (Bad Request). 
    
   Imagine, however, that a server wanted to be "kind" and decided to 
   pick the allprop element as the true element and respond to it.  A 
   client running over a bandwidth limited line who intended to execute 
   a propname would be in for a big surprise if the server treated the 
   command as an allprop. 
    
   Additionally, if a server were lenient and decided to reply to this  
   request, the results would vary randomly from server to server, with 
   some servers executing the allprop directive, and others executing 
   the propname directive. This reduces interoperability rather than 
   increasing it. 
    
24.2.4  Example - Unknown XML Element 
    
   The previous example was illegal because it contained two elements 
   that were explicitly banned from appearing together in the propfind 
   element.  However, XML is an extensible language, so one can imagine 
   new elements being defined for use with propfind.  Below is the 
   request body of a PROPFIND and, like the previous example, must be 
   rejected with a 400 (Bad Request) by a server that does not 
   understand the expired-props element. 


                           Expires Oct 2003                         93 

                         WebDAV (RFC2518) bis                June 2003 
    
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:propfind xmlns:D="DAV:" 
     xmlns:E="http://www.example.com/standards/props/"> 
      <E:expired-props/> 
     </D:propfind> 
    
   To understand why a 400 (Bad Request) is returned let us look at the 
   request body as the server unfamiliar with expired-props sees it. 
    
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:propfind xmlns:D="DAV:"   
                 xmlns:E="http://www.example.com/standards/props/"> 
     </D:propfind> 
    
   As the server does not understand the expired-props element, 
   according to the WebDAV-specific XML processing rules specified in 
   section 15, it must ignore it.  Thus the server sees an empty 
   propfind, which by the definition of the propfind element is 
   illegal. 
    
   Please note that had the extension been additive it would not 
   necessarily have resulted in a 400 (Bad Request).  For example, 
   imagine the following request body for a PROPFIND: 
    
     <?xml version="1.0" encoding="utf-8" ?> 
     <D:propfind xmlns:D="DAV:"  
                 xmlns:E="http://www.example.com/standards/props/"> 
      <D:propname/> 
      <E:leave-out>*boss*</E:leave-out> 
     </D:propfind> 
    
   The previous example contains the fictitious element leave-out. Its 
   purpose is to prevent the return of any property whose name matches 
   the submitted pattern.  If the previous example were submitted to a 
   server unfamiliar with leave-out, the only result would be that the 
   leave-out element would be ignored and a propname would be executed. 
    
24.3    Appendix 4: UUID Node Generation 
    
   UUIDs, as defined in [ISO-11578], contain a "node" field that 
   contains one of the IEEE 802 addresses for the server machine.  As 
   noted in section 18, there are several security risks associated 
   with exposing a machine's IEEE 802 address. This section provides an 
   alternate mechanism for generating the "node" field of a UUID which 
   does not employ an IEEE 802 address.  WebDAV servers MAY use this 
   algorithm for creating the node field when generating UUIDs.  The 
   text in this section is originally from an Internet-Draft by Paul 
   Leach and Rich Salz, who are noted here to properly attribute their 
   work. 
     
                           Expires Oct 2003                         94 

                         WebDAV (RFC2518) bis                June 2003 
    
    
   The ideal solution is to obtain a 47 bit cryptographic quality 
   random number, and use it as the low 47 bits of the node ID, with 
   the most significant bit of the first octet of the node ID set to 1. 
   This bit is the unicast/multicast bit, which will never be set in 
   IEEE 802 addresses obtained from network cards; hence, there can 
   never be a conflict between UUIDs generated by machines with and 
   without network cards. 
    
   If a system does not have a primitive to generate cryptographic 
   quality random numbers, then in most systems there are usually a 
   fairly large number of sources of randomness available from which 
   one can be generated. Such sources are system specific, but often 
   include: 
    
     - the percent of memory in use 
     - the size of main memory in bytes 
     - the amount of free main memory in bytes 
     - the size of the paging or swap file in bytes 
     - free bytes of paging or swap file 
     - the total size of user virtual address space in bytes 
     - the total available user address space bytes 
     - the size of boot disk drive in bytes 
     - the free disk space on boot drive in bytes 
     - the current time 
     - the amount of time since the system booted 
     - the individual sizes of files in various system directories 
     - the creation, last read, and modification times of files in    
       various system directories 
     - the utilization factors of various system resources (heap, etc.) 
     - current mouse cursor position 
     - current caret position 
     - current number of running processes, threads 
     - handles or IDs of the desktop window and the active window 
     - the value of stack pointer of the caller 
     - the process and thread ID of caller 
     - various processor architecture specific performance counters 
       (instructions executed, cache misses, TLB misses) 
    
   (Note that it is precisely the above kinds of sources of randomness 
   that are used to seed cryptographic quality random number generators 
   on systems without special hardware for their construction.) 
    
   In addition, items such as the computer's name and the name of the 
   operating system, while not strictly speaking random, will help 
   differentiate the results from those obtained by other systems. 
     
   The exact algorithm to generate a node ID using these data is system 
   specific, because both the data available and the functions to 
   obtain them are often very system specific. However, assuming that 
   one can concatenate all the values from the randomness sources into 
     
                           Expires Oct 2003                         95 

                         WebDAV (RFC2518) bis                June 2003 
    
   a buffer, and that a cryptographic hash function such as MD5 is 
   available, then any 6 bytes of the MD5 hash of the buffer, with the 
   multicast bit (the high bit of the first byte) set will be an 
   appropriately random node ID. 
    
   Other hash functions, such as SHA-1, can also be used. The only 
   requirement is that the result be suitably random _ in the sense 
   that the outputs from a set uniformly distributed inputs are 
   themselves uniformly distributed, and that a single bit change in 
   the input can be expected to cause half of the output bits to 
   change. 
    
    
25 Full Copyright Statement 
    
   Copyright (C) The Internet Society (1999).  All Rights Reserved. 
    
   This document and translations of it may be copied and furnished to 
   others, and derivative works that comment on or otherwise explain it 
   or assist in its implementation may be prepared, copied, published 
   and distributed, in whole or in part, without restriction of any 
   kind, provided that the above copyright notice and this paragraph 
   are included on all such copies and derivative works.  However, this 
   document itself may not be modified in any way, such as by removing 
   the copyright notice or references to the Internet Society or other 
   Internet organizations, except as needed for the purpose of 
   developing Internet standards in which case the procedures for 
   copyrights defined in the Internet Standards process must be 
   followed, or as required to translate it into languages other than 
   English. 
    
   The limited permissions granted above are perpetual and will not be 
   revoked by the Internet Society or its successors or assigns. 
    
   This document and the information contained herein is provided on an 
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING 
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING 
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION 
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF 
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. 
    
    




                           Expires Oct 2003                         96 
