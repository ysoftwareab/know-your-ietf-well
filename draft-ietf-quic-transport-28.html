<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>QUIC: A UDP-Based Multiplexed and Secure Transport</title>
<meta content="Jana Iyengar" name="author">
<meta content="Martin Thomson" name="author">
<meta content="
       This document defines the core of the QUIC transport protocol.  Accompanying
documents describe QUIC's loss detection and congestion control and the use of
TLS for key negotiation. 
    " name="description">
<meta content="xml2rfc 2.44.0" name="generator">
<meta content="draft-ietf-quic-transport-28" name="ietf.draft">
<link href="/tmp/draft-ietf-quic-transport-28-tvsewitg.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">/*

  NOTE: Changes at the bottom of this file overrides some earlier settings.

  Once the style has stabilized and has been adopted as an official RFC style,
  this can be consolidated so that style settings occur only in one place, but
  for now the contents of this file consists first of the initial CSS work as
  provided to the RFC Formatter (xml2rfc) work, followed by itemized and
  commented changes found necssary during the development of the v3
  formatters.

*/

/* fonts */
@import url('https://fonts.googleapis.com/css?family=Noto+Sans'); /* Sans-serif */
@import url('https://fonts.googleapis.com/css?family=Noto+Serif'); /* Serif (print) */
@import url('https://fonts.googleapis.com/css?family=Roboto+Mono'); /* Monospace */

@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}
/* general and mobile first */
html {
}
body {
  max-width: 90%;
  margin: 1.5em auto;
  color: #222;
  background-color: #fff;
  font-size: 14px;
  font-family: 'Noto Sans', Arial, Helvetica, sans-serif;
  line-height: 1.6;
  scroll-behavior: smooth;
}
.ears {
  display: none;
}

/* headings */
#title, h1, h2, h3, h4, h5, h6 {
  margin: 1em 0 0.5em;
  font-weight: bold;
  line-height: 1.3;
}
#title {
  clear: both;
  border-bottom: 1px solid #ddd;
  margin: 0 0 0.5em 0;
  padding: 1em 0 0.5em;
}
.author {
  padding-bottom: 4px;
}
h1 {
  font-size: 26px;
  margin: 1em 0;
}
h2 {
  font-size: 22px;
  margin-top: -20px;  /* provide offset for in-page anchors */
  padding-top: 33px;
}
h3 {
  font-size: 18px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h4 {
  font-size: 16px;
  margin-top: -36px;  /* provide offset for in-page anchors */
  padding-top: 42px;
}
h5, h6 {
  font-size: 14px;
}
#n-copyright-notice {
  border-bottom: 1px solid #ddd;
  padding-bottom: 1em;
  margin-bottom: 1em;
}
/* general structure */
p {
  padding: 0;
  margin: 0 0 1em 0;
  text-align: left;
}
div, span {
  position: relative;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignRight.art-text pre {
  padding: 0;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
.alignCenter.art-text {
  background-color: #f9f9f9;
  border: 1px solid #eee;
  border-radius: 3px;
  padding: 1em 1em 0;
  margin-bottom: 1.5em;
}
.alignCenter.art-text pre {
  padding: 0;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 1em 2em;
}
ol ol, ul ul, ol ul, ul ol {
  margin-left: 1em;
}
li {
  margin: 0 0 0.25em 0;
}
.ulCompact li {
  margin: 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
}
ul.empty li, .ulEmpty li {
  margin-top: 0.5em;
}
ul.compact, .ulCompact,
ol.compact, .olCompact {
  line-height: 100%;
  margin: 0 0 0 2em;
}

/* definition lists */
dl {
}
dl > dt {
  float: left;
  margin-right: 1em;
}
/* 
dl.nohang > dt {
  float: none;
}
*/
dl > dd {
  margin-bottom: .8em;
  min-height: 1.3em;
}
dl.compact > dd, .dlCompact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}

/* links */
a {
  text-decoration: none;
}
a[href] {
  color: #22e; /* Arlen: WCAG 2019 */
}
a[href]:hover {
  background-color: #f2f2f2;
}
figcaption a[href],
a[href].selfRef {
  color: #222;
}
/* XXX probably not this:
a.selfRef:hover {
  background-color: transparent;
  cursor: default;
} */

/* Figures */
tt, code, pre, code {
  background-color: #f9f9f9;
  font-family: 'Roboto Mono', monospace;
}
pre {
  border: 1px solid #eee;
  margin: 0;
  padding: 1em;
}
img {
  max-width: 100%;
}
figure {
  margin: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption {
  font-style: italic;
  margin: 0 0 1em 0;
}
@media screen {
  pre {
    overflow-x: auto;
    max-width: 100%;
    max-width: calc(100% - 22px);
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 1.2em 2em;
}
blockquote {
  background-color: #f9f9f9;
  color: #111; /* Arlen: WCAG 2019 */
  border: 1px solid #ddd;
  border-radius: 3px;
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
  border: 1px solid #eee;
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 0.5em 0.75em;
}
th {
  text-align: left;
  background-color: #e9e9e9;
}
tr:nth-child(2n+1) > td {
  background-color: #f5f5f5;
}
table caption {
  font-style: italic;
  margin: 0;
  padding: 0;
  text-align: left;
}
table p {
  /* XXX to avoid bottom margin on table row signifiers. If paragraphs should
     be allowed within tables more generally, it would be far better to select on a class. */
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  color: #666; /* Arlen: AHDJ 2019 */
  text-decoration: none;
  visibility: hidden;
  user-select: none;
  -ms-user-select: none;
  -o-user-select:none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}
@media screen {
  aside:hover > a.pilcrow,
  p:hover > a.pilcrow,
  blockquote:hover > a.pilcrow,
  div:hover > a.pilcrow,
  li:hover > a.pilcrow,
  pre:hover > a.pilcrow {
    visibility: visible;
  }
  a.pilcrow:hover {
    background-color: transparent;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid #eee;
}
.bcp14 {
  font-variant: small-caps;
}

.role {
  font-variant: all-small-caps;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: 0.9em;
}
#identifiers dt {
  width: 3em;
  clear: left;
}
#identifiers dd {
  float: left;
  margin-bottom: 0;
}
#identifiers .authors .author {
  display: inline-block;
  margin-right: 1.5em;
}
#identifiers .authors .org {
  font-style: italic;
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #666; /* Arlen: WCAG 2019 */
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: left;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc  {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;
}
nav.toc ul {
  margin: 0 0.5em 0 0;
  padding: 0;
  list-style: none;
}
nav.toc li {
  line-height: 1.3em;
  margin: 0.75em 0;
  padding-left: 1.2em;
  text-indent: -1.2em;
}
/* references */
.references dt {
  text-align: right;
  font-weight: bold;
  min-width: 7em;
}
.references dd {
  margin-left: 8em;
  overflow: auto;
}

.refInstance {
  margin-bottom: 1.25em;
}

.references .ascii {
  margin-bottom: 0.25em;
}

/* index */
.index ul {
  margin: 0 0 0 1em;
  padding: 0;
  list-style: none;
}
.index ul ul {
  margin: 0;
}
.index li {
  margin: 0;
  text-indent: -2em;
  padding-left: 2em;
  padding-bottom: 5px;
}
.indexIndex {
  margin: 0.5em 0 1em;
}
.index a {
  font-weight: 700;
}
/* make the index two-column on all but the smallest screens */
@media (min-width: 600px) {
  .index ul {
    -moz-column-count: 2;
    -moz-column-gap: 20px;
  }
  .index ul ul {
    -moz-column-count: 1;
    -moz-column-gap: 0;
  }
}

/* authors */
address.vcard {
  font-style: normal;
  margin: 1em 0;
}

address.vcard .nameRole {
  font-weight: 700;
  margin-left: 0;
}
address.vcard .label {
  font-family: "Noto Sans",Arial,Helvetica,sans-serif;
  margin: 0.5em 0;
}
address.vcard .type {
  display: none;
}
.alternative-contact {
  margin: 1.5em 0 1em;
}
hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}

/* temporary notes */
.rfcEditorRemove::before {
  position: absolute;
  top: 0.2em;
  right: 0.2em;
  padding: 0.2em;
  content: "The RFC Editor will remove this note";
  color: #9e2a00; /* Arlen: WCAG 2019 */
  background-color: #ffd; /* Arlen: WCAG 2019 */
}
.rfcEditorRemove {
  position: relative;
  padding-top: 1.8em;
  background-color: #ffd; /* Arlen: WCAG 2019 */
  border-radius: 3px;
}
.cref {
  background-color: #ffd; /* Arlen: WCAG 2019 */
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}
/* alternative layout for smaller screens */
@media screen and (max-width: 1023px) {
  body {
    padding-top: 2em;
  }
  #title {
    padding: 1em 0;
  }
  h1 {
    font-size: 24px;
  }
  h2 {
    font-size: 20px;
    margin-top: -18px;  /* provide offset for in-page anchors */
    padding-top: 38px;
  }
  #identifiers dd {
    max-width: 60%;
  }
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 0;
    margin: 0;
    background-color: inherit;
    border-bottom: 1px solid #ccc;
  }
  #toc h2 {
    margin: -1px 0 0 0;
    padding: 4px 0 4px 6px;
    padding-right: 1em;
    min-width: 190px;
    font-size: 1.1em;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
  }
  #toc h2::before { /* css hamburger */
    float: right;
    position: relative;
    width: 1em;
    height: 1px;
    left: -164px;
    margin: 6px 0 0 0;
    background: white none repeat scroll 0 0;
    box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
    content: "";
  }
  #toc nav {
    display: none;
    padding: 0.5em 1em 1em;
    overflow: auto;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
}

/* alternative layout for wide screens */
@media screen and (min-width: 1024px) {
  body {
    max-width: 724px;
    margin: 42px auto;
    padding-left: 1.5em;
    padding-right: 29em;
  }
  #toc {
    position: fixed;
    top: 42px;
    right: 42px;
    width: 25%;
    margin: 0;
    padding: 0 1em;
    z-index: 1;
  }
  #toc h2 {
    border-top: none;
    border-bottom: 1px solid #ddd;
    font-size: 1em;
    font-weight: normal;
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 0;
    overflow: auto;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
}

/* pagination */
@media print {
  body {

    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre {
    page-break-inside: avoid;
  }
  figure {
    overflow: scroll;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  h2+*, h3+*, h4+*, h5+*, h6+* {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

/* This is commented out here, as the string-set: doesn't
   pass W3C validation currently */
/*
.ears thead .left {
  string-set: ears-top-left content();
}

.ears thead .center {
  string-set: ears-top-center content();
}

.ears thead .right {
  string-set: ears-top-right content();
}

.ears tfoot .left {
  string-set: ears-bottom-left content();
}

.ears tfoot .center {
  string-set: ears-bottom-center content();
}

.ears tfoot .right {
  string-set: ears-bottom-right content();
}
*/

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
  /* The follwing is commented out here, but set appropriately by in code, as
     the content depends on the document */
  /*
  @top-left {
    content: 'Internet-Draft';
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-left {
    content: string(ears-top-left);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-center {
    content: string(ears-top-center);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @top-right {
    content: string(ears-top-right);
    vertical-align: bottom;
    border-bottom: solid 1px #ccc;
  }
  @bottom-left {
    content: string(ears-bottom-left);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-center {
    content: string(ears-bottom-center);
    vertical-align: top;
    border-top: solid 1px #ccc;
  }
  @bottom-right {
      content: '[Page ' counter(page) ']';
      vertical-align: top;
      border-top: solid 1px #ccc;
  }
  */

}

/* Changes introduced to fix issues found during implementation */
/* Make sure links are clickable even if overlapped by following H* */
a {
  z-index: 2;
}
/* Separate body from document info even without intervening H1 */
section {
  clear: both;
}


/* Top align author divs, to avoid names without organization dropping level with org names */
.author {
  vertical-align: top;
}

/* Leave room in document info to show Internet-Draft on one line */
#identifiers dt {
  width: 8em;
}

/* Don't waste quite as much whitespace between label and value in doc info */
#identifiers dd {
  margin-left: 1em;
}

/* Give floating toc a background color (needed when it's a div inside section */
#toc {
  background-color: white;
}

/* Make the collapsed ToC header render white on gray also when it's a link */
@media screen and (max-width: 1023px) {
  #toc h2 a,
  #toc h2 a:link,
  #toc h2 a:focus,
  #toc h2 a:hover,
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
}

/* Give the bottom of the ToC some whitespace */
@media screen and (min-width: 1024px) {
  #toc {
    padding: 0 0 1em 1em;
  }
}

/* Style section numbers with more space between number and title */
.section-number {
  padding-right: 0.5em;
}

/* prevent monospace from becoming overly large */
tt, code, pre, code {
  font-size: 95%;
}

/* Fix the height/width aspect for ascii art*/
pre.sourcecode,
.art-text pre {
  line-height: 1.12;
}


/* Add styling for a link in the ToC that points to the top of the document */
a.toplink {
  float: right;
  margin-right: 0.5em;
}

/* Fix the dl styling to match the RFC 7992 attributes */
dl > dt,
dl.dlParallel > dt {
  float: left;
  margin-right: 1em;
}
dl.dlNewline > dt {
  float: none;
}

/* Provide styling for table cell text alignment */
table td.text-left,
table th.text-left {
  text-align: left;
}
table td.text-center,
table th.text-center {
  text-align: center;
}
table td.text-right,
table th.text-right {
  text-align: right;
}

/* Make the alternative author contact informatio look less like just another
   author, and group it closer with the primary author contact information */
.alternative-contact {
  margin: 0.5em 0 0.25em 0;
}
address .non-ascii {
  margin: 0 0 0 2em;
}

/* With it being possible to set tables with alignment
  left, center, and right, { width: 100%; } does not make sense */
table {
  width: auto;
}

/* Avoid reference text that sits in a block with very wide left margin,
   because of a long floating dt label.*/
.references dd {
  overflow: visible;
}

/* Control caption placement */
caption {
  caption-side: bottom;
}

/* Limit the width of the author address vcard, so names in right-to-left
   script don't end up on the other side of the page. */

address.vcard {
  max-width: 30em;
  margin-right: auto;
}

/* For address alignment dependent on LTR or RTL scripts */
address div.left {
  text-align: left;
}
address div.right {
  text-align: right;
}

/* Provide table alignment support.  We can't use the alignX classes above
   since they do unwanted things with caption and other styling. */
table.right {
 margin-left: auto;
 margin-right: 0;
}
table.center {
 margin-left: auto;
 margin-right: auto;
}
table.left {
 margin-left: 0;
 margin-right: auto;
}

/* Give the table caption label the same styling as the figcaption */
caption a[href] {
  color: #222;
}

@media print {
  .toplink {
    display: none;
  }

  /* avoid overwriting the top border line with the ToC header */
  #toc {
    padding-top: 1px;
  }

  /* Avoid page breaks inside dl and author address entries */
  .vcard {
    page-break-inside: avoid;
  }

}
/* Avoid wrapping of URLs in references */
@media screen {
  .references a {
    white-space: nowrap;
  }
}
/* Tweak the bcp14 keyword presentation */
.bcp14 {
  font-variant: small-caps;
  font-weight: bold;
  font-size: 0.9em;
}
/* Tweak the invisible space above H* in order not to overlay links in text above */
 h2 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 31px;
 }
 h3 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
 h4 {
  margin-top: -18px;  /* provide offset for in-page anchors */
  padding-top: 24px;
 }
/* Float artwork pilcrow to the right */
@media screen {
  .artwork a.pilcrow {
    display: block;
    line-height: 0.7;
    margin-top: 0.15em;
  }
}
/* Make pilcrows on dd visible */
@media screen {
  dd:hover > a.pilcrow {
    visibility: visible;
  }
}
/* Make the placement of figcaption match that of a table's caption
   by removing the figure's added bottom margin */
.alignLeft.art-text,
.alignCenter.art-text,
.alignRight.art-text {
   margin-bottom: 0;
}
.alignLeft,
.alignCenter,
.alignRight {
  margin: 1em 0 0 0;
}
/* In print, the pilcrow won't show on hover, so prevent it from taking up space,
   possibly even requiring a new line */
@media print {
  a.pilcrow {
    display: none;
  }
}
/* Styling for the external metadata */
div#external-metadata {
  background-color: #eee;
  padding: 0.5em;
  margin-bottom: 0.5em;
  display: none;
}
div#internal-metadata {
  padding: 0.5em;                       /* to match the external-metadata padding */
}
/* Styling for title RFC Number */
h1#rfcnum {
  clear: both;
  margin: 0 0 -1em;
  padding: 1em 0 0 0;
}
/* Make .olPercent look the same as <ol><li> */
dl.olPercent > dd {
  margin-bottom: 0.25em;
  min-height: initial;
}
/* Give aside some styling to set it apart */
aside {
  border-left: 1px solid #ddd;
  margin: 1em 0 1em 2em;
  padding: 0.2em 2em;
}
aside > dl,
aside > ol,
aside > ul,
aside > table,
aside > p {
  margin-bottom: 0.5em;
}
/* Additional page break settings */
@media print {
  figcaption, table caption {
    page-break-before: avoid;
  }
}
/* Font size adjustments for print */
@media print {
  body  { font-size: 10pt;      line-height: normal; max-width: 96%; }
  h1    { font-size: 1.72em;    padding-top: 1.5em; } /* 1*1.2*1.2*1.2 */
  h2    { font-size: 1.44em;    padding-top: 1.5em; } /* 1*1.2*1.2 */
  h3    { font-size: 1.2em;     padding-top: 1.5em; } /* 1*1.2 */
  h4    { font-size: 1em;       padding-top: 1.5em; }
  h5, h6 { font-size: 1em;      margin: initial; padding: 0.5em 0 0.3em; }
}
/* Sourcecode margin in print, when there's no pilcrow */
@media print {
  .artwork,
  .sourcecode {
    margin-bottom: 1em;
  }
}
/* Avoid narrow tables forcing too narrow table captions, which may render badly */
table {
  min-width: 20em;
}
/* ol type a */
ol.type-a { list-style-type: lower-alpha; }
ol.type-A { list-style-type: upper-alpha; }
ol.type-i { list-style-type: lower-roman; }
ol.type-I { list-style-type: lower-roman; }
/* Apply the print table and row borders in general, on request from the RPC,
and increase the contrast between border and odd row background sligthtly */
table {
  border: 1px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
}
tr:nth-child(2n+1) > td {
  background-color: #f8f8f8;
}
/* Use style rules to govern display of the TOC. */
@media screen and (max-width: 1023px) {
  #toc nav { display: none; }
  #toc.active nav { display: block; }
}
/* Add support for keepWithNext */
.keepWithNext {
  break-after: avoid-page;
  break-after: avoid-page;
}
/* Add support for keepWithPrevious */
.keepWithPrevious {
  break-before: avoid-page;
}
/* Change the approach to avoiding breaks inside artwork etc. */
figure, pre, table, .artwork, .sourcecode  {
  break-before: avoid-page;
  break-after: auto;
}
/* Avoid breaks between <dt> and <dd> */
dl {
  break-inside: auto;
}
dt {
  break-before: auto;
  break-after: avoid-page;
}
dd {
  break-before: avoid-page;
  break-after: auto;
  orphans: 3;
  widows: 3
}
dd.break {
  margin-bottom: 0;
  min-height: 0;
  break-before: auto;
  break-inside: auto;
  break-after: auto;
}
/* Undo break-before ToC */
@media print {
  #toc {
    break-before: auto;
  }
}</style>
<link href="rfc-local.css" rel="stylesheet" type="text/css">
</head>
<body>
<script src="metadata.min.js"></script>
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">QUIC Transport Protocol</td>
<td class="right">May 2020</td>
</tr></thead>
<tfoot><tr>
<td class="left">Iyengar &amp; Thomson</td>
<td class="center">Expires 21 November 2020</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">QUIC</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-ietf-quic-transport-28</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2020-05-20" class="published">20 May 2020</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Standards Track</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2020-11-21">21 November 2020</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">J. Iyengar, <span class="editor">Ed.</span>
</div>
<div class="org">Fastly</div>
</div>
<div class="author">
      <div class="author-name">M. Thomson, <span class="editor">Ed.</span>
</div>
<div class="org">Mozilla</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">QUIC: A UDP-Based Multiplexed and Secure Transport</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This document defines the core of the QUIC transport protocol.  Accompanying
documents describe QUIC's loss detection and congestion control and the use of
TLS for key negotiation.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<section class="note" id="section-note.1">
      <h2 id="name-note-to-readers">
<a href="#name-note-to-readers" class="section-name selfRef">Note to Readers</a>
      </h2>
<p id="section-note.1-1">Discussion of this draft takes place on the QUIC working group mailing list
(<a href="mailto:quic@ietf.org">quic@ietf.org</a>), which is archived at
<span><a href="https://mailarchive.ietf.org/arch/search/?email_list=quic">https://mailarchive.ietf.org/arch/search/?email_list=quic</a></span><a href="#section-note.1-1" class="pilcrow">¶</a></p>
<p id="section-note.1-2">Working Group information can be found at <span><a href="https://github.com/quicwg">https://github.com/quicwg</a></span>; source
code and issues list for this draft can be found at
<span><a href="https://github.com/quicwg/base-drafts/labels/-transport">https://github.com/quicwg/base-drafts/labels/-transport</a></span>.<a href="#section-note.1-2" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 21 November 2020.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2020 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Simplified BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Simplified BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1"><a href="#section-1" class="xref">1</a>.  <a href="#name-introduction" class="xref">Introduction</a><a href="#section-toc.1-1.1.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="xref">1.1</a>.  <a href="#name-document-structure" class="xref">Document Structure</a><a href="#section-toc.1-1.1.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.1.2.2">
                <p id="section-toc.1-1.1.2.2.1" class="keepWithNext"><a href="#section-1.2" class="xref">1.2</a>.  <a href="#name-terms-and-definitions" class="xref">Terms and Definitions</a><a href="#section-toc.1-1.1.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.1.2.3">
                <p id="section-toc.1-1.1.2.3.1" class="keepWithNext"><a href="#section-1.3" class="xref">1.3</a>.  <a href="#name-notational-conventions" class="xref">Notational Conventions</a><a href="#section-toc.1-1.1.2.3.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a href="#section-2" class="xref">2</a>.  <a href="#name-streams" class="xref">Streams</a><a href="#section-toc.1-1.2.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.2.2.1">
                <p id="section-toc.1-1.2.2.1.1"><a href="#section-2.1" class="xref">2.1</a>.  <a href="#name-stream-types-and-identifier" class="xref">Stream Types and Identifiers</a><a href="#section-toc.1-1.2.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.2.2.2">
                <p id="section-toc.1-1.2.2.2.1"><a href="#section-2.2" class="xref">2.2</a>.  <a href="#name-sending-and-receiving-data" class="xref">Sending and Receiving Data</a><a href="#section-toc.1-1.2.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.2.2.3">
                <p id="section-toc.1-1.2.2.3.1"><a href="#section-2.3" class="xref">2.3</a>.  <a href="#name-stream-prioritization" class="xref">Stream Prioritization</a><a href="#section-toc.1-1.2.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.2.2.4">
                <p id="section-toc.1-1.2.2.4.1"><a href="#section-2.4" class="xref">2.4</a>.  <a href="#name-required-operations-on-stre" class="xref">Required Operations on Streams</a><a href="#section-toc.1-1.2.2.4.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="xref">3</a>.  <a href="#name-stream-states" class="xref">Stream States</a><a href="#section-toc.1-1.3.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1"><a href="#section-3.1" class="xref">3.1</a>.  <a href="#name-sending-stream-states" class="xref">Sending Stream States</a><a href="#section-toc.1-1.3.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a href="#section-3.2" class="xref">3.2</a>.  <a href="#name-receiving-stream-states" class="xref">Receiving Stream States</a><a href="#section-toc.1-1.3.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.3">
                <p id="section-toc.1-1.3.2.3.1"><a href="#section-3.3" class="xref">3.3</a>.  <a href="#name-permitted-frame-types" class="xref">Permitted Frame Types</a><a href="#section-toc.1-1.3.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.4">
                <p id="section-toc.1-1.3.2.4.1"><a href="#section-3.4" class="xref">3.4</a>.  <a href="#name-bidirectional-stream-states" class="xref">Bidirectional Stream States</a><a href="#section-toc.1-1.3.2.4.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.3.2.5">
                <p id="section-toc.1-1.3.2.5.1"><a href="#section-3.5" class="xref">3.5</a>.  <a href="#name-solicited-state-transitions" class="xref">Solicited State Transitions</a><a href="#section-toc.1-1.3.2.5.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="xref">4</a>.  <a href="#name-flow-control" class="xref">Flow Control</a><a href="#section-toc.1-1.4.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="xref">4.1</a>.  <a href="#name-data-flow-control" class="xref">Data Flow Control</a><a href="#section-toc.1-1.4.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="xref">4.2</a>.  <a href="#name-flow-credit-increments" class="xref">Flow Credit Increments</a><a href="#section-toc.1-1.4.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a href="#section-4.3" class="xref">4.3</a>.  <a href="#name-handling-stream-cancellatio" class="xref">Handling Stream Cancellation</a><a href="#section-toc.1-1.4.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.4">
                <p id="section-toc.1-1.4.2.4.1"><a href="#section-4.4" class="xref">4.4</a>.  <a href="#name-stream-final-size" class="xref">Stream Final Size</a><a href="#section-toc.1-1.4.2.4.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.4.2.5">
                <p id="section-toc.1-1.4.2.5.1"><a href="#section-4.5" class="xref">4.5</a>.  <a href="#name-controlling-concurrency" class="xref">Controlling Concurrency</a><a href="#section-toc.1-1.4.2.5.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="xref">5</a>.  <a href="#name-connections" class="xref">Connections</a><a href="#section-toc.1-1.5.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.5.2.1">
                <p id="section-toc.1-1.5.2.1.1"><a href="#section-5.1" class="xref">5.1</a>.  <a href="#name-connection-id" class="xref">Connection ID</a><a href="#section-toc.1-1.5.2.1.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.5.2.1.2.1">
                    <p id="section-toc.1-1.5.2.1.2.1.1"><a href="#section-5.1.1" class="xref">5.1.1</a>.  <a href="#name-issuing-connection-ids" class="xref">Issuing Connection IDs</a><a href="#section-toc.1-1.5.2.1.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.1.2.2">
                    <p id="section-toc.1-1.5.2.1.2.2.1"><a href="#section-5.1.2" class="xref">5.1.2</a>.  <a href="#name-consuming-and-retiring-conn" class="xref">Consuming and Retiring Connection IDs</a><a href="#section-toc.1-1.5.2.1.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.2">
                <p id="section-toc.1-1.5.2.2.1"><a href="#section-5.2" class="xref">5.2</a>.  <a href="#name-matching-packets-to-connect" class="xref">Matching Packets to Connections</a><a href="#section-toc.1-1.5.2.2.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.5.2.2.2.1">
                    <p id="section-toc.1-1.5.2.2.2.1.1"><a href="#section-5.2.1" class="xref">5.2.1</a>.  <a href="#name-client-packet-handling" class="xref">Client Packet Handling</a><a href="#section-toc.1-1.5.2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.2.2.2">
                    <p id="section-toc.1-1.5.2.2.2.2.1"><a href="#section-5.2.2" class="xref">5.2.2</a>.  <a href="#name-server-packet-handling" class="xref">Server Packet Handling</a><a href="#section-toc.1-1.5.2.2.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.2.2.3">
                    <p id="section-toc.1-1.5.2.2.2.3.1"><a href="#section-5.2.3" class="xref">5.2.3</a>.  <a href="#name-considerations-for-simple-l" class="xref">Considerations for Simple Load Balancers</a><a href="#section-toc.1-1.5.2.2.2.3.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.3">
                <p id="section-toc.1-1.5.2.3.1"><a href="#section-5.3" class="xref">5.3</a>.  <a href="#name-life-of-a-quic-connection" class="xref">Life of a QUIC Connection</a><a href="#section-toc.1-1.5.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.5.2.4">
                <p id="section-toc.1-1.5.2.4.1"><a href="#section-5.4" class="xref">5.4</a>.  <a href="#name-required-operations-on-conn" class="xref">Required Operations on Connections</a><a href="#section-toc.1-1.5.2.4.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="xref">6</a>.  <a href="#name-version-negotiation" class="xref">Version Negotiation</a><a href="#section-toc.1-1.6.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.6.2.1">
                <p id="section-toc.1-1.6.2.1.1"><a href="#section-6.1" class="xref">6.1</a>.  <a href="#name-sending-version-negotiation" class="xref">Sending Version Negotiation Packets</a><a href="#section-toc.1-1.6.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6.2.2">
                <p id="section-toc.1-1.6.2.2.1"><a href="#section-6.2" class="xref">6.2</a>.  <a href="#name-handling-version-negotiatio" class="xref">Handling Version Negotiation Packets</a><a href="#section-toc.1-1.6.2.2.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.6.2.2.2.1">
                    <p id="section-toc.1-1.6.2.2.2.1.1"><a href="#section-6.2.1" class="xref">6.2.1</a>.  <a href="#name-version-negotiation-between" class="xref">Version Negotiation Between Draft Versions</a><a href="#section-toc.1-1.6.2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.6.2.3">
                <p id="section-toc.1-1.6.2.3.1"><a href="#section-6.3" class="xref">6.3</a>.  <a href="#name-using-reserved-versions" class="xref">Using Reserved Versions</a><a href="#section-toc.1-1.6.2.3.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="xref">7</a>.  <a href="#name-cryptographic-and-transport" class="xref">Cryptographic and Transport Handshake</a><a href="#section-toc.1-1.7.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.7.2.1">
                <p id="section-toc.1-1.7.2.1.1"><a href="#section-7.1" class="xref">7.1</a>.  <a href="#name-example-handshake-flows" class="xref">Example Handshake Flows</a><a href="#section-toc.1-1.7.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7.2.2">
                <p id="section-toc.1-1.7.2.2.1"><a href="#section-7.2" class="xref">7.2</a>.  <a href="#name-negotiating-connection-ids" class="xref">Negotiating Connection IDs</a><a href="#section-toc.1-1.7.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7.2.3">
                <p id="section-toc.1-1.7.2.3.1"><a href="#section-7.3" class="xref">7.3</a>.  <a href="#name-authenticating-connection-i" class="xref">Authenticating Connection IDs</a><a href="#section-toc.1-1.7.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7.2.4">
                <p id="section-toc.1-1.7.2.4.1"><a href="#section-7.4" class="xref">7.4</a>.  <a href="#name-transport-parameters" class="xref">Transport Parameters</a><a href="#section-toc.1-1.7.2.4.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.7.2.4.2.1">
                    <p id="section-toc.1-1.7.2.4.2.1.1"><a href="#section-7.4.1" class="xref">7.4.1</a>.  <a href="#name-values-of-transport-paramet" class="xref">Values of Transport Parameters for 0-RTT</a><a href="#section-toc.1-1.7.2.4.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7.2.4.2.2">
                    <p id="section-toc.1-1.7.2.4.2.2.1"><a href="#section-7.4.2" class="xref">7.4.2</a>.  <a href="#name-new-transport-parameters" class="xref">New Transport Parameters</a><a href="#section-toc.1-1.7.2.4.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.7.2.5">
                <p id="section-toc.1-1.7.2.5.1"><a href="#section-7.5" class="xref">7.5</a>.  <a href="#name-cryptographic-message-buffe" class="xref">Cryptographic Message Buffering</a><a href="#section-toc.1-1.7.2.5.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="xref">8</a>.  <a href="#name-address-validation" class="xref">Address Validation</a><a href="#section-toc.1-1.8.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.8.2.1">
                <p id="section-toc.1-1.8.2.1.1"><a href="#section-8.1" class="xref">8.1</a>.  <a href="#name-address-validation-during-c" class="xref">Address Validation During Connection Establishment</a><a href="#section-toc.1-1.8.2.1.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.8.2.1.2.1">
                    <p id="section-toc.1-1.8.2.1.2.1.1"><a href="#section-8.1.1" class="xref">8.1.1</a>.  <a href="#name-token-construction" class="xref">Token Construction</a><a href="#section-toc.1-1.8.2.1.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.8.2.1.2.2">
                    <p id="section-toc.1-1.8.2.1.2.2.1"><a href="#section-8.1.2" class="xref">8.1.2</a>.  <a href="#name-address-validation-using-re" class="xref">Address Validation using Retry Packets</a><a href="#section-toc.1-1.8.2.1.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.8.2.1.2.3">
                    <p id="section-toc.1-1.8.2.1.2.3.1"><a href="#section-8.1.3" class="xref">8.1.3</a>.  <a href="#name-address-validation-for-futu" class="xref">Address Validation for Future Connections</a><a href="#section-toc.1-1.8.2.1.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.8.2.1.2.4">
                    <p id="section-toc.1-1.8.2.1.2.4.1"><a href="#section-8.1.4" class="xref">8.1.4</a>.  <a href="#name-address-validation-token-in" class="xref">Address Validation Token Integrity</a><a href="#section-toc.1-1.8.2.1.2.4.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.8.2.2">
                <p id="section-toc.1-1.8.2.2.1"><a href="#section-8.2" class="xref">8.2</a>.  <a href="#name-path-validation" class="xref">Path Validation</a><a href="#section-toc.1-1.8.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.8.2.3">
                <p id="section-toc.1-1.8.2.3.1"><a href="#section-8.3" class="xref">8.3</a>.  <a href="#name-initiating-path-validation" class="xref">Initiating Path Validation</a><a href="#section-toc.1-1.8.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.8.2.4">
                <p id="section-toc.1-1.8.2.4.1"><a href="#section-8.4" class="xref">8.4</a>.  <a href="#name-path-validation-responses" class="xref">Path Validation Responses</a><a href="#section-toc.1-1.8.2.4.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.8.2.5">
                <p id="section-toc.1-1.8.2.5.1"><a href="#section-8.5" class="xref">8.5</a>.  <a href="#name-successful-path-validation" class="xref">Successful Path Validation</a><a href="#section-toc.1-1.8.2.5.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.8.2.6">
                <p id="section-toc.1-1.8.2.6.1"><a href="#section-8.6" class="xref">8.6</a>.  <a href="#name-failed-path-validation" class="xref">Failed Path Validation</a><a href="#section-toc.1-1.8.2.6.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="xref">9</a>.  <a href="#name-connection-migration" class="xref">Connection Migration</a><a href="#section-toc.1-1.9.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.9.2.1">
                <p id="section-toc.1-1.9.2.1.1"><a href="#section-9.1" class="xref">9.1</a>.  <a href="#name-probing-a-new-path" class="xref">Probing a New Path</a><a href="#section-toc.1-1.9.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.9.2.2">
                <p id="section-toc.1-1.9.2.2.1"><a href="#section-9.2" class="xref">9.2</a>.  <a href="#name-initiating-connection-migra" class="xref">Initiating Connection Migration</a><a href="#section-toc.1-1.9.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.9.2.3">
                <p id="section-toc.1-1.9.2.3.1"><a href="#section-9.3" class="xref">9.3</a>.  <a href="#name-responding-to-connection-mi" class="xref">Responding to Connection Migration</a><a href="#section-toc.1-1.9.2.3.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.9.2.3.2.1">
                    <p id="section-toc.1-1.9.2.3.2.1.1"><a href="#section-9.3.1" class="xref">9.3.1</a>.  <a href="#name-peer-address-spoofing" class="xref">Peer Address Spoofing</a><a href="#section-toc.1-1.9.2.3.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.9.2.3.2.2">
                    <p id="section-toc.1-1.9.2.3.2.2.1"><a href="#section-9.3.2" class="xref">9.3.2</a>.  <a href="#name-on-path-address-spoofing" class="xref">On-Path Address Spoofing</a><a href="#section-toc.1-1.9.2.3.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.9.2.3.2.3">
                    <p id="section-toc.1-1.9.2.3.2.3.1"><a href="#section-9.3.3" class="xref">9.3.3</a>.  <a href="#name-off-path-packet-forwarding" class="xref">Off-Path Packet Forwarding</a><a href="#section-toc.1-1.9.2.3.2.3.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.9.2.4">
                <p id="section-toc.1-1.9.2.4.1"><a href="#section-9.4" class="xref">9.4</a>.  <a href="#name-loss-detection-and-congesti" class="xref">Loss Detection and Congestion Control</a><a href="#section-toc.1-1.9.2.4.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.9.2.5">
                <p id="section-toc.1-1.9.2.5.1"><a href="#section-9.5" class="xref">9.5</a>.  <a href="#name-privacy-implications-of-con" class="xref">Privacy Implications of Connection Migration</a><a href="#section-toc.1-1.9.2.5.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.9.2.6">
                <p id="section-toc.1-1.9.2.6.1"><a href="#section-9.6" class="xref">9.6</a>.  <a href="#name-servers-preferred-address" class="xref">Server's Preferred Address</a><a href="#section-toc.1-1.9.2.6.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.9.2.6.2.1">
                    <p id="section-toc.1-1.9.2.6.2.1.1"><a href="#section-9.6.1" class="xref">9.6.1</a>.  <a href="#name-communicating-a-preferred-a" class="xref">Communicating a Preferred Address</a><a href="#section-toc.1-1.9.2.6.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.9.2.6.2.2">
                    <p id="section-toc.1-1.9.2.6.2.2.1"><a href="#section-9.6.2" class="xref">9.6.2</a>.  <a href="#name-responding-to-connection-mig" class="xref">Responding to Connection Migration</a><a href="#section-toc.1-1.9.2.6.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.9.2.6.2.3">
                    <p id="section-toc.1-1.9.2.6.2.3.1"><a href="#section-9.6.3" class="xref">9.6.3</a>.  <a href="#name-interaction-of-client-migra" class="xref">Interaction of Client Migration and Preferred Address</a><a href="#section-toc.1-1.9.2.6.2.3.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.9.2.7">
                <p id="section-toc.1-1.9.2.7.1"><a href="#section-9.7" class="xref">9.7</a>.  <a href="#name-use-of-ipv6-flow-label-and-" class="xref">Use of IPv6 Flow-Label and Migration</a><a href="#section-toc.1-1.9.2.7.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="xref">10</a>. <a href="#name-connection-termination" class="xref">Connection Termination</a><a href="#section-toc.1-1.10.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.10.2.1">
                <p id="section-toc.1-1.10.2.1.1"><a href="#section-10.1" class="xref">10.1</a>.  <a href="#name-closing-and-draining-connec" class="xref">Closing and Draining Connection States</a><a href="#section-toc.1-1.10.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.2">
                <p id="section-toc.1-1.10.2.2.1"><a href="#section-10.2" class="xref">10.2</a>.  <a href="#name-idle-timeout" class="xref">Idle Timeout</a><a href="#section-toc.1-1.10.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.3">
                <p id="section-toc.1-1.10.2.3.1"><a href="#section-10.3" class="xref">10.3</a>.  <a href="#name-immediate-close" class="xref">Immediate Close</a><a href="#section-toc.1-1.10.2.3.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.10.2.3.2.1">
                    <p id="section-toc.1-1.10.2.3.2.1.1"><a href="#section-10.3.1" class="xref">10.3.1</a>.  <a href="#name-immediate-close-during-the-" class="xref">Immediate Close During the Handshake</a><a href="#section-toc.1-1.10.2.3.2.1.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.4">
                <p id="section-toc.1-1.10.2.4.1"><a href="#section-10.4" class="xref">10.4</a>.  <a href="#name-stateless-reset" class="xref">Stateless Reset</a><a href="#section-toc.1-1.10.2.4.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.10.2.4.2.1">
                    <p id="section-toc.1-1.10.2.4.2.1.1"><a href="#section-10.4.1" class="xref">10.4.1</a>.  <a href="#name-detecting-a-stateless-reset" class="xref">Detecting a Stateless Reset</a><a href="#section-toc.1-1.10.2.4.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.4.2.2">
                    <p id="section-toc.1-1.10.2.4.2.2.1"><a href="#section-10.4.2" class="xref">10.4.2</a>.  <a href="#name-calculating-a-stateless-res" class="xref">Calculating a Stateless Reset Token</a><a href="#section-toc.1-1.10.2.4.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.10.2.4.2.3">
                    <p id="section-toc.1-1.10.2.4.2.3.1"><a href="#section-10.4.3" class="xref">10.4.3</a>.  <a href="#name-looping" class="xref">Looping</a><a href="#section-toc.1-1.10.2.4.2.3.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#section-11" class="xref">11</a>. <a href="#name-error-handling" class="xref">Error Handling</a><a href="#section-toc.1-1.11.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.11.2.1">
                <p id="section-toc.1-1.11.2.1.1"><a href="#section-11.1" class="xref">11.1</a>.  <a href="#name-connection-errors" class="xref">Connection Errors</a><a href="#section-toc.1-1.11.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.11.2.2">
                <p id="section-toc.1-1.11.2.2.1"><a href="#section-11.2" class="xref">11.2</a>.  <a href="#name-stream-errors" class="xref">Stream Errors</a><a href="#section-toc.1-1.11.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#section-12" class="xref">12</a>. <a href="#name-packets-and-frames" class="xref">Packets and Frames</a><a href="#section-toc.1-1.12.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.12.2.1">
                <p id="section-toc.1-1.12.2.1.1"><a href="#section-12.1" class="xref">12.1</a>.  <a href="#name-protected-packets" class="xref">Protected Packets</a><a href="#section-toc.1-1.12.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.2">
                <p id="section-toc.1-1.12.2.2.1"><a href="#section-12.2" class="xref">12.2</a>.  <a href="#name-coalescing-packets" class="xref">Coalescing Packets</a><a href="#section-toc.1-1.12.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.3">
                <p id="section-toc.1-1.12.2.3.1"><a href="#section-12.3" class="xref">12.3</a>.  <a href="#name-packet-numbers" class="xref">Packet Numbers</a><a href="#section-toc.1-1.12.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.12.2.4">
                <p id="section-toc.1-1.12.2.4.1"><a href="#section-12.4" class="xref">12.4</a>.  <a href="#name-frames-and-frame-types" class="xref">Frames and Frame Types</a><a href="#section-toc.1-1.12.2.4.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.13">
            <p id="section-toc.1-1.13.1"><a href="#section-13" class="xref">13</a>. <a href="#name-packetization-and-reliabili" class="xref">Packetization and Reliability</a><a href="#section-toc.1-1.13.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.13.2.1">
                <p id="section-toc.1-1.13.2.1.1"><a href="#section-13.1" class="xref">13.1</a>.  <a href="#name-packet-processing" class="xref">Packet Processing</a><a href="#section-toc.1-1.13.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.13.2.2">
                <p id="section-toc.1-1.13.2.2.1"><a href="#section-13.2" class="xref">13.2</a>.  <a href="#name-generating-acknowledgements" class="xref">Generating Acknowledgements</a><a href="#section-toc.1-1.13.2.2.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.13.2.2.2.1">
                    <p id="section-toc.1-1.13.2.2.2.1.1"><a href="#section-13.2.1" class="xref">13.2.1</a>.  <a href="#name-sending-ack-frames" class="xref">Sending ACK Frames</a><a href="#section-toc.1-1.13.2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.13.2.2.2.2">
                    <p id="section-toc.1-1.13.2.2.2.2.1"><a href="#section-13.2.2" class="xref">13.2.2</a>.  <a href="#name-managing-ack-ranges" class="xref">Managing ACK Ranges</a><a href="#section-toc.1-1.13.2.2.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.13.2.2.2.3">
                    <p id="section-toc.1-1.13.2.2.2.3.1"><a href="#section-13.2.3" class="xref">13.2.3</a>.  <a href="#name-receiver-tracking-of-ack-fr" class="xref">Receiver Tracking of ACK Frames</a><a href="#section-toc.1-1.13.2.2.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.13.2.2.2.4">
                    <p id="section-toc.1-1.13.2.2.2.4.1"><a href="#section-13.2.4" class="xref">13.2.4</a>.  <a href="#name-limiting-ack-ranges" class="xref">Limiting ACK Ranges</a><a href="#section-toc.1-1.13.2.2.2.4.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.13.2.2.2.5">
                    <p id="section-toc.1-1.13.2.2.2.5.1"><a href="#section-13.2.5" class="xref">13.2.5</a>.  <a href="#name-measuring-and-reporting-hos" class="xref">Measuring and Reporting Host Delay</a><a href="#section-toc.1-1.13.2.2.2.5.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.13.2.2.2.6">
                    <p id="section-toc.1-1.13.2.2.2.6.1"><a href="#section-13.2.6" class="xref">13.2.6</a>.  <a href="#name-ack-frames-and-packet-prote" class="xref">ACK Frames and Packet Protection</a><a href="#section-toc.1-1.13.2.2.2.6.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.13.2.3">
                <p id="section-toc.1-1.13.2.3.1"><a href="#section-13.3" class="xref">13.3</a>.  <a href="#name-retransmission-of-informati" class="xref">Retransmission of Information</a><a href="#section-toc.1-1.13.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.13.2.4">
                <p id="section-toc.1-1.13.2.4.1"><a href="#section-13.4" class="xref">13.4</a>.  <a href="#name-explicit-congestion-notific" class="xref">Explicit Congestion Notification</a><a href="#section-toc.1-1.13.2.4.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.13.2.4.2.1">
                    <p id="section-toc.1-1.13.2.4.2.1.1"><a href="#section-13.4.1" class="xref">13.4.1</a>.  <a href="#name-ecn-counts" class="xref">ECN Counts</a><a href="#section-toc.1-1.13.2.4.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.13.2.4.2.2">
                    <p id="section-toc.1-1.13.2.4.2.2.1"><a href="#section-13.4.2" class="xref">13.4.2</a>.  <a href="#name-ecn-validation" class="xref">ECN Validation</a><a href="#section-toc.1-1.13.2.4.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.14">
            <p id="section-toc.1-1.14.1"><a href="#section-14" class="xref">14</a>. <a href="#name-packet-size" class="xref">Packet Size</a><a href="#section-toc.1-1.14.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.14.2.1">
                <p id="section-toc.1-1.14.2.1.1"><a href="#section-14.1" class="xref">14.1</a>.  <a href="#name-path-maximum-transmission-u" class="xref">Path Maximum Transmission Unit (PMTU)</a><a href="#section-toc.1-1.14.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.14.2.2">
                <p id="section-toc.1-1.14.2.2.1"><a href="#section-14.2" class="xref">14.2</a>.  <a href="#name-icmp-packet-too-big-message" class="xref">ICMP Packet Too Big Messages</a><a href="#section-toc.1-1.14.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.14.2.3">
                <p id="section-toc.1-1.14.2.3.1"><a href="#section-14.3" class="xref">14.3</a>.  <a href="#name-datagram-packetization-laye" class="xref">Datagram Packetization Layer PMTU Discovery</a><a href="#section-toc.1-1.14.2.3.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.14.2.3.2.1">
                    <p id="section-toc.1-1.14.2.3.2.1.1"><a href="#section-14.3.1" class="xref">14.3.1</a>.  <a href="#name-pmtu-probes-containing-sour" class="xref">PMTU Probes Containing Source Connection ID</a><a href="#section-toc.1-1.14.2.3.2.1.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.15">
            <p id="section-toc.1-1.15.1"><a href="#section-15" class="xref">15</a>. <a href="#name-versions" class="xref">Versions</a><a href="#section-toc.1-1.15.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.16">
            <p id="section-toc.1-1.16.1"><a href="#section-16" class="xref">16</a>. <a href="#name-variable-length-integer-enc" class="xref">Variable-Length Integer Encoding</a><a href="#section-toc.1-1.16.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.17">
            <p id="section-toc.1-1.17.1"><a href="#section-17" class="xref">17</a>. <a href="#name-packet-formats" class="xref">Packet Formats</a><a href="#section-toc.1-1.17.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.17.2.1">
                <p id="section-toc.1-1.17.2.1.1"><a href="#section-17.1" class="xref">17.1</a>.  <a href="#name-packet-number-encoding-and-" class="xref">Packet Number Encoding and Decoding</a><a href="#section-toc.1-1.17.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.17.2.2">
                <p id="section-toc.1-1.17.2.2.1"><a href="#section-17.2" class="xref">17.2</a>.  <a href="#name-long-header-packets" class="xref">Long Header Packets</a><a href="#section-toc.1-1.17.2.2.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.17.2.2.2.1">
                    <p id="section-toc.1-1.17.2.2.2.1.1"><a href="#section-17.2.1" class="xref">17.2.1</a>.  <a href="#name-version-negotiation-packet" class="xref">Version Negotiation Packet</a><a href="#section-toc.1-1.17.2.2.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.17.2.2.2.2">
                    <p id="section-toc.1-1.17.2.2.2.2.1"><a href="#section-17.2.2" class="xref">17.2.2</a>.  <a href="#name-initial-packet" class="xref">Initial Packet</a><a href="#section-toc.1-1.17.2.2.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.17.2.2.2.3">
                    <p id="section-toc.1-1.17.2.2.2.3.1"><a href="#section-17.2.3" class="xref">17.2.3</a>.  <a href="#name-0-rtt" class="xref">0-RTT</a><a href="#section-toc.1-1.17.2.2.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.17.2.2.2.4">
                    <p id="section-toc.1-1.17.2.2.2.4.1"><a href="#section-17.2.4" class="xref">17.2.4</a>.  <a href="#name-handshake-packet" class="xref">Handshake Packet</a><a href="#section-toc.1-1.17.2.2.2.4.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.17.2.2.2.5">
                    <p id="section-toc.1-1.17.2.2.2.5.1"><a href="#section-17.2.5" class="xref">17.2.5</a>.  <a href="#name-retry-packet" class="xref">Retry Packet</a><a href="#section-toc.1-1.17.2.2.2.5.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.17.2.3">
                <p id="section-toc.1-1.17.2.3.1"><a href="#section-17.3" class="xref">17.3</a>.  <a href="#name-short-header-packets" class="xref">Short Header Packets</a><a href="#section-toc.1-1.17.2.3.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.17.2.3.2.1">
                    <p id="section-toc.1-1.17.2.3.2.1.1"><a href="#section-17.3.1" class="xref">17.3.1</a>.  <a href="#name-latency-spin-bit" class="xref">Latency Spin Bit</a><a href="#section-toc.1-1.17.2.3.2.1.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.18">
            <p id="section-toc.1-1.18.1"><a href="#section-18" class="xref">18</a>. <a href="#name-transport-parameter-encodin" class="xref">Transport Parameter Encoding</a><a href="#section-toc.1-1.18.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.18.2.1">
                <p id="section-toc.1-1.18.2.1.1"><a href="#section-18.1" class="xref">18.1</a>.  <a href="#name-reserved-transport-paramete" class="xref">Reserved Transport Parameters</a><a href="#section-toc.1-1.18.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.18.2.2">
                <p id="section-toc.1-1.18.2.2.1"><a href="#section-18.2" class="xref">18.2</a>.  <a href="#name-transport-parameter-definit" class="xref">Transport Parameter Definitions</a><a href="#section-toc.1-1.18.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19">
            <p id="section-toc.1-1.19.1"><a href="#section-19" class="xref">19</a>. <a href="#name-frame-types-and-formats" class="xref">Frame Types and Formats</a><a href="#section-toc.1-1.19.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.19.2.1">
                <p id="section-toc.1-1.19.2.1.1"><a href="#section-19.1" class="xref">19.1</a>.  <a href="#name-padding-frame" class="xref">PADDING Frame</a><a href="#section-toc.1-1.19.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.2">
                <p id="section-toc.1-1.19.2.2.1"><a href="#section-19.2" class="xref">19.2</a>.  <a href="#name-ping-frame" class="xref">PING Frame</a><a href="#section-toc.1-1.19.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.3">
                <p id="section-toc.1-1.19.2.3.1"><a href="#section-19.3" class="xref">19.3</a>.  <a href="#name-ack-frames" class="xref">ACK Frames</a><a href="#section-toc.1-1.19.2.3.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.19.2.3.2.1">
                    <p id="section-toc.1-1.19.2.3.2.1.1"><a href="#section-19.3.1" class="xref">19.3.1</a>.  <a href="#name-ack-ranges" class="xref">ACK Ranges</a><a href="#section-toc.1-1.19.2.3.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.3.2.2">
                    <p id="section-toc.1-1.19.2.3.2.2.1"><a href="#section-19.3.2" class="xref">19.3.2</a>.  <a href="#name-ecn-counts-2" class="xref">ECN Counts</a><a href="#section-toc.1-1.19.2.3.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.4">
                <p id="section-toc.1-1.19.2.4.1"><a href="#section-19.4" class="xref">19.4</a>.  <a href="#name-reset_stream-frame" class="xref">RESET_STREAM Frame</a><a href="#section-toc.1-1.19.2.4.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.5">
                <p id="section-toc.1-1.19.2.5.1"><a href="#section-19.5" class="xref">19.5</a>.  <a href="#name-stop_sending-frame" class="xref">STOP_SENDING Frame</a><a href="#section-toc.1-1.19.2.5.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.6">
                <p id="section-toc.1-1.19.2.6.1"><a href="#section-19.6" class="xref">19.6</a>.  <a href="#name-crypto-frame" class="xref">CRYPTO Frame</a><a href="#section-toc.1-1.19.2.6.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.7">
                <p id="section-toc.1-1.19.2.7.1"><a href="#section-19.7" class="xref">19.7</a>.  <a href="#name-new_token-frame" class="xref">NEW_TOKEN Frame</a><a href="#section-toc.1-1.19.2.7.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.8">
                <p id="section-toc.1-1.19.2.8.1"><a href="#section-19.8" class="xref">19.8</a>.  <a href="#name-stream-frames" class="xref">STREAM Frames</a><a href="#section-toc.1-1.19.2.8.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.9">
                <p id="section-toc.1-1.19.2.9.1"><a href="#section-19.9" class="xref">19.9</a>.  <a href="#name-max_data-frame" class="xref">MAX_DATA Frame</a><a href="#section-toc.1-1.19.2.9.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.10">
                <p id="section-toc.1-1.19.2.10.1"><a href="#section-19.10" class="xref">19.10</a>. <a href="#name-max_stream_data-frame" class="xref">MAX_STREAM_DATA Frame</a><a href="#section-toc.1-1.19.2.10.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.11">
                <p id="section-toc.1-1.19.2.11.1"><a href="#section-19.11" class="xref">19.11</a>. <a href="#name-max_streams-frames" class="xref">MAX_STREAMS Frames</a><a href="#section-toc.1-1.19.2.11.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.12">
                <p id="section-toc.1-1.19.2.12.1"><a href="#section-19.12" class="xref">19.12</a>. <a href="#name-data_blocked-frame" class="xref">DATA_BLOCKED Frame</a><a href="#section-toc.1-1.19.2.12.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.13">
                <p id="section-toc.1-1.19.2.13.1"><a href="#section-19.13" class="xref">19.13</a>. <a href="#name-stream_data_blocked-frame" class="xref">STREAM_DATA_BLOCKED Frame</a><a href="#section-toc.1-1.19.2.13.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.14">
                <p id="section-toc.1-1.19.2.14.1"><a href="#section-19.14" class="xref">19.14</a>. <a href="#name-streams_blocked-frames" class="xref">STREAMS_BLOCKED Frames</a><a href="#section-toc.1-1.19.2.14.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.15">
                <p id="section-toc.1-1.19.2.15.1"><a href="#section-19.15" class="xref">19.15</a>. <a href="#name-new_connection_id-frame" class="xref">NEW_CONNECTION_ID Frame</a><a href="#section-toc.1-1.19.2.15.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.16">
                <p id="section-toc.1-1.19.2.16.1"><a href="#section-19.16" class="xref">19.16</a>. <a href="#name-retire_connection_id-frame" class="xref">RETIRE_CONNECTION_ID Frame</a><a href="#section-toc.1-1.19.2.16.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.17">
                <p id="section-toc.1-1.19.2.17.1"><a href="#section-19.17" class="xref">19.17</a>. <a href="#name-path_challenge-frame" class="xref">PATH_CHALLENGE Frame</a><a href="#section-toc.1-1.19.2.17.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.18">
                <p id="section-toc.1-1.19.2.18.1"><a href="#section-19.18" class="xref">19.18</a>. <a href="#name-path_response-frame" class="xref">PATH_RESPONSE Frame</a><a href="#section-toc.1-1.19.2.18.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.19">
                <p id="section-toc.1-1.19.2.19.1"><a href="#section-19.19" class="xref">19.19</a>. <a href="#name-connection_close-frames" class="xref">CONNECTION_CLOSE Frames</a><a href="#section-toc.1-1.19.2.19.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.20">
                <p id="section-toc.1-1.19.2.20.1"><a href="#section-19.20" class="xref">19.20</a>. <a href="#name-handshake_done-frame" class="xref">HANDSHAKE_DONE frame</a><a href="#section-toc.1-1.19.2.20.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.19.2.21">
                <p id="section-toc.1-1.19.2.21.1"><a href="#section-19.21" class="xref">19.21</a>. <a href="#name-extension-frames" class="xref">Extension Frames</a><a href="#section-toc.1-1.19.2.21.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.20">
            <p id="section-toc.1-1.20.1"><a href="#section-20" class="xref">20</a>. <a href="#name-transport-error-codes" class="xref">Transport Error Codes</a><a href="#section-toc.1-1.20.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.20.2.1">
                <p id="section-toc.1-1.20.2.1.1"><a href="#section-20.1" class="xref">20.1</a>.  <a href="#name-application-protocol-error-" class="xref">Application Protocol Error Codes</a><a href="#section-toc.1-1.20.2.1.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.21">
            <p id="section-toc.1-1.21.1"><a href="#section-21" class="xref">21</a>. <a href="#name-security-considerations" class="xref">Security Considerations</a><a href="#section-toc.1-1.21.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.21.2.1">
                <p id="section-toc.1-1.21.2.1.1"><a href="#section-21.1" class="xref">21.1</a>.  <a href="#name-handshake-denial-of-service" class="xref">Handshake Denial of Service</a><a href="#section-toc.1-1.21.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.21.2.2">
                <p id="section-toc.1-1.21.2.2.1"><a href="#section-21.2" class="xref">21.2</a>.  <a href="#name-amplification-attack" class="xref">Amplification Attack</a><a href="#section-toc.1-1.21.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.21.2.3">
                <p id="section-toc.1-1.21.2.3.1"><a href="#section-21.3" class="xref">21.3</a>.  <a href="#name-optimistic-ack-attack" class="xref">Optimistic ACK Attack</a><a href="#section-toc.1-1.21.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.21.2.4">
                <p id="section-toc.1-1.21.2.4.1"><a href="#section-21.4" class="xref">21.4</a>.  <a href="#name-slowloris-attacks" class="xref">Slowloris Attacks</a><a href="#section-toc.1-1.21.2.4.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.21.2.5">
                <p id="section-toc.1-1.21.2.5.1"><a href="#section-21.5" class="xref">21.5</a>.  <a href="#name-stream-fragmentation-and-re" class="xref">Stream Fragmentation and Reassembly Attacks</a><a href="#section-toc.1-1.21.2.5.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.21.2.6">
                <p id="section-toc.1-1.21.2.6.1"><a href="#section-21.6" class="xref">21.6</a>.  <a href="#name-stream-commitment-attack" class="xref">Stream Commitment Attack</a><a href="#section-toc.1-1.21.2.6.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.21.2.7">
                <p id="section-toc.1-1.21.2.7.1"><a href="#section-21.7" class="xref">21.7</a>.  <a href="#name-peer-denial-of-service" class="xref">Peer Denial of Service</a><a href="#section-toc.1-1.21.2.7.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.21.2.8">
                <p id="section-toc.1-1.21.2.8.1"><a href="#section-21.8" class="xref">21.8</a>.  <a href="#name-explicit-congestion-notifica" class="xref">Explicit Congestion Notification Attacks</a><a href="#section-toc.1-1.21.2.8.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.21.2.9">
                <p id="section-toc.1-1.21.2.9.1"><a href="#section-21.9" class="xref">21.9</a>.  <a href="#name-stateless-reset-oracle" class="xref">Stateless Reset Oracle</a><a href="#section-toc.1-1.21.2.9.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.21.2.10">
                <p id="section-toc.1-1.21.2.10.1"><a href="#section-21.10" class="xref">21.10</a>. <a href="#name-version-downgrade" class="xref">Version Downgrade</a><a href="#section-toc.1-1.21.2.10.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.21.2.11">
                <p id="section-toc.1-1.21.2.11.1"><a href="#section-21.11" class="xref">21.11</a>. <a href="#name-targeted-attacks-by-routing" class="xref">Targeted Attacks by Routing</a><a href="#section-toc.1-1.21.2.11.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.21.2.12">
                <p id="section-toc.1-1.21.2.12.1"><a href="#section-21.12" class="xref">21.12</a>. <a href="#name-overview-of-security-proper" class="xref">Overview of Security Properties</a><a href="#section-toc.1-1.21.2.12.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.21.2.12.2.1">
                    <p id="section-toc.1-1.21.2.12.2.1.1"><a href="#section-21.12.1" class="xref">21.12.1</a>.  <a href="#name-handshake" class="xref">Handshake</a><a href="#section-toc.1-1.21.2.12.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.21.2.12.2.2">
                    <p id="section-toc.1-1.21.2.12.2.2.1"><a href="#section-21.12.2" class="xref">21.12.2</a>.  <a href="#name-protected-packets-2" class="xref">Protected Packets</a><a href="#section-toc.1-1.21.2.12.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.21.2.12.2.3">
                    <p id="section-toc.1-1.21.2.12.2.3.1"><a href="#section-21.12.3" class="xref">21.12.3</a>.  <a href="#name-connection-migration-2" class="xref">Connection Migration</a><a href="#section-toc.1-1.21.2.12.2.3.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.22">
            <p id="section-toc.1-1.22.1"><a href="#section-22" class="xref">22</a>. <a href="#name-iana-considerations" class="xref">IANA Considerations</a><a href="#section-toc.1-1.22.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.22.2.1">
                <p id="section-toc.1-1.22.2.1.1"><a href="#section-22.1" class="xref">22.1</a>.  <a href="#name-registration-policies-for-q" class="xref">Registration Policies for QUIC Registries</a><a href="#section-toc.1-1.22.2.1.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.22.2.1.2.1">
                    <p id="section-toc.1-1.22.2.1.2.1.1"><a href="#section-22.1.1" class="xref">22.1.1</a>.  <a href="#name-provisional-registrations" class="xref">Provisional Registrations</a><a href="#section-toc.1-1.22.2.1.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.22.2.1.2.2">
                    <p id="section-toc.1-1.22.2.1.2.2.1"><a href="#section-22.1.2" class="xref">22.1.2</a>.  <a href="#name-selecting-codepoints" class="xref">Selecting Codepoints</a><a href="#section-toc.1-1.22.2.1.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.22.2.1.2.3">
                    <p id="section-toc.1-1.22.2.1.2.3.1"><a href="#section-22.1.3" class="xref">22.1.3</a>.  <a href="#name-reclaiming-provisional-code" class="xref">Reclaiming Provisional Codepoints</a><a href="#section-toc.1-1.22.2.1.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.22.2.1.2.4">
                    <p id="section-toc.1-1.22.2.1.2.4.1"><a href="#section-22.1.4" class="xref">22.1.4</a>.  <a href="#name-permanent-registrations" class="xref">Permanent Registrations</a><a href="#section-toc.1-1.22.2.1.2.4.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.22.2.2">
                <p id="section-toc.1-1.22.2.2.1"><a href="#section-22.2" class="xref">22.2</a>.  <a href="#name-quic-transport-parameter-re" class="xref">QUIC Transport Parameter Registry</a><a href="#section-toc.1-1.22.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.22.2.3">
                <p id="section-toc.1-1.22.2.3.1"><a href="#section-22.3" class="xref">22.3</a>.  <a href="#name-quic-frame-type-registry" class="xref">QUIC Frame Type Registry</a><a href="#section-toc.1-1.22.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.22.2.4">
                <p id="section-toc.1-1.22.2.4.1"><a href="#section-22.4" class="xref">22.4</a>.  <a href="#name-quic-transport-error-codes-" class="xref">QUIC Transport Error Codes Registry</a><a href="#section-toc.1-1.22.2.4.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.23">
            <p id="section-toc.1-1.23.1"><a href="#section-23" class="xref">23</a>. <a href="#name-references" class="xref">References</a><a href="#section-toc.1-1.23.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.23.2.1">
                <p id="section-toc.1-1.23.2.1.1"><a href="#section-23.1" class="xref">23.1</a>.  <a href="#name-normative-references" class="xref">Normative References</a><a href="#section-toc.1-1.23.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.23.2.2">
                <p id="section-toc.1-1.23.2.2.1"><a href="#section-23.2" class="xref">23.2</a>.  <a href="#name-informative-references" class="xref">Informative References</a><a href="#section-toc.1-1.23.2.2.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.24">
            <p id="section-toc.1-1.24.1"><a href="#section-appendix.a" class="xref">Appendix A</a>.  <a href="#name-sample-packet-number-decodi" class="xref">Sample Packet Number Decoding Algorithm</a><a href="#section-toc.1-1.24.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.25">
            <p id="section-toc.1-1.25.1"><a href="#section-appendix.b" class="xref">Appendix B</a>.  <a href="#name-sample-ecn-validation-algor" class="xref">Sample ECN Validation Algorithm</a><a href="#section-toc.1-1.25.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26">
            <p id="section-toc.1-1.26.1"><a href="#section-appendix.c" class="xref">Appendix C</a>.  <a href="#name-change-log" class="xref">Change Log</a><a href="#section-toc.1-1.26.1" class="pilcrow">¶</a></p>
<ul class="toc ulEmpty">
<li class="toc ulEmpty" id="section-toc.1-1.26.2.1">
                <p id="section-toc.1-1.26.2.1.1"><a href="#section-c.1" class="xref">C.1</a>.  <a href="#name-since-draft-ietf-quic-trans" class="xref">Since draft-ietf-quic-transport-27</a><a href="#section-toc.1-1.26.2.1.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.2">
                <p id="section-toc.1-1.26.2.2.1"><a href="#section-c.2" class="xref">C.2</a>.  <a href="#name-since-draft-ietf-quic-transp" class="xref">Since draft-ietf-quic-transport-26</a><a href="#section-toc.1-1.26.2.2.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.3">
                <p id="section-toc.1-1.26.2.3.1"><a href="#section-c.3" class="xref">C.3</a>.  <a href="#name-since-draft-ietf-quic-transpo" class="xref">Since draft-ietf-quic-transport-25</a><a href="#section-toc.1-1.26.2.3.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.4">
                <p id="section-toc.1-1.26.2.4.1"><a href="#section-c.4" class="xref">C.4</a>.  <a href="#name-since-draft-ietf-quic-transpor" class="xref">Since draft-ietf-quic-transport-24</a><a href="#section-toc.1-1.26.2.4.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.5">
                <p id="section-toc.1-1.26.2.5.1"><a href="#section-c.5" class="xref">C.5</a>.  <a href="#name-since-draft-ietf-quic-transport" class="xref">Since draft-ietf-quic-transport-23</a><a href="#section-toc.1-1.26.2.5.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.6">
                <p id="section-toc.1-1.26.2.6.1"><a href="#section-c.6" class="xref">C.6</a>.  <a href="#name-since-draft-ietf-quic-transport-" class="xref">Since draft-ietf-quic-transport-22</a><a href="#section-toc.1-1.26.2.6.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.7">
                <p id="section-toc.1-1.26.2.7.1"><a href="#section-c.7" class="xref">C.7</a>.  <a href="#name-since-draft-ietf-quic-transport-2" class="xref">Since draft-ietf-quic-transport-21</a><a href="#section-toc.1-1.26.2.7.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.8">
                <p id="section-toc.1-1.26.2.8.1"><a href="#section-c.8" class="xref">C.8</a>.  <a href="#name-since-draft-ietf-quic-transport-20" class="xref">Since draft-ietf-quic-transport-20</a><a href="#section-toc.1-1.26.2.8.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.9">
                <p id="section-toc.1-1.26.2.9.1"><a href="#section-c.9" class="xref">C.9</a>.  <a href="#name-since-draft-ietf-quic-transport-1" class="xref">Since draft-ietf-quic-transport-19</a><a href="#section-toc.1-1.26.2.9.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.10">
                <p id="section-toc.1-1.26.2.10.1"><a href="#section-c.10" class="xref">C.10</a>. <a href="#name-since-draft-ietf-quic-transport-18" class="xref">Since draft-ietf-quic-transport-18</a><a href="#section-toc.1-1.26.2.10.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.11">
                <p id="section-toc.1-1.26.2.11.1"><a href="#section-c.11" class="xref">C.11</a>. <a href="#name-since-draft-ietf-quic-transport-17" class="xref">Since draft-ietf-quic-transport-17</a><a href="#section-toc.1-1.26.2.11.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.12">
                <p id="section-toc.1-1.26.2.12.1"><a href="#section-c.12" class="xref">C.12</a>. <a href="#name-since-draft-ietf-quic-transport-16" class="xref">Since draft-ietf-quic-transport-16</a><a href="#section-toc.1-1.26.2.12.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.13">
                <p id="section-toc.1-1.26.2.13.1"><a href="#section-c.13" class="xref">C.13</a>. <a href="#name-since-draft-ietf-quic-transport-15" class="xref">Since draft-ietf-quic-transport-15</a><a href="#section-toc.1-1.26.2.13.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.14">
                <p id="section-toc.1-1.26.2.14.1"><a href="#section-c.14" class="xref">C.14</a>. <a href="#name-since-draft-ietf-quic-transport-14" class="xref">Since draft-ietf-quic-transport-14</a><a href="#section-toc.1-1.26.2.14.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.15">
                <p id="section-toc.1-1.26.2.15.1"><a href="#section-c.15" class="xref">C.15</a>. <a href="#name-since-draft-ietf-quic-transport-13" class="xref">Since draft-ietf-quic-transport-13</a><a href="#section-toc.1-1.26.2.15.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.16">
                <p id="section-toc.1-1.26.2.16.1"><a href="#section-c.16" class="xref">C.16</a>. <a href="#name-since-draft-ietf-quic-transport-12" class="xref">Since draft-ietf-quic-transport-12</a><a href="#section-toc.1-1.26.2.16.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.17">
                <p id="section-toc.1-1.26.2.17.1"><a href="#section-c.17" class="xref">C.17</a>. <a href="#name-since-draft-ietf-quic-transport-11" class="xref">Since draft-ietf-quic-transport-11</a><a href="#section-toc.1-1.26.2.17.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.18">
                <p id="section-toc.1-1.26.2.18.1"><a href="#section-c.18" class="xref">C.18</a>. <a href="#name-since-draft-ietf-quic-transport-10" class="xref">Since draft-ietf-quic-transport-10</a><a href="#section-toc.1-1.26.2.18.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.19">
                <p id="section-toc.1-1.26.2.19.1"><a href="#section-c.19" class="xref">C.19</a>. <a href="#name-since-draft-ietf-quic-transport-0" class="xref">Since draft-ietf-quic-transport-09</a><a href="#section-toc.1-1.26.2.19.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.20">
                <p id="section-toc.1-1.26.2.20.1"><a href="#section-c.20" class="xref">C.20</a>. <a href="#name-since-draft-ietf-quic-transport-08" class="xref">Since draft-ietf-quic-transport-08</a><a href="#section-toc.1-1.26.2.20.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.21">
                <p id="section-toc.1-1.26.2.21.1"><a href="#section-c.21" class="xref">C.21</a>. <a href="#name-since-draft-ietf-quic-transport-07" class="xref">Since draft-ietf-quic-transport-07</a><a href="#section-toc.1-1.26.2.21.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.22">
                <p id="section-toc.1-1.26.2.22.1"><a href="#section-c.22" class="xref">C.22</a>. <a href="#name-since-draft-ietf-quic-transport-06" class="xref">Since draft-ietf-quic-transport-06</a><a href="#section-toc.1-1.26.2.22.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.23">
                <p id="section-toc.1-1.26.2.23.1"><a href="#section-c.23" class="xref">C.23</a>. <a href="#name-since-draft-ietf-quic-transport-05" class="xref">Since draft-ietf-quic-transport-05</a><a href="#section-toc.1-1.26.2.23.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.24">
                <p id="section-toc.1-1.26.2.24.1"><a href="#section-c.24" class="xref">C.24</a>. <a href="#name-since-draft-ietf-quic-transport-04" class="xref">Since draft-ietf-quic-transport-04</a><a href="#section-toc.1-1.26.2.24.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.25">
                <p id="section-toc.1-1.26.2.25.1"><a href="#section-c.25" class="xref">C.25</a>. <a href="#name-since-draft-ietf-quic-transport-03" class="xref">Since draft-ietf-quic-transport-03</a><a href="#section-toc.1-1.26.2.25.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.26">
                <p id="section-toc.1-1.26.2.26.1"><a href="#section-c.26" class="xref">C.26</a>. <a href="#name-since-draft-ietf-quic-transport-02" class="xref">Since draft-ietf-quic-transport-02</a><a href="#section-toc.1-1.26.2.26.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.27">
                <p id="section-toc.1-1.26.2.27.1"><a href="#section-c.27" class="xref">C.27</a>. <a href="#name-since-draft-ietf-quic-transport-01" class="xref">Since draft-ietf-quic-transport-01</a><a href="#section-toc.1-1.26.2.27.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.28">
                <p id="section-toc.1-1.26.2.28.1"><a href="#section-c.28" class="xref">C.28</a>. <a href="#name-since-draft-ietf-quic-transport-00" class="xref">Since draft-ietf-quic-transport-00</a><a href="#section-toc.1-1.26.2.28.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.26.2.29">
                <p id="section-toc.1-1.26.2.29.1"><a href="#section-c.29" class="xref">C.29</a>. <a href="#name-since-draft-hamilton-quic-t" class="xref">Since draft-hamilton-quic-transport-protocol-01</a><a href="#section-toc.1-1.26.2.29.1" class="pilcrow">¶</a></p>
</li>
</ul>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.27">
            <p id="section-toc.1-1.27.1"><a href="#section-appendix.d" class="xref"></a><a href="#name-contributors" class="xref">Contributors</a><a href="#section-toc.1-1.27.1" class="pilcrow">¶</a></p>
</li>
<li class="toc ulEmpty" id="section-toc.1-1.28">
            <p id="section-toc.1-1.28.1"><a href="#section-appendix.e" class="xref"></a><a href="#name-authors-addresses" class="xref">Authors' Addresses</a><a href="#section-toc.1-1.28.1" class="pilcrow">¶</a></p>
</li>
</ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">QUIC is a multiplexed and secure general-purpose transport protocol that
provides:<a href="#section-1-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-1-2.1">Stream multiplexing<a href="#section-1-2.1" class="pilcrow">¶</a>
</li>
<li id="section-1-2.2">Stream and connection-level flow control<a href="#section-1-2.2" class="pilcrow">¶</a>
</li>
<li id="section-1-2.3">Low-latency connection establishment<a href="#section-1-2.3" class="pilcrow">¶</a>
</li>
<li id="section-1-2.4">Connection migration and resilience to NAT rebinding<a href="#section-1-2.4" class="pilcrow">¶</a>
</li>
<li id="section-1-2.5">Authenticated and encrypted header and payload<a href="#section-1-2.5" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-1-3">QUIC uses UDP as a substrate to avoid requiring changes to legacy client
operating systems and middleboxes.  QUIC authenticates all of its headers and
encrypts most of the data it exchanges, including its signaling, to avoid
incurring a dependency on middleboxes.<a href="#section-1-3" class="pilcrow">¶</a></p>
<div id="document-structure">
<section id="section-1.1">
        <h3 id="name-document-structure">
<a href="#section-1.1" class="section-number selfRef">1.1. </a><a href="#name-document-structure" class="section-name selfRef">Document Structure</a>
        </h3>
<p id="section-1.1-1">This document describes the core QUIC protocol and is structured as follows:<a href="#section-1.1-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-1.1-2.1">
            <p id="section-1.1-2.1.1">Streams are the basic service abstraction that QUIC provides.<a href="#section-1.1-2.1.1" class="pilcrow">¶</a></p>
<ul>
<li id="section-1.1-2.1.2.1">
                <a href="#streams" class="xref">Section 2</a> describes core concepts related to streams,<a href="#section-1.1-2.1.2.1" class="pilcrow">¶</a>
</li>
<li id="section-1.1-2.1.2.2">
                <a href="#stream-states" class="xref">Section 3</a> provides a reference model for stream states, and<a href="#section-1.1-2.1.2.2" class="pilcrow">¶</a>
</li>
<li id="section-1.1-2.1.2.3">
                <a href="#flow-control" class="xref">Section 4</a> outlines the operation of flow control.<a href="#section-1.1-2.1.2.3" class="pilcrow">¶</a>
</li>
</ul>
</li>
<li id="section-1.1-2.2">
            <p id="section-1.1-2.2.1">Connections are the context in which QUIC endpoints communicate.<a href="#section-1.1-2.2.1" class="pilcrow">¶</a></p>
<ul>
<li id="section-1.1-2.2.2.1">
                <a href="#connections" class="xref">Section 5</a> describes core concepts related to connections,<a href="#section-1.1-2.2.2.1" class="pilcrow">¶</a>
</li>
<li id="section-1.1-2.2.2.2">
                <a href="#version-negotiation" class="xref">Section 6</a> describes version negotiation,<a href="#section-1.1-2.2.2.2" class="pilcrow">¶</a>
</li>
<li id="section-1.1-2.2.2.3">
                <a href="#handshake" class="xref">Section 7</a> details the process for establishing connections,<a href="#section-1.1-2.2.2.3" class="pilcrow">¶</a>
</li>
<li id="section-1.1-2.2.2.4">
                <a href="#address-validation" class="xref">Section 8</a> specifies critical denial of service mitigation
mechanisms,<a href="#section-1.1-2.2.2.4" class="pilcrow">¶</a>
</li>
<li id="section-1.1-2.2.2.5">
                <a href="#migration" class="xref">Section 9</a> describes how endpoints migrate a connection to a new
network path,<a href="#section-1.1-2.2.2.5" class="pilcrow">¶</a>
</li>
<li id="section-1.1-2.2.2.6">
                <a href="#termination" class="xref">Section 10</a> lists the options for terminating an open connection, and<a href="#section-1.1-2.2.2.6" class="pilcrow">¶</a>
</li>
<li id="section-1.1-2.2.2.7">
                <a href="#error-handling" class="xref">Section 11</a> provides general guidance for error handling.<a href="#section-1.1-2.2.2.7" class="pilcrow">¶</a>
</li>
</ul>
</li>
<li id="section-1.1-2.3">
            <p id="section-1.1-2.3.1">Packets and frames are the basic unit used by QUIC to communicate.<a href="#section-1.1-2.3.1" class="pilcrow">¶</a></p>
<ul>
<li id="section-1.1-2.3.2.1">
                <a href="#packets-frames" class="xref">Section 12</a> describes concepts related to packets and frames,<a href="#section-1.1-2.3.2.1" class="pilcrow">¶</a>
</li>
<li id="section-1.1-2.3.2.2">
                <a href="#packetization" class="xref">Section 13</a> defines models for the transmission, retransmission, and
acknowledgement of data, and<a href="#section-1.1-2.3.2.2" class="pilcrow">¶</a>
</li>
<li id="section-1.1-2.3.2.3">
                <a href="#packet-size" class="xref">Section 14</a> specifies rules for managing the size of packets.<a href="#section-1.1-2.3.2.3" class="pilcrow">¶</a>
</li>
</ul>
</li>
<li id="section-1.1-2.4">
            <p id="section-1.1-2.4.1">Finally, encoding details of QUIC protocol elements are described in:<a href="#section-1.1-2.4.1" class="pilcrow">¶</a></p>
<ul>
<li id="section-1.1-2.4.2.1">
                <a href="#versions" class="xref">Section 15</a> (Versions),<a href="#section-1.1-2.4.2.1" class="pilcrow">¶</a>
</li>
<li id="section-1.1-2.4.2.2">
                <a href="#integer-encoding" class="xref">Section 16</a> (Integer Encoding),<a href="#section-1.1-2.4.2.2" class="pilcrow">¶</a>
</li>
<li id="section-1.1-2.4.2.3">
                <a href="#packet-formats" class="xref">Section 17</a> (Packet Headers),<a href="#section-1.1-2.4.2.3" class="pilcrow">¶</a>
</li>
<li id="section-1.1-2.4.2.4">
                <a href="#transport-parameter-encoding" class="xref">Section 18</a> (Transport Parameters),<a href="#section-1.1-2.4.2.4" class="pilcrow">¶</a>
</li>
<li id="section-1.1-2.4.2.5">
                <a href="#frame-formats" class="xref">Section 19</a> (Frames), and<a href="#section-1.1-2.4.2.5" class="pilcrow">¶</a>
</li>
<li id="section-1.1-2.4.2.6">
                <a href="#error-codes" class="xref">Section 20</a> (Errors).<a href="#section-1.1-2.4.2.6" class="pilcrow">¶</a>
</li>
</ul>
</li>
</ul>
<p id="section-1.1-3">Accompanying documents describe QUIC's loss detection and congestion control
<span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span>, and the use of TLS for key negotiation <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>.<a href="#section-1.1-3" class="pilcrow">¶</a></p>
<p id="section-1.1-4">This document defines QUIC version 1, which conforms to the protocol invariants
in <span>[<a href="#QUIC-INVARIANTS" class="xref">QUIC-INVARIANTS</a>]</span>.<a href="#section-1.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="terms-and-definitions">
<section id="section-1.2">
        <h3 id="name-terms-and-definitions">
<a href="#section-1.2" class="section-number selfRef">1.2. </a><a href="#name-terms-and-definitions" class="section-name selfRef">Terms and Definitions</a>
        </h3>
<p id="section-1.2-1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED",
"MAY", and "OPTIONAL" in this document are to be interpreted as
described in BCP 14 <span>[<a href="#RFC2119" class="xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="xref">RFC8174</a>]</span> when, and only when, they
appear in all capitals, as shown here.<a href="#section-1.2-1" class="pilcrow">¶</a></p>
<p id="section-1.2-2">Commonly used terms in the document are described below.<a href="#section-1.2-2" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-1.2-3">
          <dt id="section-1.2-3.1">QUIC:</dt>
<dd id="section-1.2-3.2">
  The transport protocol described by this document. QUIC is a name, not an
acronym.<a href="#section-1.2-3.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-1.2-3.3">QUIC packet:</dt>
<dd id="section-1.2-3.4">
  A complete processable unit of QUIC that can be encapsulated in a UDP
datagram.  Multiple QUIC packets can be encapsulated in a single UDP datagram.<a href="#section-1.2-3.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-1.2-3.5">Ack-eliciting Packet:</dt>
<dd id="section-1.2-3.6">
  A QUIC packet that contains frames other than ACK, PADDING, and
CONNECTION_CLOSE. These cause a recipient to send an acknowledgment; see
<a href="#sending-acknowledgements" class="xref">Section 13.2.1</a>.<a href="#section-1.2-3.6" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-1.2-3.7">Out-of-order packet:</dt>
<dd id="section-1.2-3.8">
  A packet that does not increase the largest received packet number for its
packet number space (<a href="#packet-numbers" class="xref">Section 12.3</a>) by exactly one. A packet can arrive
out of order if it is delayed, if earlier packets are lost or delayed, or if
the sender intentionally skips a packet number.<a href="#section-1.2-3.8" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-1.2-3.9">Endpoint:</dt>
<dd id="section-1.2-3.10">
  An entity that can participate in a QUIC connection by generating,
receiving, and processing QUIC packets. There are only two types of endpoint
in QUIC: client and server.<a href="#section-1.2-3.10" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-1.2-3.11">Client:</dt>
<dd id="section-1.2-3.12">
  The endpoint initiating a QUIC connection.<a href="#section-1.2-3.12" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-1.2-3.13">Server:</dt>
<dd id="section-1.2-3.14">
  The endpoint accepting incoming QUIC connections.<a href="#section-1.2-3.14" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-1.2-3.15">Address:</dt>
<dd id="section-1.2-3.16">
  When used without qualification, the tuple of IP version, IP address, UDP
protocol, and UDP port number that represents one end of a network path.<a href="#section-1.2-3.16" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-1.2-3.17">Connection ID:</dt>
<dd id="section-1.2-3.18">
  An opaque identifier that is used to identify a QUIC connection at an
endpoint.  Each endpoint sets a value for its peer to include in packets sent
towards the endpoint.<a href="#section-1.2-3.18" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-1.2-3.19">Stream:</dt>
<dd id="section-1.2-3.20">
  A unidirectional or bidirectional channel of ordered bytes within a QUIC
connection. A QUIC connection can carry multiple simultaneous streams.<a href="#section-1.2-3.20" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-1.2-3.21">Application:</dt>
<dd id="section-1.2-3.22">
  An entity that uses QUIC to send and receive data.<a href="#section-1.2-3.22" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
</section>
</div>
<div id="notational-conventions">
<section id="section-1.3">
        <h3 id="name-notational-conventions">
<a href="#section-1.3" class="section-number selfRef">1.3. </a><a href="#name-notational-conventions" class="section-name selfRef">Notational Conventions</a>
        </h3>
<p id="section-1.3-1">Packet and frame diagrams in this document use a bespoke format. The purpose of
this format is to summarize, not define, protocol elements. Prose defines the
complete semantics and details of structures.<a href="#section-1.3-1" class="pilcrow">¶</a></p>
<p id="section-1.3-2">Complex fields are named and then followed by a list of fields surrounded by a
pair of matching braces. Each field in this list is separated by commas.<a href="#section-1.3-2" class="pilcrow">¶</a></p>
<p id="section-1.3-3">Individual fields include length information, plus indications about fixed
value, optionality, or repetitions. Individual fields use the following
notational conventions, with all lengths in bits:<a href="#section-1.3-3" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-1.3-4">
          <dt id="section-1.3-4.1">x (A):</dt>
<dd id="section-1.3-4.2">
  Indicates that x is A bits long<a href="#section-1.3-4.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-1.3-4.3">x (i):</dt>
<dd id="section-1.3-4.4">
  Indicates that x uses the variable-length encoding in <a href="#integer-encoding" class="xref">Section 16</a><a href="#section-1.3-4.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-1.3-4.5">x (A..B):</dt>
<dd id="section-1.3-4.6">
  Indicates that x can be any length from A to B; A can be omitted to indicate
a minimum of zero bits and B can be omitted to indicate no set upper limit;
values in this format always end on an octet boundary<a href="#section-1.3-4.6" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-1.3-4.7">x (?) = C:</dt>
<dd id="section-1.3-4.8">
  Indicates that x has a fixed value of C<a href="#section-1.3-4.8" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-1.3-4.9">x (?) = C..D:</dt>
<dd id="section-1.3-4.10">
  Indicates that x has a value in the range from C to D, inclusive<a href="#section-1.3-4.10" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-1.3-4.11">[x (E)]:</dt>
<dd id="section-1.3-4.12">
  Indicates that x is optional (and has length of E)<a href="#section-1.3-4.12" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-1.3-4.13">x (E) ...:</dt>
<dd id="section-1.3-4.14">
  Indicates that x is repeated zero or more times (and that each instance is
length E)<a href="#section-1.3-4.14" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-1.3-5">By convention, individual fields reference a complex field by using the name of
the complex field.<a href="#section-1.3-5" class="pilcrow">¶</a></p>
<p id="section-1.3-6">For example:<a href="#section-1.3-6" class="pilcrow">¶</a></p>
<span id="name-example-format"></span><div id="fig-ex-format">
<figure id="figure-1">
          <div class="artwork art-text alignLeft" id="section-1.3-7.1">
<pre>
Example Structure {
  One-bit Field (1),
  7-bit Field with Fixed Value (7) = 61,
  Arbitrary-Length Field (..),
  Variable-Length Field (8..24),
  Field With Minimum Length (16..),
  Field With Maximum Length (..128),
  [Optional Field (64)],
  Repeated Field (8) ...,
}
</pre>
</div>
<figcaption><a href="#figure-1" class="selfRef">Figure 1</a>:
<a href="#name-example-format" class="selfRef">Example Format</a>
          </figcaption></figure>
</div>
</section>
</div>
</section>
</div>
<div id="streams">
<section id="section-2">
      <h2 id="name-streams">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-streams" class="section-name selfRef">Streams</a>
      </h2>
<p id="section-2-1">Streams in QUIC provide a lightweight, ordered byte-stream abstraction to an
application. Streams can be unidirectional or bidirectional.  An alternative
view of QUIC unidirectional streams is a "message" abstraction of practically
unlimited length.<a href="#section-2-1" class="pilcrow">¶</a></p>
<p id="section-2-2">Streams can be created by sending data. Other processes associated with stream
management - ending, cancelling, and managing flow control - are all designed to
impose minimal overheads. For instance, a single STREAM frame (<a href="#frame-stream" class="xref">Section 19.8</a>)
can open, carry data for, and close a stream. Streams can also be long-lived and
can last the entire duration of a connection.<a href="#section-2-2" class="pilcrow">¶</a></p>
<p id="section-2-3">Streams can be created by either endpoint, can concurrently send data
interleaved with other streams, and can be cancelled. QUIC does not provide any
means of ensuring ordering between bytes on different streams.<a href="#section-2-3" class="pilcrow">¶</a></p>
<p id="section-2-4">QUIC allows for an arbitrary number of streams to operate concurrently and for
an arbitrary amount of data to be sent on any stream, subject to flow control
constraints and stream limits; see <a href="#flow-control" class="xref">Section 4</a>.<a href="#section-2-4" class="pilcrow">¶</a></p>
<div id="stream-id">
<section id="section-2.1">
        <h3 id="name-stream-types-and-identifier">
<a href="#section-2.1" class="section-number selfRef">2.1. </a><a href="#name-stream-types-and-identifier" class="section-name selfRef">Stream Types and Identifiers</a>
        </h3>
<p id="section-2.1-1">Streams can be unidirectional or bidirectional.  Unidirectional streams carry
data in one direction: from the initiator of the stream to its peer.
Bidirectional streams allow for data to be sent in both directions.<a href="#section-2.1-1" class="pilcrow">¶</a></p>
<p id="section-2.1-2">Streams are identified within a connection by a numeric value, referred to as
the stream ID.  A stream ID is a 62-bit integer (0 to 2^62-1) that is unique for
all streams on a connection.  Stream IDs are encoded as variable-length
integers; see <a href="#integer-encoding" class="xref">Section 16</a>.  A QUIC endpoint MUST NOT reuse a stream ID
within a connection.<a href="#section-2.1-2" class="pilcrow">¶</a></p>
<p id="section-2.1-3">The least significant bit (0x1) of the stream ID identifies the initiator of the
stream.  Client-initiated streams have even-numbered stream IDs (with the bit
set to 0), and server-initiated streams have odd-numbered stream IDs (with the
bit set to 1).<a href="#section-2.1-3" class="pilcrow">¶</a></p>
<p id="section-2.1-4">The second least significant bit (0x2) of the stream ID distinguishes between
bidirectional streams (with the bit set to 0) and unidirectional streams (with
the bit set to 1).<a href="#section-2.1-4" class="pilcrow">¶</a></p>
<p id="section-2.1-5">The least significant two bits from a stream ID therefore identify a stream as
one of four types, as summarized in <a href="#stream-id-types" class="xref">Table 1</a>.<a href="#section-2.1-5" class="pilcrow">¶</a></p>
<span id="name-stream-id-types"></span><div id="stream-id-types">
<table class="center" id="table-1">
          <caption>
<a href="#table-1" class="selfRef">Table 1</a>:
<a href="#name-stream-id-types" class="selfRef">Stream ID Types</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Bits</th>
              <th class="text-left" rowspan="1" colspan="1">Stream Type</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x0</td>
              <td class="text-left" rowspan="1" colspan="1">Client-Initiated, Bidirectional</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x1</td>
              <td class="text-left" rowspan="1" colspan="1">Server-Initiated, Bidirectional</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x2</td>
              <td class="text-left" rowspan="1" colspan="1">Client-Initiated, Unidirectional</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x3</td>
              <td class="text-left" rowspan="1" colspan="1">Server-Initiated, Unidirectional</td>
            </tr>
          </tbody>
        </table>
</div>
<p id="section-2.1-7">Within each type, streams are created with numerically increasing stream IDs.  A
stream ID that is used out of order results in all streams of that type with
lower-numbered stream IDs also being opened.<a href="#section-2.1-7" class="pilcrow">¶</a></p>
<p id="section-2.1-8">The first bidirectional stream opened by the client has a stream ID of 0.<a href="#section-2.1-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sending-and-receiving-data">
<section id="section-2.2">
        <h3 id="name-sending-and-receiving-data">
<a href="#section-2.2" class="section-number selfRef">2.2. </a><a href="#name-sending-and-receiving-data" class="section-name selfRef">Sending and Receiving Data</a>
        </h3>
<p id="section-2.2-1">STREAM frames (<a href="#frame-stream" class="xref">Section 19.8</a>) encapsulate data sent by an application. An
endpoint uses the Stream ID and Offset fields in STREAM frames to place data in
order.<a href="#section-2.2-1" class="pilcrow">¶</a></p>
<p id="section-2.2-2">Endpoints MUST be able to deliver stream data to an application as an ordered
byte-stream.  Delivering an ordered byte-stream requires that an endpoint buffer
any data that is received out of order, up to the advertised flow control limit.<a href="#section-2.2-2" class="pilcrow">¶</a></p>
<p id="section-2.2-3">QUIC makes no specific allowances for delivery of stream data out of
order. However, implementations MAY choose to offer the ability to deliver data
out of order to a receiving application.<a href="#section-2.2-3" class="pilcrow">¶</a></p>
<p id="section-2.2-4">An endpoint could receive data for a stream at the same stream offset multiple
times.  Data that has already been received can be discarded.  The data at a
given offset MUST NOT change if it is sent multiple times; an endpoint MAY treat
receipt of different data at the same offset within a stream as a connection
error of type PROTOCOL_VIOLATION.<a href="#section-2.2-4" class="pilcrow">¶</a></p>
<p id="section-2.2-5">Streams are an ordered byte-stream abstraction with no other structure visible
to QUIC.  STREAM frame boundaries are not expected to be preserved when
data is transmitted, retransmitted after packet loss, or delivered to the
application at a receiver.<a href="#section-2.2-5" class="pilcrow">¶</a></p>
<p id="section-2.2-6">An endpoint MUST NOT send data on any stream without ensuring that it is within
the flow control limits set by its peer.  Flow control is described in detail in
<a href="#flow-control" class="xref">Section 4</a>.<a href="#section-2.2-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="stream-prioritization">
<section id="section-2.3">
        <h3 id="name-stream-prioritization">
<a href="#section-2.3" class="section-number selfRef">2.3. </a><a href="#name-stream-prioritization" class="section-name selfRef">Stream Prioritization</a>
        </h3>
<p id="section-2.3-1">Stream multiplexing can have a significant effect on application performance if
resources allocated to streams are correctly prioritized.<a href="#section-2.3-1" class="pilcrow">¶</a></p>
<p id="section-2.3-2">QUIC does not provide a mechanism for exchanging prioritization information.
Instead, it relies on receiving priority information from the application that
uses QUIC.<a href="#section-2.3-2" class="pilcrow">¶</a></p>
<p id="section-2.3-3">A QUIC implementation SHOULD provide ways in which an application can indicate
the relative priority of streams.  When deciding which streams to dedicate
resources to, the implementation SHOULD use the information provided by the
application.<a href="#section-2.3-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="stream-operations">
<section id="section-2.4">
        <h3 id="name-required-operations-on-stre">
<a href="#section-2.4" class="section-number selfRef">2.4. </a><a href="#name-required-operations-on-stre" class="section-name selfRef">Required Operations on Streams</a>
        </h3>
<p id="section-2.4-1">There are certain operations which an application MUST be able to perform when
interacting with QUIC streams.  This document does not specify an API, but
any implementation of this version of QUIC MUST expose the ability to perform
the operations described in this section on a QUIC stream.<a href="#section-2.4-1" class="pilcrow">¶</a></p>
<p id="section-2.4-2">On the sending part of a stream, application protocols need to be able to:<a href="#section-2.4-2" class="pilcrow">¶</a></p>
<ul>
<li id="section-2.4-3.1">write data, understanding when stream flow control credit
(<a href="#data-flow-control" class="xref">Section 4.1</a>) has successfully been reserved to send the written
data;<a href="#section-2.4-3.1" class="pilcrow">¶</a>
</li>
<li id="section-2.4-3.2">end the stream (clean termination), resulting in a STREAM frame
(<a href="#frame-stream" class="xref">Section 19.8</a>) with the FIN bit set; and<a href="#section-2.4-3.2" class="pilcrow">¶</a>
</li>
<li id="section-2.4-3.3">reset the stream (abrupt termination), resulting in a RESET_STREAM frame
(<a href="#frame-reset-stream" class="xref">Section 19.4</a>), if the stream was not already in a terminal state.<a href="#section-2.4-3.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-2.4-4">On the receiving part of a stream, application protocols need to be able to:<a href="#section-2.4-4" class="pilcrow">¶</a></p>
<ul>
<li id="section-2.4-5.1">read data; and<a href="#section-2.4-5.1" class="pilcrow">¶</a>
</li>
<li id="section-2.4-5.2">abort reading of the stream and request closure, possibly resulting in a
STOP_SENDING frame (<a href="#frame-stop-sending" class="xref">Section 19.5</a>).<a href="#section-2.4-5.2" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-2.4-6">Applications also need to be informed of state changes on streams, including
when the peer has opened or reset a stream, when a peer aborts reading on a
stream, when new data is available, and when data can or cannot be written to
the stream due to flow control.<a href="#section-2.4-6" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="stream-states">
<section id="section-3">
      <h2 id="name-stream-states">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-stream-states" class="section-name selfRef">Stream States</a>
      </h2>
<p id="section-3-1">This section describes streams in terms of their send or receive components.
Two state machines are described: one for the streams on which an endpoint
transmits data (<a href="#stream-send-states" class="xref">Section 3.1</a>), and another for streams on which an
endpoint receives data (<a href="#stream-recv-states" class="xref">Section 3.2</a>).<a href="#section-3-1" class="pilcrow">¶</a></p>
<p id="section-3-2">Unidirectional streams use the applicable state machine directly.  Bidirectional
streams use both state machines.  For the most part, the use of these state
machines is the same whether the stream is unidirectional or bidirectional.  The
conditions for opening a stream are slightly more complex for a bidirectional
stream because the opening of either send or receive sides causes the stream
to open in both directions.<a href="#section-3-2" class="pilcrow">¶</a></p>
<p id="section-3-3">An endpoint MUST open streams of the same type in increasing order of stream ID.<a href="#section-3-3" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-3-4">
        <dt id="section-3-4.1">Note:</dt>
<dd id="section-3-4.2">
  These states are largely informative.  This document uses stream states to
describe rules for when and how different types of frames can be sent and the
reactions that are expected when different types of frames are received.
Though these state machines are intended to be useful in implementing QUIC,
these states aren't intended to constrain implementations.  An implementation
can define a different state machine as long as its behavior is consistent
with an implementation that implements these states.<a href="#section-3-4.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<div id="stream-send-states">
<section id="section-3.1">
        <h3 id="name-sending-stream-states">
<a href="#section-3.1" class="section-number selfRef">3.1. </a><a href="#name-sending-stream-states" class="section-name selfRef">Sending Stream States</a>
        </h3>
<p id="section-3.1-1"><a href="#fig-stream-send-states" class="xref">Figure 2</a> shows the states for the part of a stream that sends
data to a peer.<a href="#section-3.1-1" class="pilcrow">¶</a></p>
<span id="name-states-for-sending-parts-of"></span><div id="fig-stream-send-states">
<figure id="figure-2">
          <div class="artwork art-text alignLeft" id="section-3.1-2.1">
<pre>
       o
       | Create Stream (Sending)
       | Peer Creates Bidirectional Stream
       v
   +-------+
   | Ready | Send RESET_STREAM
   |       |-----------------------.
   +-------+                       |
       |                           |
       | Send STREAM /             |
       |      STREAM_DATA_BLOCKED  |
       |                           |
       | Peer Creates              |
       |      Bidirectional Stream |
       v                           |
   +-------+                       |
   | Send  | Send RESET_STREAM     |
   |       |----------------------&gt;|
   +-------+                       |
       |                           |
       | Send STREAM + FIN         |
       v                           v
   +-------+                   +-------+
   | Data  | Send RESET_STREAM | Reset |
   | Sent  |------------------&gt;| Sent  |
   +-------+                   +-------+
       |                           |
       | Recv All ACKs             | Recv ACK
       v                           v
   +-------+                   +-------+
   | Data  |                   | Reset |
   | Recvd |                   | Recvd |
   +-------+                   +-------+
</pre>
</div>
<figcaption><a href="#figure-2" class="selfRef">Figure 2</a>:
<a href="#name-states-for-sending-parts-of" class="selfRef">States for Sending Parts of Streams</a>
          </figcaption></figure>
</div>
<p id="section-3.1-3">The sending part of stream that the endpoint initiates (types 0
and 2 for clients, 1 and 3 for servers) is opened by the application.  The
"Ready" state represents a newly created stream that is able to accept data from
the application.  Stream data might be buffered in this state in preparation for
sending.<a href="#section-3.1-3" class="pilcrow">¶</a></p>
<p id="section-3.1-4">Sending the first STREAM or STREAM_DATA_BLOCKED frame causes a sending part of a
stream to enter the "Send" state.  An implementation might choose to defer
allocating a stream ID to a stream until it sends the first STREAM frame and
enters this state, which can allow for better stream prioritization.<a href="#section-3.1-4" class="pilcrow">¶</a></p>
<p id="section-3.1-5">The sending part of a bidirectional stream initiated by a peer (type 0 for a
server, type 1 for a client) starts in the "Ready" state when the receiving part
is created.<a href="#section-3.1-5" class="pilcrow">¶</a></p>
<p id="section-3.1-6">In the "Send" state, an endpoint transmits - and retransmits as necessary -
stream data in STREAM frames.  The endpoint respects the flow control limits set
by its peer, and continues to accept and process MAX_STREAM_DATA frames.  An
endpoint in the "Send" state generates STREAM_DATA_BLOCKED frames if it is
blocked from sending by stream or connection flow control limits
<a href="#data-flow-control" class="xref">Section 4.1</a>.<a href="#section-3.1-6" class="pilcrow">¶</a></p>
<p id="section-3.1-7">After the application indicates that all stream data has been sent and a STREAM
frame containing the FIN bit is sent, the sending part of the stream enters the
"Data Sent" state.  From this state, the endpoint only retransmits stream data
as necessary.  The endpoint does not need to check flow control limits or send
STREAM_DATA_BLOCKED frames for a stream in this state.  MAX_STREAM_DATA frames
might be received until the peer receives the final stream offset. The endpoint
can safely ignore any MAX_STREAM_DATA frames it receives from its peer for a
stream in this state.<a href="#section-3.1-7" class="pilcrow">¶</a></p>
<p id="section-3.1-8">Once all stream data has been successfully acknowledged, the sending part of the
stream enters the "Data Recvd" state, which is a terminal state.<a href="#section-3.1-8" class="pilcrow">¶</a></p>
<p id="section-3.1-9">From any of the "Ready", "Send", or "Data Sent" states, an application can
signal that it wishes to abandon transmission of stream data. Alternatively, an
endpoint might receive a STOP_SENDING frame from its peer.  In either case, the
endpoint sends a RESET_STREAM frame, which causes the stream to enter the "Reset
Sent" state.<a href="#section-3.1-9" class="pilcrow">¶</a></p>
<p id="section-3.1-10">An endpoint MAY send a RESET_STREAM as the first frame that mentions a stream;
this causes the sending part of that stream to open and then immediately
transition to the "Reset Sent" state.<a href="#section-3.1-10" class="pilcrow">¶</a></p>
<p id="section-3.1-11">Once a packet containing a RESET_STREAM has been acknowledged, the sending part
of the stream enters the "Reset Recvd" state, which is a terminal state.<a href="#section-3.1-11" class="pilcrow">¶</a></p>
</section>
</div>
<div id="stream-recv-states">
<section id="section-3.2">
        <h3 id="name-receiving-stream-states">
<a href="#section-3.2" class="section-number selfRef">3.2. </a><a href="#name-receiving-stream-states" class="section-name selfRef">Receiving Stream States</a>
        </h3>
<p id="section-3.2-1"><a href="#fig-stream-recv-states" class="xref">Figure 3</a> shows the states for the part of a stream that
receives data from a peer.  The states for a receiving part of a stream mirror
only some of the states of the sending part of the stream at the peer.  The
receiving part of a stream does not track states on the sending part that cannot
be observed, such as the "Ready" state.  Instead, the receiving part of a stream
tracks the delivery of data to the application, some of which cannot be observed
by the sender.<a href="#section-3.2-1" class="pilcrow">¶</a></p>
<span id="name-states-for-receiving-parts-"></span><div id="fig-stream-recv-states">
<figure id="figure-3">
          <div class="artwork art-text alignLeft" id="section-3.2-2.1">
<pre>
       o
       | Recv STREAM / STREAM_DATA_BLOCKED / RESET_STREAM
       | Create Bidirectional Stream (Sending)
       | Recv MAX_STREAM_DATA / STOP_SENDING (Bidirectional)
       | Create Higher-Numbered Stream
       v
   +-------+
   | Recv  | Recv RESET_STREAM
   |       |-----------------------.
   +-------+                       |
       |                           |
       | Recv STREAM + FIN         |
       v                           |
   +-------+                       |
   | Size  | Recv RESET_STREAM     |
   | Known |----------------------&gt;|
   +-------+                       |
       |                           |
       | Recv All Data             |
       v                           v
   +-------+ Recv RESET_STREAM +-------+
   | Data  |--- (optional) ---&gt;| Reset |
   | Recvd |  Recv All Data    | Recvd |
   +-------+&lt;-- (optional) ----+-------+
       |                           |
       | App Read All Data         | App Read RST
       v                           v
   +-------+                   +-------+
   | Data  |                   | Reset |
   | Read  |                   | Read  |
   +-------+                   +-------+
</pre>
</div>
<figcaption><a href="#figure-3" class="selfRef">Figure 3</a>:
<a href="#name-states-for-receiving-parts-" class="selfRef">States for Receiving Parts of Streams</a>
          </figcaption></figure>
</div>
<p id="section-3.2-3">The receiving part of a stream initiated by a peer (types 1 and 3 for a client,
or 0 and 2 for a server) is created when the first STREAM, STREAM_DATA_BLOCKED,
or RESET_STREAM is received for that stream.  For bidirectional streams
initiated by a peer, receipt of a MAX_STREAM_DATA or STOP_SENDING frame for the
sending part of the stream also creates the receiving part.  The initial state
for the receiving part of stream is "Recv".<a href="#section-3.2-3" class="pilcrow">¶</a></p>
<p id="section-3.2-4">The receiving part of a stream enters the "Recv" state when the sending part of
a bidirectional stream initiated by the endpoint (type 0 for a client, type 1
for a server) enters the "Ready" state.<a href="#section-3.2-4" class="pilcrow">¶</a></p>
<p id="section-3.2-5">An endpoint opens a bidirectional stream when a MAX_STREAM_DATA or STOP_SENDING
frame is received from the peer for that stream.  Receiving a MAX_STREAM_DATA
frame for an unopened stream indicates that the remote peer has opened the
stream and is providing flow control credit.  Receiving a STOP_SENDING frame for
an unopened stream indicates that the remote peer no longer wishes to receive
data on this stream.  Either frame might arrive before a STREAM or
STREAM_DATA_BLOCKED frame if packets are lost or reordered.<a href="#section-3.2-5" class="pilcrow">¶</a></p>
<p id="section-3.2-6">Before a stream is created, all streams of the same type with lower-numbered
stream IDs MUST be created.  This ensures that the creation order for streams is
consistent on both endpoints.<a href="#section-3.2-6" class="pilcrow">¶</a></p>
<p id="section-3.2-7">In the "Recv" state, the endpoint receives STREAM and STREAM_DATA_BLOCKED
frames.  Incoming data is buffered and can be reassembled into the correct order
for delivery to the application.  As data is consumed by the application and
buffer space becomes available, the endpoint sends MAX_STREAM_DATA frames to
allow the peer to send more data.<a href="#section-3.2-7" class="pilcrow">¶</a></p>
<p id="section-3.2-8">When a STREAM frame with a FIN bit is received, the final size of the stream is
known; see <a href="#final-size" class="xref">Section 4.4</a>.  The receiving part of the stream then enters the
"Size Known" state.  In this state, the endpoint no longer needs to send
MAX_STREAM_DATA frames, it only receives any retransmissions of stream data.<a href="#section-3.2-8" class="pilcrow">¶</a></p>
<p id="section-3.2-9">Once all data for the stream has been received, the receiving part enters the
"Data Recvd" state.  This might happen as a result of receiving the same STREAM
frame that causes the transition to "Size Known".  After all data has been
received, any STREAM or STREAM_DATA_BLOCKED frames for the stream can be
discarded.<a href="#section-3.2-9" class="pilcrow">¶</a></p>
<p id="section-3.2-10">The "Data Recvd" state persists until stream data has been delivered to the
application.  Once stream data has been delivered, the stream enters the "Data
Read" state, which is a terminal state.<a href="#section-3.2-10" class="pilcrow">¶</a></p>
<p id="section-3.2-11">Receiving a RESET_STREAM frame in the "Recv" or "Size Known" states causes the
stream to enter the "Reset Recvd" state.  This might cause the delivery of
stream data to the application to be interrupted.<a href="#section-3.2-11" class="pilcrow">¶</a></p>
<p id="section-3.2-12">It is possible that all stream data is received when a RESET_STREAM is received
(that is, from the "Data Recvd" state).  Similarly, it is possible for remaining
stream data to arrive after receiving a RESET_STREAM frame (the "Reset Recvd"
state).  An implementation is free to manage this situation as it chooses.<a href="#section-3.2-12" class="pilcrow">¶</a></p>
<p id="section-3.2-13">Sending RESET_STREAM means that an endpoint cannot guarantee delivery of stream
data; however there is no requirement that stream data not be delivered if a
RESET_STREAM is received.  An implementation MAY interrupt delivery of stream
data, discard any data that was not consumed, and signal the receipt of the
RESET_STREAM.  A RESET_STREAM signal might be suppressed or withheld if stream
data is completely received and is buffered to be read by the application.  If
the RESET_STREAM is suppressed, the receiving part of the stream remains in
"Data Recvd".<a href="#section-3.2-13" class="pilcrow">¶</a></p>
<p id="section-3.2-14">Once the application receives the signal indicating that the stream
was reset, the receiving part of the stream transitions to the "Reset Read"
state, which is a terminal state.<a href="#section-3.2-14" class="pilcrow">¶</a></p>
</section>
</div>
<div id="permitted-frame-types">
<section id="section-3.3">
        <h3 id="name-permitted-frame-types">
<a href="#section-3.3" class="section-number selfRef">3.3. </a><a href="#name-permitted-frame-types" class="section-name selfRef">Permitted Frame Types</a>
        </h3>
<p id="section-3.3-1">The sender of a stream sends just three frame types that affect the state of a
stream at either sender or receiver: STREAM (<a href="#frame-stream" class="xref">Section 19.8</a>),
STREAM_DATA_BLOCKED (<a href="#frame-stream-data-blocked" class="xref">Section 19.13</a>), and RESET_STREAM
(<a href="#frame-reset-stream" class="xref">Section 19.4</a>).<a href="#section-3.3-1" class="pilcrow">¶</a></p>
<p id="section-3.3-2">A sender MUST NOT send any of these frames from a terminal state ("Data Recvd"
or "Reset Recvd").  A sender MUST NOT send STREAM or STREAM_DATA_BLOCKED after
sending a RESET_STREAM; that is, in the terminal states and in the "Reset Sent"
state.  A receiver could receive any of these three frames in any state, due to
the possibility of delayed delivery of packets carrying them.<a href="#section-3.3-2" class="pilcrow">¶</a></p>
<p id="section-3.3-3">The receiver of a stream sends MAX_STREAM_DATA (<a href="#frame-max-stream-data" class="xref">Section 19.10</a>) and
STOP_SENDING frames (<a href="#frame-stop-sending" class="xref">Section 19.5</a>).<a href="#section-3.3-3" class="pilcrow">¶</a></p>
<p id="section-3.3-4">The receiver only sends MAX_STREAM_DATA in the "Recv" state.  A receiver can
send STOP_SENDING in any state where it has not received a RESET_STREAM frame;
that is states other than "Reset Recvd" or "Reset Read".  However there is
little value in sending a STOP_SENDING frame in the "Data Recvd" state, since
all stream data has been received.  A sender could receive either of these two
frames in any state as a result of delayed delivery of packets.<a href="#section-3.3-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="stream-bidi-states">
<section id="section-3.4">
        <h3 id="name-bidirectional-stream-states">
<a href="#section-3.4" class="section-number selfRef">3.4. </a><a href="#name-bidirectional-stream-states" class="section-name selfRef">Bidirectional Stream States</a>
        </h3>
<p id="section-3.4-1">A bidirectional stream is composed of sending and receiving parts.
Implementations may represent states of the bidirectional stream as composites
of sending and receiving stream states.  The simplest model presents the stream
as "open" when either sending or receiving parts are in a non-terminal state and
"closed" when both sending and receiving streams are in terminal states.<a href="#section-3.4-1" class="pilcrow">¶</a></p>
<p id="section-3.4-2"><a href="#stream-bidi-mapping" class="xref">Table 2</a> shows a more complex mapping of bidirectional stream
states that loosely correspond to the stream states in HTTP/2
<span>[<a href="#HTTP2" class="xref">HTTP2</a>]</span>.  This shows that multiple states on sending or receiving
parts of streams are mapped to the same composite state.  Note that this is just
one possibility for such a mapping; this mapping requires that data is
acknowledged before the transition to a "closed" or "half-closed" state.<a href="#section-3.4-2" class="pilcrow">¶</a></p>
<span id="name-possible-mapping-of-stream-"></span><div id="stream-bidi-mapping">
<table class="center" id="table-2">
          <caption>
<a href="#table-2" class="selfRef">Table 2</a>:
<a href="#name-possible-mapping-of-stream-" class="selfRef">Possible Mapping of Stream States to HTTP/2</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Sending Part</th>
              <th class="text-left" rowspan="1" colspan="1">Receiving Part</th>
              <th class="text-left" rowspan="1" colspan="1">Composite State</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">No Stream/Ready</td>
              <td class="text-left" rowspan="1" colspan="1">No Stream/Recv *1</td>
              <td class="text-left" rowspan="1" colspan="1">idle</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Ready/Send/Data Sent</td>
              <td class="text-left" rowspan="1" colspan="1">Recv/Size Known</td>
              <td class="text-left" rowspan="1" colspan="1">open</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Ready/Send/Data Sent</td>
              <td class="text-left" rowspan="1" colspan="1">Data Recvd/Data Read</td>
              <td class="text-left" rowspan="1" colspan="1">half-closed (remote)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Ready/Send/Data Sent</td>
              <td class="text-left" rowspan="1" colspan="1">Reset Recvd/Reset Read</td>
              <td class="text-left" rowspan="1" colspan="1">half-closed (remote)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Data Recvd</td>
              <td class="text-left" rowspan="1" colspan="1">Recv/Size Known</td>
              <td class="text-left" rowspan="1" colspan="1">half-closed (local)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Reset Sent/Reset Recvd</td>
              <td class="text-left" rowspan="1" colspan="1">Recv/Size Known</td>
              <td class="text-left" rowspan="1" colspan="1">half-closed (local)</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Reset Sent/Reset Recvd</td>
              <td class="text-left" rowspan="1" colspan="1">Data Recvd/Data Read</td>
              <td class="text-left" rowspan="1" colspan="1">closed</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Reset Sent/Reset Recvd</td>
              <td class="text-left" rowspan="1" colspan="1">Reset Recvd/Reset Read</td>
              <td class="text-left" rowspan="1" colspan="1">closed</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Data Recvd</td>
              <td class="text-left" rowspan="1" colspan="1">Data Recvd/Data Read</td>
              <td class="text-left" rowspan="1" colspan="1">closed</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">Data Recvd</td>
              <td class="text-left" rowspan="1" colspan="1">Reset Recvd/Reset Read</td>
              <td class="text-left" rowspan="1" colspan="1">closed</td>
            </tr>
          </tbody>
        </table>
</div>
<dl class="dlParallel" id="section-3.4-4">
          <dt id="section-3.4-4.1">Note (*1):</dt>
<dd id="section-3.4-4.2">
  A stream is considered "idle" if it has not yet been created, or if the
receiving part of the stream is in the "Recv" state without yet having
received any frames.<a href="#section-3.4-4.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
</section>
</div>
<div id="solicited-state-transitions">
<section id="section-3.5">
        <h3 id="name-solicited-state-transitions">
<a href="#section-3.5" class="section-number selfRef">3.5. </a><a href="#name-solicited-state-transitions" class="section-name selfRef">Solicited State Transitions</a>
        </h3>
<p id="section-3.5-1">If an application is no longer interested in the data it is receiving on a
stream, it can abort reading the stream and specify an application error code.<a href="#section-3.5-1" class="pilcrow">¶</a></p>
<p id="section-3.5-2">If the stream is in the "Recv" or "Size Known" states, the transport SHOULD
signal this by sending a STOP_SENDING frame to prompt closure of the stream in
the opposite direction.  This typically indicates that the receiving application
is no longer reading data it receives from the stream, but it is not a guarantee
that incoming data will be ignored.<a href="#section-3.5-2" class="pilcrow">¶</a></p>
<p id="section-3.5-3">STREAM frames received after sending STOP_SENDING are still counted toward
connection and stream flow control, even though these frames can be discarded
upon receipt.<a href="#section-3.5-3" class="pilcrow">¶</a></p>
<p id="section-3.5-4">A STOP_SENDING frame requests that the receiving endpoint send a RESET_STREAM
frame.  An endpoint that receives a STOP_SENDING frame MUST send a RESET_STREAM
frame if the stream is in the Ready or Send state.  If the stream is in the Data
Sent state and any outstanding data is declared lost, an endpoint SHOULD send a
RESET_STREAM frame in lieu of a retransmission.<a href="#section-3.5-4" class="pilcrow">¶</a></p>
<p id="section-3.5-5">An endpoint SHOULD copy the error code from the STOP_SENDING frame to the
RESET_STREAM frame it sends, but MAY use any application error code.  The
endpoint that sends a STOP_SENDING frame MAY ignore the error code carried in
any RESET_STREAM frame it receives.<a href="#section-3.5-5" class="pilcrow">¶</a></p>
<p id="section-3.5-6">If the STOP_SENDING frame is received on a stream that is already in the
"Data Sent" state, an endpoint that wishes to cease retransmission of
previously-sent STREAM frames on that stream MUST first send a RESET_STREAM
frame.<a href="#section-3.5-6" class="pilcrow">¶</a></p>
<p id="section-3.5-7">STOP_SENDING SHOULD only be sent for a stream that has not been reset by the
peer. STOP_SENDING is most useful for streams in the "Recv" or "Size Known"
states.<a href="#section-3.5-7" class="pilcrow">¶</a></p>
<p id="section-3.5-8">An endpoint is expected to send another STOP_SENDING frame if a packet
containing a previous STOP_SENDING is lost.  However, once either all stream
data or a RESET_STREAM frame has been received for the stream - that is, the
stream is in any state other than "Recv" or "Size Known" - sending a
STOP_SENDING frame is unnecessary.<a href="#section-3.5-8" class="pilcrow">¶</a></p>
<p id="section-3.5-9">An endpoint that wishes to terminate both directions of a bidirectional stream
can terminate one direction by sending a RESET_STREAM, and it can encourage
prompt termination in the opposite direction by sending a STOP_SENDING frame.<a href="#section-3.5-9" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="flow-control">
<section id="section-4">
      <h2 id="name-flow-control">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-flow-control" class="section-name selfRef">Flow Control</a>
      </h2>
<p id="section-4-1">It is necessary to limit the amount of data that a receiver could buffer, to
prevent a fast sender from overwhelming a slow receiver, or to prevent a
malicious sender from consuming a large amount of memory at a receiver.  To
enable a receiver to limit memory commitment to a connection and to apply back
pressure on the sender, streams are flow controlled both individually and as an
aggregate.  A QUIC receiver controls the maximum amount of data the sender can
send on a stream at any time, as described in <a href="#data-flow-control" class="xref">Section 4.1</a> and
<a href="#fc-credit" class="xref">Section 4.2</a><a href="#section-4-1" class="pilcrow">¶</a></p>
<p id="section-4-2">Similarly, to limit concurrency within a connection, a QUIC endpoint controls
the maximum cumulative number of streams that its peer can initiate, as
described in <a href="#controlling-concurrency" class="xref">Section 4.5</a>.<a href="#section-4-2" class="pilcrow">¶</a></p>
<p id="section-4-3">Data sent in CRYPTO frames is not flow controlled in the same way as stream
data.  QUIC relies on the cryptographic protocol implementation to avoid
excessive buffering of data; see <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>.  The implementation SHOULD
provide an interface to QUIC to tell it about its buffering limits so that there
is not excessive buffering at multiple layers.<a href="#section-4-3" class="pilcrow">¶</a></p>
<div id="data-flow-control">
<section id="section-4.1">
        <h3 id="name-data-flow-control">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-data-flow-control" class="section-name selfRef">Data Flow Control</a>
        </h3>
<p id="section-4.1-1">QUIC employs a credit-based flow-control scheme similar to that in HTTP/2
<span>[<a href="#HTTP2" class="xref">HTTP2</a>]</span>, where a receiver advertises the number of bytes it is prepared to
receive on a given stream and for the entire connection.  This leads to two
levels of data flow control in QUIC:<a href="#section-4.1-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-4.1-2.1">Stream flow control, which prevents a single stream from consuming the entire
receive buffer for a connection by limiting the amount of data that can be
sent on any stream.<a href="#section-4.1-2.1" class="pilcrow">¶</a>
</li>
<li id="section-4.1-2.2">Connection flow control, which prevents senders from exceeding a receiver's
buffer capacity for the connection, by limiting the total bytes of stream data
sent in STREAM frames on all streams.<a href="#section-4.1-2.2" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-4.1-3">A receiver sets initial credits for all streams by sending transport parameters
during the handshake (<a href="#transport-parameters" class="xref">Section 7.4</a>).  A receiver sends
MAX_STREAM_DATA (<a href="#frame-max-stream-data" class="xref">Section 19.10</a>) or MAX_DATA (<a href="#frame-max-data" class="xref">Section 19.9</a>)
frames to the sender to advertise additional credit.<a href="#section-4.1-3" class="pilcrow">¶</a></p>
<p id="section-4.1-4">A receiver advertises credit for a stream by sending a MAX_STREAM_DATA frame
with the Stream ID field set appropriately.  A MAX_STREAM_DATA frame indicates
the maximum absolute byte offset of a stream.  A receiver could use the current
offset of data consumed to determine the flow control offset to be advertised.
A receiver MAY send MAX_STREAM_DATA frames in multiple packets in order to make
sure that the sender receives an update before running out of flow control
credit, even if one of the packets is lost.<a href="#section-4.1-4" class="pilcrow">¶</a></p>
<p id="section-4.1-5">A receiver advertises credit for a connection by sending a MAX_DATA frame, which
indicates the maximum of the sum of the absolute byte offsets of all streams.  A
receiver maintains a cumulative sum of bytes received on all streams, which is
used to check for flow control violations. A receiver might use a sum of bytes
consumed on all streams to determine the maximum data limit to be advertised.<a href="#section-4.1-5" class="pilcrow">¶</a></p>
<p id="section-4.1-6">A receiver can advertise a larger offset by sending MAX_STREAM_DATA or MAX_DATA
frames.  Once a receiver advertises an offset, it MAY advertise a smaller
offset, but this has no effect.<a href="#section-4.1-6" class="pilcrow">¶</a></p>
<p id="section-4.1-7">A receiver MUST close the connection with a FLOW_CONTROL_ERROR error
(<a href="#error-handling" class="xref">Section 11</a>) if the sender violates the advertised connection or stream
data limits.<a href="#section-4.1-7" class="pilcrow">¶</a></p>
<p id="section-4.1-8">A sender MUST ignore any MAX_STREAM_DATA or MAX_DATA frames that do not increase
flow control limits.<a href="#section-4.1-8" class="pilcrow">¶</a></p>
<p id="section-4.1-9">If a sender runs out of flow control credit, it will be unable to send new data
and is considered blocked.  A sender SHOULD send a STREAM_DATA_BLOCKED or
DATA_BLOCKED frame to indicate it has data to write but is blocked by flow
control limits.  If a sender is blocked for a period longer than the idle
timeout (<a href="#idle-timeout" class="xref">Section 10.2</a>), the connection might be closed even when data is
available for transmission.  To keep the connection from closing, a sender that
is flow control limited SHOULD periodically send a STREAM_DATA_BLOCKED or
DATA_BLOCKED frame when it has no ack-eliciting packets in flight.<a href="#section-4.1-9" class="pilcrow">¶</a></p>
</section>
</div>
<div id="fc-credit">
<section id="section-4.2">
        <h3 id="name-flow-credit-increments">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-flow-credit-increments" class="section-name selfRef">Flow Credit Increments</a>
        </h3>
<p id="section-4.2-1">Implementations decide when and how much credit to advertise in MAX_STREAM_DATA
and MAX_DATA frames, but this section offers a few considerations.<a href="#section-4.2-1" class="pilcrow">¶</a></p>
<p id="section-4.2-2">To avoid blocking a sender, a receiver can send a MAX_STREAM_DATA or MAX_DATA
frame multiple times within a round trip or send it early enough to allow for
recovery from loss of the frame.<a href="#section-4.2-2" class="pilcrow">¶</a></p>
<p id="section-4.2-3">Control frames contribute to connection overhead. Therefore, frequently sending
MAX_STREAM_DATA and MAX_DATA frames with small changes is undesirable.  On the
other hand, if updates are less frequent, larger increments to limits are
necessary to avoid blocking a sender, requiring larger resource commitments at
the receiver.  There is a trade-off between resource commitment and overhead
when determining how large a limit is advertised.<a href="#section-4.2-3" class="pilcrow">¶</a></p>
<p id="section-4.2-4">A receiver can use an autotuning mechanism to tune the frequency and amount of
advertised additional credit based on a round-trip time estimate and the rate at
which the receiving application consumes data, similar to common TCP
implementations.  As an optimization, an endpoint could send frames related to
flow control only when there are other frames to send or when a peer is blocked,
ensuring that flow control does not cause extra packets to be sent.<a href="#section-4.2-4" class="pilcrow">¶</a></p>
<p id="section-4.2-5">A blocked sender is not required to send STREAM_DATA_BLOCKED or DATA_BLOCKED
frames. Therefore, a receiver MUST NOT wait for a STREAM_DATA_BLOCKED or
DATA_BLOCKED frame before sending a MAX_STREAM_DATA or MAX_DATA frame; doing so
could result in the sender being blocked for the rest of the connection. Even if
the sender sends these frames, waiting for them will result in the sender being
blocked for at least an entire round trip.<a href="#section-4.2-5" class="pilcrow">¶</a></p>
<p id="section-4.2-6">When a sender receives credit after being blocked, it might be able to send a
large amount of data in response, resulting in short-term congestion; see
Section 6.9 in <span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span> for a discussion of how a sender can avoid this
congestion.<a href="#section-4.2-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="stream-cancellation">
<section id="section-4.3">
        <h3 id="name-handling-stream-cancellatio">
<a href="#section-4.3" class="section-number selfRef">4.3. </a><a href="#name-handling-stream-cancellatio" class="section-name selfRef">Handling Stream Cancellation</a>
        </h3>
<p id="section-4.3-1">Endpoints need to eventually agree on the amount of flow control credit that has
been consumed, to avoid either exceeding flow control limits or deadlocking.<a href="#section-4.3-1" class="pilcrow">¶</a></p>
<p id="section-4.3-2">On receipt of a RESET_STREAM frame, an endpoint will tear down state for the
matching stream and ignore further data arriving on that stream.  Without the
offset included in RESET_STREAM, the two endpoints could disagree on
the number of bytes that count towards connection flow control.<a href="#section-4.3-2" class="pilcrow">¶</a></p>
<p id="section-4.3-3">To remedy this issue, a RESET_STREAM frame (<a href="#frame-reset-stream" class="xref">Section 19.4</a>) includes the
final size of data sent on the stream.  On receiving a RESET_STREAM frame, a
receiver definitively knows how many bytes were sent on that stream before the
RESET_STREAM frame, and the receiver MUST use the final size of the stream to
account for all bytes sent on the stream in its connection level flow
controller.<a href="#section-4.3-3" class="pilcrow">¶</a></p>
<p id="section-4.3-4">RESET_STREAM terminates one direction of a stream abruptly.  For a bidirectional
stream, RESET_STREAM has no effect on data flow in the opposite direction.  Both
endpoints MUST maintain flow control state for the stream in the unterminated
direction until that direction enters a terminal state, or until one of the
endpoints sends CONNECTION_CLOSE.<a href="#section-4.3-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="final-size">
<section id="section-4.4">
        <h3 id="name-stream-final-size">
<a href="#section-4.4" class="section-number selfRef">4.4. </a><a href="#name-stream-final-size" class="section-name selfRef">Stream Final Size</a>
        </h3>
<p id="section-4.4-1">The final size is the amount of flow control credit that is consumed by a
stream.  Assuming that every contiguous byte on the stream was sent once, the
final size is the number of bytes sent.  More generally, this is one higher
than the offset of the byte with the largest offset sent on the stream, or zero
if no bytes were sent.<a href="#section-4.4-1" class="pilcrow">¶</a></p>
<p id="section-4.4-2">For a stream that is reset, the final size is carried explicitly in a
RESET_STREAM frame.  Otherwise, the final size is the offset plus the length of
a STREAM frame marked with a FIN flag, or 0 in the case of incoming
unidirectional streams.<a href="#section-4.4-2" class="pilcrow">¶</a></p>
<p id="section-4.4-3">An endpoint will know the final size for a stream when the receiving part of the
stream enters the "Size Known" or "Reset Recvd" state (<a href="#stream-states" class="xref">Section 3</a>).<a href="#section-4.4-3" class="pilcrow">¶</a></p>
<p id="section-4.4-4">An endpoint MUST NOT send data on a stream at or beyond the final size.<a href="#section-4.4-4" class="pilcrow">¶</a></p>
<p id="section-4.4-5">Once a final size for a stream is known, it cannot change.  If a RESET_STREAM or
STREAM frame is received indicating a change in the final size for the stream,
an endpoint SHOULD respond with a FINAL_SIZE_ERROR error; see
<a href="#error-handling" class="xref">Section 11</a>.  A receiver SHOULD treat receipt of data at or beyond the
final size as a FINAL_SIZE_ERROR error, even after a stream is closed.
Generating these errors is not mandatory, but only because requiring that an
endpoint generate these errors also means that the endpoint needs to maintain
the final size state for closed streams, which could mean a significant state
commitment.<a href="#section-4.4-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="controlling-concurrency">
<section id="section-4.5">
        <h3 id="name-controlling-concurrency">
<a href="#section-4.5" class="section-number selfRef">4.5. </a><a href="#name-controlling-concurrency" class="section-name selfRef">Controlling Concurrency</a>
        </h3>
<p id="section-4.5-1">An endpoint limits the cumulative number of incoming streams a peer can open.
Only streams with a stream ID less than (max_stream * 4 +
initial_stream_id_for_type) can be opened; see <a href="#long-packet-types" class="xref">Table 5</a>.  Initial
limits are set in the transport parameters (see
<a href="#transport-parameter-definitions" class="xref">Section 18.2</a>) and subsequently limits are advertised
using MAX_STREAMS frames (<a href="#frame-max-streams" class="xref">Section 19.11</a>). Separate limits apply to
unidirectional and bidirectional streams.<a href="#section-4.5-1" class="pilcrow">¶</a></p>
<p id="section-4.5-2">If a max_streams transport parameter or MAX_STREAMS frame is received with a
value greater than 2^60, this would allow a maximum stream ID that cannot be
expressed as a variable-length integer; see <a href="#integer-encoding" class="xref">Section 16</a>.
If either is received, the connection MUST be closed immediately with a
connection error of type STREAM_LIMIT_ERROR; see <a href="#immediate-close" class="xref">Section 10.3</a>.<a href="#section-4.5-2" class="pilcrow">¶</a></p>
<p id="section-4.5-3">Endpoints MUST NOT exceed the limit set by their peer.  An endpoint that
receives a frame with a stream ID exceeding the limit it has sent MUST treat
this as a connection error of type STREAM_LIMIT_ERROR (<a href="#error-handling" class="xref">Section 11</a>).<a href="#section-4.5-3" class="pilcrow">¶</a></p>
<p id="section-4.5-4">Once a receiver advertises a stream limit using the MAX_STREAMS frame,
advertising a smaller limit has no effect.  A receiver MUST ignore any
MAX_STREAMS frame that does not increase the stream limit.<a href="#section-4.5-4" class="pilcrow">¶</a></p>
<p id="section-4.5-5">As with stream and connection flow control, this document leaves when and how
many streams to advertise to a peer via MAX_STREAMS to implementations.
Implementations might choose to increase limits as streams close to keep the
number of streams available to peers roughly consistent.<a href="#section-4.5-5" class="pilcrow">¶</a></p>
<p id="section-4.5-6">An endpoint that is unable to open a new stream due to the peer's limits SHOULD
send a STREAMS_BLOCKED frame (<a href="#frame-streams-blocked" class="xref">Section 19.14</a>).  This signal is
considered useful for debugging. An endpoint MUST NOT wait to receive this
signal before advertising additional credit, since doing so will mean that the
peer will be blocked for at least an entire round trip, and potentially for
longer if the peer chooses to not send STREAMS_BLOCKED frames.<a href="#section-4.5-6" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="connections">
<section id="section-5">
      <h2 id="name-connections">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-connections" class="section-name selfRef">Connections</a>
      </h2>
<p id="section-5-1">QUIC's connection establishment combines version negotiation with the
cryptographic and transport handshakes to reduce connection establishment
latency, as described in <a href="#handshake" class="xref">Section 7</a>.  Once established, a connection
may migrate to a different IP or port at either endpoint as
described in <a href="#migration" class="xref">Section 9</a>.  Finally, a connection may be terminated by either
endpoint, as described in <a href="#termination" class="xref">Section 10</a>.<a href="#section-5-1" class="pilcrow">¶</a></p>
<div id="connection-id">
<section id="section-5.1">
        <h3 id="name-connection-id">
<a href="#section-5.1" class="section-number selfRef">5.1. </a><a href="#name-connection-id" class="section-name selfRef">Connection ID</a>
        </h3>
<p id="section-5.1-1">Each connection possesses a set of connection identifiers, or connection IDs,
each of which can identify the connection.  Connection IDs are independently
selected by endpoints; each endpoint selects the connection IDs that its peer
uses.<a href="#section-5.1-1" class="pilcrow">¶</a></p>
<p id="section-5.1-2">The primary function of a connection ID is to ensure that changes in addressing
at lower protocol layers (UDP, IP) don't cause packets for a QUIC
connection to be delivered to the wrong endpoint.  Each endpoint selects
connection IDs using an implementation-specific (and perhaps
deployment-specific) method which will allow packets with that connection ID to
be routed back to the endpoint and identified by the endpoint upon receipt.<a href="#section-5.1-2" class="pilcrow">¶</a></p>
<p id="section-5.1-3">Connection IDs MUST NOT contain any information that can be used by an external
observer (that is, one that does not cooperate with the issuer) to correlate
them with other connection IDs for the same connection.  As a trivial example,
this means the same connection ID MUST NOT be issued more than once on the same
connection.<a href="#section-5.1-3" class="pilcrow">¶</a></p>
<p id="section-5.1-4">Packets with long headers include Source Connection ID and Destination
Connection ID fields.  These fields are used to set the connection IDs for new
connections; see <a href="#negotiating-connection-ids" class="xref">Section 7.2</a> for details.<a href="#section-5.1-4" class="pilcrow">¶</a></p>
<p id="section-5.1-5">Packets with short headers (<a href="#short-header" class="xref">Section 17.3</a>) only include the Destination
Connection ID and omit the explicit length.  The length of the Destination
Connection ID field is expected to be known to endpoints.  Endpoints using a
load balancer that routes based on connection ID could agree with the load
balancer on a fixed length for connection IDs, or agree on an encoding scheme.
A fixed portion could encode an explicit length, which allows the entire
connection ID to vary in length and still be used by the load balancer.<a href="#section-5.1-5" class="pilcrow">¶</a></p>
<p id="section-5.1-6">A Version Negotiation (<a href="#packet-version" class="xref">Section 17.2.1</a>) packet echoes the connection IDs
selected by the client, both to ensure correct routing toward the client and to
allow the client to validate that the packet is in response to an Initial
packet.<a href="#section-5.1-6" class="pilcrow">¶</a></p>
<p id="section-5.1-7">A zero-length connection ID can be used when a connection ID is not needed to
route to the correct endpoint. However, multiplexing connections on the same
local IP address and port while using zero-length connection IDs will cause
failures in the presence of peer connection migration, NAT rebinding, and client
port reuse; and therefore MUST NOT be done unless an endpoint is certain that
those protocol features are not in use.<a href="#section-5.1-7" class="pilcrow">¶</a></p>
<p id="section-5.1-8">When an endpoint uses a non-zero-length connection ID, it needs to ensure that
the peer has a supply of connection IDs from which to choose for packets sent to
the endpoint.  These connection IDs are supplied by the endpoint using the
NEW_CONNECTION_ID frame (<a href="#frame-new-connection-id" class="xref">Section 19.15</a>).<a href="#section-5.1-8" class="pilcrow">¶</a></p>
<div id="issue-cid">
<section id="section-5.1.1">
          <h4 id="name-issuing-connection-ids">
<a href="#section-5.1.1" class="section-number selfRef">5.1.1. </a><a href="#name-issuing-connection-ids" class="section-name selfRef">Issuing Connection IDs</a>
          </h4>
<p id="section-5.1.1-1">Each Connection ID has an associated sequence number to assist in deduplicating
messages.  The initial connection ID issued by an endpoint is sent in the Source
Connection ID field of the long packet header (<a href="#long-header" class="xref">Section 17.2</a>) during the
handshake.  The sequence number of the initial connection ID is 0.  If the
preferred_address transport parameter is sent, the sequence number of the
supplied connection ID is 1.<a href="#section-5.1.1-1" class="pilcrow">¶</a></p>
<p id="section-5.1.1-2">Additional connection IDs are communicated to the peer using NEW_CONNECTION_ID
frames (<a href="#frame-new-connection-id" class="xref">Section 19.15</a>).  The sequence number on each newly-issued
connection ID MUST increase by 1.  The connection ID randomly selected by the
client in the Initial packet and any connection ID provided by a Retry packet
are not assigned sequence numbers unless a server opts to retain them as its
initial connection ID.<a href="#section-5.1.1-2" class="pilcrow">¶</a></p>
<p id="section-5.1.1-3">When an endpoint issues a connection ID, it MUST accept packets that carry this
connection ID for the duration of the connection or until its peer invalidates
the connection ID via a RETIRE_CONNECTION_ID frame
(<a href="#frame-retire-connection-id" class="xref">Section 19.16</a>).  Connection IDs that are issued and not
retired are considered active; any active connection ID is valid for use with
the current connection at any time, in any packet type.  This includes the
connection ID issued by the server via the preferred_address transport
parameter.<a href="#section-5.1.1-3" class="pilcrow">¶</a></p>
<p id="section-5.1.1-4">An endpoint SHOULD ensure that its peer has a sufficient number of available and
unused connection IDs.  Endpoints advertise the number of active connection IDs
they are willing to maintain using the active_connection_id_limit transport
parameter.  An endpoint MUST NOT provide more connection IDs than the peer's
limit.  An endpoint MAY send connection IDs that temporarily exceed a peer's
limit if the NEW_CONNECTION_ID frame also requires the retirement of any excess,
by including a sufficiently large value in the Retire Prior To field.<a href="#section-5.1.1-4" class="pilcrow">¶</a></p>
<p id="section-5.1.1-5">A NEW_CONNECTION_ID frame might cause an endpoint to add some active connection
IDs and retire others based on the value of the Retire Prior To field.  After
processing a NEW_CONNECTION_ID frame and adding and retiring active connection
IDs, if the number of active connection IDs exceeds the value advertised in its
active_connection_id_limit transport parameter, an endpoint MUST close the
connection with an error of type CONNECTION_ID_LIMIT_ERROR.<a href="#section-5.1.1-5" class="pilcrow">¶</a></p>
<p id="section-5.1.1-6">An endpoint SHOULD supply a new connection ID when the peer retires a connection
ID.  If an endpoint provided fewer connection IDs than the peer's
active_connection_id_limit, it MAY supply a new connection ID when it receives a
packet with a previously unused connection ID.  An endpoint MAY limit the
frequency or the total number of connection IDs issued for each connection to
avoid the risk of running out of connection IDs; see <a href="#reset-token" class="xref">Section 10.4.2</a>.  An
endpoint MAY also limit the issuance of connection IDs to reduce the amount of
per-path state it maintains, such as path validation status, as its peer
might interact with it over as many paths as there are issued connection
IDs.<a href="#section-5.1.1-6" class="pilcrow">¶</a></p>
<p id="section-5.1.1-7">An endpoint that initiates migration and requires non-zero-length connection IDs
SHOULD ensure that the pool of connection IDs available to its peer allows the
peer to use a new connection ID on migration, as the peer will close the
connection if the pool is exhausted.<a href="#section-5.1.1-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="retire-cid">
<section id="section-5.1.2">
          <h4 id="name-consuming-and-retiring-conn">
<a href="#section-5.1.2" class="section-number selfRef">5.1.2. </a><a href="#name-consuming-and-retiring-conn" class="section-name selfRef">Consuming and Retiring Connection IDs</a>
          </h4>
<p id="section-5.1.2-1">An endpoint can change the connection ID it uses for a peer to another available
one at any time during the connection.  An endpoint consumes connection IDs in
response to a migrating peer; see <a href="#migration-linkability" class="xref">Section 9.5</a> for more.<a href="#section-5.1.2-1" class="pilcrow">¶</a></p>
<p id="section-5.1.2-2">An endpoint maintains a set of connection IDs received from its peer, any of
which it can use when sending packets.  When the endpoint wishes to remove a
connection ID from use, it sends a RETIRE_CONNECTION_ID frame to its peer.
Sending a RETIRE_CONNECTION_ID frame indicates that the connection ID will not
be used again and requests that the peer replace it with a new connection ID
using a NEW_CONNECTION_ID frame.<a href="#section-5.1.2-2" class="pilcrow">¶</a></p>
<p id="section-5.1.2-3">As discussed in <a href="#migration-linkability" class="xref">Section 9.5</a>, endpoints limit the use of a
connection ID to packets sent from a single local address to a single
destination address.  Endpoints SHOULD retire connection IDs when they are no
longer actively using either the local or destination address for which the
connection ID was used.<a href="#section-5.1.2-3" class="pilcrow">¶</a></p>
<p id="section-5.1.2-4">An endpoint might need to stop accepting previously issued connection IDs in
certain circumstances.  Such an endpoint can cause its peer to retire connection
IDs by sending a NEW_CONNECTION_ID frame with an increased Retire Prior To
field.  The endpoint SHOULD continue to accept the previously issued connection
IDs until they are retired by the peer.  If the endpoint can no longer process
the indicated connection IDs, it MAY close the connection.<a href="#section-5.1.2-4" class="pilcrow">¶</a></p>
<p id="section-5.1.2-5">Upon receipt of an increased Retire Prior To field, the peer MUST stop using
the corresponding connection IDs and retire them with RETIRE_CONNECTION_ID
frames before adding the newly provided connection ID to the set of active
connection IDs. This ordering allows an endpoint to replace all active
connection IDs without the possibility of a peer having no available connection
IDs and without exceeding the limit the peer sets in the
active_connection_id_limit transport parameter; see
<a href="#transport-parameter-definitions" class="xref">Section 18.2</a>. Failure to cease using the connection IDs
when requested can result in connection failures, as the issuing endpoint might
be unable to continue using the connection IDs with the active connection.<a href="#section-5.1.2-5" class="pilcrow">¶</a></p>
<p id="section-5.1.2-6">An endpoint SHOULD limit the number of connection IDs it has retired locally and
have not yet been acknowledged. An endpoint SHOULD allow for sending and
tracking a number of RETIRE_CONNECTION_ID frames of at least twice the
active_connection_id limit. An endpoint MUST NOT forget a connection ID without
retiring it, though it MAY choose to treat having connection IDs in need of
retirement that exceed this limit as a connection error of type
CONNECTION_ID_LIMIT_ERROR.<a href="#section-5.1.2-6" class="pilcrow">¶</a></p>
<p id="section-5.1.2-7">Endpoints SHOULD NOT issue updates of the Retire Prior To field before receiving
RETIRE_CONNECTION_ID frames that retire all connection IDs indicated by the
previous Retire Prior To value.<a href="#section-5.1.2-7" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="packet-handling">
<section id="section-5.2">
        <h3 id="name-matching-packets-to-connect">
<a href="#section-5.2" class="section-number selfRef">5.2. </a><a href="#name-matching-packets-to-connect" class="section-name selfRef">Matching Packets to Connections</a>
        </h3>
<p id="section-5.2-1">Incoming packets are classified on receipt.  Packets can either be associated
with an existing connection, or - for servers - potentially create a new
connection.<a href="#section-5.2-1" class="pilcrow">¶</a></p>
<p id="section-5.2-2">Endpoints try to associate a packet with an existing connection. If the packet
has a non-zero-length Destination Connection ID corresponding to an existing
connection, QUIC processes that packet accordingly. Note that more than one
connection ID can be associated with a connection; see <a href="#connection-id" class="xref">Section 5.1</a>.<a href="#section-5.2-2" class="pilcrow">¶</a></p>
<p id="section-5.2-3">If the Destination Connection ID is zero length and the addressing information
in the packet matches the addressing information the endpoint uses to identify a
connection with a zero-length connection ID, QUIC processes the packet as part
of that connection.  An endpoint can use just destination IP and port or both
source and destination addresses for identification, though this makes
connections fragile as described in <a href="#connection-id" class="xref">Section 5.1</a>.<a href="#section-5.2-3" class="pilcrow">¶</a></p>
<p id="section-5.2-4">Endpoints can send a Stateless Reset (<a href="#stateless-reset" class="xref">Section 10.4</a>) for any packets that
cannot be attributed to an existing connection. A stateless reset allows a peer
to more quickly identify when a connection becomes unusable.<a href="#section-5.2-4" class="pilcrow">¶</a></p>
<p id="section-5.2-5">Packets that are matched to an existing connection are discarded if the packets
are inconsistent with the state of that connection.  For example, packets are
discarded if they indicate a different protocol version than that of the
connection, or if the removal of packet protection is unsuccessful once the
expected keys are available.<a href="#section-5.2-5" class="pilcrow">¶</a></p>
<p id="section-5.2-6">Invalid packets without packet protection, such as Initial, Retry, or Version
Negotiation, MAY be discarded.  An endpoint MUST generate a connection error if
it commits changes to state before discovering an error.<a href="#section-5.2-6" class="pilcrow">¶</a></p>
<div id="client-pkt-handling">
<section id="section-5.2.1">
          <h4 id="name-client-packet-handling">
<a href="#section-5.2.1" class="section-number selfRef">5.2.1. </a><a href="#name-client-packet-handling" class="section-name selfRef">Client Packet Handling</a>
          </h4>
<p id="section-5.2.1-1">Valid packets sent to clients always include a Destination Connection ID that
matches a value the client selects.  Clients that choose to receive
zero-length connection IDs can use the local address and port to identify a
connection.  Packets that don't match an existing connection are discarded.<a href="#section-5.2.1-1" class="pilcrow">¶</a></p>
<p id="section-5.2.1-2">Due to packet reordering or loss, a client might receive packets for a
connection that are encrypted with a key it has not yet computed. The client MAY
drop these packets, or MAY buffer them in anticipation of later packets that
allow it to compute the key.<a href="#section-5.2.1-2" class="pilcrow">¶</a></p>
<p id="section-5.2.1-3">If a client receives a packet that has an unsupported version, it MUST discard
that packet.<a href="#section-5.2.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="server-pkt-handling">
<section id="section-5.2.2">
          <h4 id="name-server-packet-handling">
<a href="#section-5.2.2" class="section-number selfRef">5.2.2. </a><a href="#name-server-packet-handling" class="section-name selfRef">Server Packet Handling</a>
          </h4>
<p id="section-5.2.2-1">If a server receives a packet that has an unsupported version, but the packet is
sufficiently large to initiate a new connection for any version supported by the
server, it SHOULD send a Version Negotiation packet as described in
<a href="#send-vn" class="xref">Section 6.1</a>. Servers MAY rate control these packets to avoid storms of Version
Negotiation packets.  Otherwise, servers MUST drop packets that specify
unsupported versions.<a href="#section-5.2.2-1" class="pilcrow">¶</a></p>
<p id="section-5.2.2-2">The first packet for an unsupported version can use different semantics and
encodings for any version-specific field.  In particular, different packet
protection keys might be used for different versions.  Servers that do not
support a particular version are unlikely to be able to decrypt the payload of
the packet.  Servers SHOULD NOT attempt to decode or decrypt a packet from an
unknown version, but instead send a Version Negotiation packet, provided that
the packet is sufficiently long.<a href="#section-5.2.2-2" class="pilcrow">¶</a></p>
<p id="section-5.2.2-3">Packets with a supported version, or no version field, are matched to a
connection using the connection ID or - for packets with zero-length connection
IDs - the local address and port.  If the packet doesn't match an existing
connection, the server continues below.<a href="#section-5.2.2-3" class="pilcrow">¶</a></p>
<p id="section-5.2.2-4">If the packet is an Initial packet fully conforming with the specification, the
server proceeds with the handshake (<a href="#handshake" class="xref">Section 7</a>). This commits the server to
the version that the client selected.<a href="#section-5.2.2-4" class="pilcrow">¶</a></p>
<p id="section-5.2.2-5">If a server isn't currently accepting any new connections, it SHOULD send an
Initial packet containing a CONNECTION_CLOSE frame with error code
SERVER_BUSY.<a href="#section-5.2.2-5" class="pilcrow">¶</a></p>
<p id="section-5.2.2-6">If the packet is a 0-RTT packet, the server MAY buffer a limited number of these
packets in anticipation of a late-arriving Initial packet. Clients are not able
to send Handshake packets prior to receiving a server response, so servers
SHOULD ignore any such packets.<a href="#section-5.2.2-6" class="pilcrow">¶</a></p>
<p id="section-5.2.2-7">Servers MUST drop incoming packets under all other circumstances.<a href="#section-5.2.2-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="considerations-for-simple-load-balancers">
<section id="section-5.2.3">
          <h4 id="name-considerations-for-simple-l">
<a href="#section-5.2.3" class="section-number selfRef">5.2.3. </a><a href="#name-considerations-for-simple-l" class="section-name selfRef">Considerations for Simple Load Balancers</a>
          </h4>
<p id="section-5.2.3-1">A server deployment could load balance among servers using only source and
destination IP addresses and ports. Changes to the client's IP address or port
could result in packets being forwarded to the wrong server. Such a server
deployment could use one of the following methods for connection continuity
when a client's address changes.<a href="#section-5.2.3-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-5.2.3-2.1">Servers could use an out-of-band mechanism to forward packets to the correct
server based on Connection ID.<a href="#section-5.2.3-2.1" class="pilcrow">¶</a>
</li>
<li id="section-5.2.3-2.2">If servers can use a dedicated server IP address or port, other than the one
that the client initially connects to, they could use the preferred_address
transport parameter to request that clients move connections to that dedicated
address. Note that clients could choose not to use the preferred address.<a href="#section-5.2.3-2.2" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-5.2.3-3">A server in a deployment that does not implement a solution to
maintain connection continuity during connection migration
SHOULD disallow migration using the disable_active_migration transport
parameter.<a href="#section-5.2.3-3" class="pilcrow">¶</a></p>
<p id="section-5.2.3-4">Server deployments that use this simple form of load balancing MUST avoid the
creation of a stateless reset oracle; see <a href="#reset-oracle" class="xref">Section 21.9</a>.<a href="#section-5.2.3-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="connection-lifecycle">
<section id="section-5.3">
        <h3 id="name-life-of-a-quic-connection">
<a href="#section-5.3" class="section-number selfRef">5.3. </a><a href="#name-life-of-a-quic-connection" class="section-name selfRef">Life of a QUIC Connection</a>
        </h3>
<p id="section-5.3-1">A QUIC connection is a stateful interaction between a client and server, the
primary purpose of which is to support the exchange of data by an application
protocol.  Streams (<a href="#streams" class="xref">Section 2</a>) are the primary means by which an application
protocol exchanges information.<a href="#section-5.3-1" class="pilcrow">¶</a></p>
<p id="section-5.3-2">Each connection starts with a handshake phase, during which client and server
establish a shared secret using the cryptographic handshake protocol
<span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span> and negotiate the application protocol.  The handshake
(<a href="#handshake" class="xref">Section 7</a>) confirms that both endpoints are willing to communicate
(<a href="#validate-handshake" class="xref">Section 8.1</a>) and establishes parameters for the connection
(<a href="#transport-parameters" class="xref">Section 7.4</a>).<a href="#section-5.3-2" class="pilcrow">¶</a></p>
<p id="section-5.3-3">An application protocol can also operate in a limited fashion during the
handshake phase.  0-RTT allows application messages to be sent by a client
before receiving any messages from the server.  However, 0-RTT lacks certain key
security guarantees. In particular, there is no protection against replay
attacks in 0-RTT; see <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>.  Separately, a server can also send
application data to a client before it receives the final cryptographic
handshake messages that allow it to confirm the identity and liveness of the
client.  These capabilities allow an application protocol to offer the option to
trade some security guarantees for reduced latency.<a href="#section-5.3-3" class="pilcrow">¶</a></p>
<p id="section-5.3-4">The use of connection IDs (<a href="#connection-id" class="xref">Section 5.1</a>) allows connections to migrate to a
new network path, both as a direct choice of an endpoint and when forced by a
change in a middlebox.  <a href="#migration" class="xref">Section 9</a> describes mitigations for the security and
privacy issues associated with migration.<a href="#section-5.3-4" class="pilcrow">¶</a></p>
<p id="section-5.3-5">For connections that are no longer needed or desired, there are several ways for
a client and server to terminate a connection (<a href="#termination" class="xref">Section 10</a>).<a href="#section-5.3-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="required-operations-on-connections">
<section id="section-5.4">
        <h3 id="name-required-operations-on-conn">
<a href="#section-5.4" class="section-number selfRef">5.4. </a><a href="#name-required-operations-on-conn" class="section-name selfRef">Required Operations on Connections</a>
        </h3>
<p id="section-5.4-1">There are certain operations which an application MUST be able to perform when
interacting with the QUIC transport.  This document does not specify an API, but
any implementation of this version of QUIC MUST expose the ability to perform
the operations described in this section on a QUIC connection.<a href="#section-5.4-1" class="pilcrow">¶</a></p>
<p id="section-5.4-2">When implementing the client role, applications need to be able to:<a href="#section-5.4-2" class="pilcrow">¶</a></p>
<ul>
<li id="section-5.4-3.1">open a connection, which begins the exchange described in <a href="#handshake" class="xref">Section 7</a>;<a href="#section-5.4-3.1" class="pilcrow">¶</a>
</li>
<li id="section-5.4-3.2">enable 0-RTT when available; and<a href="#section-5.4-3.2" class="pilcrow">¶</a>
</li>
<li id="section-5.4-3.3">be informed when 0-RTT has been accepted or rejected by a server.<a href="#section-5.4-3.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-5.4-4">When implementing the server role, applications need to be able to:<a href="#section-5.4-4" class="pilcrow">¶</a></p>
<ul>
<li id="section-5.4-5.1">listen for incoming connections, which prepares for the exchange described in
<a href="#handshake" class="xref">Section 7</a>;<a href="#section-5.4-5.1" class="pilcrow">¶</a>
</li>
<li id="section-5.4-5.2">if Early Data is supported, embed application-controlled data in the TLS
resumption ticket sent to the client; and<a href="#section-5.4-5.2" class="pilcrow">¶</a>
</li>
<li id="section-5.4-5.3">if Early Data is supported, retrieve application-controlled data from the
client's resumption ticket and enable rejecting Early Data based on that
information.<a href="#section-5.4-5.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-5.4-6">In either role, applications need to be able to:<a href="#section-5.4-6" class="pilcrow">¶</a></p>
<ul>
<li id="section-5.4-7.1">configure minimum values for the initial number of permitted streams of each
type, as communicated in the transport parameters (<a href="#transport-parameters" class="xref">Section 7.4</a>);<a href="#section-5.4-7.1" class="pilcrow">¶</a>
</li>
<li id="section-5.4-7.2">control resource allocation of various types, including flow control and the
number of permitted streams of each type;<a href="#section-5.4-7.2" class="pilcrow">¶</a>
</li>
<li id="section-5.4-7.3">identify whether the handshake has completed successfully or is still ongoing;<a href="#section-5.4-7.3" class="pilcrow">¶</a>
</li>
<li id="section-5.4-7.4">keep a connection from silently closing, either by generating PING frames
(<a href="#frame-ping" class="xref">Section 19.2</a>) or by requesting that the transport send additional frames
before the idle timeout expires (<a href="#idle-timeout" class="xref">Section 10.2</a>); and<a href="#section-5.4-7.4" class="pilcrow">¶</a>
</li>
<li id="section-5.4-7.5">immediately close (<a href="#immediate-close" class="xref">Section 10.3</a>) the connection.<a href="#section-5.4-7.5" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
</section>
</div>
<div id="version-negotiation">
<section id="section-6">
      <h2 id="name-version-negotiation">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-version-negotiation" class="section-name selfRef">Version Negotiation</a>
      </h2>
<p id="section-6-1">Version negotiation ensures that client and server agree to a QUIC version
that is mutually supported. A server sends a Version Negotiation packet in
response to each packet that might initiate a new connection; see
<a href="#packet-handling" class="xref">Section 5.2</a> for details.<a href="#section-6-1" class="pilcrow">¶</a></p>
<p id="section-6-2">The size of the first packet sent by a client will determine whether a server
sends a Version Negotiation packet. Clients that support multiple QUIC versions
SHOULD pad the first packet they send to the largest of the minimum packet sizes
across all versions they support. This ensures that the server responds if there
is a mutually supported version.<a href="#section-6-2" class="pilcrow">¶</a></p>
<div id="send-vn">
<section id="section-6.1">
        <h3 id="name-sending-version-negotiation">
<a href="#section-6.1" class="section-number selfRef">6.1. </a><a href="#name-sending-version-negotiation" class="section-name selfRef">Sending Version Negotiation Packets</a>
        </h3>
<p id="section-6.1-1">If the version selected by the client is not acceptable to the server, the
server responds with a Version Negotiation packet; see <a href="#packet-version" class="xref">Section 17.2.1</a>.  This
includes a list of versions that the server will accept.  An endpoint MUST NOT
send a Version Negotiation packet in response to receiving a Version Negotiation
packet.<a href="#section-6.1-1" class="pilcrow">¶</a></p>
<p id="section-6.1-2">This system allows a server to process packets with unsupported versions without
retaining state.  Though either the Initial packet or the Version Negotiation
packet that is sent in response could be lost, the client will send new packets
until it successfully receives a response or it abandons the connection attempt.
As a result, the client discards all state for the connection and does not send
any more packets on the connection.<a href="#section-6.1-2" class="pilcrow">¶</a></p>
<p id="section-6.1-3">A server MAY limit the number of Version Negotiation packets it sends.  For
instance, a server that is able to recognize packets as 0-RTT might choose not
to send Version Negotiation packets in response to 0-RTT packets with the
expectation that it will eventually receive an Initial packet.<a href="#section-6.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="handle-vn">
<section id="section-6.2">
        <h3 id="name-handling-version-negotiatio">
<a href="#section-6.2" class="section-number selfRef">6.2. </a><a href="#name-handling-version-negotiatio" class="section-name selfRef">Handling Version Negotiation Packets</a>
        </h3>
<p id="section-6.2-1">Version Negotiation packets are designed to allow future versions of QUIC to
negotiate the version in use between endpoints.  Future versions of QUIC might
change how implementations that support multiple versions of QUIC react to
Version Negotiation packets when attempting to establish a connection using this
version.<a href="#section-6.2-1" class="pilcrow">¶</a></p>
<p id="section-6.2-2">A client that supports only this version of QUIC MUST abandon the current
connection attempt if it receives a Version Negotiation packet, with the
following two exceptions. A client MUST discard any Version Negotiation packet
if it has received and successfully processed any other packet, including an
earlier Version Negotiation packet. A client MUST discard a Version Negotiation
packet that lists the QUIC version selected by the client.<a href="#section-6.2-2" class="pilcrow">¶</a></p>
<p id="section-6.2-3">How to perform version negotiation is left as future work defined by future
versions of QUIC.  In particular, that future work will ensure robustness
against version downgrade attacks; see <a href="#version-downgrade" class="xref">Section 21.10</a>.<a href="#section-6.2-3" class="pilcrow">¶</a></p>
<div id="version-negotiation-between-draft-versions">
<section id="section-6.2.1">
          <h4 id="name-version-negotiation-between">
<a href="#section-6.2.1" class="section-number selfRef">6.2.1. </a><a href="#name-version-negotiation-between" class="section-name selfRef">Version Negotiation Between Draft Versions</a>
          </h4>
<p id="section-6.2.1-1">[[RFC editor: please remove this section before publication.]]<a href="#section-6.2.1-1" class="pilcrow">¶</a></p>
<p id="section-6.2.1-2">When a draft implementation receives a Version Negotiation packet, it MAY use
it to attempt a new connection with one of the versions listed in the packet,
instead of abandoning the current connection attempt; see <a href="#handle-vn" class="xref">Section 6.2</a>.<a href="#section-6.2.1-2" class="pilcrow">¶</a></p>
<p id="section-6.2.1-3">The client MUST check that the Destination and Source Connection ID fields
match the Source and Destination Connection ID fields in a packet that the
client sent.  If this check fails, the packet MUST be discarded.<a href="#section-6.2.1-3" class="pilcrow">¶</a></p>
<p id="section-6.2.1-4">Once the Version Negotiation packet is determined to be valid, the client then
selects an acceptable protocol version from the list provided by the server.
The client then attempts to create a new connection using that version. The new
connection MUST use a new random Destination Connection ID different from the
one it had previously sent.<a href="#section-6.2.1-4" class="pilcrow">¶</a></p>
<p id="section-6.2.1-5">Note that this mechanism does not protect against downgrade attacks and
MUST NOT be used outside of draft implementations.<a href="#section-6.2.1-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="using-reserved-versions">
<section id="section-6.3">
        <h3 id="name-using-reserved-versions">
<a href="#section-6.3" class="section-number selfRef">6.3. </a><a href="#name-using-reserved-versions" class="section-name selfRef">Using Reserved Versions</a>
        </h3>
<p id="section-6.3-1">For a server to use a new version in the future, clients need to correctly
handle unsupported versions. Some version numbers (0x?a?a?a?a as defined in
<a href="#versions" class="xref">Section 15</a>) are reserved for inclusion in fields that contain version
numbers.<a href="#section-6.3-1" class="pilcrow">¶</a></p>
<p id="section-6.3-2">Endpoints MAY add reserved versions to any field where unknown or unsupported
versions are ignored to test that a peer correctly ignores the value. For
instance, an endpoint could include a reserved version in a Version Negotiation
packet; see <a href="#packet-version" class="xref">Section 17.2.1</a>. Endpoints MAY send packets with a reserved
version to test that a peer correctly discards the packet.<a href="#section-6.3-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="handshake">
<section id="section-7">
      <h2 id="name-cryptographic-and-transport">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-cryptographic-and-transport" class="section-name selfRef">Cryptographic and Transport Handshake</a>
      </h2>
<p id="section-7-1">QUIC relies on a combined cryptographic and transport handshake to minimize
connection establishment latency.  QUIC uses the CRYPTO frame <a href="#frame-crypto" class="xref">Section 19.6</a>
to transmit the cryptographic handshake.  Version 0x00000001 of QUIC uses TLS as
described in <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>; a different QUIC version number could indicate that a
different cryptographic handshake protocol is in use.<a href="#section-7-1" class="pilcrow">¶</a></p>
<p id="section-7-2">QUIC provides reliable, ordered delivery of the cryptographic handshake
data. QUIC packet protection is used to encrypt as much of the handshake
protocol as possible. The cryptographic handshake MUST provide the following
properties:<a href="#section-7-2" class="pilcrow">¶</a></p>
<ul>
<li id="section-7-3.1">
          <p id="section-7-3.1.1">authenticated key exchange, where<a href="#section-7-3.1.1" class="pilcrow">¶</a></p>
<ul>
<li id="section-7-3.1.2.1">a server is always authenticated,<a href="#section-7-3.1.2.1" class="pilcrow">¶</a>
</li>
<li id="section-7-3.1.2.2">a client is optionally authenticated,<a href="#section-7-3.1.2.2" class="pilcrow">¶</a>
</li>
<li id="section-7-3.1.2.3">every connection produces distinct and unrelated keys,<a href="#section-7-3.1.2.3" class="pilcrow">¶</a>
</li>
<li id="section-7-3.1.2.4">keying material is usable for packet protection for both 0-RTT and 1-RTT
packets, and<a href="#section-7-3.1.2.4" class="pilcrow">¶</a>
</li>
<li id="section-7-3.1.2.5">1-RTT keys have forward secrecy<a href="#section-7-3.1.2.5" class="pilcrow">¶</a>
</li>
</ul>
</li>
<li id="section-7-3.2">authenticated values for transport parameters of both endpoints, and
confidentiality protection for server transport parameters (see
<a href="#transport-parameters" class="xref">Section 7.4</a>)<a href="#section-7-3.2" class="pilcrow">¶</a>
</li>
<li id="section-7-3.3">authenticated negotiation of an application protocol (TLS uses ALPN
<span>[<a href="#RFC7301" class="xref">RFC7301</a>]</span> for this purpose)<a href="#section-7-3.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-7-4">An endpoint can verify support for Explicit Congestion Notification (ECN) in the
first packets it sends, as described in <a href="#ecn-validation" class="xref">Section 13.4.2</a>.<a href="#section-7-4" class="pilcrow">¶</a></p>
<p id="section-7-5">The CRYPTO frame can be sent in different packet number spaces
(<a href="#packet-numbers" class="xref">Section 12.3</a>).  The sequence numbers used by CRYPTO frames to ensure
ordered delivery of cryptographic handshake data start from zero in each
packet number space.<a href="#section-7-5" class="pilcrow">¶</a></p>
<p id="section-7-6">Endpoints MUST explicitly negotiate an application protocol.  This avoids
situations where there is a disagreement about the protocol that is in use.<a href="#section-7-6" class="pilcrow">¶</a></p>
<div id="example-handshake-flows">
<section id="section-7.1">
        <h3 id="name-example-handshake-flows">
<a href="#section-7.1" class="section-number selfRef">7.1. </a><a href="#name-example-handshake-flows" class="section-name selfRef">Example Handshake Flows</a>
        </h3>
<p id="section-7.1-1">Details of how TLS is integrated with QUIC are provided in <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>, but
some examples are provided here.  An extension of this exchange to support
client address validation is shown in <a href="#validate-retry" class="xref">Section 8.1.2</a>.<a href="#section-7.1-1" class="pilcrow">¶</a></p>
<p id="section-7.1-2">Once any address validation exchanges are complete, the
cryptographic handshake is used to agree on cryptographic keys.  The
cryptographic handshake is carried in Initial (<a href="#packet-initial" class="xref">Section 17.2.2</a>) and Handshake
(<a href="#packet-handshake" class="xref">Section 17.2.4</a>) packets.<a href="#section-7.1-2" class="pilcrow">¶</a></p>
<p id="section-7.1-3"><a href="#tls-1rtt-handshake" class="xref">Figure 4</a> provides an overview of the 1-RTT handshake.  Each line
shows a QUIC packet with the packet type and packet number shown first, followed
by the frames that are typically contained in those packets. So, for instance
the first packet is of type Initial, with packet number 0, and contains a CRYPTO
frame carrying the ClientHello.<a href="#section-7.1-3" class="pilcrow">¶</a></p>
<p id="section-7.1-4">Note that multiple QUIC packets - even of different packet types - can be
coalesced into a single UDP datagram; see <a href="#packet-coalesce" class="xref">Section 12.2</a>). As a result,
this handshake may consist of as few as 4 UDP datagrams, or any number more.
For instance, the server's first flight contains Initial packets,
Handshake packets, and "0.5-RTT data" in 1-RTT packets with a short header.<a href="#section-7.1-4" class="pilcrow">¶</a></p>
<span id="name-example-1-rtt-handshake"></span><div id="tls-1rtt-handshake">
<figure id="figure-4">
          <div class="artwork art-text alignLeft" id="section-7.1-5.1">
<pre>
Client                                                  Server

Initial[0]: CRYPTO[CH] -&gt;

                                 Initial[0]: CRYPTO[SH] ACK[0]
                       Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                 &lt;- 1-RTT[0]: STREAM[1, "..."]

Initial[1]: ACK[0]
Handshake[0]: CRYPTO[FIN], ACK[0]
1-RTT[0]: STREAM[0, "..."], ACK[0] -&gt;

                                          Handshake[1]: ACK[0]
                         &lt;- 1-RTT[1]: STREAM[3, "..."], ACK[0]
</pre>
</div>
<figcaption><a href="#figure-4" class="selfRef">Figure 4</a>:
<a href="#name-example-1-rtt-handshake" class="selfRef">Example 1-RTT Handshake</a>
          </figcaption></figure>
</div>
<p id="section-7.1-6"><a href="#tls-0rtt-handshake" class="xref">Figure 5</a> shows an example of a connection with a 0-RTT handshake
and a single packet of 0-RTT data. Note that as described in
<a href="#packet-numbers" class="xref">Section 12.3</a>, the server acknowledges 0-RTT data in 1-RTT packets, and
the client sends 1-RTT packets in the same packet number space.<a href="#section-7.1-6" class="pilcrow">¶</a></p>
<span id="name-example-0-rtt-handshake"></span><div id="tls-0rtt-handshake">
<figure id="figure-5">
          <div class="artwork art-text alignLeft" id="section-7.1-7.1">
<pre>
Client                                                  Server

Initial[0]: CRYPTO[CH]
0-RTT[0]: STREAM[0, "..."] -&gt;

                                 Initial[0]: CRYPTO[SH] ACK[0]
                                  Handshake[0] CRYPTO[EE, FIN]
                          &lt;- 1-RTT[0]: STREAM[1, "..."] ACK[0]

Initial[1]: ACK[0]
Handshake[0]: CRYPTO[FIN], ACK[0]
1-RTT[1]: STREAM[0, "..."] ACK[0] -&gt;

                                          Handshake[1]: ACK[0]
                         &lt;- 1-RTT[1]: STREAM[3, "..."], ACK[1]
</pre>
</div>
<figcaption><a href="#figure-5" class="selfRef">Figure 5</a>:
<a href="#name-example-0-rtt-handshake" class="selfRef">Example 0-RTT Handshake</a>
          </figcaption></figure>
</div>
</section>
</div>
<div id="negotiating-connection-ids">
<section id="section-7.2">
        <h3 id="name-negotiating-connection-ids">
<a href="#section-7.2" class="section-number selfRef">7.2. </a><a href="#name-negotiating-connection-ids" class="section-name selfRef">Negotiating Connection IDs</a>
        </h3>
<p id="section-7.2-1">A connection ID is used to ensure consistent routing of packets, as described in
<a href="#connection-id" class="xref">Section 5.1</a>.  The long header contains two connection IDs: the Destination
Connection ID is chosen by the recipient of the packet and is used to provide
consistent routing; the Source Connection ID is used to set the Destination
Connection ID used by the peer.<a href="#section-7.2-1" class="pilcrow">¶</a></p>
<p id="section-7.2-2">During the handshake, packets with the long header (<a href="#long-header" class="xref">Section 17.2</a>) are used to
establish the connection IDs in each direction. Each endpoint uses the Source
Connection ID field to specify the connection ID that is used in the Destination
Connection ID field of packets being sent to them. Upon receiving a packet, each
endpoint sets the Destination Connection ID it sends to match the value of the
Source Connection ID that it receives.<a href="#section-7.2-2" class="pilcrow">¶</a></p>
<p id="section-7.2-3">When an Initial packet is sent by a client that has not previously received an
Initial or Retry packet from the server, the client populates the Destination
Connection ID field with an unpredictable value.  This Destination Connection ID
MUST be at least 8 bytes in length.  Until a packet is received from the server,
the client MUST use the same Destination Connection ID value on all packets in
this connection. This Destination Connection ID is used to determine packet
protection keys for Initial packets.<a href="#section-7.2-3" class="pilcrow">¶</a></p>
<p id="section-7.2-4">The client populates the Source Connection ID field with a value of its choosing
and sets the SCID Length field to indicate the length.<a href="#section-7.2-4" class="pilcrow">¶</a></p>
<p id="section-7.2-5">The first flight of 0-RTT packets use the same Destination Connection ID and
Source Connection ID values as the client's first Initial packet.<a href="#section-7.2-5" class="pilcrow">¶</a></p>
<p id="section-7.2-6">Upon first receiving an Initial or Retry packet from the server, the client uses
the Source Connection ID supplied by the server as the Destination Connection ID
for subsequent packets, including any 0-RTT packets.  This means that a client
might have to change the connection ID it sets in the Destination Connection ID
field twice during connection establishment: once in response to a Retry, and
once in response to an Initial packet from the server. Once a client has
received a valid Initial packet from the server, it MUST discard any subsequent
packet it receives with a different Source Connection ID.<a href="#section-7.2-6" class="pilcrow">¶</a></p>
<p id="section-7.2-7">A client MUST change the Destination Connection ID it uses for sending packets
in response to only the first received Initial or Retry packet.  A server MUST
set the Destination Connection ID it uses for sending packets based on the first
received Initial packet. Any further changes to the Destination Connection ID
are only permitted if the values are taken from any received
NEW_CONNECTION_ID frames; if subsequent Initial packets include a different
Source Connection ID, they MUST be discarded.  This avoids unpredictable
outcomes that might otherwise result from stateless processing of multiple
Initial packets with different Source Connection IDs.<a href="#section-7.2-7" class="pilcrow">¶</a></p>
<p id="section-7.2-8">The Destination Connection ID that an endpoint sends can change over the
lifetime of a connection, especially in response to connection migration
(<a href="#migration" class="xref">Section 9</a>); see <a href="#issue-cid" class="xref">Section 5.1.1</a> for details.<a href="#section-7.2-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="cid-auth">
<section id="section-7.3">
        <h3 id="name-authenticating-connection-i">
<a href="#section-7.3" class="section-number selfRef">7.3. </a><a href="#name-authenticating-connection-i" class="section-name selfRef">Authenticating Connection IDs</a>
        </h3>
<p id="section-7.3-1">The choice each endpoint makes about connection IDs during the handshake is
authenticated by including all values in transport parameters; see
<a href="#transport-parameters" class="xref">Section 7.4</a>. This ensures that all connection IDs used for the
handshake are also authenticated by the cryptographic handshake.<a href="#section-7.3-1" class="pilcrow">¶</a></p>
<p id="section-7.3-2">Each endpoint includes the value of the Source Connection ID field from the
first Initial packet it sent in the initial_source_connection_id transport
parameter; see <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>. A server includes the
Destination Connection ID field from the first Initial packet it received from
the client in the original_destination_connection_id transport parameter; if
the server sent a Retry packet this refers to the first Initial packet received
before sending the Retry packet. If it sends a Retry packet, a server also
includes the Source Connection ID field from the Retry packet in the
retry_source_connection_id transport parameter.<a href="#section-7.3-2" class="pilcrow">¶</a></p>
<p id="section-7.3-3">The values provided by a peer for these transport parameters MUST match the
values that an endpoint used in the Destination and Source Connection ID fields
of Initial packets that it sent. Including connection ID values in transport
parameters and verifying them ensures that that an attacker cannot influence
the choice of connection ID for a successful connection by injecting packets
carrying attacker-chosen connection IDs during the handshake. An endpoint MUST
treat any of the following as a connection error of type PROTOCOL_VIOLATION:<a href="#section-7.3-3" class="pilcrow">¶</a></p>
<ul>
<li id="section-7.3-4.1">absence of the initial_source_connection_id transport parameter from either
endpoint,<a href="#section-7.3-4.1" class="pilcrow">¶</a>
</li>
<li id="section-7.3-4.2">absence of the original_destination_connection_id transport parameter from
the server,<a href="#section-7.3-4.2" class="pilcrow">¶</a>
</li>
<li id="section-7.3-4.3">absence of the retry_source_connection_id transport parameter from the server
after receiving a Retry packet,<a href="#section-7.3-4.3" class="pilcrow">¶</a>
</li>
<li id="section-7.3-4.4">presence of the retry_source_connection_id transport parameter when no Retry
packet was received, or<a href="#section-7.3-4.4" class="pilcrow">¶</a>
</li>
<li id="section-7.3-4.5">a mismatch between values received from a peer in these transport parameters
and the value sent in the corresponding Destination or Source Connection ID
fields of Initial packets.<a href="#section-7.3-4.5" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-7.3-5">If a zero-length connection ID is selected, the corresponding transport
parameter is included with a zero-length value.<a href="#section-7.3-5" class="pilcrow">¶</a></p>
<p id="section-7.3-6"><a href="#fig-auth-cid" class="xref">Figure 6</a> shows the connection IDs that are used in a complete
handshake. The exchange of Initial packets is shown, plus the later exchange of
1-RTT packets that includes the connection ID established during the handshake.<a href="#section-7.3-6" class="pilcrow">¶</a></p>
<span id="name-use-of-connection-ids-in-a-"></span><div id="fig-auth-cid">
<figure id="figure-6">
          <div class="artwork art-text alignLeft" id="section-7.3-7.1">
<pre>
Client                                                  Server

Initial: DCID=S1, SCID=C1 -&gt;
                                  &lt;- Initial: DCID=C1, SCID=S3
                             ...
1-RTT: DCID=S3 -&gt;
                                             &lt;- 1-RTT: DCID=C1
</pre>
</div>
<figcaption><a href="#figure-6" class="selfRef">Figure 6</a>:
<a href="#name-use-of-connection-ids-in-a-" class="selfRef">Use of Connection IDs in a Handshake</a>
          </figcaption></figure>
</div>
<p id="section-7.3-8"><a href="#fig-auth-cid-retry" class="xref">Figure 7</a> shows a similar handshake that includes a Retry packet.<a href="#section-7.3-8" class="pilcrow">¶</a></p>
<span id="name-use-of-connection-ids-in-a-h"></span><div id="fig-auth-cid-retry">
<figure id="figure-7">
          <div class="artwork art-text alignLeft" id="section-7.3-9.1">
<pre>
Client                                                  Server

Initial: DCID=S1, SCID=C1 -&gt;
                                    &lt;- Retry: DCID=C1, SCID=S2
Initial: DCID=S2, SCID=C1 -&gt;
                                  &lt;- Initial: DCID=C1, SCID=S3
                             ...
1-RTT: DCID=S3 -&gt;
                                             &lt;- 1-RTT: DCID=C1
</pre>
</div>
<figcaption><a href="#figure-7" class="selfRef">Figure 7</a>:
<a href="#name-use-of-connection-ids-in-a-h" class="selfRef">Use of Connection IDs in a Handshake with Retry</a>
          </figcaption></figure>
</div>
<p id="section-7.3-10">For the handshakes in <a href="#fig-auth-cid" class="xref">Figure 6</a> and <a href="#fig-auth-cid-retry" class="xref">Figure 7</a> the client
sets the value of the initial_source_connection_id transport parameter to <code>C1</code>.
In <a href="#fig-auth-cid-retry" class="xref">Figure 7</a>, the server sets original_destination_connection_id
to <code>S1</code>, retry_source_connection_id to <code>S2</code>, and initial_source_connection_id
to <code>S3</code>. In <a href="#fig-auth-cid" class="xref">Figure 6</a>, the server sets
original_destination_connection_id to <code>S1</code>, initial_source_connection_id to
<code>S3</code>, and does not include retry_source_connection_id. Each endpoint validates
the transport parameters set by their peer, including the client confirming
that retry_source_connection_id is absent if no Retry packet was processed.<a href="#section-7.3-10" class="pilcrow">¶</a></p>
</section>
</div>
<div id="transport-parameters">
<section id="section-7.4">
        <h3 id="name-transport-parameters">
<a href="#section-7.4" class="section-number selfRef">7.4. </a><a href="#name-transport-parameters" class="section-name selfRef">Transport Parameters</a>
        </h3>
<p id="section-7.4-1">During connection establishment, both endpoints make authenticated declarations
of their transport parameters.  Endpoints are required to comply with the
restrictions implied by these parameters; the description of each parameter
includes rules for its handling.<a href="#section-7.4-1" class="pilcrow">¶</a></p>
<p id="section-7.4-2">Transport parameters are declarations that are made unilaterally by each
endpoint.  Each endpoint can choose values for transport parameters independent
of the values chosen by its peer.<a href="#section-7.4-2" class="pilcrow">¶</a></p>
<p id="section-7.4-3">The encoding of the transport parameters is detailed in
<a href="#transport-parameter-encoding" class="xref">Section 18</a>.<a href="#section-7.4-3" class="pilcrow">¶</a></p>
<p id="section-7.4-4">QUIC includes the encoded transport parameters in the cryptographic handshake.
Once the handshake completes, the transport parameters declared by the peer are
available.  Each endpoint validates the value provided by its peer.<a href="#section-7.4-4" class="pilcrow">¶</a></p>
<p id="section-7.4-5">Definitions for each of the defined transport parameters are included in
<a href="#transport-parameter-definitions" class="xref">Section 18.2</a>.<a href="#section-7.4-5" class="pilcrow">¶</a></p>
<p id="section-7.4-6">An endpoint MUST treat receipt of a transport parameter with an invalid value as
a connection error of type TRANSPORT_PARAMETER_ERROR.<a href="#section-7.4-6" class="pilcrow">¶</a></p>
<p id="section-7.4-7">An endpoint MUST NOT send a parameter more than once in a given transport
parameters extension.  An endpoint SHOULD treat receipt of duplicate transport
parameters as a connection error of type TRANSPORT_PARAMETER_ERROR.<a href="#section-7.4-7" class="pilcrow">¶</a></p>
<p id="section-7.4-8">Endpoints use transport parameters to authenticate the negotiation of
connection IDs during the handshake; see <a href="#cid-auth" class="xref">Section 7.3</a>.<a href="#section-7.4-8" class="pilcrow">¶</a></p>
<div id="zerortt-parameters">
<section id="section-7.4.1">
          <h4 id="name-values-of-transport-paramet">
<a href="#section-7.4.1" class="section-number selfRef">7.4.1. </a><a href="#name-values-of-transport-paramet" class="section-name selfRef">Values of Transport Parameters for 0-RTT</a>
          </h4>
<p id="section-7.4.1-1">Both endpoints store the value of the server transport parameters from
a connection and apply them to any 0-RTT packets that are sent in
subsequent connections to that peer, except for transport parameters that
are explicitly excluded. Remembered transport parameters apply to the new
connection until the handshake completes and the client starts sending
1-RTT packets. Once the handshake completes, the client uses the transport
parameters established in the handshake.<a href="#section-7.4.1-1" class="pilcrow">¶</a></p>
<p id="section-7.4.1-2">The definition of new transport parameters (<a href="#new-transport-parameters" class="xref">Section 7.4.2</a>) MUST
specify whether they MUST, MAY, or MUST NOT be stored for 0-RTT. A client need
not store a transport parameter it cannot process.<a href="#section-7.4.1-2" class="pilcrow">¶</a></p>
<p id="section-7.4.1-3">A client MUST NOT use remembered values for the following parameters:
ack_delay_exponent, max_ack_delay, initial_source_connection_id,
original_destination_connection_id, preferred_address,
retry_source_connection_id, and stateless_reset_token. The client MUST use the
server's new values in the handshake instead, and absent new values from the
server, the default value.<a href="#section-7.4.1-3" class="pilcrow">¶</a></p>
<p id="section-7.4.1-4">A client that attempts to send 0-RTT data MUST remember all other transport
parameters used by the server. The server can remember these transport
parameters, or store an integrity-protected copy of the values in the ticket
and recover the information when accepting 0-RTT data. A server uses the
transport parameters in determining whether to accept 0-RTT data.<a href="#section-7.4.1-4" class="pilcrow">¶</a></p>
<p id="section-7.4.1-5">If 0-RTT data is accepted by the server, the server MUST NOT reduce any
limits or alter any values that might be violated by the client with its
0-RTT data.  In particular, a server that accepts 0-RTT data MUST NOT set
values for the following parameters (<a href="#transport-parameter-definitions" class="xref">Section 18.2</a>)
that are smaller than the remembered value of the parameters.<a href="#section-7.4.1-5" class="pilcrow">¶</a></p>
<ul>
<li id="section-7.4.1-6.1">active_connection_id_limit<a href="#section-7.4.1-6.1" class="pilcrow">¶</a>
</li>
<li id="section-7.4.1-6.2">initial_max_data<a href="#section-7.4.1-6.2" class="pilcrow">¶</a>
</li>
<li id="section-7.4.1-6.3">initial_max_stream_data_bidi_local<a href="#section-7.4.1-6.3" class="pilcrow">¶</a>
</li>
<li id="section-7.4.1-6.4">initial_max_stream_data_bidi_remote<a href="#section-7.4.1-6.4" class="pilcrow">¶</a>
</li>
<li id="section-7.4.1-6.5">initial_max_stream_data_uni<a href="#section-7.4.1-6.5" class="pilcrow">¶</a>
</li>
<li id="section-7.4.1-6.6">initial_max_streams_bidi<a href="#section-7.4.1-6.6" class="pilcrow">¶</a>
</li>
<li id="section-7.4.1-6.7">initial_max_streams_uni<a href="#section-7.4.1-6.7" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-7.4.1-7">Omitting or setting a zero value for certain transport parameters can result in
0-RTT data being enabled, but not usable.  The applicable subset of transport
parameters that permit sending of application data SHOULD be set to non-zero
values for 0-RTT.  This includes initial_max_data and either
initial_max_streams_bidi and initial_max_stream_data_bidi_remote, or
initial_max_streams_uni and initial_max_stream_data_uni.<a href="#section-7.4.1-7" class="pilcrow">¶</a></p>
<p id="section-7.4.1-8">A server MUST either reject 0-RTT data or abort a handshake if the implied
values for transport parameters cannot be supported.<a href="#section-7.4.1-8" class="pilcrow">¶</a></p>
<p id="section-7.4.1-9">When sending frames in 0-RTT packets, a client MUST only use remembered
transport parameters; importantly, it MUST NOT use updated values that it learns
from the server's updated transport parameters or from frames received in 1-RTT
packets.  Updated values of transport parameters from the handshake apply only
to 1-RTT packets.  For instance, flow control limits from remembered transport
parameters apply to all 0-RTT packets even if those values are increased by the
handshake or by frames sent in 1-RTT packets.  A server MAY treat use of updated
transport parameters in 0-RTT as a connection error of type PROTOCOL_VIOLATION.<a href="#section-7.4.1-9" class="pilcrow">¶</a></p>
</section>
</div>
<div id="new-transport-parameters">
<section id="section-7.4.2">
          <h4 id="name-new-transport-parameters">
<a href="#section-7.4.2" class="section-number selfRef">7.4.2. </a><a href="#name-new-transport-parameters" class="section-name selfRef">New Transport Parameters</a>
          </h4>
<p id="section-7.4.2-1">New transport parameters can be used to negotiate new protocol behavior.  An
endpoint MUST ignore transport parameters that it does not support.  Absence of
a transport parameter therefore disables any optional protocol feature that is
negotiated using the parameter.  As described in <a href="#transport-parameter-grease" class="xref">Section 18.1</a>,
some identifiers are reserved in order to exercise this requirement.<a href="#section-7.4.2-1" class="pilcrow">¶</a></p>
<p id="section-7.4.2-2">New transport parameters can be registered according to the rules in
<a href="#iana-transport-parameters" class="xref">Section 22.2</a>.<a href="#section-7.4.2-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="cryptographic-message-buffering">
<section id="section-7.5">
        <h3 id="name-cryptographic-message-buffe">
<a href="#section-7.5" class="section-number selfRef">7.5. </a><a href="#name-cryptographic-message-buffe" class="section-name selfRef">Cryptographic Message Buffering</a>
        </h3>
<p id="section-7.5-1">Implementations need to maintain a buffer of CRYPTO data received out of order.
Because there is no flow control of CRYPTO frames, an endpoint could
potentially force its peer to buffer an unbounded amount of data.<a href="#section-7.5-1" class="pilcrow">¶</a></p>
<p id="section-7.5-2">Implementations MUST support buffering at least 4096 bytes of data received in
CRYPTO frames out of order. Endpoints MAY choose to allow more data to be
buffered during the handshake. A larger limit during the handshake could allow
for larger keys or credentials to be exchanged. An endpoint's buffer size does
not need to remain constant during the life of the connection.<a href="#section-7.5-2" class="pilcrow">¶</a></p>
<p id="section-7.5-3">Being unable to buffer CRYPTO frames during the handshake can lead to a
connection failure. If an endpoint's buffer is exceeded during the handshake, it
can expand its buffer temporarily to complete the handshake. If an endpoint
does not expand its buffer, it MUST close the connection with a
CRYPTO_BUFFER_EXCEEDED error code.<a href="#section-7.5-3" class="pilcrow">¶</a></p>
<p id="section-7.5-4">Once the handshake completes, if an endpoint is unable to buffer all data in a
CRYPTO frame, it MAY discard that CRYPTO frame and all CRYPTO frames received in
the future, or it MAY close the connection with a CRYPTO_BUFFER_EXCEEDED error
code. Packets containing discarded CRYPTO frames MUST be acknowledged because
the packet has been received and processed by the transport even though the
CRYPTO frame was discarded.<a href="#section-7.5-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="address-validation">
<section id="section-8">
      <h2 id="name-address-validation">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-address-validation" class="section-name selfRef">Address Validation</a>
      </h2>
<p id="section-8-1">Address validation is used by QUIC to avoid being used for a traffic
amplification attack.  In such an attack, a packet is sent to a server with
spoofed source address information that identifies a victim.  If a server
generates more or larger packets in response to that packet, the attacker can
use the server to send more data toward the victim than it would be able to send
on its own.<a href="#section-8-1" class="pilcrow">¶</a></p>
<p id="section-8-2">The primary defense against amplification attack is verifying that an endpoint
is able to receive packets at the transport address that it claims.  Address
validation is performed both during connection establishment (see
<a href="#validate-handshake" class="xref">Section 8.1</a>) and during connection migration (see
<a href="#migrate-validate" class="xref">Section 8.2</a>).<a href="#section-8-2" class="pilcrow">¶</a></p>
<div id="validate-handshake">
<section id="section-8.1">
        <h3 id="name-address-validation-during-c">
<a href="#section-8.1" class="section-number selfRef">8.1. </a><a href="#name-address-validation-during-c" class="section-name selfRef">Address Validation During Connection Establishment</a>
        </h3>
<p id="section-8.1-1">Connection establishment implicitly provides address validation for both
endpoints.  In particular, receipt of a packet protected with Handshake keys
confirms that the client received the Initial packet from the server.  Once the
server has successfully processed a Handshake packet from the client, it can
consider the client address to have been validated.<a href="#section-8.1-1" class="pilcrow">¶</a></p>
<p id="section-8.1-2">Prior to validating the client address, servers MUST NOT send more than three
times as many bytes as the number of bytes they have received.  This limits the
magnitude of any amplification attack that can be mounted using spoofed source
addresses.  For the purposes of avoiding amplification prior to address
validation, servers MUST count all of the payload bytes received in datagrams
that are uniquely attributed to a single connection. This includes datagrams
that contain packets that are successfully processed and datagrams that contain
packets that are all discarded.<a href="#section-8.1-2" class="pilcrow">¶</a></p>
<p id="section-8.1-3">Clients MUST ensure that UDP datagrams containing Initial packets have UDP
payloads of at least 1200 bytes, adding padding to packets in the datagram as
necessary. Sending padded datagrams ensures that the server is not overly
constrained by the amplification restriction.<a href="#section-8.1-3" class="pilcrow">¶</a></p>
<p id="section-8.1-4">Loss of an Initial or Handshake packet from the server can cause a deadlock if
the client does not send additional Initial or Handshake packets. A deadlock
could occur when the server reaches its anti-amplification limit and the client
has received acknowledgements for all the data it has sent.  In this case, when
the client has no reason to send additional packets, the server will be unable
to send more data because it has not validated the client's address. To prevent
this deadlock, clients MUST send a packet on a probe timeout
(PTO, see Section 5.3 of <span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span>). Specifically, the client MUST send
an Initial packet in a UDP datagram of at least 1200 bytes if it does not have
Handshake keys, and otherwise send a Handshake packet.<a href="#section-8.1-4" class="pilcrow">¶</a></p>
<p id="section-8.1-5">A server might wish to validate the client address before starting the
cryptographic handshake. QUIC uses a token in the Initial packet to provide
address validation prior to completing the handshake. This token is delivered to
the client during connection establishment with a Retry packet (see
<a href="#validate-retry" class="xref">Section 8.1.2</a>) or in a previous connection using the NEW_TOKEN frame (see
<a href="#validate-future" class="xref">Section 8.1.3</a>).<a href="#section-8.1-5" class="pilcrow">¶</a></p>
<p id="section-8.1-6">In addition to sending limits imposed prior to address validation, servers are
also constrained in what they can send by the limits set by the congestion
controller.  Clients are only constrained by the congestion controller.<a href="#section-8.1-6" class="pilcrow">¶</a></p>
<div id="token-construction">
<section id="section-8.1.1">
          <h4 id="name-token-construction">
<a href="#section-8.1.1" class="section-number selfRef">8.1.1. </a><a href="#name-token-construction" class="section-name selfRef">Token Construction</a>
          </h4>
<p id="section-8.1.1-1">A token sent in a NEW_TOKEN frames or a Retry packet MUST be constructed in a
way that allows the server to identify how it was provided to a client.  These
tokens are carried in the same field, but require different handling from
servers.<a href="#section-8.1.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="validate-retry">
<section id="section-8.1.2">
          <h4 id="name-address-validation-using-re">
<a href="#section-8.1.2" class="section-number selfRef">8.1.2. </a><a href="#name-address-validation-using-re" class="section-name selfRef">Address Validation using Retry Packets</a>
          </h4>
<p id="section-8.1.2-1">Upon receiving the client's Initial packet, the server can request address
validation by sending a Retry packet (<a href="#packet-retry" class="xref">Section 17.2.5</a>) containing a token. This
token MUST be repeated by the client in all Initial packets it sends for that
connection after it receives the Retry packet.  In response to processing an
Initial containing a token, a server can either abort the connection or permit
it to proceed.<a href="#section-8.1.2-1" class="pilcrow">¶</a></p>
<p id="section-8.1.2-2">As long as it is not possible for an attacker to generate a valid token for
its own address (see <a href="#token-integrity" class="xref">Section 8.1.4</a>) and the client is able to return
that token, it proves to the server that it received the token.<a href="#section-8.1.2-2" class="pilcrow">¶</a></p>
<p id="section-8.1.2-3">A server can also use a Retry packet to defer the state and processing costs of
connection establishment. Requiring the server to provide a different
connection ID, along with the original_destination_connection_id transport
parameter defined in <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>, forces the server to
demonstrate that it, or an entity it cooperates with, received the original
Initial packet from the client. Providing a different connection ID also grants
a server some control over how subsequent packets are routed. This can be used
to direct connections to a different server instance.<a href="#section-8.1.2-3" class="pilcrow">¶</a></p>
<p id="section-8.1.2-4">If a server receives a client Initial that can be unprotected but contains an
invalid Retry token, it knows the client will not accept another Retry token.
The server can discard such a packet and allow the client to time out to
detect handshake failure, but that could impose a significant latency penalty on
the client.  Instead, the server SHOULD immediately close (<a href="#immediate-close" class="xref">Section 10.3</a>)
the connection with an INVALID_TOKEN error.  Note that a server has not
established any state for the connection at this point and so does not enter the
closing period.<a href="#section-8.1.2-4" class="pilcrow">¶</a></p>
<p id="section-8.1.2-5">A flow showing the use of a Retry packet is shown in <a href="#fig-retry" class="xref">Figure 8</a>.<a href="#section-8.1.2-5" class="pilcrow">¶</a></p>
<span id="name-example-handshake-with-retr"></span><div id="fig-retry">
<figure id="figure-8">
            <div class="artwork art-text alignLeft" id="section-8.1.2-6.1">
<pre>
Client                                                  Server

Initial[0]: CRYPTO[CH] -&gt;

                                                &lt;- Retry+Token

Initial+Token[1]: CRYPTO[CH] -&gt;

                                 Initial[0]: CRYPTO[SH] ACK[1]
                       Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                 &lt;- 1-RTT[0]: STREAM[1, "..."]
</pre>
</div>
<figcaption><a href="#figure-8" class="selfRef">Figure 8</a>:
<a href="#name-example-handshake-with-retr" class="selfRef">Example Handshake with Retry</a>
            </figcaption></figure>
</div>
</section>
</div>
<div id="validate-future">
<section id="section-8.1.3">
          <h4 id="name-address-validation-for-futu">
<a href="#section-8.1.3" class="section-number selfRef">8.1.3. </a><a href="#name-address-validation-for-futu" class="section-name selfRef">Address Validation for Future Connections</a>
          </h4>
<p id="section-8.1.3-1">A server MAY provide clients with an address validation token during one
connection that can be used on a subsequent connection.  Address validation is
especially important with 0-RTT because a server potentially sends a significant
amount of data to a client in response to 0-RTT data.<a href="#section-8.1.3-1" class="pilcrow">¶</a></p>
<p id="section-8.1.3-2">The server uses the NEW_TOKEN frame <a href="#frame-new-token" class="xref">Section 19.7</a> to provide the client
with an address validation token that can be used to validate future
connections.  The client includes this token in Initial packets to provide
address validation in a future connection.  The client MUST include the token in
all Initial packets it sends, unless a Retry replaces the token with a newer
one.  The client MUST NOT use the token provided in a Retry for future
connections. Servers MAY discard any Initial packet that does not carry the
expected token.<a href="#section-8.1.3-2" class="pilcrow">¶</a></p>
<p id="section-8.1.3-3">Unlike the token that is created for a Retry packet, which is used immediately,
the token sent in the NEW_TOKEN frame might be used after some period of
time has passed.  Thus, a token SHOULD have an expiration time, which could
be either an explicit expiration time or an issued timestamp that can be
used to dynamically calculate the expiration time.  A server can store the
expiration time or include it in an encrypted form in the token.<a href="#section-8.1.3-3" class="pilcrow">¶</a></p>
<p id="section-8.1.3-4">A token issued with NEW_TOKEN MUST NOT include information that would allow
values to be linked by an observer to the connection on which it was
issued, unless the values are encrypted.  For example, it cannot include the
previous connection ID or addressing information.  A server MUST ensure that
every NEW_TOKEN frame it sends is unique across all clients, with the exception
of those sent to repair losses of previously sent NEW_TOKEN frames.  Information
that allows the server to distinguish between tokens from Retry and NEW_TOKEN
MAY be accessible to entities other than the server.<a href="#section-8.1.3-4" class="pilcrow">¶</a></p>
<p id="section-8.1.3-5">It is unlikely that the client port number is the same on two different
connections; validating the port is therefore unlikely to be successful.<a href="#section-8.1.3-5" class="pilcrow">¶</a></p>
<p id="section-8.1.3-6">A token received in a NEW_TOKEN frame is applicable to any server that the
connection is considered authoritative for (e.g., server names included in the
certificate).  When connecting to a server for which the client retains an
applicable and unused token, it SHOULD include that token in the Token field of
its Initial packet.  Including a token might allow the server to validate the
client address without an additional round trip.  A client MUST NOT include a
token that is not applicable to the server that it is connecting to, unless the
client has the knowledge that the server that issued the token and the server
the client is connecting to are jointly managing the tokens.  A client MAY use a
token from any previous connection to that server.<a href="#section-8.1.3-6" class="pilcrow">¶</a></p>
<p id="section-8.1.3-7">A token allows a server to correlate activity between the connection where the
token was issued and any connection where it is used.  Clients that want to
break continuity of identity with a server MAY discard tokens provided using the
NEW_TOKEN frame.  In comparison, a token obtained in a Retry packet MUST be used
immediately during the connection attempt and cannot be used in subsequent
connection attempts.<a href="#section-8.1.3-7" class="pilcrow">¶</a></p>
<p id="section-8.1.3-8">A client SHOULD NOT reuse a NEW_TOKEN token for different connection attempts.
Reusing a token allows connections to be linked by entities on the network path;
see <a href="#migration-linkability" class="xref">Section 9.5</a>.<a href="#section-8.1.3-8" class="pilcrow">¶</a></p>
<p id="section-8.1.3-9">Clients might receive multiple tokens on a single connection.  Aside from
preventing linkability, any token can be used in any connection attempt.
Servers can send additional tokens to either enable address validation for
multiple connection attempts or to replace older tokens that might become
invalid.  For a client, this ambiguity means that sending the most recent unused
token is most likely to be effective.  Though saving and using older tokens has
no negative consequences, clients can regard older tokens as being less likely
be useful to the server for address validation.<a href="#section-8.1.3-9" class="pilcrow">¶</a></p>
<p id="section-8.1.3-10">When a server receives an Initial packet with an address validation token, it
MUST attempt to validate the token, unless it has already completed address
validation.  If the token is invalid then the server SHOULD proceed as if
the client did not have a validated address, including potentially sending
a Retry. If the validation succeeds, the server SHOULD then allow the
handshake to proceed.<a href="#section-8.1.3-10" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-8.1.3-11">
            <dt id="section-8.1.3-11.1">Note:</dt>
<dd id="section-8.1.3-11.2">
  The rationale for treating the client as unvalidated rather than discarding
the packet is that the client might have received the token in a previous
connection using the NEW_TOKEN frame, and if the server has lost state, it
might be unable to validate the token at all, leading to connection failure if
the packet is discarded.  A server SHOULD encode tokens provided with
NEW_TOKEN frames and Retry packets differently, and validate the latter more
strictly.<a href="#section-8.1.3-11.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-8.1.3-12">In a stateless design, a server can use encrypted and authenticated tokens to
pass information to clients that the server can later recover and use to
validate a client address.  Tokens are not integrated into the cryptographic
handshake and so they are not authenticated.  For instance, a client might be
able to reuse a token.  To avoid attacks that exploit this property, a server
can limit its use of tokens to only the information needed to validate client
addresses.<a href="#section-8.1.3-12" class="pilcrow">¶</a></p>
<p id="section-8.1.3-13">Clients MAY use tokens obtained on one connection for any connection attempt
using the same version.  When selecting a token to use, clients do not need to
consider other properties of the connection that is being attempted, including
the choice of possible application protocols, session tickets, or other
connection properties.<a href="#section-8.1.3-13" class="pilcrow">¶</a></p>
<p id="section-8.1.3-14">Attackers could replay tokens to use servers as amplifiers in DDoS attacks. To
protect against such attacks, servers SHOULD ensure that tokens sent in Retry
packets are only accepted for a short time. Tokens that are provided in
NEW_TOKEN frames (<a href="#frame-new-token" class="xref">Section 19.7</a>) need to be valid for longer, but
SHOULD NOT be accepted multiple times in a short period. Servers are encouraged
to allow tokens to be used only once, if possible.<a href="#section-8.1.3-14" class="pilcrow">¶</a></p>
</section>
</div>
<div id="token-integrity">
<section id="section-8.1.4">
          <h4 id="name-address-validation-token-in">
<a href="#section-8.1.4" class="section-number selfRef">8.1.4. </a><a href="#name-address-validation-token-in" class="section-name selfRef">Address Validation Token Integrity</a>
          </h4>
<p id="section-8.1.4-1">An address validation token MUST be difficult to guess.  Including a large
enough random value in the token would be sufficient, but this depends on the
server remembering the value it sends to clients.<a href="#section-8.1.4-1" class="pilcrow">¶</a></p>
<p id="section-8.1.4-2">A token-based scheme allows the server to offload any state associated with
validation to the client.  For this design to work, the token MUST be covered by
integrity protection against modification or falsification by clients.  Without
integrity protection, malicious clients could generate or guess values for
tokens that would be accepted by the server.  Only the server requires access to
the integrity protection key for tokens.<a href="#section-8.1.4-2" class="pilcrow">¶</a></p>
<p id="section-8.1.4-3">There is no need for a single well-defined format for the token because the
server that generates the token also consumes it.  Tokens sent in Retry packets
SHOULD include information that allows the server to verify that the source IP
address and port in client packets remains constant.<a href="#section-8.1.4-3" class="pilcrow">¶</a></p>
<p id="section-8.1.4-4">Tokens sent in NEW_TOKEN frames MUST include information that allows the server
to verify that the client IP address has not changed from when the token was
issued. Servers can use tokens from NEW_TOKEN in deciding not to send a Retry
packet, even if the client address has changed. If the client IP address has
changed, the server MUST adhere to the anti-amplification limits found in
<a href="#validate-handshake" class="xref">Section 8.1</a>.  Note that in the presence of NAT, this requirement
might be insufficient to protect other hosts that share the NAT from
amplification attack.<a href="#section-8.1.4-4" class="pilcrow">¶</a></p>
<p id="section-8.1.4-5">Servers MUST ensure that replay of tokens is prevented or limited.  For
instance, servers might limit the time over which a token is accepted.  Tokens
provided in NEW_TOKEN frames might need to allow longer validity periods.
Tokens MAY include additional information about clients to further narrow
applicability or reuse.<a href="#section-8.1.4-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="migrate-validate">
<section id="section-8.2">
        <h3 id="name-path-validation">
<a href="#section-8.2" class="section-number selfRef">8.2. </a><a href="#name-path-validation" class="section-name selfRef">Path Validation</a>
        </h3>
<p id="section-8.2-1">Path validation is used during connection migration (see <a href="#migration" class="xref">Section 9</a> and
<a href="#preferred-address" class="xref">Section 9.6</a>) by the migrating endpoint to verify reachability of a
peer from a new local address.  In path validation, endpoints test reachability
between a specific local address and a specific peer address, where an address
is the two-tuple of IP address and port.<a href="#section-8.2-1" class="pilcrow">¶</a></p>
<p id="section-8.2-2">Path validation tests that packets (PATH_CHALLENGE) can be both sent to and
received (PATH_RESPONSE) from a peer on the path.  Importantly, it validates
that the packets received from the migrating endpoint do not carry a spoofed
source address.<a href="#section-8.2-2" class="pilcrow">¶</a></p>
<p id="section-8.2-3">Path validation can be used at any time by either endpoint.  For instance, an
endpoint might check that a peer is still in possession of its address after a
period of quiescence.<a href="#section-8.2-3" class="pilcrow">¶</a></p>
<p id="section-8.2-4">Path validation is not designed as a NAT traversal mechanism. Though the
mechanism described here might be effective for the creation of NAT bindings
that support NAT traversal, the expectation is that one or other peer is able to
receive packets without first having sent a packet on that path. Effective NAT
traversal needs additional synchronization mechanisms that are not provided
here.<a href="#section-8.2-4" class="pilcrow">¶</a></p>
<p id="section-8.2-5">An endpoint MAY bundle PATH_CHALLENGE and PATH_RESPONSE frames that are used for
path validation with other frames.  In particular, an endpoint may pad a packet
carrying a PATH_CHALLENGE for PMTU discovery, or an endpoint may bundle a
PATH_RESPONSE with its own PATH_CHALLENGE.<a href="#section-8.2-5" class="pilcrow">¶</a></p>
<p id="section-8.2-6">When probing a new path, an endpoint might want to ensure that its peer has an
unused connection ID available for responses. The endpoint can send
NEW_CONNECTION_ID and PATH_CHALLENGE frames in the same packet. This ensures
that an unused connection ID will be available to the peer when sending a
response.<a href="#section-8.2-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="initiating-path-validation">
<section id="section-8.3">
        <h3 id="name-initiating-path-validation">
<a href="#section-8.3" class="section-number selfRef">8.3. </a><a href="#name-initiating-path-validation" class="section-name selfRef">Initiating Path Validation</a>
        </h3>
<p id="section-8.3-1">To initiate path validation, an endpoint sends a PATH_CHALLENGE frame containing
a random payload on the path to be validated.<a href="#section-8.3-1" class="pilcrow">¶</a></p>
<p id="section-8.3-2">An endpoint MAY send multiple PATH_CHALLENGE frames to guard against packet
loss. However, an endpoint SHOULD NOT send multiple PATH_CHALLENGE frames in a
single packet.  An endpoint SHOULD NOT send a PATH_CHALLENGE more frequently
than it would an Initial packet, ensuring that connection migration is no more
load on a new path than establishing a new connection.<a href="#section-8.3-2" class="pilcrow">¶</a></p>
<p id="section-8.3-3">The endpoint MUST use unpredictable data in every PATH_CHALLENGE frame so that
it can associate the peer's response with the corresponding PATH_CHALLENGE.<a href="#section-8.3-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="path-validation-responses">
<section id="section-8.4">
        <h3 id="name-path-validation-responses">
<a href="#section-8.4" class="section-number selfRef">8.4. </a><a href="#name-path-validation-responses" class="section-name selfRef">Path Validation Responses</a>
        </h3>
<p id="section-8.4-1">On receiving a PATH_CHALLENGE frame, an endpoint MUST respond immediately by
echoing the data contained in the PATH_CHALLENGE frame in a PATH_RESPONSE frame.<a href="#section-8.4-1" class="pilcrow">¶</a></p>
<p id="section-8.4-2">An endpoint MUST NOT send more than one PATH_RESPONSE frame in response to one
PATH_CHALLENGE frame; see <a href="#retransmission-of-information" class="xref">Section 13.3</a>.  The peer is
expected to send more PATH_CHALLENGE frames as necessary to evoke additional
PATH_RESPONSE frames.<a href="#section-8.4-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="successful-path-validation">
<section id="section-8.5">
        <h3 id="name-successful-path-validation">
<a href="#section-8.5" class="section-number selfRef">8.5. </a><a href="#name-successful-path-validation" class="section-name selfRef">Successful Path Validation</a>
        </h3>
<p id="section-8.5-1">A new address is considered valid when a PATH_RESPONSE frame is received that
contains the data that was sent in a previous PATH_CHALLENGE. Receipt of an
acknowledgment for a packet containing a PATH_CHALLENGE frame is not adequate
validation, since the acknowledgment can be spoofed by a malicious peer.<a href="#section-8.5-1" class="pilcrow">¶</a></p>
<p id="section-8.5-2">Note that receipt on a different local address does not result in path
validation failure, as it might be a result of a forwarded packet (see
<a href="#off-path-forward" class="xref">Section 9.3.3</a>) or misrouting. It is possible that a valid PATH_RESPONSE
might be received in the future.<a href="#section-8.5-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="failed-path-validation">
<section id="section-8.6">
        <h3 id="name-failed-path-validation">
<a href="#section-8.6" class="section-number selfRef">8.6. </a><a href="#name-failed-path-validation" class="section-name selfRef">Failed Path Validation</a>
        </h3>
<p id="section-8.6-1">Path validation only fails when the endpoint attempting to validate the path
abandons its attempt to validate the path.<a href="#section-8.6-1" class="pilcrow">¶</a></p>
<p id="section-8.6-2">Endpoints SHOULD abandon path validation based on a timer. When setting this
timer, implementations are cautioned that the new path could have a longer
round-trip time than the original.  A value of three times the larger of the
current Probe Timeout (PTO) or the initial timeout (that is, 2*kInitialRtt) as
defined in <span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span> is RECOMMENDED.  That is:<a href="#section-8.6-2" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-8.6-3">
<pre>
   validation_timeout = max(3*PTO, 6*kInitialRtt)
</pre><a href="#section-8.6-3" class="pilcrow">¶</a>
</div>
<p id="section-8.6-4">Note that the endpoint might receive packets containing other frames on the new
path, but a PATH_RESPONSE frame with appropriate data is required for path
validation to succeed.<a href="#section-8.6-4" class="pilcrow">¶</a></p>
<p id="section-8.6-5">When an endpoint abandons path validation, it determines that the path is
unusable.  This does not necessarily imply a failure of the connection -
endpoints can continue sending packets over other paths as appropriate.  If no
paths are available, an endpoint can wait for a new path to become available or
close the connection.<a href="#section-8.6-5" class="pilcrow">¶</a></p>
<p id="section-8.6-6">A path validation might be abandoned for other reasons besides
failure. Primarily, this happens if a connection migration to a new path is
initiated while a path validation on the old path is in progress.<a href="#section-8.6-6" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="migration">
<section id="section-9">
      <h2 id="name-connection-migration">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-connection-migration" class="section-name selfRef">Connection Migration</a>
      </h2>
<p id="section-9-1">The use of a connection ID allows connections to survive changes to endpoint
addresses (IP address and port), such as those caused by an
endpoint migrating to a new network.  This section describes the process by
which an endpoint migrates to a new address.<a href="#section-9-1" class="pilcrow">¶</a></p>
<p id="section-9-2">The design of QUIC relies on endpoints retaining a stable address for the
duration of the handshake.  An endpoint MUST NOT initiate connection migration
before the handshake is confirmed, as defined in section 4.1.2 of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>.<a href="#section-9-2" class="pilcrow">¶</a></p>
<p id="section-9-3">An endpoint also MUST NOT send packets from a different local address, actively
initiating migration, if the peer sent the disable_active_migration transport
parameter during the handshake. An endpoint which has sent this transport
parameter, but detects that a peer has nonetheless migrated to a different
network MUST either drop the incoming packets on that path without generating a
stateless reset or proceed with path validation and allow the peer to migrate.
Generating a stateless reset or closing the connection would allow third parties
in the network to cause connections to close by spoofing or otherwise
manipulating observed traffic.<a href="#section-9-3" class="pilcrow">¶</a></p>
<p id="section-9-4">Not all changes of peer address are intentional, or active, migrations. The peer
could experience NAT rebinding: a change of address due to a middlebox, usually
a NAT, allocating a new outgoing port or even a new outgoing IP address for a
flow.  An endpoint MUST perform path validation (<a href="#migrate-validate" class="xref">Section 8.2</a>) if it
detects any change to a peer's address, unless it has previously validated that
address.<a href="#section-9-4" class="pilcrow">¶</a></p>
<p id="section-9-5">When an endpoint has no validated path on which to send packets, it MAY discard
connection state.  An endpoint capable of connection migration MAY wait for a
new path to become available before discarding connection state.<a href="#section-9-5" class="pilcrow">¶</a></p>
<p id="section-9-6">This document limits migration of connections to new client addresses, except as
described in <a href="#preferred-address" class="xref">Section 9.6</a>. Clients are responsible for initiating all
migrations.  Servers do not send non-probing packets (see <a href="#probing" class="xref">Section 9.1</a>) toward a
client address until they see a non-probing packet from that address.  If a
client receives packets from an unknown server address, the client MUST discard
these packets.<a href="#section-9-6" class="pilcrow">¶</a></p>
<div id="probing">
<section id="section-9.1">
        <h3 id="name-probing-a-new-path">
<a href="#section-9.1" class="section-number selfRef">9.1. </a><a href="#name-probing-a-new-path" class="section-name selfRef">Probing a New Path</a>
        </h3>
<p id="section-9.1-1">An endpoint MAY probe for peer reachability from a new local address using path
validation <a href="#migrate-validate" class="xref">Section 8.2</a> prior to migrating the connection to the new
local address.  Failure of path validation simply means that the new path is not
usable for this connection.  Failure to validate a path does not cause the
connection to end unless there are no valid alternative paths available.<a href="#section-9.1-1" class="pilcrow">¶</a></p>
<p id="section-9.1-2">An endpoint uses a new connection ID for probes sent from a new local address;
see <a href="#migration-linkability" class="xref">Section 9.5</a> for further discussion. An endpoint that uses
a new local address needs to ensure that at least one new connection ID is
available at the peer. That can be achieved by including a NEW_CONNECTION_ID
frame in the probe.<a href="#section-9.1-2" class="pilcrow">¶</a></p>
<p id="section-9.1-3">Receiving a PATH_CHALLENGE frame from a peer indicates that the peer is probing
for reachability on a path. An endpoint sends a PATH_RESPONSE in response as per
<a href="#migrate-validate" class="xref">Section 8.2</a>.<a href="#section-9.1-3" class="pilcrow">¶</a></p>
<p id="section-9.1-4">PATH_CHALLENGE, PATH_RESPONSE, NEW_CONNECTION_ID, and PADDING frames are
"probing frames", and all other frames are "non-probing frames".  A packet
containing only probing frames is a "probing packet", and a packet containing
any other frame is a "non-probing packet".<a href="#section-9.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="initiating-migration">
<section id="section-9.2">
        <h3 id="name-initiating-connection-migra">
<a href="#section-9.2" class="section-number selfRef">9.2. </a><a href="#name-initiating-connection-migra" class="section-name selfRef">Initiating Connection Migration</a>
        </h3>
<p id="section-9.2-1">An endpoint can migrate a connection to a new local address by sending packets
containing non-probing frames from that address.<a href="#section-9.2-1" class="pilcrow">¶</a></p>
<p id="section-9.2-2">Each endpoint validates its peer's address during connection establishment.
Therefore, a migrating endpoint can send to its peer knowing that the peer is
willing to receive at the peer's current address. Thus an endpoint can migrate
to a new local address without first validating the peer's address.<a href="#section-9.2-2" class="pilcrow">¶</a></p>
<p id="section-9.2-3">When migrating, the new path might not support the endpoint's current sending
rate. Therefore, the endpoint resets its congestion controller, as described in
<a href="#migration-cc" class="xref">Section 9.4</a>.<a href="#section-9.2-3" class="pilcrow">¶</a></p>
<p id="section-9.2-4">The new path might not have the same ECN capability. Therefore, the endpoint
verifies ECN capability as described in <a href="#ecn" class="xref">Section 13.4</a>.<a href="#section-9.2-4" class="pilcrow">¶</a></p>
<p id="section-9.2-5">Receiving acknowledgments for data sent on the new path serves as proof of the
peer's reachability from the new address.  Note that since acknowledgments may
be received on any path, return reachability on the new path is not established.
To establish return reachability on the new path, an endpoint MAY concurrently
initiate path validation <a href="#migrate-validate" class="xref">Section 8.2</a> on the new path or it MAY choose
to wait for the peer to send the next non-probing frame to its new address.<a href="#section-9.2-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="migration-response">
<section id="section-9.3">
        <h3 id="name-responding-to-connection-mi">
<a href="#section-9.3" class="section-number selfRef">9.3. </a><a href="#name-responding-to-connection-mi" class="section-name selfRef">Responding to Connection Migration</a>
        </h3>
<p id="section-9.3-1">Receiving a packet from a new peer address containing a non-probing frame
indicates that the peer has migrated to that address.<a href="#section-9.3-1" class="pilcrow">¶</a></p>
<p id="section-9.3-2">In response to such a packet, an endpoint MUST start sending subsequent packets
to the new peer address and MUST initiate path validation (<a href="#migrate-validate" class="xref">Section 8.2</a>)
to verify the peer's ownership of the unvalidated address.<a href="#section-9.3-2" class="pilcrow">¶</a></p>
<p id="section-9.3-3">An endpoint MAY send data to an unvalidated peer address, but it MUST protect
against potential attacks as described in <a href="#address-spoofing" class="xref">Section 9.3.1</a> and
<a href="#on-path-spoofing" class="xref">Section 9.3.2</a>.  An endpoint MAY skip validation of a peer address if that
address has been seen recently.  In particular, if an endpoint returns to a
previously-validated path after detecting some form of spurious migration,
skipping address validation and restoring loss detection and congestion state
can reduce the performance impact of the attack.<a href="#section-9.3-3" class="pilcrow">¶</a></p>
<p id="section-9.3-4">An endpoint only changes the address that it sends packets to in response to the
highest-numbered non-probing packet. This ensures that an endpoint does not send
packets to an old peer address in the case that it receives reordered packets.<a href="#section-9.3-4" class="pilcrow">¶</a></p>
<p id="section-9.3-5">After changing the address to which it sends non-probing packets, an endpoint
could abandon any path validation for other addresses.<a href="#section-9.3-5" class="pilcrow">¶</a></p>
<p id="section-9.3-6">Receiving a packet from a new peer address might be the result of a NAT
rebinding at the peer.<a href="#section-9.3-6" class="pilcrow">¶</a></p>
<p id="section-9.3-7">After verifying a new client address, the server SHOULD send new address
validation tokens (<a href="#address-validation" class="xref">Section 8</a>) to the client.<a href="#section-9.3-7" class="pilcrow">¶</a></p>
<div id="address-spoofing">
<section id="section-9.3.1">
          <h4 id="name-peer-address-spoofing">
<a href="#section-9.3.1" class="section-number selfRef">9.3.1. </a><a href="#name-peer-address-spoofing" class="section-name selfRef">Peer Address Spoofing</a>
          </h4>
<p id="section-9.3.1-1">It is possible that a peer is spoofing its source address to cause an endpoint
to send excessive amounts of data to an unwilling host.  If the endpoint sends
significantly more data than the spoofing peer, connection migration might be
used to amplify the volume of data that an attacker can generate toward a
victim.<a href="#section-9.3.1-1" class="pilcrow">¶</a></p>
<p id="section-9.3.1-2">As described in <a href="#migration-response" class="xref">Section 9.3</a>, an endpoint is required to validate a
peer's new address to confirm the peer's possession of the new address.  Until a
peer's address is deemed valid, an endpoint MUST limit the rate at which it
sends data to this address.  The endpoint MUST NOT send more than a minimum
congestion window's worth of data per estimated round-trip time (kMinimumWindow,
as defined in <span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span>).  In the absence of this limit, an endpoint
risks being used for a denial of service attack against an unsuspecting victim.
Note that since the endpoint will not have any round-trip time measurements to
this address, the estimate SHOULD be the default initial value; see
<span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span>.<a href="#section-9.3.1-2" class="pilcrow">¶</a></p>
<p id="section-9.3.1-3">If an endpoint skips validation of a peer address as described in
<a href="#migration-response" class="xref">Section 9.3</a>, it does not need to limit its sending rate.<a href="#section-9.3.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="on-path-spoofing">
<section id="section-9.3.2">
          <h4 id="name-on-path-address-spoofing">
<a href="#section-9.3.2" class="section-number selfRef">9.3.2. </a><a href="#name-on-path-address-spoofing" class="section-name selfRef">On-Path Address Spoofing</a>
          </h4>
<p id="section-9.3.2-1">An on-path attacker could cause a spurious connection migration by copying and
forwarding a packet with a spoofed address such that it arrives before the
original packet.  The packet with the spoofed address will be seen to come from
a migrating connection, and the original packet will be seen as a duplicate and
dropped. After a spurious migration, validation of the source address will fail
because the entity at the source address does not have the necessary
cryptographic keys to read or respond to the PATH_CHALLENGE frame that is sent
to it even if it wanted to.<a href="#section-9.3.2-1" class="pilcrow">¶</a></p>
<p id="section-9.3.2-2">To protect the connection from failing due to such a spurious migration, an
endpoint MUST revert to using the last validated peer address when validation of
a new peer address fails.<a href="#section-9.3.2-2" class="pilcrow">¶</a></p>
<p id="section-9.3.2-3">If an endpoint has no state about the last validated peer address, it MUST close
the connection silently by discarding all connection state. This results in new
packets on the connection being handled generically. For instance, an endpoint
MAY send a stateless reset in response to any further incoming packets.<a href="#section-9.3.2-3" class="pilcrow">¶</a></p>
<p id="section-9.3.2-4">Note that receipt of packets with higher packet numbers from the legitimate peer
address will trigger another connection migration.  This will cause the
validation of the address of the spurious migration to be abandoned.<a href="#section-9.3.2-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="off-path-forward">
<section id="section-9.3.3">
          <h4 id="name-off-path-packet-forwarding">
<a href="#section-9.3.3" class="section-number selfRef">9.3.3. </a><a href="#name-off-path-packet-forwarding" class="section-name selfRef">Off-Path Packet Forwarding</a>
          </h4>
<p id="section-9.3.3-1">An off-path attacker that can observe packets might forward copies of genuine
packets to endpoints.  If the copied packet arrives before the genuine packet,
this will appear as a NAT rebinding.  Any genuine packet will be discarded as a
duplicate.  If the attacker is able to continue forwarding packets, it might be
able to cause migration to a path via the attacker.  This places the attacker on
path, giving it the ability to observe or drop all subsequent packets.<a href="#section-9.3.3-1" class="pilcrow">¶</a></p>
<p id="section-9.3.3-2">Unlike the attack described in <a href="#on-path-spoofing" class="xref">Section 9.3.2</a>, the attacker can ensure
that the new path is successfully validated.<a href="#section-9.3.3-2" class="pilcrow">¶</a></p>
<p id="section-9.3.3-3">This style of attack relies on the attacker using a path that is approximately
as fast as the direct path between endpoints.  The attack is more reliable if
relatively few packets are sent or if packet loss coincides with the attempted
attack.<a href="#section-9.3.3-3" class="pilcrow">¶</a></p>
<p id="section-9.3.3-4">A non-probing packet received on the original path that increases the maximum
received packet number will cause the endpoint to move back to that path.
Eliciting packets on this path increases the likelihood that the attack is
unsuccessful.  Therefore, mitigation of this attack relies on triggering the
exchange of packets.<a href="#section-9.3.3-4" class="pilcrow">¶</a></p>
<p id="section-9.3.3-5">In response to an apparent migration, endpoints MUST validate the previously
active path using a PATH_CHALLENGE frame.  This induces the sending of new
packets on that path.  If the path is no longer viable, the validation attempt
will time out and fail; if the path is viable, but no longer desired, the
validation will succeed, but only results in probing packets being sent on the
path.<a href="#section-9.3.3-5" class="pilcrow">¶</a></p>
<p id="section-9.3.3-6">An endpoint that receives a PATH_CHALLENGE on an active path SHOULD send a
non-probing packet in response.  If the non-probing packet arrives before any
copy made by an attacker, this results in the connection being migrated back to
the original path.  Any subsequent migration to another path restarts this
entire process.<a href="#section-9.3.3-6" class="pilcrow">¶</a></p>
<p id="section-9.3.3-7">This defense is imperfect, but this is not considered a serious problem. If the
path via the attack is reliably faster than the original path despite multiple
attempts to use that original path, it is not possible to distinguish between
attack and an improvement in routing.<a href="#section-9.3.3-7" class="pilcrow">¶</a></p>
<p id="section-9.3.3-8">An endpoint could also use heuristics to improve detection of this style of
attack.  For instance, NAT rebinding is improbable if packets were recently
received on the old path, similarly rebinding is rare on IPv6 paths.  Endpoints
can also look for duplicated packets.  Conversely, a change in connection ID is
more likely to indicate an intentional migration rather than an attack.<a href="#section-9.3.3-8" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="migration-cc">
<section id="section-9.4">
        <h3 id="name-loss-detection-and-congesti">
<a href="#section-9.4" class="section-number selfRef">9.4. </a><a href="#name-loss-detection-and-congesti" class="section-name selfRef">Loss Detection and Congestion Control</a>
        </h3>
<p id="section-9.4-1">The capacity available on the new path might not be the same as the old path.
Packets sent on the old path MUST NOT contribute to congestion control or RTT
estimation for the new path.<a href="#section-9.4-1" class="pilcrow">¶</a></p>
<p id="section-9.4-2">On confirming a peer's ownership of its new address, an endpoint MUST
immediately reset the congestion controller and round-trip time estimator for
the new path to initial values (see Sections A.3 and B.3 in <span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span>)
unless it has knowledge that a previous send rate or round-trip time estimate is
valid for the new path.  For instance, an endpoint might infer that a change in
only the client's port number is indicative of a NAT rebinding, meaning that the
new path is likely to have similar bandwidth and round-trip time. However, this
determination will be imperfect.  If the determination is incorrect, the
congestion controller and the RTT estimator are expected to adapt to the new
path.  Generally, implementations are advised to be cautious when using previous
values on a new path.<a href="#section-9.4-2" class="pilcrow">¶</a></p>
<p id="section-9.4-3">There may be apparent reordering at the receiver when an endpoint sends data and
probes from/to multiple addresses during the migration period, since the two
resulting paths may have different round-trip times.  A receiver of packets on
multiple paths will still send ACK frames covering all received packets.<a href="#section-9.4-3" class="pilcrow">¶</a></p>
<p id="section-9.4-4">While multiple paths might be used during connection migration, a single
congestion control context and a single loss recovery context (as described in
<span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span>) may be adequate.  For instance, an endpoint might delay
switching to a new congestion control context until it is confirmed that an old
path is no longer needed (such as the case in <a href="#off-path-forward" class="xref">Section 9.3.3</a>).<a href="#section-9.4-4" class="pilcrow">¶</a></p>
<p id="section-9.4-5">A sender can make exceptions for probe packets so that their loss detection is
independent and does not unduly cause the congestion controller to reduce its
sending rate.  An endpoint might set a separate timer when a PATH_CHALLENGE is
sent, which is cancelled if the corresponding PATH_RESPONSE is received. If
the timer fires before the PATH_RESPONSE is received, the endpoint might send a
new PATH_CHALLENGE, and restart the timer for a longer period of time.
This timer SHOULD be set as described in Section 5.3 of <span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span> and
MUST NOT be more aggressive.<a href="#section-9.4-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="migration-linkability">
<section id="section-9.5">
        <h3 id="name-privacy-implications-of-con">
<a href="#section-9.5" class="section-number selfRef">9.5. </a><a href="#name-privacy-implications-of-con" class="section-name selfRef">Privacy Implications of Connection Migration</a>
        </h3>
<p id="section-9.5-1">Using a stable connection ID on multiple network paths allows a passive observer
to correlate activity between those paths.  An endpoint that moves between
networks might not wish to have their activity correlated by any entity other
than their peer, so different connection IDs are used when sending from
different local addresses, as discussed in <a href="#connection-id" class="xref">Section 5.1</a>.  For this to be
effective endpoints need to ensure that connection IDs they provide cannot be
linked by any other entity.<a href="#section-9.5-1" class="pilcrow">¶</a></p>
<p id="section-9.5-2">At any time, endpoints MAY change the Destination Connection ID they send to a
value that has not been used on another path.<a href="#section-9.5-2" class="pilcrow">¶</a></p>
<p id="section-9.5-3">An endpoint MUST NOT reuse a connection ID when sending from more than one local
address, for example when initiating connection migration as described in
<a href="#initiating-migration" class="xref">Section 9.2</a> or when probing a new network path as described in
<a href="#probing" class="xref">Section 9.1</a>.<a href="#section-9.5-3" class="pilcrow">¶</a></p>
<p id="section-9.5-4">Similarly, an endpoint MUST NOT reuse a connection ID when sending to more than
one destination address.  Due to network changes outside the control of its
peer, an endpoint might receive packets from a new source address with the same
destination connection ID, in which case it MAY continue to use the current
connection ID with the new remote address while still sending from the same
local address.<a href="#section-9.5-4" class="pilcrow">¶</a></p>
<p id="section-9.5-5">These requirements regarding connection ID reuse apply only to the sending of
packets, as unintentional changes in path without a change in connection ID are
possible.  For example, after a period of network inactivity, NAT rebinding
might cause packets to be sent on a new path when the client resumes sending.
An endpoint responds to such an event as described in <a href="#migration-response" class="xref">Section 9.3</a>.<a href="#section-9.5-5" class="pilcrow">¶</a></p>
<p id="section-9.5-6">Using different connection IDs for packets sent in both directions on each new
network path eliminates the use of the connection ID for linking packets from
the same connection across different network paths.  Header protection ensures
that packet numbers cannot be used to correlate activity.  This does not prevent
other properties of packets, such as timing and size, from being used to
correlate activity.<a href="#section-9.5-6" class="pilcrow">¶</a></p>
<p id="section-9.5-7">An endpoint SHOULD NOT initiate migration with a peer that has requested a
zero-length connection ID, because traffic over the new path might be trivially
linkable to traffic over the old one.  If the server is able to route packets
with a zero-length connection ID to the right connection, it means that the
server is using other information to demultiplex packets.  For example, a server
might provide a unique address to every client, for instance using HTTP
alternative services <span>[<a href="#ALTSVC" class="xref">ALTSVC</a>]</span>.  Information that might allow correct
routing of packets across multiple network paths will also allow activity on
those paths to be linked by entities other than the peer.<a href="#section-9.5-7" class="pilcrow">¶</a></p>
<p id="section-9.5-8">A client might wish to reduce linkability by employing a new connection ID and
source UDP port when sending traffic after a period of inactivity.  Changing the
UDP port from which it sends packets at the same time might cause the packet to
appear as a connection migration. This ensures that the mechanisms that support
migration are exercised even for clients that don't experience NAT rebindings or
genuine migrations.  Changing port number can cause a peer to reset its
congestion state (see <a href="#migration-cc" class="xref">Section 9.4</a>), so the port SHOULD only be changed
infrequently.<a href="#section-9.5-8" class="pilcrow">¶</a></p>
<p id="section-9.5-9">An endpoint that exhausts available connection IDs cannot probe new paths or
initiate migration, nor can it respond to probes or attempts by its peer to
migrate.  To ensure that migration is possible and packets sent on different
paths cannot be correlated, endpoints SHOULD provide new connection IDs before
peers migrate; see <a href="#issue-cid" class="xref">Section 5.1.1</a>.  If a peer might have exhausted available
connection IDs, a migrating endpoint could include a NEW_CONNECTION_ID frame in
all packets sent on a new network path.<a href="#section-9.5-9" class="pilcrow">¶</a></p>
</section>
</div>
<div id="preferred-address">
<section id="section-9.6">
        <h3 id="name-servers-preferred-address">
<a href="#section-9.6" class="section-number selfRef">9.6. </a><a href="#name-servers-preferred-address" class="section-name selfRef">Server's Preferred Address</a>
        </h3>
<p id="section-9.6-1">QUIC allows servers to accept connections on one IP address and attempt to
transfer these connections to a more preferred address shortly after the
handshake.  This is particularly useful when clients initially connect to an
address shared by multiple servers but would prefer to use a unicast address to
ensure connection stability. This section describes the protocol for migrating a
connection to a preferred server address.<a href="#section-9.6-1" class="pilcrow">¶</a></p>
<p id="section-9.6-2">Migrating a connection to a new server address mid-connection is left for future
work. If a client receives packets from a new server address not indicated by
the preferred_address transport parameter, the client SHOULD discard these
packets.<a href="#section-9.6-2" class="pilcrow">¶</a></p>
<div id="communicating-a-preferred-address">
<section id="section-9.6.1">
          <h4 id="name-communicating-a-preferred-a">
<a href="#section-9.6.1" class="section-number selfRef">9.6.1. </a><a href="#name-communicating-a-preferred-a" class="section-name selfRef">Communicating a Preferred Address</a>
          </h4>
<p id="section-9.6.1-1">A server conveys a preferred address by including the preferred_address
transport parameter in the TLS handshake.<a href="#section-9.6.1-1" class="pilcrow">¶</a></p>
<p id="section-9.6.1-2">Servers MAY communicate a preferred address of each address family (IPv4 and
IPv6) to allow clients to pick the one most suited to their network attachment.<a href="#section-9.6.1-2" class="pilcrow">¶</a></p>
<p id="section-9.6.1-3">Once the handshake is confirmed, the client SHOULD select one of the two
server's preferred addresses and initiate path validation (see
<a href="#migrate-validate" class="xref">Section 8.2</a>) of that address using any previously unused active
connection ID, taken from either the preferred_address transport parameter or
a NEW_CONNECTION_ID frame.<a href="#section-9.6.1-3" class="pilcrow">¶</a></p>
<p id="section-9.6.1-4">If path validation succeeds, the client SHOULD immediately begin sending all
future packets to the new server address using the new connection ID and
discontinue use of the old server address.  If path validation fails, the client
MUST continue sending all future packets to the server's original IP address.<a href="#section-9.6.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="responding-to-connection-migration">
<section id="section-9.6.2">
          <h4 id="name-responding-to-connection-mig">
<a href="#section-9.6.2" class="section-number selfRef">9.6.2. </a><a href="#name-responding-to-connection-mig" class="section-name selfRef">Responding to Connection Migration</a>
          </h4>
<p id="section-9.6.2-1">A server might receive a packet addressed to its preferred IP address at any
time after it accepts a connection.  If this packet contains a PATH_CHALLENGE
frame, the server sends a PATH_RESPONSE frame as per <a href="#migrate-validate" class="xref">Section 8.2</a>.  The
server MUST send other non-probing frames from its original address until it
receives a non-probing packet from the client at its preferred address and until
the server has validated the new path.<a href="#section-9.6.2-1" class="pilcrow">¶</a></p>
<p id="section-9.6.2-2">The server MUST probe on the path toward the client from its preferred address.
This helps to guard against spurious migration initiated by an attacker.<a href="#section-9.6.2-2" class="pilcrow">¶</a></p>
<p id="section-9.6.2-3">Once the server has completed its path validation and has received a non-probing
packet with a new largest packet number on its preferred address, the server
begins sending non-probing packets to the client exclusively from its preferred
IP address.  It SHOULD drop packets for this connection received on the old IP
address, but MAY continue to process delayed packets.<a href="#section-9.6.2-3" class="pilcrow">¶</a></p>
<p id="section-9.6.2-4">The addresses that a server provides in the preferred_address transport
parameter are only valid for the connection in which they are provided. A
client MUST NOT use these for other connections, including connections that are
resumed from the current connection.<a href="#section-9.6.2-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="interaction-of-client-migration-and-preferred-address">
<section id="section-9.6.3">
          <h4 id="name-interaction-of-client-migra">
<a href="#section-9.6.3" class="section-number selfRef">9.6.3. </a><a href="#name-interaction-of-client-migra" class="section-name selfRef">Interaction of Client Migration and Preferred Address</a>
          </h4>
<p id="section-9.6.3-1">A client might need to perform a connection migration before it has migrated to
the server's preferred address.  In this case, the client SHOULD perform path
validation to both the original and preferred server address from the client's
new address concurrently.<a href="#section-9.6.3-1" class="pilcrow">¶</a></p>
<p id="section-9.6.3-2">If path validation of the server's preferred address succeeds, the client MUST
abandon validation of the original address and migrate to using the server's
preferred address.  If path validation of the server's preferred address fails
but validation of the server's original address succeeds, the client MAY migrate
to its new address and continue sending to the server's original address.<a href="#section-9.6.3-2" class="pilcrow">¶</a></p>
<p id="section-9.6.3-3">If the connection to the server's preferred address is not from the same client
address, the server MUST protect against potential attacks as described in
<a href="#address-spoofing" class="xref">Section 9.3.1</a> and <a href="#on-path-spoofing" class="xref">Section 9.3.2</a>.  In addition to intentional
simultaneous migration, this might also occur because the client's access
network used a different NAT binding for the server's preferred address.<a href="#section-9.6.3-3" class="pilcrow">¶</a></p>
<p id="section-9.6.3-4">Servers SHOULD initiate path validation to the client's new address upon
receiving a probe packet from a different address.  Servers MUST NOT send more
than a minimum congestion window's worth of non-probing packets to the new
address before path validation is complete.<a href="#section-9.6.3-4" class="pilcrow">¶</a></p>
<p id="section-9.6.3-5">A client that migrates to a new address SHOULD use a preferred address from the
same address family for the server.<a href="#section-9.6.3-5" class="pilcrow">¶</a></p>
<p id="section-9.6.3-6">The connection ID provided in the preferred_address transport parameter is not
specific to the addresses that are provided. This connection ID is provided to
ensure that the client has a connection ID available for migration, but the
client MAY use this connection ID on any path.<a href="#section-9.6.3-6" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="ipv6-flow-label">
<section id="section-9.7">
        <h3 id="name-use-of-ipv6-flow-label-and-">
<a href="#section-9.7" class="section-number selfRef">9.7. </a><a href="#name-use-of-ipv6-flow-label-and-" class="section-name selfRef">Use of IPv6 Flow-Label and Migration</a>
        </h3>
<p id="section-9.7-1">Endpoints that send data using IPv6 SHOULD apply an IPv6 flow label
in compliance with <span>[<a href="#RFC6437" class="xref">RFC6437</a>]</span>, unless the local API does not allow
setting IPv6 flow labels.<a href="#section-9.7-1" class="pilcrow">¶</a></p>
<p id="section-9.7-2">The IPv6 flow label SHOULD be a pseudo-random function of the source and
destination addresses, source and destination UDP ports, and the destination
CID.  The flow label generation MUST be designed to minimize the chances of
linkability with a previously used flow label, as this would enable correlating
activity on multiple paths; see <a href="#migration-linkability" class="xref">Section 9.5</a>.<a href="#section-9.7-2" class="pilcrow">¶</a></p>
<p id="section-9.7-3">A possible implementation is to compute the flow label as a cryptographic hash
function of the source and destination addresses, source and destination
UDP ports, destination CID, and a local secret.<a href="#section-9.7-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="termination">
<section id="section-10">
      <h2 id="name-connection-termination">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-connection-termination" class="section-name selfRef">Connection Termination</a>
      </h2>
<p id="section-10-1">An established QUIC connection can be terminated in one of three ways:<a href="#section-10-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-10-2.1">idle timeout (<a href="#idle-timeout" class="xref">Section 10.2</a>)<a href="#section-10-2.1" class="pilcrow">¶</a>
</li>
<li id="section-10-2.2">immediate close (<a href="#immediate-close" class="xref">Section 10.3</a>)<a href="#section-10-2.2" class="pilcrow">¶</a>
</li>
<li id="section-10-2.3">stateless reset (<a href="#stateless-reset" class="xref">Section 10.4</a>)<a href="#section-10-2.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-10-3">An endpoint MAY discard connection state if it does not have a validated path on
which it can send packets; see <a href="#migrate-validate" class="xref">Section 8.2</a>.<a href="#section-10-3" class="pilcrow">¶</a></p>
<div id="draining">
<section id="section-10.1">
        <h3 id="name-closing-and-draining-connec">
<a href="#section-10.1" class="section-number selfRef">10.1. </a><a href="#name-closing-and-draining-connec" class="section-name selfRef">Closing and Draining Connection States</a>
        </h3>
<p id="section-10.1-1">The closing and draining connection states exist to ensure that connections
close cleanly and that delayed or reordered packets are properly discarded.
These states SHOULD persist for at least three times the current Probe Timeout
(PTO) interval as defined in <span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span>.<a href="#section-10.1-1" class="pilcrow">¶</a></p>
<p id="section-10.1-2">An endpoint enters a closing period after initiating an immediate close;
<a href="#immediate-close" class="xref">Section 10.3</a>.  While closing, an endpoint MUST NOT send packets unless
they contain a CONNECTION_CLOSE frame; see <a href="#immediate-close" class="xref">Section 10.3</a> for details.  An
endpoint retains only enough information to generate a packet containing a
CONNECTION_CLOSE frame and to identify packets as belonging to the connection.
The endpoint's selected connection ID and the QUIC version are sufficient
information to identify packets for a closing connection; an endpoint can
discard all other connection state. An endpoint MAY retain packet protection
keys for incoming packets to allow it to read and process a CONNECTION_CLOSE
frame.<a href="#section-10.1-2" class="pilcrow">¶</a></p>
<p id="section-10.1-3">The draining state is entered once an endpoint receives a signal that its peer
is closing or draining.  While otherwise identical to the closing state, an
endpoint in the draining state MUST NOT send any packets.  Retaining packet
protection keys is unnecessary once a connection is in the draining state.<a href="#section-10.1-3" class="pilcrow">¶</a></p>
<p id="section-10.1-4">An endpoint MAY transition from the closing period to the draining period if it
receives a CONNECTION_CLOSE frame or stateless reset, both of which indicate
that the peer is also closing or draining.  The draining period SHOULD end when
the closing period would have ended.  In other words, the endpoint can use the
same end time, but cease retransmission of the closing packet.<a href="#section-10.1-4" class="pilcrow">¶</a></p>
<p id="section-10.1-5">Disposing of connection state prior to the end of the closing or draining period
could cause delayed or reordered packets to generate an unnecessary stateless
reset. Endpoints that have some alternative means to ensure that late-arriving
packets on the connection do not induce a response, such as those that are able
to close the UDP socket, MAY use an abbreviated draining period which can allow
for faster resource recovery.  Servers that retain an open socket for accepting
new connections SHOULD NOT exit the closing or draining period early.<a href="#section-10.1-5" class="pilcrow">¶</a></p>
<p id="section-10.1-6">Once the closing or draining period has ended, an endpoint SHOULD discard all
connection state.  This results in new packets on the connection being handled
generically.  For instance, an endpoint MAY send a stateless reset in response
to any further incoming packets.<a href="#section-10.1-6" class="pilcrow">¶</a></p>
<p id="section-10.1-7">The draining and closing periods do not apply when a stateless reset
(<a href="#stateless-reset" class="xref">Section 10.4</a>) is sent.<a href="#section-10.1-7" class="pilcrow">¶</a></p>
<p id="section-10.1-8">An endpoint is not expected to handle key updates when it is closing or
draining.  A key update might prevent the endpoint from moving from the closing
state to draining, but it otherwise has no impact.<a href="#section-10.1-8" class="pilcrow">¶</a></p>
<p id="section-10.1-9">While in the closing period, an endpoint could receive packets from a new source
address, indicating a connection migration; <a href="#migration" class="xref">Section 9</a>. An endpoint in the
closing state MUST strictly limit the number of packets it sends to this new
address until the address is validated; see <a href="#migrate-validate" class="xref">Section 8.2</a>. A server in
the closing state MAY instead choose to discard packets received from a new
source address.<a href="#section-10.1-9" class="pilcrow">¶</a></p>
</section>
</div>
<div id="idle-timeout">
<section id="section-10.2">
        <h3 id="name-idle-timeout">
<a href="#section-10.2" class="section-number selfRef">10.2. </a><a href="#name-idle-timeout" class="section-name selfRef">Idle Timeout</a>
        </h3>
<p id="section-10.2-1">If a max_idle_timeout is specified by either peer in its transport parameters
(<a href="#transport-parameter-definitions" class="xref">Section 18.2</a>), the connection is silently closed
and its state is discarded when it remains idle for longer than the minimum of
both peers max_idle_timeout values and three times the current Probe Timeout
(PTO).<a href="#section-10.2-1" class="pilcrow">¶</a></p>
<p id="section-10.2-2">Each endpoint advertises a max_idle_timeout, but the effective value
at an endpoint is computed as the minimum of the two advertised values. By
announcing a max_idle_timeout, an endpoint commits to initiating an immediate
close (<a href="#immediate-close" class="xref">Section 10.3</a>) if it abandons the connection prior to the effective
value.<a href="#section-10.2-2" class="pilcrow">¶</a></p>
<p id="section-10.2-3">An endpoint restarts its idle timer when a packet from its peer is received and
processed successfully. An endpoint also restarts its idle timer when sending an
ack-eliciting packet if no other ack-eliciting packets have been sent since last
receiving and processing a packet. Restarting this timer when sending a packet
ensures that connections are not closed after new activity is initiated.<a href="#section-10.2-3" class="pilcrow">¶</a></p>
<p id="section-10.2-4">An endpoint might need to send ack-eliciting packets to avoid an idle timeout
if it is expecting response data, but does not have or is unable to send
application data.<a href="#section-10.2-4" class="pilcrow">¶</a></p>
<p id="section-10.2-5">An endpoint that sends packets close to the effective timeout risks having
them be discarded at the peer, since the peer might enter its draining state
before these packets arrive. An endpoint can send a PING or another
ack-eliciting frame to test the connection for liveness if the peer could
time out soon, such as within a PTO; see Section 6.6 of <span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span>.
This is especially useful if any available application data cannot be safely
retried. Note that the application determines what data is safe to retry.<a href="#section-10.2-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="immediate-close">
<section id="section-10.3">
        <h3 id="name-immediate-close">
<a href="#section-10.3" class="section-number selfRef">10.3. </a><a href="#name-immediate-close" class="section-name selfRef">Immediate Close</a>
        </h3>
<p id="section-10.3-1">An endpoint sends a CONNECTION_CLOSE frame (<a href="#frame-connection-close" class="xref">Section 19.19</a>) to
terminate the connection immediately.  A CONNECTION_CLOSE frame causes all
streams to immediately become closed; open streams can be assumed to be
implicitly reset.<a href="#section-10.3-1" class="pilcrow">¶</a></p>
<p id="section-10.3-2">After sending a CONNECTION_CLOSE frame, an endpoint immediately enters the
closing state.<a href="#section-10.3-2" class="pilcrow">¶</a></p>
<p id="section-10.3-3">During the closing period, an endpoint that sends a CONNECTION_CLOSE frame
SHOULD respond to any incoming packet that can be decrypted with another packet
containing a CONNECTION_CLOSE frame.  Such an endpoint SHOULD limit the number
of packets it generates containing a CONNECTION_CLOSE frame.  For instance, an
endpoint could wait for a progressively increasing number of received packets or
amount of time before responding to a received packet.<a href="#section-10.3-3" class="pilcrow">¶</a></p>
<p id="section-10.3-4">An endpoint is allowed to drop the packet protection keys when entering the
closing period (<a href="#draining" class="xref">Section 10.1</a>) and send a packet containing a CONNECTION_CLOSE in
response to any UDP datagram that is received.  However, an endpoint without the
packet protection keys cannot identify and discard invalid packets.  To avoid
creating an unwitting amplification attack, such endpoints MUST reduce the
frequency with which it sends packets containing a CONNECTION_CLOSE frame.  To
minimize the state that an endpoint maintains for a closing connection,
endpoints MAY send the exact same packet.<a href="#section-10.3-4" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-10.3-5">
          <dt id="section-10.3-5.1">Note:</dt>
<dd id="section-10.3-5.2">
  Allowing retransmission of a closing packet contradicts other advice in this
document that recommends the creation of new packet numbers for every packet.
Sending new packet numbers is primarily of advantage to loss recovery and
congestion control, which are not expected to be relevant for a closed
connection.  Retransmitting the final packet requires less state.<a href="#section-10.3-5.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-10.3-6">New packets from unverified addresses could be used to create an amplification
attack; see <a href="#address-validation" class="xref">Section 8</a>.  To avoid this, endpoints MUST either limit
transmission of CONNECTION_CLOSE frames to validated addresses or drop packets
without response if the response would be more than three times larger than the
received packet.<a href="#section-10.3-6" class="pilcrow">¶</a></p>
<p id="section-10.3-7">After receiving a CONNECTION_CLOSE frame, endpoints enter the draining state.
An endpoint that receives a CONNECTION_CLOSE frame MAY send a single packet
containing a CONNECTION_CLOSE frame before entering the draining state, using a
CONNECTION_CLOSE frame and a NO_ERROR code if appropriate.  An endpoint MUST NOT
send further packets, which could result in a constant exchange of
CONNECTION_CLOSE frames until the closing period on either peer ended.<a href="#section-10.3-7" class="pilcrow">¶</a></p>
<p id="section-10.3-8">An immediate close can be used after an application protocol has arranged to
close a connection.  This might be after the application protocols negotiates a
graceful shutdown.  The application protocol exchanges whatever messages that
are needed to cause both endpoints to agree to close the connection, after which
the application requests that the connection be closed.  The application
protocol can use a CONNECTION_CLOSE frame with an appropriate error code to
signal closure.<a href="#section-10.3-8" class="pilcrow">¶</a></p>
<div id="immediate-close-hs">
<section id="section-10.3.1">
          <h4 id="name-immediate-close-during-the-">
<a href="#section-10.3.1" class="section-number selfRef">10.3.1. </a><a href="#name-immediate-close-during-the-" class="section-name selfRef">Immediate Close During the Handshake</a>
          </h4>
<p id="section-10.3.1-1">When sending CONNECTION_CLOSE, the goal is to ensure that the peer will process
the frame.  Generally, this means sending the frame in a packet with the highest
level of packet protection to avoid the packet being discarded.  After the
handshake is confirmed (see Section 4.1.2 of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>), an endpoint MUST
send any CONNECTION_CLOSE frames in a 1-RTT packet.  However, prior to
confirming the handshake, it is possible that more advanced packet protection
keys are not available to the peer, so another CONNECTION_CLOSE frame MAY be
sent in a packet that uses a lower packet protection level.  More specifically:<a href="#section-10.3.1-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-10.3.1-2.1">A client will always know whether the server has Handshake keys (see
<a href="#discard-initial" class="xref">Section 17.2.2.1</a>), but it is possible that a server does not know whether
the client has Handshake keys.  Under these circumstances, a server SHOULD
send a CONNECTION_CLOSE frame in both Handshake and Initial packets to ensure
that at least one of them is processable by the client.<a href="#section-10.3.1-2.1" class="pilcrow">¶</a>
</li>
<li id="section-10.3.1-2.2">A client that sends CONNECTION_CLOSE in a 0-RTT packet cannot be assured of
the server has accepted 0-RTT and so sending a CONNECTION_CLOSE frame in an
Initial packet makes it more likely that the server can receive the close
signal, even if the application error code might not be received.<a href="#section-10.3.1-2.2" class="pilcrow">¶</a>
</li>
<li id="section-10.3.1-2.3">Prior to confirming the handshake, a peer might be unable to process 1-RTT
packets, so an endpoint SHOULD send CONNECTION_CLOSE in both Handshake and
1-RTT packets.  A server SHOULD also send CONNECTION_CLOSE in an Initial
packet.<a href="#section-10.3.1-2.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-10.3.1-3">Sending a CONNECTION_CLOSE of type 0x1d in an Initial or Handshake packet could
expose application state or be used to alter application state. A
CONNECTION_CLOSE of type 0x1d MUST be replaced by a CONNECTION_CLOSE of type
0x1c when sending the frame in Initial or Handshake packets. Otherwise,
information about the application state might be revealed. Endpoints MUST clear
the value of the Reason Phrase field and SHOULD use the APPLICATION_ERROR code
when converting to a CONNECTION_CLOSE of type 0x1c.<a href="#section-10.3.1-3" class="pilcrow">¶</a></p>
<p id="section-10.3.1-4">CONNECTION_CLOSE frames sent in multiple packet types can be coalesced into a
single UDP datagram; see <a href="#packet-coalesce" class="xref">Section 12.2</a>.<a href="#section-10.3.1-4" class="pilcrow">¶</a></p>
<p id="section-10.3.1-5">An endpoint might send a CONNECTION_CLOSE frame in an Initial packet or in
response to unauthenticated information received in Initial or Handshake
packets.  Such an immediate close might expose legitimate connections to a
denial of service.  QUIC does not include defensive measures for on-path attacks
during the handshake; see <a href="#handshake-dos" class="xref">Section 21.1</a>.  However, at the cost of reducing
feedback about errors for legitimate peers, some forms of denial of service can
be made more difficult for an attacker if endpoints discard illegal packets
rather than terminating a connection with CONNECTION_CLOSE.  For this reason,
endpoints MAY discard packets rather than immediately close if errors are
detected in packets that lack authentication.<a href="#section-10.3.1-5" class="pilcrow">¶</a></p>
<p id="section-10.3.1-6">An endpoint that has not established state, such as a server that detects an
error in an Initial packet, does not enter the closing state.  An endpoint that
has no state for the connection does not enter a closing or draining period on
sending a CONNECTION_CLOSE frame.<a href="#section-10.3.1-6" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="stateless-reset">
<section id="section-10.4">
        <h3 id="name-stateless-reset">
<a href="#section-10.4" class="section-number selfRef">10.4. </a><a href="#name-stateless-reset" class="section-name selfRef">Stateless Reset</a>
        </h3>
<p id="section-10.4-1">A stateless reset is provided as an option of last resort for an endpoint that
does not have access to the state of a connection.  A crash or outage might
result in peers continuing to send data to an endpoint that is unable to
properly continue the connection.  An endpoint MAY send a stateless reset in
response to receiving a packet that it cannot associate with an active
connection.<a href="#section-10.4-1" class="pilcrow">¶</a></p>
<p id="section-10.4-2">A stateless reset is not appropriate for signaling error conditions.  An
endpoint that wishes to communicate a fatal connection error MUST use a
CONNECTION_CLOSE frame if it has sufficient state to do so.<a href="#section-10.4-2" class="pilcrow">¶</a></p>
<p id="section-10.4-3">To support this process, a token is sent by endpoints.  The token is carried in
the Stateless Reset Token field of a NEW_CONNECTION_ID frame.  Servers can also
specify a stateless_reset_token transport parameter during the handshake that
applies to the connection ID that it selected during the handshake; clients
cannot use this transport parameter because their transport parameters don't
have confidentiality protection.  These tokens are protected by encryption, so
only client and server know their value.  Tokens are invalidated when their
associated connection ID is retired via a RETIRE_CONNECTION_ID frame
(<a href="#frame-retire-connection-id" class="xref">Section 19.16</a>).<a href="#section-10.4-3" class="pilcrow">¶</a></p>
<p id="section-10.4-4">An endpoint that receives packets that it cannot process sends a packet in the
following layout:<a href="#section-10.4-4" class="pilcrow">¶</a></p>
<span id="name-stateless-reset-packet"></span><div id="fig-stateless-reset">
<figure id="figure-9">
          <div class="artwork art-text alignLeft" id="section-10.4-5.1">
<pre>
Stateless Reset {
  Fixed Bits (2) = 1,
  Unpredictable Bits (38..),
  Stateless Reset Token (128),
}
</pre>
</div>
<figcaption><a href="#figure-9" class="selfRef">Figure 9</a>:
<a href="#name-stateless-reset-packet" class="selfRef">Stateless Reset Packet</a>
          </figcaption></figure>
</div>
<p id="section-10.4-6">This design ensures that a stateless reset packet is - to the extent possible -
indistinguishable from a regular packet with a short header.<a href="#section-10.4-6" class="pilcrow">¶</a></p>
<p id="section-10.4-7">A stateless reset uses an entire UDP datagram, starting with the first two bits
of the packet header.  The remainder of the first byte and an arbitrary number
of bytes following it that are set to unpredictable values.  The last 16 bytes
of the datagram contain a Stateless Reset Token.<a href="#section-10.4-7" class="pilcrow">¶</a></p>
<p id="section-10.4-8">To entities other than its intended recipient, a stateless reset will appear to
be a packet with a short header.  For the stateless reset to appear as a valid
QUIC packet, the Unpredictable Bits field needs to include at least 38 bits of
data (or 5 bytes, less the two fixed bits).<a href="#section-10.4-8" class="pilcrow">¶</a></p>
<p id="section-10.4-9">A minimum size of 21 bytes does not guarantee that a stateless reset is
difficult to distinguish from other packets if the recipient requires the use of
a connection ID.  To prevent a resulting stateless reset from being trivially
distinguishable from a valid packet, all packets sent by an endpoint SHOULD be
padded to at least 22 bytes longer than the minimum connection ID that the
endpoint might use.  An endpoint that sends a stateless reset in response to
packet that is 43 bytes or less in length SHOULD send a stateless reset that is
one byte shorter than the packet it responds to.<a href="#section-10.4-9" class="pilcrow">¶</a></p>
<p id="section-10.4-10">These values assume that the Stateless Reset Token is the same as the minimum
expansion of the packet protection AEAD.  Additional unpredictable bytes are
necessary if the endpoint could have negotiated a packet protection scheme with
a larger minimum expansion.<a href="#section-10.4-10" class="pilcrow">¶</a></p>
<p id="section-10.4-11">An endpoint MUST NOT send a stateless reset that is three times or more larger
than the packet it receives to avoid being used for amplification.
<a href="#reset-looping" class="xref">Section 10.4.3</a> describes additional limits on stateless reset size.<a href="#section-10.4-11" class="pilcrow">¶</a></p>
<p id="section-10.4-12">Endpoints MUST discard packets that are too small to be valid QUIC packets.
With the set of AEAD functions defined in <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>, packets that are smaller
than 21 bytes are never valid.<a href="#section-10.4-12" class="pilcrow">¶</a></p>
<p id="section-10.4-13">Endpoints MUST send stateless reset packets formatted as a packet with a short
header.  However, endpoints MUST treat any packet ending in a valid stateless
reset token as a stateless reset, as other QUIC versions might allow the use of
a long header.<a href="#section-10.4-13" class="pilcrow">¶</a></p>
<p id="section-10.4-14">An endpoint MAY send a stateless reset in response to a packet with a long
header.  Sending a stateless reset is not effective prior to the stateless reset
token being available to a peer.  In this QUIC version, packets with a long
header are only used during connection establishment.   Because the stateless
reset token is not available until connection establishment is complete or near
completion, ignoring an unknown packet with a long header might be as effective
as sending a stateless reset.<a href="#section-10.4-14" class="pilcrow">¶</a></p>
<p id="section-10.4-15">An endpoint cannot determine the Source Connection ID from a packet with a short
header, therefore it cannot set the Destination Connection ID in the stateless
reset packet.  The Destination Connection ID will therefore differ from the
value used in previous packets.  A random Destination Connection ID makes the
connection ID appear to be the result of moving to a new connection ID that was
provided using a NEW_CONNECTION_ID frame (<a href="#frame-new-connection-id" class="xref">Section 19.15</a>).<a href="#section-10.4-15" class="pilcrow">¶</a></p>
<p id="section-10.4-16">Using a randomized connection ID results in two problems:<a href="#section-10.4-16" class="pilcrow">¶</a></p>
<ul>
<li id="section-10.4-17.1">The packet might not reach the peer.  If the Destination Connection ID is
critical for routing toward the peer, then this packet could be incorrectly
routed.  This might also trigger another Stateless Reset in response; see
<a href="#reset-looping" class="xref">Section 10.4.3</a>.  A Stateless Reset that is not correctly routed is
an ineffective error detection and recovery mechanism.  In this
case, endpoints will need to rely on other methods - such as timers - to
detect that the connection has failed.<a href="#section-10.4-17.1" class="pilcrow">¶</a>
</li>
<li id="section-10.4-17.2">The randomly generated connection ID can be used by entities other than the
peer to identify this as a potential stateless reset.  An endpoint that
occasionally uses different connection IDs might introduce some uncertainty
about this.<a href="#section-10.4-17.2" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-10.4-18">This stateless reset design is specific to QUIC version 1.  An endpoint that
supports multiple versions of QUIC needs to generate a stateless reset that will
be accepted by peers that support any version that the endpoint might support
(or might have supported prior to losing state).  Designers of new versions of
QUIC need to be aware of this and either reuse this design, or use a portion of
the packet other than the last 16 bytes for carrying data.<a href="#section-10.4-18" class="pilcrow">¶</a></p>
<div id="detecting-a-stateless-reset">
<section id="section-10.4.1">
          <h4 id="name-detecting-a-stateless-reset">
<a href="#section-10.4.1" class="section-number selfRef">10.4.1. </a><a href="#name-detecting-a-stateless-reset" class="section-name selfRef">Detecting a Stateless Reset</a>
          </h4>
<p id="section-10.4.1-1">An endpoint detects a potential stateless reset using the trailing 16 bytes of
the UDP datagram.  An endpoint remembers all Stateless Reset Tokens associated
with the connection IDs and remote addresses for datagrams it has recently sent.
This includes Stateless Reset Tokens from NEW_CONNECTION_ID frames and the
server's transport parameters but excludes Stateless Reset Tokens associated
with connection IDs that are either unused or retired.  The endpoint identifies
a received datagram as a stateless reset by comparing the last 16 bytes of the
datagram with all Stateless Reset Tokens associated with the remote address on
which the datagram was received.<a href="#section-10.4.1-1" class="pilcrow">¶</a></p>
<p id="section-10.4.1-2">This comparison can be performed for every inbound datagram.  Endpoints MAY skip
this check if any packet from a datagram is successfully processed.  However,
the comparison MUST be performed when the first packet in an incoming datagram
either cannot be associated with a connection, or cannot be decrypted.<a href="#section-10.4.1-2" class="pilcrow">¶</a></p>
<p id="section-10.4.1-3">An endpoint MUST NOT check for any Stateless Reset Tokens associated with
connection IDs it has not used or for connection IDs that have been retired.<a href="#section-10.4.1-3" class="pilcrow">¶</a></p>
<p id="section-10.4.1-4">When comparing a datagram to Stateless Reset Token values, endpoints MUST
perform the comparison without leaking information about the value of the token.
For example, performing this comparison in constant time protects the value of
individual Stateless Reset Tokens from information leakage through timing side
channels.  Another approach would be to store and compare the transformed values
of Stateless Reset Tokens instead of the raw token values, where the
transformation is defined as a cryptographically-secure pseudo-random function
using a secret key (e.g., block cipher, HMAC <span>[<a href="#RFC2104" class="xref">RFC2104</a>]</span>). An endpoint is not
expected to protect information about whether a packet was successfully
decrypted, or the number of valid Stateless Reset Tokens.<a href="#section-10.4.1-4" class="pilcrow">¶</a></p>
<p id="section-10.4.1-5">If the last 16 bytes of the datagram are identical in value to a Stateless Reset
Token, the endpoint MUST enter the draining period and not send any further
packets on this connection.<a href="#section-10.4.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="reset-token">
<section id="section-10.4.2">
          <h4 id="name-calculating-a-stateless-res">
<a href="#section-10.4.2" class="section-number selfRef">10.4.2. </a><a href="#name-calculating-a-stateless-res" class="section-name selfRef">Calculating a Stateless Reset Token</a>
          </h4>
<p id="section-10.4.2-1">The stateless reset token MUST be difficult to guess.  In order to create a
Stateless Reset Token, an endpoint could randomly generate <span>[<a href="#RFC4086" class="xref">RFC4086</a>]</span> a secret
for every connection that it creates.  However, this presents a coordination
problem when there are multiple instances in a cluster or a storage problem for
an endpoint that might lose state.  Stateless reset specifically exists to
handle the case where state is lost, so this approach is suboptimal.<a href="#section-10.4.2-1" class="pilcrow">¶</a></p>
<p id="section-10.4.2-2">A single static key can be used across all connections to the same endpoint by
generating the proof using a second iteration of a preimage-resistant function
that takes a static key and the connection ID chosen by the endpoint (see
<a href="#connection-id" class="xref">Section 5.1</a>) as input.  An endpoint could use HMAC <span>[<a href="#RFC2104" class="xref">RFC2104</a>]</span> (for
example, HMAC(static_key, connection_id)) or HKDF <span>[<a href="#RFC5869" class="xref">RFC5869</a>]</span> (for example,
using the static key as input keying material, with the connection ID as salt).
The output of this function is truncated to 16 bytes to produce the Stateless
Reset Token for that connection.<a href="#section-10.4.2-2" class="pilcrow">¶</a></p>
<p id="section-10.4.2-3">An endpoint that loses state can use the same method to generate a valid
Stateless Reset Token.  The connection ID comes from the packet that the
endpoint receives.<a href="#section-10.4.2-3" class="pilcrow">¶</a></p>
<p id="section-10.4.2-4">This design relies on the peer always sending a connection ID in its packets so
that the endpoint can use the connection ID from a packet to reset the
connection.  An endpoint that uses this design MUST either use the same
connection ID length for all connections or encode the length of the connection
ID such that it can be recovered without state.  In addition, it cannot provide
a zero-length connection ID.<a href="#section-10.4.2-4" class="pilcrow">¶</a></p>
<p id="section-10.4.2-5">Revealing the Stateless Reset Token allows any entity to terminate the
connection, so a value can only be used once.  This method for choosing the
Stateless Reset Token means that the combination of connection ID and static key
MUST NOT be used for another connection.  A denial of service attack is possible
if the same connection ID is used by instances that share a static key, or if an
attacker can cause a packet to be routed to an instance that has no state but
the same static key; see <a href="#reset-oracle" class="xref">Section 21.9</a>.  A connection ID from a connection
that is reset by revealing the Stateless Reset Token MUST NOT be reused for new
connections at nodes that share a static key.<a href="#section-10.4.2-5" class="pilcrow">¶</a></p>
<p id="section-10.4.2-6">The same Stateless Reset Token MUST NOT be used for multiple connection IDs.
Endpoints are not required to compare new values against all previous values,
but a duplicate value MAY be treated as a connection error of type
PROTOCOL_VIOLATION.<a href="#section-10.4.2-6" class="pilcrow">¶</a></p>
<p id="section-10.4.2-7">Note that Stateless Reset packets do not have any cryptographic protection.<a href="#section-10.4.2-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="reset-looping">
<section id="section-10.4.3">
          <h4 id="name-looping">
<a href="#section-10.4.3" class="section-number selfRef">10.4.3. </a><a href="#name-looping" class="section-name selfRef">Looping</a>
          </h4>
<p id="section-10.4.3-1">The design of a Stateless Reset is such that without knowing the stateless reset
token it is indistinguishable from a valid packet.  For instance, if a server
sends a Stateless Reset to another server it might receive another Stateless
Reset in response, which could lead to an infinite exchange.<a href="#section-10.4.3-1" class="pilcrow">¶</a></p>
<p id="section-10.4.3-2">An endpoint MUST ensure that every Stateless Reset that it sends is smaller than
the packet which triggered it, unless it maintains state sufficient to prevent
looping.  In the event of a loop, this results in packets eventually being too
small to trigger a response.<a href="#section-10.4.3-2" class="pilcrow">¶</a></p>
<p id="section-10.4.3-3">An endpoint can remember the number of Stateless Reset packets that it has sent
and stop generating new Stateless Reset packets once a limit is reached.  Using
separate limits for different remote addresses will ensure that Stateless Reset
packets can be used to close connections when other peers or connections have
exhausted limits.<a href="#section-10.4.3-3" class="pilcrow">¶</a></p>
<p id="section-10.4.3-4">Reducing the size of a Stateless Reset below 41 bytes means that the packet
could reveal to an observer that it is a Stateless Reset, depending upon the
length of the peer's connection IDs.  Conversely, refusing to send a Stateless
Reset in response to a small packet might result in Stateless Reset not being
useful in detecting cases of broken connections where only very small packets
are sent; such failures might only be detected by other means, such as timers.<a href="#section-10.4.3-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="error-handling">
<section id="section-11">
      <h2 id="name-error-handling">
<a href="#section-11" class="section-number selfRef">11. </a><a href="#name-error-handling" class="section-name selfRef">Error Handling</a>
      </h2>
<p id="section-11-1">An endpoint that detects an error SHOULD signal the existence of that error to
its peer.  Both transport-level and application-level errors can affect an
entire connection; see <a href="#connection-errors" class="xref">Section 11.1</a>.  Only application-level
errors can be isolated to a single stream; see <a href="#stream-errors" class="xref">Section 11.2</a>.<a href="#section-11-1" class="pilcrow">¶</a></p>
<p id="section-11-2">The most appropriate error code (<a href="#error-codes" class="xref">Section 20</a>) SHOULD be included in the
frame that signals the error.  Where this specification identifies error
conditions, it also identifies the error code that is used; though these are
worded as requirements, different implementation strategies might lead to
different errors being reported.  In particular, an endpoint MAY use any
applicable error code when it detects an error condition; a generic error code
(such as PROTOCOL_VIOLATION or INTERNAL_ERROR) can always be used in place of
specific error codes.<a href="#section-11-2" class="pilcrow">¶</a></p>
<p id="section-11-3">A stateless reset (<a href="#stateless-reset" class="xref">Section 10.4</a>) is not suitable for any error that can
be signaled with a CONNECTION_CLOSE or RESET_STREAM frame.  A stateless reset
MUST NOT be used by an endpoint that has the state necessary to send a frame on
the connection.<a href="#section-11-3" class="pilcrow">¶</a></p>
<div id="connection-errors">
<section id="section-11.1">
        <h3 id="name-connection-errors">
<a href="#section-11.1" class="section-number selfRef">11.1. </a><a href="#name-connection-errors" class="section-name selfRef">Connection Errors</a>
        </h3>
<p id="section-11.1-1">Errors that result in the connection being unusable, such as an obvious
violation of protocol semantics or corruption of state that affects an entire
connection, MUST be signaled using a CONNECTION_CLOSE frame
(<a href="#frame-connection-close" class="xref">Section 19.19</a>). An endpoint MAY close the connection in this
manner even if the error only affects a single stream.<a href="#section-11.1-1" class="pilcrow">¶</a></p>
<p id="section-11.1-2">Application protocols can signal application-specific protocol errors using the
application-specific variant of the CONNECTION_CLOSE frame.  Errors that are
specific to the transport, including all those described in this document, are
carried in the QUIC-specific variant of the CONNECTION_CLOSE frame.<a href="#section-11.1-2" class="pilcrow">¶</a></p>
<p id="section-11.1-3">A CONNECTION_CLOSE frame could be sent in a packet that is lost.  An endpoint
SHOULD be prepared to retransmit a packet containing a CONNECTION_CLOSE frame if
it receives more packets on a terminated connection. Limiting the number of
retransmissions and the time over which this final packet is sent limits the
effort expended on terminated connections.<a href="#section-11.1-3" class="pilcrow">¶</a></p>
<p id="section-11.1-4">An endpoint that chooses not to retransmit packets containing a CONNECTION_CLOSE
frame risks a peer missing the first such packet.  The only mechanism available
to an endpoint that continues to receive data for a terminated connection is to
use the stateless reset process (<a href="#stateless-reset" class="xref">Section 10.4</a>).<a href="#section-11.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="stream-errors">
<section id="section-11.2">
        <h3 id="name-stream-errors">
<a href="#section-11.2" class="section-number selfRef">11.2. </a><a href="#name-stream-errors" class="section-name selfRef">Stream Errors</a>
        </h3>
<p id="section-11.2-1">If an application-level error affects a single stream, but otherwise leaves the
connection in a recoverable state, the endpoint can send a RESET_STREAM frame
(<a href="#frame-reset-stream" class="xref">Section 19.4</a>) with an appropriate error code to terminate just the
affected stream.<a href="#section-11.2-1" class="pilcrow">¶</a></p>
<p id="section-11.2-2">Resetting a stream without the involvement of the application protocol could
cause the application protocol to enter an unrecoverable state.  RESET_STREAM
MUST only be instigated by the application protocol that uses QUIC.<a href="#section-11.2-2" class="pilcrow">¶</a></p>
<p id="section-11.2-3">The semantics of the application error code carried in RESET_STREAM are
defined by the application protocol.  Only the application protocol is able to
cause a stream to be terminated.  A local instance of the application protocol
uses a direct API call and a remote instance uses the STOP_SENDING frame, which
triggers an automatic RESET_STREAM.<a href="#section-11.2-3" class="pilcrow">¶</a></p>
<p id="section-11.2-4">Application protocols SHOULD define rules for handling streams that are
prematurely cancelled by either endpoint.<a href="#section-11.2-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="packets-frames">
<section id="section-12">
      <h2 id="name-packets-and-frames">
<a href="#section-12" class="section-number selfRef">12. </a><a href="#name-packets-and-frames" class="section-name selfRef">Packets and Frames</a>
      </h2>
<p id="section-12-1">QUIC endpoints communicate by exchanging packets. Packets have confidentiality
and integrity protection; see <a href="#packet-protected" class="xref">Section 12.1</a>. Packets are carried in UDP
datagrams; see <a href="#packet-coalesce" class="xref">Section 12.2</a>.<a href="#section-12-1" class="pilcrow">¶</a></p>
<p id="section-12-2">This version of QUIC uses the long packet header during connection
establishment; see <a href="#long-header" class="xref">Section 17.2</a>.  Packets with the long header are Initial
(<a href="#packet-initial" class="xref">Section 17.2.2</a>), 0-RTT (<a href="#packet-0rtt" class="xref">Section 17.2.3</a>), Handshake (<a href="#packet-handshake" class="xref">Section 17.2.4</a>),
and Retry (<a href="#packet-retry" class="xref">Section 17.2.5</a>).  Version negotiation uses a version-independent
packet with a long header; see <a href="#packet-version" class="xref">Section 17.2.1</a>.<a href="#section-12-2" class="pilcrow">¶</a></p>
<p id="section-12-3">Packets with the short header are designed for minimal overhead and are used
after a connection is established and 1-RTT keys are available; see
<a href="#short-header" class="xref">Section 17.3</a>.<a href="#section-12-3" class="pilcrow">¶</a></p>
<div id="packet-protected">
<section id="section-12.1">
        <h3 id="name-protected-packets">
<a href="#section-12.1" class="section-number selfRef">12.1. </a><a href="#name-protected-packets" class="section-name selfRef">Protected Packets</a>
        </h3>
<p id="section-12.1-1">All QUIC packets except Version Negotiation packets use authenticated
encryption with additional data (AEAD) <span>[<a href="#RFC5116" class="xref">RFC5116</a>]</span> to provide confidentiality
and integrity protection.  Retry packets use AEAD to provide integrity
protection.  Details of packet protection are found in <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>; this
section includes an overview of the process.<a href="#section-12.1-1" class="pilcrow">¶</a></p>
<p id="section-12.1-2">Initial packets are protected using keys that are statically derived. This
packet protection is not effective confidentiality protection.  Initial
protection only exists to ensure that the sender of the packet is on the network
path. Any entity that receives the Initial packet from a client can recover the
keys necessary to remove packet protection or to generate packets that will be
successfully authenticated.<a href="#section-12.1-2" class="pilcrow">¶</a></p>
<p id="section-12.1-3">All other packets are protected with keys derived from the cryptographic
handshake. The type of the packet from the long header or key phase from the
short header are used to identify which encryption keys are used. Packets
protected with 0-RTT and 1-RTT keys are expected to have confidentiality and
data origin authentication; the cryptographic handshake ensures that only the
communicating endpoints receive the corresponding keys.<a href="#section-12.1-3" class="pilcrow">¶</a></p>
<p id="section-12.1-4">The packet number field contains a packet number, which has additional
confidentiality protection that is applied after packet protection is applied;
see <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span> for details.  The underlying packet number increases with each
packet sent in a given packet number space; see <a href="#packet-numbers" class="xref">Section 12.3</a> for details.<a href="#section-12.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="packet-coalesce">
<section id="section-12.2">
        <h3 id="name-coalescing-packets">
<a href="#section-12.2" class="section-number selfRef">12.2. </a><a href="#name-coalescing-packets" class="section-name selfRef">Coalescing Packets</a>
        </h3>
<p id="section-12.2-1">Initial (<a href="#packet-initial" class="xref">Section 17.2.2</a>), 0-RTT (<a href="#packet-0rtt" class="xref">Section 17.2.3</a>), and Handshake
(<a href="#packet-handshake" class="xref">Section 17.2.4</a>) packets contain a Length field, which determines the end
of the packet.  The length includes both the Packet Number and Payload
fields, both of which are confidentiality protected and initially of unknown
length. The length of the Payload field is learned once header protection is
removed.<a href="#section-12.2-1" class="pilcrow">¶</a></p>
<p id="section-12.2-2">Using the Length field, a sender can coalesce multiple QUIC packets into one UDP
datagram.  This can reduce the number of UDP datagrams needed to complete the
cryptographic handshake and start sending data.  This can also be used to
construct PMTU probes; see <a href="#pmtu-probes-src-cid" class="xref">Section 14.3.1</a>.  Receivers MUST be able to
process coalesced packets.<a href="#section-12.2-2" class="pilcrow">¶</a></p>
<p id="section-12.2-3">Coalescing packets in order of increasing encryption levels (Initial, 0-RTT,
Handshake, 1-RTT; see Section 4.1.4 of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>) makes it more likely the
receiver will be able to process all the packets in a single pass. A packet
with a short header does not include a length, so it can only be the last
packet included in a UDP datagram. An endpoint SHOULD NOT coalesce multiple
packets at the same encryption level.<a href="#section-12.2-3" class="pilcrow">¶</a></p>
<p id="section-12.2-4">Senders MUST NOT coalesce QUIC packets for different connections into a single
UDP datagram. Receivers SHOULD ignore any subsequent packets with a different
Destination Connection ID than the first packet in the datagram.<a href="#section-12.2-4" class="pilcrow">¶</a></p>
<p id="section-12.2-5">Every QUIC packet that is coalesced into a single UDP datagram is separate and
complete.  The receiver of coalesced QUIC packets MUST individually process each
QUIC packet and separately acknowledge them, as if they were received as the
payload of different UDP datagrams.  For example, if decryption fails (because
the keys are not available or any other reason), the receiver MAY either discard
or buffer the packet for later processing and MUST attempt to process the
remaining packets.<a href="#section-12.2-5" class="pilcrow">¶</a></p>
<p id="section-12.2-6">Retry packets (<a href="#packet-retry" class="xref">Section 17.2.5</a>), Version Negotiation packets
(<a href="#packet-version" class="xref">Section 17.2.1</a>), and packets with a short header (<a href="#short-header" class="xref">Section 17.3</a>) do not
contain a Length field and so cannot be followed by other packets in the same
UDP datagram.  Note also that there is no situation where a Retry or Version
Negotiation packet is coalesced with another packet.<a href="#section-12.2-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="packet-numbers">
<section id="section-12.3">
        <h3 id="name-packet-numbers">
<a href="#section-12.3" class="section-number selfRef">12.3. </a><a href="#name-packet-numbers" class="section-name selfRef">Packet Numbers</a>
        </h3>
<p id="section-12.3-1">The packet number is an integer in the range 0 to 2^62-1.  This number is used
in determining the cryptographic nonce for packet protection.  Each endpoint
maintains a separate packet number for sending and receiving.<a href="#section-12.3-1" class="pilcrow">¶</a></p>
<p id="section-12.3-2">Packet numbers are limited to this range because they need to be representable
in whole in the Largest Acknowledged field of an ACK frame (<a href="#frame-ack" class="xref">Section 19.3</a>).
When present in a long or short header however, packet numbers are reduced and
encoded in 1 to 4 bytes; see <a href="#packet-encoding" class="xref">Section 17.1</a>.<a href="#section-12.3-2" class="pilcrow">¶</a></p>
<p id="section-12.3-3">Version Negotiation (<a href="#packet-version" class="xref">Section 17.2.1</a>) and Retry (<a href="#packet-retry" class="xref">Section 17.2.5</a>) packets
do not include a packet number.<a href="#section-12.3-3" class="pilcrow">¶</a></p>
<p id="section-12.3-4">Packet numbers are divided into 3 spaces in QUIC:<a href="#section-12.3-4" class="pilcrow">¶</a></p>
<ul>
<li id="section-12.3-5.1">Initial space: All Initial packets (<a href="#packet-initial" class="xref">Section 17.2.2</a>) are in this space.<a href="#section-12.3-5.1" class="pilcrow">¶</a>
</li>
<li id="section-12.3-5.2">Handshake space: All Handshake packets (<a href="#packet-handshake" class="xref">Section 17.2.4</a>) are in this
space.<a href="#section-12.3-5.2" class="pilcrow">¶</a>
</li>
<li id="section-12.3-5.3">Application data space: All 0-RTT and 1-RTT encrypted packets
(<a href="#packet-protected" class="xref">Section 12.1</a>) are in this space.<a href="#section-12.3-5.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-12.3-6">As described in <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>, each packet type uses different protection keys.<a href="#section-12.3-6" class="pilcrow">¶</a></p>
<p id="section-12.3-7">Conceptually, a packet number space is the context in which a packet can be
processed and acknowledged.  Initial packets can only be sent with Initial
packet protection keys and acknowledged in packets which are also Initial
packets.  Similarly, Handshake packets are sent at the Handshake encryption
level and can only be acknowledged in Handshake packets.<a href="#section-12.3-7" class="pilcrow">¶</a></p>
<p id="section-12.3-8">This enforces cryptographic separation between the data sent in the different
packet sequence number spaces.  Packet numbers in each space start at packet
number 0.  Subsequent packets sent in the same packet number space MUST increase
the packet number by at least one.<a href="#section-12.3-8" class="pilcrow">¶</a></p>
<p id="section-12.3-9">0-RTT and 1-RTT data exist in the same packet number space to make loss recovery
algorithms easier to implement between the two packet types.<a href="#section-12.3-9" class="pilcrow">¶</a></p>
<p id="section-12.3-10">A QUIC endpoint MUST NOT reuse a packet number within the same packet number
space in one connection.  If the packet number for sending reaches 2^62 - 1, the
sender MUST close the connection without sending a CONNECTION_CLOSE frame or any
further packets; an endpoint MAY send a Stateless Reset (<a href="#stateless-reset" class="xref">Section 10.4</a>) in
response to further packets that it receives.<a href="#section-12.3-10" class="pilcrow">¶</a></p>
<p id="section-12.3-11">A receiver MUST discard a newly unprotected packet unless it is certain that it
has not processed another packet with the same packet number from the same
packet number space. Duplicate suppression MUST happen after removing packet
protection for the reasons described in Section 9.3 of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>. An
efficient algorithm for duplicate suppression can be found in Section 3.4.3 of
<span>[<a href="#RFC4303" class="xref">RFC4303</a>]</span>.<a href="#section-12.3-11" class="pilcrow">¶</a></p>
<p id="section-12.3-12">Packet number encoding at a sender and decoding at a receiver are described in
<a href="#packet-encoding" class="xref">Section 17.1</a>.<a href="#section-12.3-12" class="pilcrow">¶</a></p>
</section>
</div>
<div id="frames">
<section id="section-12.4">
        <h3 id="name-frames-and-frame-types">
<a href="#section-12.4" class="section-number selfRef">12.4. </a><a href="#name-frames-and-frame-types" class="section-name selfRef">Frames and Frame Types</a>
        </h3>
<p id="section-12.4-1">The payload of QUIC packets, after removing packet protection, consists of a
sequence of complete frames, as shown in <a href="#packet-frames" class="xref">Figure 10</a>.  Version
Negotiation, Stateless Reset, and Retry packets do not contain frames.<a href="#section-12.4-1" class="pilcrow">¶</a></p>
<span id="name-quic-payload"></span><div id="packet-frames">
<figure id="figure-10">
          <div class="artwork art-text alignLeft" id="section-12.4-2.1">
<pre>
Packet Payload {
  Frame (..) ...,
}
</pre>
</div>
<figcaption><a href="#figure-10" class="selfRef">Figure 10</a>:
<a href="#name-quic-payload" class="selfRef">QUIC Payload</a>
          </figcaption></figure>
</div>
<p id="section-12.4-3">The payload of a packet that contains frames MUST contain at least one frame,
and MAY contain multiple frames and multiple frame types.  Frames always fit
within a single QUIC packet and cannot span multiple packets.<a href="#section-12.4-3" class="pilcrow">¶</a></p>
<p id="section-12.4-4">Each frame begins with a Frame Type, indicating its type, followed by
additional type-dependent fields:<a href="#section-12.4-4" class="pilcrow">¶</a></p>
<span id="name-generic-frame-layout"></span><div id="frame-layout">
<figure id="figure-11">
          <div class="artwork art-text alignLeft" id="section-12.4-5.1">
<pre>
Frame {
  Frame Type (i),
  Type-Dependent Fields (..),
}
</pre>
</div>
<figcaption><a href="#figure-11" class="selfRef">Figure 11</a>:
<a href="#name-generic-frame-layout" class="selfRef">Generic Frame Layout</a>
          </figcaption></figure>
</div>
<p id="section-12.4-6">The frame types defined in this specification are listed in <a href="#frame-types" class="xref">Table 3</a>.
The Frame Type in ACK, STREAM, MAX_STREAMS, STREAMS_BLOCKED, and
CONNECTION_CLOSE frames is used to carry other frame-specific flags. For all
other frames, the Frame Type field simply identifies the frame.  These
frames are explained in more detail in <a href="#frame-formats" class="xref">Section 19</a>.<a href="#section-12.4-6" class="pilcrow">¶</a></p>
<span id="name-frame-types"></span><div id="frame-types">
<table class="center" id="table-3">
          <caption>
<a href="#table-3" class="selfRef">Table 3</a>:
<a href="#name-frame-types" class="selfRef">Frame Types</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Type Value</th>
              <th class="text-left" rowspan="1" colspan="1">Frame Type Name</th>
              <th class="text-left" rowspan="1" colspan="1">Definition</th>
              <th class="text-left" rowspan="1" colspan="1">Packets</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x00</td>
              <td class="text-left" rowspan="1" colspan="1">PADDING</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-padding" class="xref">Section 19.1</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">IH01</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x01</td>
              <td class="text-left" rowspan="1" colspan="1">PING</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-ping" class="xref">Section 19.2</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">IH01</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x02 - 0x03</td>
              <td class="text-left" rowspan="1" colspan="1">ACK</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-ack" class="xref">Section 19.3</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">IH_1</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x04</td>
              <td class="text-left" rowspan="1" colspan="1">RESET_STREAM</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-reset-stream" class="xref">Section 19.4</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">__01</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x05</td>
              <td class="text-left" rowspan="1" colspan="1">STOP_SENDING</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-stop-sending" class="xref">Section 19.5</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">__01</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x06</td>
              <td class="text-left" rowspan="1" colspan="1">CRYPTO</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-crypto" class="xref">Section 19.6</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">IH_1</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x07</td>
              <td class="text-left" rowspan="1" colspan="1">NEW_TOKEN</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-new-token" class="xref">Section 19.7</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">___1</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x08 - 0x0f</td>
              <td class="text-left" rowspan="1" colspan="1">STREAM</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-stream" class="xref">Section 19.8</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">__01</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x10</td>
              <td class="text-left" rowspan="1" colspan="1">MAX_DATA</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-max-data" class="xref">Section 19.9</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">__01</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x11</td>
              <td class="text-left" rowspan="1" colspan="1">MAX_STREAM_DATA</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-max-stream-data" class="xref">Section 19.10</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">__01</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x12 - 0x13</td>
              <td class="text-left" rowspan="1" colspan="1">MAX_STREAMS</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-max-streams" class="xref">Section 19.11</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">__01</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x14</td>
              <td class="text-left" rowspan="1" colspan="1">DATA_BLOCKED</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-data-blocked" class="xref">Section 19.12</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">__01</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x15</td>
              <td class="text-left" rowspan="1" colspan="1">STREAM_DATA_BLOCKED</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-stream-data-blocked" class="xref">Section 19.13</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">__01</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x16 - 0x17</td>
              <td class="text-left" rowspan="1" colspan="1">STREAMS_BLOCKED</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-streams-blocked" class="xref">Section 19.14</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">__01</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x18</td>
              <td class="text-left" rowspan="1" colspan="1">NEW_CONNECTION_ID</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-new-connection-id" class="xref">Section 19.15</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">__01</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x19</td>
              <td class="text-left" rowspan="1" colspan="1">RETIRE_CONNECTION_ID</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-retire-connection-id" class="xref">Section 19.16</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">__01</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x1a</td>
              <td class="text-left" rowspan="1" colspan="1">PATH_CHALLENGE</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-path-challenge" class="xref">Section 19.17</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">__01</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x1b</td>
              <td class="text-left" rowspan="1" colspan="1">PATH_RESPONSE</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-path-response" class="xref">Section 19.18</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">__01</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x1c - 0x1d</td>
              <td class="text-left" rowspan="1" colspan="1">CONNECTION_CLOSE</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-connection-close" class="xref">Section 19.19</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">ih01</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x1e</td>
              <td class="text-left" rowspan="1" colspan="1">HANDSHAKE_DONE</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#frame-handshake-done" class="xref">Section 19.20</a>
</td>
              <td class="text-left" rowspan="1" colspan="1">___1</td>
            </tr>
          </tbody>
        </table>
</div>
<p id="section-12.4-8">The "Packets" column in <a href="#frame-types" class="xref">Table 3</a> does not form part of the IANA registry;
see <a href="#iana-frames" class="xref">Section 22.3</a>.  This column lists the types of packets that each frame
type could appear in, indicated by the following characters:<a href="#section-12.4-8" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-12.4-9">
          <dt id="section-12.4-9.1">I:</dt>
<dd id="section-12.4-9.2">
  Initial (<a href="#packet-initial" class="xref">Section 17.2.2</a>)<a href="#section-12.4-9.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-12.4-9.3">H:</dt>
<dd id="section-12.4-9.4">
  Handshake (<a href="#packet-handshake" class="xref">Section 17.2.4</a>)<a href="#section-12.4-9.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-12.4-9.5">0:</dt>
<dd id="section-12.4-9.6">
  0-RTT (<a href="#packet-0rtt" class="xref">Section 17.2.3</a>)<a href="#section-12.4-9.6" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-12.4-9.7">1:</dt>
<dd id="section-12.4-9.8">
  1-RTT (<a href="#short-header" class="xref">Section 17.3</a>)<a href="#section-12.4-9.8" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-12.4-9.9">ih:</dt>
<dd id="section-12.4-9.10">
  A CONNECTION_CLOSE frame of type 0x1d cannot appear in Initial or Handshake
packets.<a href="#section-12.4-9.10" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-12.4-10">Section 4 of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span> provides more detail about these restrictions.  Note
that all frames can appear in 1-RTT packets.<a href="#section-12.4-10" class="pilcrow">¶</a></p>
<p id="section-12.4-11">An endpoint MUST treat the receipt of a frame of unknown type as a connection
error of type FRAME_ENCODING_ERROR.<a href="#section-12.4-11" class="pilcrow">¶</a></p>
<p id="section-12.4-12">All QUIC frames are idempotent in this version of QUIC.  That is, a valid
frame does not cause undesirable side effects or errors when received more
than once.<a href="#section-12.4-12" class="pilcrow">¶</a></p>
<p id="section-12.4-13">The Frame Type field uses a variable length integer encoding (see
<a href="#integer-encoding" class="xref">Section 16</a>) with one exception.  To ensure simple and efficient
implementations of frame parsing, a frame type MUST use the shortest possible
encoding.  For frame types defined in this document, this means a single-byte
encoding, even though it is possible to encode these values as a two-, four-
or eight-byte variable length integer.  For instance, though 0x4001 is
a legitimate two-byte encoding for a variable-length integer with a value
of 1, PING frames are always encoded as a single byte with the value 0x01.
This rule applies to all current and future QUIC frame types.  An endpoint
MAY treat the receipt of a frame type that uses a longer encoding than
necessary as a connection error of type PROTOCOL_VIOLATION.<a href="#section-12.4-13" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="packetization">
<section id="section-13">
      <h2 id="name-packetization-and-reliabili">
<a href="#section-13" class="section-number selfRef">13. </a><a href="#name-packetization-and-reliabili" class="section-name selfRef">Packetization and Reliability</a>
      </h2>
<p id="section-13-1">A sender bundles one or more frames in a QUIC packet; see <a href="#frames" class="xref">Section 12.4</a>.<a href="#section-13-1" class="pilcrow">¶</a></p>
<p id="section-13-2">A sender can minimize per-packet bandwidth and computational costs by bundling
as many frames as possible within a QUIC packet.  A sender MAY wait for a short
period of time to bundle multiple frames before sending a packet that is not
maximally packed, to avoid sending out large numbers of small packets.  An
implementation MAY use knowledge about application sending behavior or
heuristics to determine whether and for how long to wait.  This waiting period
is an implementation decision, and an implementation should be careful to delay
conservatively, since any delay is likely to increase application-visible
latency.<a href="#section-13-2" class="pilcrow">¶</a></p>
<p id="section-13-3">Stream multiplexing is achieved by interleaving STREAM frames from multiple
streams into one or more QUIC packets.  A single QUIC packet can include
multiple STREAM frames from one or more streams.<a href="#section-13-3" class="pilcrow">¶</a></p>
<p id="section-13-4">One of the benefits of QUIC is avoidance of head-of-line blocking across
multiple streams.  When a packet loss occurs, only streams with data in that
packet are blocked waiting for a retransmission to be received, while other
streams can continue making progress.  Note that when data from multiple streams
is bundled into a single QUIC packet, loss of that packet blocks all those
streams from making progress.  Implementations are advised to bundle as few
streams as necessary in outgoing packets without losing transmission efficiency
to underfilled packets.<a href="#section-13-4" class="pilcrow">¶</a></p>
<div id="processing">
<section id="section-13.1">
        <h3 id="name-packet-processing">
<a href="#section-13.1" class="section-number selfRef">13.1. </a><a href="#name-packet-processing" class="section-name selfRef">Packet Processing</a>
        </h3>
<p id="section-13.1-1">A packet MUST NOT be acknowledged until packet protection has been successfully
removed and all frames contained in the packet have been processed.  For STREAM
frames, this means the data has been enqueued in preparation to be received by
the application protocol, but it does not require that data is delivered and
consumed.<a href="#section-13.1-1" class="pilcrow">¶</a></p>
<p id="section-13.1-2">Once the packet has been fully processed, a receiver acknowledges receipt by
sending one or more ACK frames containing the packet number of the received
packet.<a href="#section-13.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="generating-acks">
<section id="section-13.2">
        <h3 id="name-generating-acknowledgements">
<a href="#section-13.2" class="section-number selfRef">13.2. </a><a href="#name-generating-acknowledgements" class="section-name selfRef">Generating Acknowledgements</a>
        </h3>
<p id="section-13.2-1">Endpoints acknowledge all packets they receive and process. However, only
ack-eliciting packets cause an ACK frame to be sent within the maximum ack
delay.  Packets that are not ack-eliciting are only acknowledged when an ACK
frame is sent for other reasons.<a href="#section-13.2-1" class="pilcrow">¶</a></p>
<p id="section-13.2-2">When sending a packet for any reason, an endpoint SHOULD attempt to bundle an
ACK frame if one has not been sent recently. Doing so helps with timely loss
detection at the peer.<a href="#section-13.2-2" class="pilcrow">¶</a></p>
<p id="section-13.2-3">In general, frequent feedback from a receiver improves loss and congestion
response, but this has to be balanced against excessive load generated by a
receiver that sends an ACK frame in response to every ack-eliciting packet.  The
guidance offered below seeks to strike this balance.<a href="#section-13.2-3" class="pilcrow">¶</a></p>
<div id="sending-acknowledgements">
<section id="section-13.2.1">
          <h4 id="name-sending-ack-frames">
<a href="#section-13.2.1" class="section-number selfRef">13.2.1. </a><a href="#name-sending-ack-frames" class="section-name selfRef">Sending ACK Frames</a>
          </h4>
<p id="section-13.2.1-1">Every packet SHOULD be acknowledged at least once, and ack-eliciting packets
MUST be acknowledged at least once within the maximum ack delay. An endpoint
communicates its maximum delay using the max_ack_delay transport parameter;
see <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>.  max_ack_delay declares an explicit
contract: an endpoint promises to never intentionally delay acknowledgments
of an ack-eliciting packet by more than the indicated value. If it does,
any excess accrues to the RTT estimate and could result in spurious or
delayed retransmissions from the peer. For Initial and Handshake packets,
a max_ack_delay of 0 is used. The sender uses the receiver's max_ack_delay
value in determining timeouts for timer-based retransmission, as detailed in
Section 5.2.1 of <span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span>.<a href="#section-13.2.1-1" class="pilcrow">¶</a></p>
<p id="section-13.2.1-2">An ACK frame SHOULD be generated for at least every second ack-eliciting packet.
This recommendation is in keeping with standard practice for TCP <span>[<a href="#RFC5681" class="xref">RFC5681</a>]</span>.
A receiver could decide to send an ACK frame less frequently if it has
information about how frequently the sender's congestion controller
needs feedback, or if the receiver is CPU or bandwidth constrained.<a href="#section-13.2.1-2" class="pilcrow">¶</a></p>
<p id="section-13.2.1-3">In order to assist loss detection at the sender, an endpoint SHOULD send an ACK
frame immediately on receiving an ack-eliciting packet that is out of order. The
endpoint SHOULD NOT continue sending ACK frames immediately unless more
ack-eliciting packets are received out of order.  If every subsequent
ack-eliciting packet arrives out of order, then an ACK frame SHOULD be sent
immediately for every received ack-eliciting packet.<a href="#section-13.2.1-3" class="pilcrow">¶</a></p>
<p id="section-13.2.1-4">Similarly, packets marked with the ECN Congestion Experienced (CE) codepoint in
the IP header SHOULD be acknowledged immediately, to reduce the peer's response
time to congestion events.<a href="#section-13.2.1-4" class="pilcrow">¶</a></p>
<p id="section-13.2.1-5">As an optimization, a receiver MAY process multiple packets before sending any
ACK frames in response.  In this case the receiver can determine whether an
immediate or delayed acknowledgement should be generated after processing
incoming packets.<a href="#section-13.2.1-5" class="pilcrow">¶</a></p>
<p id="section-13.2.1-6">Packets containing PADDING frames are considered to be in flight for congestion
control purposes <span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span>. Sending only PADDING frames might cause the
sender to become limited by the congestion controller with no acknowledgments
forthcoming from the receiver. Therefore, a sender SHOULD ensure that other
frames are sent in addition to PADDING frames to elicit acknowledgments from
the receiver.<a href="#section-13.2.1-6" class="pilcrow">¶</a></p>
<p id="section-13.2.1-7">An endpoint that is only sending ACK frames will not receive acknowledgments
from its peer unless those acknowledgements are included in packets with
ack-eliciting frames.  An endpoint SHOULD bundle ACK frames with other frames
when there are new ack-eliciting packets to acknowledge.  When only
non-ack-eliciting packets need to be acknowledged, an endpoint MAY wait until an
ack-eliciting packet has been received to bundle an ACK frame with outgoing
frames.<a href="#section-13.2.1-7" class="pilcrow">¶</a></p>
<p id="section-13.2.1-8">The algorithms in <span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span> are resilient to receivers that do not
follow guidance offered above. However, an implementor should only deviate from
these requirements after careful consideration of the performance implications
of doing so.<a href="#section-13.2.1-8" class="pilcrow">¶</a></p>
<p id="section-13.2.1-9">Packets containing only ACK frames are not congestion controlled, so there are
limits on how frequently they can be sent.  An endpoint MUST NOT send more than
one ACK-frame-only packet in response to receiving an ack-eliciting packet.  An
endpoint MUST NOT send a non-ack-eliciting packet in response to a
non-ack-eliciting packet, even if there are packet gaps which precede the
received packet. Limiting ACK frames avoids an infinite feedback loop of
acknowledgements, which could prevent the connection from ever becoming idle.
However, the endpoint acknowledges non-ACK-eliciting packets when it sends an
ACK frame.<a href="#section-13.2.1-9" class="pilcrow">¶</a></p>
<p id="section-13.2.1-10">An endpoint SHOULD treat receipt of an acknowledgment for a packet it did not
send as a connection error of type PROTOCOL_VIOLATION, if it is able to detect
the condition.<a href="#section-13.2.1-10" class="pilcrow">¶</a></p>
</section>
</div>
<div id="managing-ack-ranges">
<section id="section-13.2.2">
          <h4 id="name-managing-ack-ranges">
<a href="#section-13.2.2" class="section-number selfRef">13.2.2. </a><a href="#name-managing-ack-ranges" class="section-name selfRef">Managing ACK Ranges</a>
          </h4>
<p id="section-13.2.2-1">When an ACK frame is sent, one or more ranges of acknowledged packets are
included.  Including older packets reduces the chance of spurious retransmits
caused by losing previously sent ACK frames, at the cost of larger ACK frames.<a href="#section-13.2.2-1" class="pilcrow">¶</a></p>
<p id="section-13.2.2-2">ACK frames SHOULD always acknowledge the most recently received packets, and the
more out-of-order the packets are, the more important it is to send an updated
ACK frame quickly, to prevent the peer from declaring a packet as lost and
spuriously retransmitting the frames it contains.  An ACK frame is expected
to fit within a single QUIC packet.  If it does not, then older ranges
(those with the smallest packet numbers) are omitted.<a href="#section-13.2.2-2" class="pilcrow">¶</a></p>
<p id="section-13.2.2-3"><a href="#ack-tracking" class="xref">Section 13.2.3</a> and <a href="#ack-limiting" class="xref">Section 13.2.4</a> describe an exemplary approach for
determining what packets to acknowledge in each ACK frame.  Though the goal of
these algorithms is to generate an acknowledgment for every packet that is
processed, it is still possible for acknowledgments to be lost.  A sender cannot
expect to receive an acknowledgment for every packet that the receiver
processes.<a href="#section-13.2.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="ack-tracking">
<section id="section-13.2.3">
          <h4 id="name-receiver-tracking-of-ack-fr">
<a href="#section-13.2.3" class="section-number selfRef">13.2.3. </a><a href="#name-receiver-tracking-of-ack-fr" class="section-name selfRef">Receiver Tracking of ACK Frames</a>
          </h4>
<p id="section-13.2.3-1">When a packet containing an ACK frame is sent, the largest acknowledged in that
frame may be saved.  When a packet containing an ACK frame is acknowledged, the
receiver can stop acknowledging packets less than or equal to the largest
acknowledged in the sent ACK frame.<a href="#section-13.2.3-1" class="pilcrow">¶</a></p>
<p id="section-13.2.3-2">In cases without ACK frame loss, this algorithm allows for a minimum of 1 RTT
of reordering. In cases with ACK frame loss and reordering, this approach does
not guarantee that every acknowledgement is seen by the sender before it is no
longer included in the ACK frame. Packets could be received out of order and
all subsequent ACK frames containing them could be lost. In this case, the
loss recovery algorithm could cause spurious retransmits, but the sender will
continue making forward progress.<a href="#section-13.2.3-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="ack-limiting">
<section id="section-13.2.4">
          <h4 id="name-limiting-ack-ranges">
<a href="#section-13.2.4" class="section-number selfRef">13.2.4. </a><a href="#name-limiting-ack-ranges" class="section-name selfRef">Limiting ACK Ranges</a>
          </h4>
<p id="section-13.2.4-1">A receiver limits the number of ACK Ranges (<a href="#ack-ranges" class="xref">Section 19.3.1</a>) it remembers and
sends in ACK frames, both to limit the size of ACK frames and to avoid resource
exhaustion. After receiving acknowledgments for an ACK frame, the receiver
SHOULD stop tracking those acknowledged ACK Ranges.<a href="#section-13.2.4-1" class="pilcrow">¶</a></p>
<p id="section-13.2.4-2">It is possible that retaining many ACK Ranges could cause an ACK frame to become
too large. A receiver can discard unacknowledged ACK Ranges to limit ACK frame
size, at the cost of increased retransmissions from the sender. This is
necessary if an ACK frame would be too large to fit in a packet, however
receivers MAY also limit ACK frame size further to preserve space for other
frames.<a href="#section-13.2.4-2" class="pilcrow">¶</a></p>
<p id="section-13.2.4-3">A receiver MUST retain an ACK Range unless it can ensure that it will not
subsequently accept packets with numbers in that range. Maintaining a minimum
packet number that increases as ranges are discarded is one way to achieve this
with minimal state.<a href="#section-13.2.4-3" class="pilcrow">¶</a></p>
<p id="section-13.2.4-4">Receivers can discard all ACK Ranges, but they MUST retain the largest packet
number that has been successfully processed as that is used to recover packet
numbers from subsequent packets; see <a href="#packet-encoding" class="xref">Section 17.1</a>.<a href="#section-13.2.4-4" class="pilcrow">¶</a></p>
<p id="section-13.2.4-5">A receiver SHOULD include an ACK Range containing the largest received packet
number in every ACK frame. The Largest Acknowledged field is used in ECN
validation at a sender and including a lower value than what was included in a
previous ACK frame could cause ECN to be unnecessarily disabled; see
<a href="#ecn-validation" class="xref">Section 13.4.2</a>.<a href="#section-13.2.4-5" class="pilcrow">¶</a></p>
<p id="section-13.2.4-6">A receiver that sends only non-ack-eliciting packets, such as ACK frames, might
not receive an acknowledgement for a long period of time.  This could cause the
receiver to maintain state for a large number of ACK frames for a long period of
time, and ACK frames it sends could be unnecessarily large.  In such a case, a
receiver could bundle a PING or other small ack-eliciting frame occasionally,
such as once per round trip, to elicit an ACK from the peer.<a href="#section-13.2.4-6" class="pilcrow">¶</a></p>
<p id="section-13.2.4-7">A receiver MUST NOT bundle an ack-eliciting frame with all packets that would
otherwise be non-ack-eliciting, to avoid an infinite feedback loop of
acknowledgements.<a href="#section-13.2.4-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="host-delay">
<section id="section-13.2.5">
          <h4 id="name-measuring-and-reporting-hos">
<a href="#section-13.2.5" class="section-number selfRef">13.2.5. </a><a href="#name-measuring-and-reporting-hos" class="section-name selfRef">Measuring and Reporting Host Delay</a>
          </h4>
<p id="section-13.2.5-1">An endpoint measures the delays intentionally introduced between the time the
packet with the largest packet number is received and the time an acknowledgment
is sent.  The endpoint encodes this delay in the Ack Delay field of an ACK
frame; see <a href="#frame-ack" class="xref">Section 19.3</a>.  This allows the receiver of the ACK to adjust for any
intentional delays, which is important for getting a better estimate of the path
RTT when acknowledgments are delayed.  A packet might be held in the OS kernel
or elsewhere on the host before being processed.  An endpoint MUST NOT include
delays that it does not control when populating the Ack Delay field in an ACK
frame.<a href="#section-13.2.5-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="ack-frames-and-packet-protection">
<section id="section-13.2.6">
          <h4 id="name-ack-frames-and-packet-prote">
<a href="#section-13.2.6" class="section-number selfRef">13.2.6. </a><a href="#name-ack-frames-and-packet-prote" class="section-name selfRef">ACK Frames and Packet Protection</a>
          </h4>
<p id="section-13.2.6-1">ACK frames MUST only be carried in a packet that has the same packet number
space as the packet being ACKed; see <a href="#packet-protected" class="xref">Section 12.1</a>.  For instance,
packets that are protected with 1-RTT keys MUST be acknowledged in packets that
are also protected with 1-RTT keys.<a href="#section-13.2.6-1" class="pilcrow">¶</a></p>
<p id="section-13.2.6-2">Packets that a client sends with 0-RTT packet protection MUST be acknowledged by
the server in packets protected by 1-RTT keys.  This can mean that the client is
unable to use these acknowledgments if the server cryptographic handshake
messages are delayed or lost.  Note that the same limitation applies to other
data sent by the server protected by the 1-RTT keys.<a href="#section-13.2.6-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="retransmission-of-information">
<section id="section-13.3">
        <h3 id="name-retransmission-of-informati">
<a href="#section-13.3" class="section-number selfRef">13.3. </a><a href="#name-retransmission-of-informati" class="section-name selfRef">Retransmission of Information</a>
        </h3>
<p id="section-13.3-1">QUIC packets that are determined to be lost are not retransmitted whole. The
same applies to the frames that are contained within lost packets. Instead, the
information that might be carried in frames is sent again in new frames as
needed.<a href="#section-13.3-1" class="pilcrow">¶</a></p>
<p id="section-13.3-2">New frames and packets are used to carry information that is determined to have
been lost.  In general, information is sent again when a packet containing that
information is determined to be lost and sending ceases when a packet
containing that information is acknowledged.<a href="#section-13.3-2" class="pilcrow">¶</a></p>
<ul>
<li id="section-13.3-3.1">Data sent in CRYPTO frames is retransmitted according to the rules in
<span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span>, until all data has been acknowledged.  Data in CRYPTO
frames for Initial and Handshake packets is discarded when keys for the
corresponding packet number space are discarded.<a href="#section-13.3-3.1" class="pilcrow">¶</a>
</li>
<li id="section-13.3-3.2">Application data sent in STREAM frames is retransmitted in new STREAM frames
unless the endpoint has sent a RESET_STREAM for that stream.  Once an endpoint
sends a RESET_STREAM frame, no further STREAM frames are needed.<a href="#section-13.3-3.2" class="pilcrow">¶</a>
</li>
<li id="section-13.3-3.3">ACK frames carry the most recent set of acknowledgements and the Ack Delay
from the largest acknowledged packet, as described in
<a href="#sending-acknowledgements" class="xref">Section 13.2.1</a>. Delaying the transmission of packets
containing ACK frames or sending old ACK frames can cause the peer to
generate an inflated RTT sample or unnecessarily disable ECN.<a href="#section-13.3-3.3" class="pilcrow">¶</a>
</li>
<li id="section-13.3-3.4">Cancellation of stream transmission, as carried in a RESET_STREAM frame, is
sent until acknowledged or until all stream data is acknowledged by the peer
(that is, either the "Reset Recvd" or "Data Recvd" state is reached on the
sending part of the stream). The content of a RESET_STREAM frame MUST NOT
change when it is sent again.<a href="#section-13.3-3.4" class="pilcrow">¶</a>
</li>
<li id="section-13.3-3.5">Similarly, a request to cancel stream transmission, as encoded in a
STOP_SENDING frame, is sent until the receiving part of the stream enters
either a "Data Recvd" or "Reset Recvd" state; see
<a href="#solicited-state-transitions" class="xref">Section 3.5</a>.<a href="#section-13.3-3.5" class="pilcrow">¶</a>
</li>
<li id="section-13.3-3.6">Connection close signals, including packets that contain CONNECTION_CLOSE
frames, are not sent again when packet loss is detected, but as described in
<a href="#termination" class="xref">Section 10</a>.<a href="#section-13.3-3.6" class="pilcrow">¶</a>
</li>
<li id="section-13.3-3.7">The current connection maximum data is sent in MAX_DATA frames. An updated
value is sent in a MAX_DATA frame if the packet containing the most recently
sent MAX_DATA frame is declared lost, or when the endpoint decides to update
the limit.  Care is necessary to avoid sending this frame too often as the
limit can increase frequently and cause an unnecessarily large number of
MAX_DATA frames to be sent.<a href="#section-13.3-3.7" class="pilcrow">¶</a>
</li>
<li id="section-13.3-3.8">The current maximum stream data offset is sent in MAX_STREAM_DATA frames.
Like MAX_DATA, an updated value is sent when the packet containing the most
recent MAX_STREAM_DATA frame for a stream is lost or when the limit is
updated, with care taken to prevent the frame from being sent too often. An
endpoint SHOULD stop sending MAX_STREAM_DATA frames when the receiving part of
the stream enters a "Size Known" state.<a href="#section-13.3-3.8" class="pilcrow">¶</a>
</li>
<li id="section-13.3-3.9">The limit on streams of a given type is sent in MAX_STREAMS frames.  Like
MAX_DATA, an updated value is sent when a packet containing the most recent
MAX_STREAMS for a stream type frame is declared lost or when the limit is
updated, with care taken to prevent the frame from being sent too often.<a href="#section-13.3-3.9" class="pilcrow">¶</a>
</li>
<li id="section-13.3-3.10">Blocked signals are carried in DATA_BLOCKED, STREAM_DATA_BLOCKED, and
STREAMS_BLOCKED frames. DATA_BLOCKED frames have connection scope,
STREAM_DATA_BLOCKED frames have stream scope, and STREAMS_BLOCKED frames are
scoped to a specific stream type. New frames are sent if packets containing
the most recent frame for a scope is lost, but only while the endpoint is
blocked on the corresponding limit. These frames always include the limit that
is causing blocking at the time that they are transmitted.<a href="#section-13.3-3.10" class="pilcrow">¶</a>
</li>
<li id="section-13.3-3.11">A liveness or path validation check using PATH_CHALLENGE frames is sent
periodically until a matching PATH_RESPONSE frame is received or until there
is no remaining need for liveness or path validation checking. PATH_CHALLENGE
frames include a different payload each time they are sent.<a href="#section-13.3-3.11" class="pilcrow">¶</a>
</li>
<li id="section-13.3-3.12">Responses to path validation using PATH_RESPONSE frames are sent just once.
The peer is expected to send more PATH_CHALLENGE frames as necessary to evoke
additional PATH_RESPONSE frames.<a href="#section-13.3-3.12" class="pilcrow">¶</a>
</li>
<li id="section-13.3-3.13">New connection IDs are sent in NEW_CONNECTION_ID frames and retransmitted if
the packet containing them is lost.  Retransmissions of this frame carry the
same sequence number value.  Likewise, retired connection IDs are sent in
RETIRE_CONNECTION_ID frames and retransmitted if the packet containing them is
lost.<a href="#section-13.3-3.13" class="pilcrow">¶</a>
</li>
<li id="section-13.3-3.14">NEW_TOKEN frames are retransmitted if the packet containing them is lost.  No
special support is made for detecting reordered and duplicated NEW_TOKEN
frames other than a direct comparison of the frame contents.<a href="#section-13.3-3.14" class="pilcrow">¶</a>
</li>
<li id="section-13.3-3.15">PING and PADDING frames contain no information, so lost PING or PADDING frames
do not require repair.<a href="#section-13.3-3.15" class="pilcrow">¶</a>
</li>
<li id="section-13.3-3.16">The HANDSHAKE_DONE frame MUST be retransmitted until it is acknowledged.<a href="#section-13.3-3.16" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-13.3-4">Endpoints SHOULD prioritize retransmission of data over sending new data, unless
priorities specified by the application indicate otherwise; see
<a href="#stream-prioritization" class="xref">Section 2.3</a>.<a href="#section-13.3-4" class="pilcrow">¶</a></p>
<p id="section-13.3-5">Even though a sender is encouraged to assemble frames containing up-to-date
information every time it sends a packet, it is not forbidden to retransmit
copies of frames from lost packets.  A sender that retransmits copies of frames
needs to handle decreases in available payload size due to change in packet
number length, connection ID length, and path MTU.  A receiver MUST accept
packets containing an outdated frame, such as a MAX_DATA frame carrying a
smaller maximum data than one found in an older packet.<a href="#section-13.3-5" class="pilcrow">¶</a></p>
<p id="section-13.3-6">Upon detecting losses, a sender MUST take appropriate congestion control action.
The details of loss detection and congestion control are described in
<span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span>.<a href="#section-13.3-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="ecn">
<section id="section-13.4">
        <h3 id="name-explicit-congestion-notific">
<a href="#section-13.4" class="section-number selfRef">13.4. </a><a href="#name-explicit-congestion-notific" class="section-name selfRef">Explicit Congestion Notification</a>
        </h3>
<p id="section-13.4-1">QUIC endpoints can use Explicit Congestion Notification (ECN) <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> to
detect and respond to network congestion.  ECN allows a network node to indicate
congestion in the network by setting a codepoint in the IP header of a packet
instead of dropping it.  Endpoints react to congestion by reducing their sending
rate in response, as described in <span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span>.<a href="#section-13.4-1" class="pilcrow">¶</a></p>
<p id="section-13.4-2">To use ECN, QUIC endpoints first determine whether a path supports ECN marking
and the peer is able to access the ECN codepoint in the IP header.  A network
path does not support ECN if ECN marked packets get dropped or ECN markings are
rewritten on the path. An endpoint validates the use of ECN on the path, both
during connection establishment and when migrating to a new path
(<a href="#migration" class="xref">Section 9</a>).<a href="#section-13.4-2" class="pilcrow">¶</a></p>
<div id="ecn-counts">
<section id="section-13.4.1">
          <h4 id="name-ecn-counts">
<a href="#section-13.4.1" class="section-number selfRef">13.4.1. </a><a href="#name-ecn-counts" class="section-name selfRef">ECN Counts</a>
          </h4>
<p id="section-13.4.1-1">On receiving a QUIC packet with an ECT or CE codepoint, an ECN-enabled endpoint
that can access the ECN codepoints from the enclosing IP packet increases the
corresponding ECT(0), ECT(1), or CE count, and includes these counts in
subsequent ACK frames; see <a href="#generating-acks" class="xref">Section 13.2</a> and <a href="#frame-ack" class="xref">Section 19.3</a>.  Note that
this requires being able to read the ECN codepoints from the enclosing IP
packet, which is not possible on all platforms.<a href="#section-13.4.1-1" class="pilcrow">¶</a></p>
<p id="section-13.4.1-2">A packet detected by a receiver as a duplicate does not affect the receiver's
local ECN codepoint counts; see (<a href="#security-ecn" class="xref">Section 21.8</a>) for relevant security
concerns.<a href="#section-13.4.1-2" class="pilcrow">¶</a></p>
<p id="section-13.4.1-3">If an endpoint receives a QUIC packet without an ECT or CE codepoint in the IP
packet header, it responds per <a href="#generating-acks" class="xref">Section 13.2</a> with an ACK frame without
increasing any ECN counts.  If an endpoint does not implement ECN
support or does not have access to received ECN codepoints, it does not increase
ECN counts.<a href="#section-13.4.1-3" class="pilcrow">¶</a></p>
<p id="section-13.4.1-4">Coalesced packets (see <a href="#packet-coalesce" class="xref">Section 12.2</a>) mean that several packets can share
the same IP header.  The ECN counter for the ECN codepoint received in the
associated IP header are incremented once for each QUIC packet, not per
enclosing IP packet or UDP datagram.<a href="#section-13.4.1-4" class="pilcrow">¶</a></p>
<p id="section-13.4.1-5">Each packet number space maintains separate acknowledgement state and separate
ECN counts.  For example, if one each of an Initial, 0-RTT, Handshake, and 1-RTT
QUIC packet are coalesced, the corresponding counts for the Initial and
Handshake packet number space will be incremented by one and the counts for the
1-RTT packet number space will be increased by two.<a href="#section-13.4.1-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="ecn-validation">
<section id="section-13.4.2">
          <h4 id="name-ecn-validation">
<a href="#section-13.4.2" class="section-number selfRef">13.4.2. </a><a href="#name-ecn-validation" class="section-name selfRef">ECN Validation</a>
          </h4>
<p id="section-13.4.2-1">It is possible for faulty network devices to corrupt or erroneously drop packets
with ECN markings.  To provide robust connectivity in the presence of such
devices, each endpoint independently validates ECN counts and disables ECN if
errors are detected.<a href="#section-13.4.2-1" class="pilcrow">¶</a></p>
<p id="section-13.4.2-2">Endpoints validate ECN for packets sent on each network path independently.  An
endpoint thus validates ECN on new connection establishment, when switching to a
new server preferred address, and on active connection migration to a new path.
<a href="#ecn-alg" class="xref">Appendix B</a> describes one possible algorithm for testing paths for ECN support.<a href="#section-13.4.2-2" class="pilcrow">¶</a></p>
<p id="section-13.4.2-3">Even if an endpoint does not use ECN markings on packets it transmits, the
endpoint MUST provide feedback about ECN markings received from the peer if they
are accessible.  Failing to report ECN counts will cause the peer to disable ECN
marking.<a href="#section-13.4.2-3" class="pilcrow">¶</a></p>
<div id="sending-ecn-markings">
<section id="section-13.4.2.1">
            <h5 id="name-sending-ecn-markings">
<a href="#section-13.4.2.1" class="section-number selfRef">13.4.2.1. </a><a href="#name-sending-ecn-markings" class="section-name selfRef">Sending ECN Markings</a>
            </h5>
<p id="section-13.4.2.1-1">To start ECN validation, an endpoint SHOULD do the following when sending
packets on a new path to a peer:<a href="#section-13.4.2.1-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-13.4.2.1-2.1">Set the ECT(0) codepoint in the IP header of early outgoing packets sent on a
new path to the peer <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>.<a href="#section-13.4.2.1-2.1" class="pilcrow">¶</a>
</li>
<li id="section-13.4.2.1-2.2">If all packets that were sent with the ECT(0) codepoint are eventually deemed
lost <span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span>, validation is deemed to have failed.<a href="#section-13.4.2.1-2.2" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-13.4.2.1-3">To reduce the chances of misinterpreting congestive loss as packets dropped by a
faulty network element, an endpoint could set the ECT(0) codepoint in the first
ten outgoing packets on a path, or for a period of three RTTs, whichever occurs
first.<a href="#section-13.4.2.1-3" class="pilcrow">¶</a></p>
<p id="section-13.4.2.1-4">Implementations MAY experiment with and use other strategies for use of ECN.
Other methods of probing paths for ECN support are possible, as are different
marking strategies.  Implementations can also use the ECT(1) codepoint, as
specified in <span>[<a href="#RFC8311" class="xref">RFC8311</a>]</span>.<a href="#section-13.4.2.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="ecn-ack">
<section id="section-13.4.2.2">
            <h5 id="name-receiving-ack-frames">
<a href="#section-13.4.2.2" class="section-number selfRef">13.4.2.2. </a><a href="#name-receiving-ack-frames" class="section-name selfRef">Receiving ACK Frames</a>
            </h5>
<p id="section-13.4.2.2-1">An endpoint that sets ECT(0) or ECT(1) codepoints on packets it transmits MUST
use the following steps on receiving an ACK frame to validate ECN.<a href="#section-13.4.2.2-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-13.4.2.2-2.1">If this ACK frame newly acknowledges a packet that the endpoint sent with
either ECT(0) or ECT(1) codepoints set, and if no ECN feedback is present in
the ACK frame, validation fails.  This step protects against both a network
element that zeroes out ECN bits and a peer that is unable to access ECN
markings, since the peer could respond without ECN feedback in these cases.<a href="#section-13.4.2.2-2.1" class="pilcrow">¶</a>
</li>
<li id="section-13.4.2.2-2.2">For validation to succeed, the total increase in ECT(0), ECT(1), and CE counts
MUST be no smaller than the total number of QUIC packets sent with an ECT
codepoint that are newly acknowledged in this ACK frame.  This step detects
any network remarking from ECT(0), ECT(1), or CE codepoints to Not-ECT.<a href="#section-13.4.2.2-2.2" class="pilcrow">¶</a>
</li>
<li id="section-13.4.2.2-2.3">Any increase in either ECT(0) or ECT(1) counts, plus any increase in the CE
count, MUST be no smaller than the number of packets sent with the
corresponding ECT codepoint that are newly acknowledged in this ACK frame.
This step detects any erroneous network remarking from ECT(0) to ECT(1) (or
vice versa).<a href="#section-13.4.2.2-2.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-13.4.2.2-3">Processing ECN counts out of order can result in validation failure.  An
endpoint SHOULD NOT perform this validation if this ACK frame does not advance
the largest packet number acknowledged in this connection.<a href="#section-13.4.2.2-3" class="pilcrow">¶</a></p>
<p id="section-13.4.2.2-4">An endpoint could miss acknowledgements for a packet when ACK frames are lost.
It is therefore possible for the total increase in ECT(0), ECT(1), and CE counts
to be greater than the number of packets acknowledged in an ACK frame.  When
this happens, and if validation succeeds, the local reference counts MUST be
increased to match the counts in the ACK frame.<a href="#section-13.4.2.2-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="validation-outcomes">
<section id="section-13.4.2.3">
            <h5 id="name-validation-outcomes">
<a href="#section-13.4.2.3" class="section-number selfRef">13.4.2.3. </a><a href="#name-validation-outcomes" class="section-name selfRef">Validation Outcomes</a>
            </h5>
<p id="section-13.4.2.3-1">If validation fails, then the endpoint stops sending ECN markings in subsequent
IP packets with the expectation that either the network path or the peer does
not support ECN.<a href="#section-13.4.2.3-1" class="pilcrow">¶</a></p>
<p id="section-13.4.2.3-2">Upon successful validation, an endpoint can continue to set ECT codepoints in
subsequent packets with the expectation that the path is ECN-capable.  Network
routing and path elements can change mid-connection however; an endpoint MUST
disable ECN if validation fails at any point in the connection.<a href="#section-13.4.2.3-2" class="pilcrow">¶</a></p>
<p id="section-13.4.2.3-3">Even if validation fails, an endpoint MAY revalidate ECN on the same path at any
later time in the connection.<a href="#section-13.4.2.3-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="packet-size">
<section id="section-14">
      <h2 id="name-packet-size">
<a href="#section-14" class="section-number selfRef">14. </a><a href="#name-packet-size" class="section-name selfRef">Packet Size</a>
      </h2>
<p id="section-14-1">The QUIC packet size includes the QUIC header and protected payload, but not the
UDP or IP header.<a href="#section-14-1" class="pilcrow">¶</a></p>
<p id="section-14-2">A client MUST expand the payload of all UDP datagrams carrying Initial packets
to at least 1200 bytes, by adding PADDING frames to the Initial packet or by
coalescing the Initial packet; see <a href="#packet-coalesce" class="xref">Section 12.2</a>.  Sending a UDP datagram
of this size ensures that the network path from the client to the server
supports a reasonable Maximum Transmission Unit (MTU).  Padding datagrams also
helps reduce the amplitude of amplification attacks caused by server responses
toward an unverified client address; see <a href="#address-validation" class="xref">Section 8</a>.<a href="#section-14-2" class="pilcrow">¶</a></p>
<p id="section-14-3">Enforcement of the max_udp_payload_size transport parameter
(<a href="#transport-parameter-definitions" class="xref">Section 18.2</a>) might act as an additional limit on
packet size. Exceeding this limit can be avoided once the value is known.
However, prior to learning the value of the transport parameter, endpoints risk
datagrams being lost if they send packets larger than 1200 bytes.<a href="#section-14-3" class="pilcrow">¶</a></p>
<p id="section-14-4">Datagrams containing Initial packets MAY exceed 1200 bytes if the client
believes that the network path and peer both support the size that it chooses.<a href="#section-14-4" class="pilcrow">¶</a></p>
<p id="section-14-5">UDP datagrams MUST NOT be fragmented at the IP layer.  In IPv4
<span>[<a href="#IPv4" class="xref">IPv4</a>]</span>, the DF bit MUST be set to prevent fragmentation on the path.<a href="#section-14-5" class="pilcrow">¶</a></p>
<p id="section-14-6">A server MUST discard an Initial packet that is carried in a UDP datagram with
a payload that is less than 1200 bytes. A server MAY also immediately close the
connection by sending a CONNECTION_CLOSE frame with an error code of
PROTOCOL_VIOLATION; see <a href="#immediate-close-hs" class="xref">Section 10.3.1</a>.<a href="#section-14-6" class="pilcrow">¶</a></p>
<p id="section-14-7">The server MUST also limit the number of bytes it sends before validating the
address of the client; see <a href="#address-validation" class="xref">Section 8</a>.<a href="#section-14-7" class="pilcrow">¶</a></p>
<div id="path-maximum-transmission-unit-pmtu">
<section id="section-14.1">
        <h3 id="name-path-maximum-transmission-u">
<a href="#section-14.1" class="section-number selfRef">14.1. </a><a href="#name-path-maximum-transmission-u" class="section-name selfRef">Path Maximum Transmission Unit (PMTU)</a>
        </h3>
<p id="section-14.1-1">The Path Maximum Transmission Unit (PMTU) is the maximum size of the entire IP
packet including the IP header, UDP header, and UDP payload.  The UDP payload
includes the QUIC packet header, protected payload, and any authentication
fields.  The PMTU can depend on path characteristics, and can therefore change
over time.  The largest UDP payload an endpoint sends at any given time is
referred to as the endpoint's maximum packet size.<a href="#section-14.1-1" class="pilcrow">¶</a></p>
<p id="section-14.1-2">QUIC depends on a PMTU of at least 1280 bytes. This is the IPv6 minimum size
<span>[<a href="#RFC8200" class="xref">RFC8200</a>]</span> and is also supported by most modern IPv4 networks.  All QUIC
packets (except for PMTU probe packets) SHOULD be sized to fit within the
maximum packet size to avoid the packet being fragmented or dropped
<span>[<a href="#RFC8085" class="xref">RFC8085</a>]</span>.<a href="#section-14.1-2" class="pilcrow">¶</a></p>
<p id="section-14.1-3">An endpoint SHOULD use Datagram Packetization Layer PMTU Discovery
(<span>[<a href="#DPLPMTUD" class="xref">DPLPMTUD</a>]</span>) or implement Path MTU Discovery
(PMTUD) <span>[<a href="#RFC1191" class="xref">RFC1191</a>]</span> <span>[<a href="#RFC8201" class="xref">RFC8201</a>]</span> to determine whether the path to a destination
will support a desired message size without fragmentation.<a href="#section-14.1-3" class="pilcrow">¶</a></p>
<p id="section-14.1-4">In the absence of these mechanisms, QUIC endpoints SHOULD NOT send IP packets
larger than 1280 bytes. Assuming the minimum IP header size, this results in a
QUIC maximum packet size of 1232 bytes for IPv6 and 1252 bytes for IPv4. A QUIC
implementation MAY be more conservative in computing the QUIC maximum packet
size to allow for unknown tunnel overheads or IP header options/extensions.<a href="#section-14.1-4" class="pilcrow">¶</a></p>
<p id="section-14.1-5">Each pair of local and remote addresses could have a different PMTU.  QUIC
implementations that implement any kind of PMTU discovery therefore SHOULD
maintain a maximum packet size for each combination of local and remote IP
addresses.<a href="#section-14.1-5" class="pilcrow">¶</a></p>
<p id="section-14.1-6">If a QUIC endpoint determines that the PMTU between any pair of local and remote
IP addresses has fallen below the size needed to support the smallest allowed
maximum packet size, it MUST immediately cease sending QUIC packets, except for
PMTU probe packets, on the affected path.  An endpoint MAY terminate the
connection if an alternative path cannot be found.<a href="#section-14.1-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="icmp-pmtud">
<section id="section-14.2">
        <h3 id="name-icmp-packet-too-big-message">
<a href="#section-14.2" class="section-number selfRef">14.2. </a><a href="#name-icmp-packet-too-big-message" class="section-name selfRef">ICMP Packet Too Big Messages</a>
        </h3>
<p id="section-14.2-1">PMTU discovery <span>[<a href="#RFC1191" class="xref">RFC1191</a>]</span> <span>[<a href="#RFC8201" class="xref">RFC8201</a>]</span> relies on reception of ICMP messages
(e.g., IPv6 Packet Too Big messages) that indicate when a packet is dropped
because it is larger than the local router MTU. DPLPMTUD can also optionally use
these messages.  This use of ICMP messages is potentially vulnerable to off-path
attacks that successfully guess the addresses used on the path and reduce the
PMTU to a bandwidth-inefficient value.<a href="#section-14.2-1" class="pilcrow">¶</a></p>
<p id="section-14.2-2">An endpoint MUST ignore an ICMP message that claims the PMTU has decreased below
1280 bytes.<a href="#section-14.2-2" class="pilcrow">¶</a></p>
<p id="section-14.2-3">The requirements for generating ICMP (<span>[<a href="#RFC1812" class="xref">RFC1812</a>]</span>, <span>[<a href="#RFC4443" class="xref">RFC4443</a>]</span>) state that the
quoted packet should contain as much of the original packet as possible without
exceeding the minimum MTU for the IP version.  The size of the quoted packet can
actually be smaller, or the information unintelligible, as described in Section
1.1 of <span>[<a href="#DPLPMTUD" class="xref">DPLPMTUD</a>]</span>.<a href="#section-14.2-3" class="pilcrow">¶</a></p>
<p id="section-14.2-4">QUIC endpoints SHOULD validate ICMP messages to protect from off-path injection
as specified in <span>[<a href="#RFC8201" class="xref">RFC8201</a>]</span> and Section 5.2 of <span>[<a href="#RFC8085" class="xref">RFC8085</a>]</span>. This validation
SHOULD use the quoted packet supplied in the payload of an ICMP message to
associate the message with a corresponding transport connection <span>[<a href="#DPLPMTUD" class="xref">DPLPMTUD</a>]</span>.<a href="#section-14.2-4" class="pilcrow">¶</a></p>
<p id="section-14.2-5">ICMP message validation MUST include matching IP addresses and UDP ports
<span>[<a href="#RFC8085" class="xref">RFC8085</a>]</span> and, when possible, connection IDs to an active QUIC session.<a href="#section-14.2-5" class="pilcrow">¶</a></p>
<p id="section-14.2-6">The endpoint SHOULD ignore all ICMP messages that fail validation.<a href="#section-14.2-6" class="pilcrow">¶</a></p>
<p id="section-14.2-7">An endpoint MUST NOT increase PMTU based on ICMP messages; see Section 3, clause
6 of <span>[<a href="#DPLPMTUD" class="xref">DPLPMTUD</a>]</span>.  Any reduction in the QUIC maximum packet size in response
to ICMP messages MAY be provisional until QUIC's loss detection algorithm
determines that the quoted packet has actually been lost.<a href="#section-14.2-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="datagram-packetization-layer-pmtu-discovery">
<section id="section-14.3">
        <h3 id="name-datagram-packetization-laye">
<a href="#section-14.3" class="section-number selfRef">14.3. </a><a href="#name-datagram-packetization-laye" class="section-name selfRef">Datagram Packetization Layer PMTU Discovery</a>
        </h3>
<p id="section-14.3-1">Section 6.3 of <span>[<a href="#DPLPMTUD" class="xref">DPLPMTUD</a>]</span> provides considerations for implementing Datagram
Packetization Layer PMTUD (DPLPMTUD) with QUIC.<a href="#section-14.3-1" class="pilcrow">¶</a></p>
<p id="section-14.3-2">When implementing the algorithm in Section 5 of <span>[<a href="#DPLPMTUD" class="xref">DPLPMTUD</a>]</span>, the initial
value of BASE_PMTU SHOULD be consistent with the minimum QUIC packet size (1232
bytes for IPv6 and 1252 bytes for IPv4).<a href="#section-14.3-2" class="pilcrow">¶</a></p>
<p id="section-14.3-3">PING and PADDING frames can be used to generate PMTU probe packets. These frames
might not be retransmitted if a probe packet containing them is lost.  However,
these frames do consume congestion window, which could delay the transmission of
subsequent application data.<a href="#section-14.3-3" class="pilcrow">¶</a></p>
<p id="section-14.3-4">A PING frame can be included in a PMTU probe to ensure that a valid probe is
acknowledged.<a href="#section-14.3-4" class="pilcrow">¶</a></p>
<p id="section-14.3-5">The considerations for processing ICMP messages in the previous section also
apply if these messages are used by DPLPMTUD.<a href="#section-14.3-5" class="pilcrow">¶</a></p>
<div id="pmtu-probes-src-cid">
<section id="section-14.3.1">
          <h4 id="name-pmtu-probes-containing-sour">
<a href="#section-14.3.1" class="section-number selfRef">14.3.1. </a><a href="#name-pmtu-probes-containing-sour" class="section-name selfRef">PMTU Probes Containing Source Connection ID</a>
          </h4>
<p id="section-14.3.1-1">Endpoints that rely on the destination connection ID for routing incoming QUIC
packets are likely to require that the connection ID be included in PMTU probe
packets to route any resulting ICMP messages (<a href="#icmp-pmtud" class="xref">Section 14.2</a>) back to the
correct endpoint.  However, only long header packets (<a href="#long-header" class="xref">Section 17.2</a>) contain
source connection IDs, and long header packets are not decrypted or acknowledged
by the peer once the handshake is complete.<a href="#section-14.3.1-1" class="pilcrow">¶</a></p>
<p id="section-14.3.1-2">One way to construct a probe for the path MTU is to coalesce (see
<a href="#packet-coalesce" class="xref">Section 12.2</a>) a Handshake packet (<a href="#packet-handshake" class="xref">Section 17.2.4</a>) with a short
header packet in a single UDP datagram.  If the UDP datagram reaches the
endpoint, the Handshake packet will be ignored, but the short header packet will
be acknowledged.  If the UDP datagram causes an ICMP message to be sent, the
first part of the datagram will be quoted in that message.  If the source
connection ID is within the quoted portion of the UDP datagram, that could be
used for routing.<a href="#section-14.3.1-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="versions">
<section id="section-15">
      <h2 id="name-versions">
<a href="#section-15" class="section-number selfRef">15. </a><a href="#name-versions" class="section-name selfRef">Versions</a>
      </h2>
<p id="section-15-1">QUIC versions are identified using a 32-bit unsigned number.<a href="#section-15-1" class="pilcrow">¶</a></p>
<p id="section-15-2">The version 0x00000000 is reserved to represent version negotiation.  This
version of the specification is identified by the number 0x00000001.<a href="#section-15-2" class="pilcrow">¶</a></p>
<p id="section-15-3">Other versions of QUIC might have different properties to this version.  The
properties of QUIC that are guaranteed to be consistent across all versions of
the protocol are described in <span>[<a href="#QUIC-INVARIANTS" class="xref">QUIC-INVARIANTS</a>]</span>.<a href="#section-15-3" class="pilcrow">¶</a></p>
<p id="section-15-4">Version 0x00000001 of QUIC uses TLS as a cryptographic handshake protocol, as
described in <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>.<a href="#section-15-4" class="pilcrow">¶</a></p>
<p id="section-15-5">Versions with the most significant 16 bits of the version number cleared are
reserved for use in future IETF consensus documents.<a href="#section-15-5" class="pilcrow">¶</a></p>
<p id="section-15-6">Versions that follow the pattern 0x?a?a?a?a are reserved for use in forcing
version negotiation to be exercised.  That is, any version number where the low
four bits of all bytes is 1010 (in binary).  A client or server MAY advertise
support for any of these reserved versions.<a href="#section-15-6" class="pilcrow">¶</a></p>
<p id="section-15-7">Reserved version numbers will never represent a real protocol; a client MAY use
one of these version numbers with the expectation that the server will initiate
version negotiation; a server MAY advertise support for one of these versions
and can expect that clients ignore the value.<a href="#section-15-7" class="pilcrow">¶</a></p>
<p id="section-15-8">[[RFC editor: please remove the remainder of this section before
publication.]]<a href="#section-15-8" class="pilcrow">¶</a></p>
<p id="section-15-9">The version number for the final version of this specification (0x00000001), is
reserved for the version of the protocol that is published as an RFC.<a href="#section-15-9" class="pilcrow">¶</a></p>
<p id="section-15-10">Version numbers used to identify IETF drafts are created by adding the draft
number to 0xff000000.  For example, draft-ietf-quic-transport-13 would be
identified as 0xff00000D.<a href="#section-15-10" class="pilcrow">¶</a></p>
<p id="section-15-11">Implementors are encouraged to register version numbers of QUIC that they are
using for private experimentation on the GitHub wiki at
<span><a href="https://github.com/quicwg/base-drafts/wiki/QUIC-Versions">https://github.com/quicwg/base-drafts/wiki/QUIC-Versions</a></span>.<a href="#section-15-11" class="pilcrow">¶</a></p>
</section>
</div>
<div id="integer-encoding">
<section id="section-16">
      <h2 id="name-variable-length-integer-enc">
<a href="#section-16" class="section-number selfRef">16. </a><a href="#name-variable-length-integer-enc" class="section-name selfRef">Variable-Length Integer Encoding</a>
      </h2>
<p id="section-16-1">QUIC packets and frames commonly use a variable-length encoding for non-negative
integer values.  This encoding ensures that smaller integer values need fewer
bytes to encode.<a href="#section-16-1" class="pilcrow">¶</a></p>
<p id="section-16-2">The QUIC variable-length integer encoding reserves the two most significant bits
of the first byte to encode the base 2 logarithm of the integer encoding length
in bytes.  The integer value is encoded on the remaining bits, in network byte
order.<a href="#section-16-2" class="pilcrow">¶</a></p>
<p id="section-16-3">This means that integers are encoded on 1, 2, 4, or 8 bytes and can encode 6,
14, 30, or 62 bit values respectively.  <a href="#integer-summary" class="xref">Table 4</a> summarizes the
encoding properties.<a href="#section-16-3" class="pilcrow">¶</a></p>
<span id="name-summary-of-integer-encoding"></span><div id="integer-summary">
<table class="center" id="table-4">
        <caption>
<a href="#table-4" class="selfRef">Table 4</a>:
<a href="#name-summary-of-integer-encoding" class="selfRef">Summary of Integer Encodings</a>
        </caption>
<thead>
          <tr>
            <th class="text-left" rowspan="1" colspan="1">2Bit</th>
            <th class="text-left" rowspan="1" colspan="1">Length</th>
            <th class="text-left" rowspan="1" colspan="1">Usable Bits</th>
            <th class="text-left" rowspan="1" colspan="1">Range</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">00</td>
            <td class="text-left" rowspan="1" colspan="1">1</td>
            <td class="text-left" rowspan="1" colspan="1">6</td>
            <td class="text-left" rowspan="1" colspan="1">0-63</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">01</td>
            <td class="text-left" rowspan="1" colspan="1">2</td>
            <td class="text-left" rowspan="1" colspan="1">14</td>
            <td class="text-left" rowspan="1" colspan="1">0-16383</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">10</td>
            <td class="text-left" rowspan="1" colspan="1">4</td>
            <td class="text-left" rowspan="1" colspan="1">30</td>
            <td class="text-left" rowspan="1" colspan="1">0-1073741823</td>
          </tr>
          <tr>
            <td class="text-left" rowspan="1" colspan="1">11</td>
            <td class="text-left" rowspan="1" colspan="1">8</td>
            <td class="text-left" rowspan="1" colspan="1">62</td>
            <td class="text-left" rowspan="1" colspan="1">0-4611686018427387903</td>
          </tr>
        </tbody>
      </table>
</div>
<p id="section-16-5">For example, the eight byte sequence c2 19 7c 5e ff 14 e8 8c (in hexadecimal)
decodes to the decimal value 151288809941952652; the four byte sequence 9d 7f 3e
7d decodes to 494878333; the two byte sequence 7b bd decodes to 15293; and the
single byte 25 decodes to 37 (as does the two byte sequence 40 25).<a href="#section-16-5" class="pilcrow">¶</a></p>
<p id="section-16-6">Error codes (<a href="#error-codes" class="xref">Section 20</a>) and versions (<a href="#versions" class="xref">Section 15</a>) are described using
integers, but do not use this encoding.<a href="#section-16-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="packet-formats">
<section id="section-17">
      <h2 id="name-packet-formats">
<a href="#section-17" class="section-number selfRef">17. </a><a href="#name-packet-formats" class="section-name selfRef">Packet Formats</a>
      </h2>
<p id="section-17-1">All numeric values are encoded in network byte order (that is, big-endian) and
all field sizes are in bits.  Hexadecimal notation is used for describing the
value of fields.<a href="#section-17-1" class="pilcrow">¶</a></p>
<div id="packet-encoding">
<section id="section-17.1">
        <h3 id="name-packet-number-encoding-and-">
<a href="#section-17.1" class="section-number selfRef">17.1. </a><a href="#name-packet-number-encoding-and-" class="section-name selfRef">Packet Number Encoding and Decoding</a>
        </h3>
<p id="section-17.1-1">Packet numbers are integers in the range 0 to 2^62-1 (<a href="#packet-numbers" class="xref">Section 12.3</a>).  When
present in long or short packet headers, they are encoded in 1 to 4 bytes.  The
number of bits required to represent the packet number is reduced by including
the least significant bits of the packet number.<a href="#section-17.1-1" class="pilcrow">¶</a></p>
<p id="section-17.1-2">The encoded packet number is protected as described in Section 5.4 of
<span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>.<a href="#section-17.1-2" class="pilcrow">¶</a></p>
<p id="section-17.1-3">The sender MUST use a packet number size able to represent more than twice as
large a range than the difference between the largest acknowledged packet and
packet number being sent.  A peer receiving the packet will then correctly
decode the packet number, unless the packet is delayed in transit such that it
arrives after many higher-numbered packets have been received.  An endpoint
SHOULD use a large enough packet number encoding to allow the packet number to
be recovered even if the packet arrives after packets that are sent afterwards.<a href="#section-17.1-3" class="pilcrow">¶</a></p>
<p id="section-17.1-4">As a result, the size of the packet number encoding is at least one bit more
than the base-2 logarithm of the number of contiguous unacknowledged packet
numbers, including the new packet.<a href="#section-17.1-4" class="pilcrow">¶</a></p>
<p id="section-17.1-5">For example, if an endpoint has received an acknowledgment for packet 0xabe8bc,
sending a packet with a number of 0xac5c02 requires a packet number encoding
with 16 bits or more; whereas the 24-bit packet number encoding is needed to
send a packet with a number of 0xace8fe.<a href="#section-17.1-5" class="pilcrow">¶</a></p>
<p id="section-17.1-6">At a receiver, protection of the packet number is removed prior to recovering
the full packet number. The full packet number is then reconstructed based on
the number of significant bits present, the value of those bits, and the largest
packet number received on a successfully authenticated packet. Recovering the
full packet number is necessary to successfully remove packet protection.<a href="#section-17.1-6" class="pilcrow">¶</a></p>
<p id="section-17.1-7">Once header protection is removed, the packet number is decoded by finding the
packet number value that is closest to the next expected packet.  The next
expected packet is the highest received packet number plus one.  For example, if
the highest successfully authenticated packet had a packet number of 0xa82f30ea,
then a packet containing a 16-bit value of 0x9b32 will be decoded as 0xa82f9b32.
Example pseudo-code for packet number decoding can be found in
<a href="#sample-packet-number-decoding" class="xref">Appendix A</a>.<a href="#section-17.1-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="long-header">
<section id="section-17.2">
        <h3 id="name-long-header-packets">
<a href="#section-17.2" class="section-number selfRef">17.2. </a><a href="#name-long-header-packets" class="section-name selfRef">Long Header Packets</a>
        </h3>
<span id="name-long-header-packet-format"></span><div id="fig-long-header">
<figure id="figure-12">
          <div class="artwork art-text alignLeft" id="section-17.2-1.1">
<pre>
Long Header Packet {
  Header Form (1) = 1,
  Fixed Bit (1) = 1,
  Long Packet Type (2),
  Type-Specific Bits (4),
  Version (32),
  DCID Length (8),
  Destination Connection ID (0..160),
  SCID Length (8),
  Source Connection ID (0..160),
}
</pre>
</div>
<figcaption><a href="#figure-12" class="selfRef">Figure 12</a>:
<a href="#name-long-header-packet-format" class="selfRef">Long Header Packet Format</a>
          </figcaption></figure>
</div>
<p id="section-17.2-2">Long headers are used for packets that are sent prior to the establishment
of 1-RTT keys. Once 1-RTT keys are available,
a sender switches to sending packets using the short header
(<a href="#short-header" class="xref">Section 17.3</a>).  The long form allows for special packets - such as the
Version Negotiation packet - to be represented in this uniform fixed-length
packet format. Packets that use the long header contain the following fields:<a href="#section-17.2-2" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-17.2-3">
          <dt id="section-17.2-3.1">Header Form:</dt>
<dd id="section-17.2-3.2">
  The most significant bit (0x80) of byte 0 (the first byte) is set to 1 for
long headers.<a href="#section-17.2-3.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.2-3.3">Fixed Bit:</dt>
<dd id="section-17.2-3.4">
  The next bit (0x40) of byte 0 is set to 1.  Packets containing a zero value
for this bit are not valid packets in this version and MUST be discarded.<a href="#section-17.2-3.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.2-3.5">Long Packet Type:</dt>
<dd id="section-17.2-3.6">
  The next two bits (those with a mask of 0x30) of byte 0 contain a packet type.
Packet types are listed in <a href="#long-packet-types" class="xref">Table 5</a>.<a href="#section-17.2-3.6" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.2-3.7">Type-Specific Bits:</dt>
<dd id="section-17.2-3.8">
  The lower four bits (those with a mask of 0x0f) of byte 0 are type-specific.<a href="#section-17.2-3.8" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.2-3.9">Version:</dt>
<dd id="section-17.2-3.10">
  The QUIC Version is a 32-bit field that follows the first byte.  This field
indicates which version of QUIC is in use and determines how the rest of the
protocol fields are interpreted.<a href="#section-17.2-3.10" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.2-3.11">DCID Length:</dt>
<dd id="section-17.2-3.12">
  The byte following the version contains the length in bytes of the Destination
Connection ID field that follows it.  This length is encoded as an 8-bit
unsigned integer.  In QUIC version 1, this value MUST NOT exceed 20.
Endpoints that receive a version 1 long header with a value larger than
20 MUST drop the packet. Servers SHOULD be able to read longer connection IDs
from other QUIC versions in order to properly form a version negotiation
packet.<a href="#section-17.2-3.12" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.2-3.13">Destination Connection ID:</dt>
<dd id="section-17.2-3.14">
  The Destination Connection ID field follows the DCID Length field and is
between 0 and 20 bytes in length. <a href="#negotiating-connection-ids" class="xref">Section 7.2</a> describes
the use of this field in more detail.<a href="#section-17.2-3.14" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.2-3.15">SCID Length:</dt>
<dd id="section-17.2-3.16">
  The byte following the Destination Connection ID contains the length in bytes
of the Source Connection ID field that follows it.  This length is encoded as
a 8-bit unsigned integer.  In QUIC version 1, this value MUST NOT exceed 20
bytes. Endpoints that receive a version 1 long header with a value larger than
20 MUST drop the packet. Servers SHOULD be able to read longer connection IDs
from other QUIC versions in order to properly form a version negotiation
packet.<a href="#section-17.2-3.16" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.2-3.17">Source Connection ID:</dt>
<dd id="section-17.2-3.18">
  The Source Connection ID field follows the SCID Length field and is between 0
and 20 bytes in length. <a href="#negotiating-connection-ids" class="xref">Section 7.2</a> describes the use of
this field in more detail.<a href="#section-17.2-3.18" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-17.2-4">In this version of QUIC, the following packet types with the long header are
defined:<a href="#section-17.2-4" class="pilcrow">¶</a></p>
<span id="name-long-header-packet-types"></span><div id="long-packet-types">
<table class="center" id="table-5">
          <caption>
<a href="#table-5" class="selfRef">Table 5</a>:
<a href="#name-long-header-packet-types" class="selfRef">Long Header Packet Types</a>
          </caption>
<thead>
            <tr>
              <th class="text-right" rowspan="1" colspan="1">Type</th>
              <th class="text-left" rowspan="1" colspan="1">Name</th>
              <th class="text-left" rowspan="1" colspan="1">Section</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-right" rowspan="1" colspan="1">0x0</td>
              <td class="text-left" rowspan="1" colspan="1">Initial</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#packet-initial" class="xref">Section 17.2.2</a>
</td>
            </tr>
            <tr>
              <td class="text-right" rowspan="1" colspan="1">0x1</td>
              <td class="text-left" rowspan="1" colspan="1">0-RTT</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#packet-0rtt" class="xref">Section 17.2.3</a>
</td>
            </tr>
            <tr>
              <td class="text-right" rowspan="1" colspan="1">0x2</td>
              <td class="text-left" rowspan="1" colspan="1">Handshake</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#packet-handshake" class="xref">Section 17.2.4</a>
</td>
            </tr>
            <tr>
              <td class="text-right" rowspan="1" colspan="1">0x3</td>
              <td class="text-left" rowspan="1" colspan="1">Retry</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#packet-retry" class="xref">Section 17.2.5</a>
</td>
            </tr>
          </tbody>
        </table>
</div>
<p id="section-17.2-6">The header form bit, connection ID lengths byte, Destination and Source
Connection ID fields, and Version fields of a long header packet are
version-independent. The other fields in the first byte are version-specific.
See <span>[<a href="#QUIC-INVARIANTS" class="xref">QUIC-INVARIANTS</a>]</span> for details on how packets from different versions of
QUIC are interpreted.<a href="#section-17.2-6" class="pilcrow">¶</a></p>
<p id="section-17.2-7">The interpretation of the fields and the payload are specific to a version and
packet type.  While type-specific semantics for this version are described in
the following sections, several long-header packets in this version of QUIC
contain these additional fields:<a href="#section-17.2-7" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-17.2-8">
          <dt id="section-17.2-8.1">Reserved Bits:</dt>
<dd id="section-17.2-8.2">
  Two bits (those with a mask of 0x0c) of byte 0 are reserved across multiple
packet types.  These bits are protected using header protection; see Section
5.4 of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>. The value included prior to protection MUST be set to 0.
An endpoint MUST treat receipt of a packet that has a non-zero value for these
bits, after removing both packet and header protection, as a connection error
of type PROTOCOL_VIOLATION. Discarding such a packet after only removing
header protection can expose the endpoint to attacks; see Section 9.3 of
<span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>.<a href="#section-17.2-8.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.2-8.3">Packet Number Length:</dt>
<dd id="section-17.2-8.4">
  In packet types which contain a Packet Number field, the least significant two
bits (those with a mask of 0x03) of byte 0 contain the length of the packet
number, encoded as an unsigned, two-bit integer that is one less than the
length of the packet number field in bytes.  That is, the length of the packet
number field is the value of this field, plus one.  These bits are protected
using header protection; see Section 5.4 of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>.<a href="#section-17.2-8.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.2-8.5">Length:</dt>
<dd id="section-17.2-8.6">
  The length of the remainder of the packet (that is, the Packet Number and
Payload fields) in bytes, encoded as a variable-length integer
(<a href="#integer-encoding" class="xref">Section 16</a>).<a href="#section-17.2-8.6" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.2-8.7">Packet Number:</dt>
<dd id="section-17.2-8.8">
  The packet number field is 1 to 4 bytes long. The packet number has
confidentiality protection separate from packet protection, as described in
Section 5.4 of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>. The length of the packet number field is encoded
in the Packet Number Length bits of byte 0; see above.<a href="#section-17.2-8.8" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<div id="packet-version">
<section id="section-17.2.1">
          <h4 id="name-version-negotiation-packet">
<a href="#section-17.2.1" class="section-number selfRef">17.2.1. </a><a href="#name-version-negotiation-packet" class="section-name selfRef">Version Negotiation Packet</a>
          </h4>
<p id="section-17.2.1-1">A Version Negotiation packet is inherently not version-specific. Upon receipt by
a client, it will be identified as a Version Negotiation packet based on the
Version field having a value of 0.<a href="#section-17.2.1-1" class="pilcrow">¶</a></p>
<p id="section-17.2.1-2">The Version Negotiation packet is a response to a client packet that contains a
version that is not supported by the server, and is only sent by servers.<a href="#section-17.2.1-2" class="pilcrow">¶</a></p>
<p id="section-17.2.1-3">The layout of a Version Negotiation packet is:<a href="#section-17.2.1-3" class="pilcrow">¶</a></p>
<span id="name-version-negotiation-packet-2"></span><div id="version-negotiation-format">
<figure id="figure-13">
            <div class="artwork art-text alignLeft" id="section-17.2.1-4.1">
<pre>
Version Negotiation Packet {
  Header Form (1) = 1,
  Unused (7),
  Version (32) = 0,
  DCID Length (8),
  Destination Connection ID (0..2040),
  SCID Length (8),
  Source Connection ID (0..2040),
  Supported Version (32) ...,
}
</pre>
</div>
<figcaption><a href="#figure-13" class="selfRef">Figure 13</a>:
<a href="#name-version-negotiation-packet-2" class="selfRef">Version Negotiation Packet</a>
            </figcaption></figure>
</div>
<p id="section-17.2.1-5">The value in the Unused field is selected randomly by the server.  Clients MUST
ignore the value of this field.  Servers SHOULD set the most significant bit of
this field (0x40) to 1 so that Version Negotiation packets appear to have the
Fixed Bit field.<a href="#section-17.2.1-5" class="pilcrow">¶</a></p>
<p id="section-17.2.1-6">The Version field of a Version Negotiation packet MUST be set to 0x00000000.<a href="#section-17.2.1-6" class="pilcrow">¶</a></p>
<p id="section-17.2.1-7">The server MUST include the value from the Source Connection ID field of the
packet it receives in the Destination Connection ID field.  The value for Source
Connection ID MUST be copied from the Destination Connection ID of the received
packet, which is initially randomly selected by a client.  Echoing both
connection IDs gives clients some assurance that the server received the packet
and that the Version Negotiation packet was not generated by an off-path
attacker.<a href="#section-17.2.1-7" class="pilcrow">¶</a></p>
<p id="section-17.2.1-8">As future versions of QUIC may support Connection IDs larger than the version 1
limit, Version Negotiation packets could carry Connection IDs that are longer
than 20 bytes.<a href="#section-17.2.1-8" class="pilcrow">¶</a></p>
<p id="section-17.2.1-9">The remainder of the Version Negotiation packet is a list of 32-bit versions
which the server supports.<a href="#section-17.2.1-9" class="pilcrow">¶</a></p>
<p id="section-17.2.1-10">A Version Negotiation packet cannot be explicitly acknowledged in an ACK frame
by a client.  Receiving another Initial packet implicitly acknowledges a Version
Negotiation packet.<a href="#section-17.2.1-10" class="pilcrow">¶</a></p>
<p id="section-17.2.1-11">The Version Negotiation packet does not include the Packet Number and Length
fields present in other packets that use the long header form.  Consequently,
a Version Negotiation packet consumes an entire UDP datagram.<a href="#section-17.2.1-11" class="pilcrow">¶</a></p>
<p id="section-17.2.1-12">A server MUST NOT send more than one Version Negotiation packet in response to a
single UDP datagram.<a href="#section-17.2.1-12" class="pilcrow">¶</a></p>
<p id="section-17.2.1-13">See <a href="#version-negotiation" class="xref">Section 6</a> for a description of the version negotiation
process.<a href="#section-17.2.1-13" class="pilcrow">¶</a></p>
</section>
</div>
<div id="packet-initial">
<section id="section-17.2.2">
          <h4 id="name-initial-packet">
<a href="#section-17.2.2" class="section-number selfRef">17.2.2. </a><a href="#name-initial-packet" class="section-name selfRef">Initial Packet</a>
          </h4>
<p id="section-17.2.2-1">An Initial packet uses long headers with a type value of 0x0.  It carries the
first CRYPTO frames sent by the client and server to perform key exchange, and
carries ACKs in either direction.<a href="#section-17.2.2-1" class="pilcrow">¶</a></p>
<span id="name-initial-packet-2"></span><div id="initial-format">
<figure id="figure-14">
            <div class="artwork art-text alignLeft" id="section-17.2.2-2.1">
<pre>
Initial Packet {
  Header Form (1) = 1,
  Fixed Bit (1) = 1,
  Long Packet Type (2) = 0,
  Reserved Bits (2),
  Packet Number Length (2),
  Version (32),
  DCID Length (8),
  Destination Connection ID (0..160),
  SCID Length (8),
  Source Connection ID (0..160),
  Token Length (i),
  Token (..),
  Length (i),
  Packet Number (8..32),
  Packet Payload (..),
}
</pre>
</div>
<figcaption><a href="#figure-14" class="selfRef">Figure 14</a>:
<a href="#name-initial-packet-2" class="selfRef">Initial Packet</a>
            </figcaption></figure>
</div>
<p id="section-17.2.2-3">The Initial packet contains a long header as well as the Length and Packet
Number fields.  The first byte contains the Reserved and Packet Number Length
bits.  Between the SCID and Length fields, there are two additional
fields specific to the Initial packet.<a href="#section-17.2.2-3" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-17.2.2-4">
            <dt id="section-17.2.2-4.1">Token Length:</dt>
<dd id="section-17.2.2-4.2">
  A variable-length integer specifying the length of the Token field, in bytes.
This value is zero if no token is present.  Initial packets sent by the server
MUST set the Token Length field to zero; clients that receive an Initial
packet with a non-zero Token Length field MUST either discard the packet or
generate a connection error of type PROTOCOL_VIOLATION.<a href="#section-17.2.2-4.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.2.2-4.3">Token:</dt>
<dd id="section-17.2.2-4.4">
  The value of the token that was previously provided in a Retry packet or
NEW_TOKEN frame.<a href="#section-17.2.2-4.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.2.2-4.5">Packet Payload:</dt>
<dd id="section-17.2.2-4.6">
  The payload of the packet.<a href="#section-17.2.2-4.6" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-17.2.2-5">In order to prevent tampering by version-unaware middleboxes, Initial packets
are protected with connection- and version-specific keys (Initial keys) as
described in <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>.  This protection does not provide confidentiality or
integrity against on-path attackers, but provides some level of protection
against off-path attackers.<a href="#section-17.2.2-5" class="pilcrow">¶</a></p>
<p id="section-17.2.2-6">The client and server use the Initial packet type for any packet that contains
an initial cryptographic handshake message. This includes all cases where a new
packet containing the initial cryptographic message needs to be created, such as
the packets sent after receiving a Retry packet (<a href="#packet-retry" class="xref">Section 17.2.5</a>).<a href="#section-17.2.2-6" class="pilcrow">¶</a></p>
<p id="section-17.2.2-7">A server sends its first Initial packet in response to a client Initial.  A
server may send multiple Initial packets.  The cryptographic key exchange could
require multiple round trips or retransmissions of this data.<a href="#section-17.2.2-7" class="pilcrow">¶</a></p>
<p id="section-17.2.2-8">The payload of an Initial packet includes a CRYPTO frame (or frames) containing
a cryptographic handshake message, ACK frames, or both.  PING, PADDING, and
CONNECTION_CLOSE frames are also permitted.  An endpoint that receives an
Initial packet containing other frames can either discard the packet as spurious
or treat it as a connection error.<a href="#section-17.2.2-8" class="pilcrow">¶</a></p>
<p id="section-17.2.2-9">The first packet sent by a client always includes a CRYPTO frame that contains
the start or all of the first cryptographic handshake message.  The first
CRYPTO frame sent always begins at an offset of 0; see <a href="#handshake" class="xref">Section 7</a>.<a href="#section-17.2.2-9" class="pilcrow">¶</a></p>
<p id="section-17.2.2-10">Note that if the server sends a HelloRetryRequest, the client will send another
series of Initial packets.  These Initial packets will continue the
cryptographic handshake and will contain CRYPTO frames starting at an offset
matching the size of the CRYPTO frames sent in the first flight of Initial
packets.<a href="#section-17.2.2-10" class="pilcrow">¶</a></p>
<div id="discard-initial">
<section id="section-17.2.2.1">
            <h5 id="name-abandoning-initial-packets">
<a href="#section-17.2.2.1" class="section-number selfRef">17.2.2.1. </a><a href="#name-abandoning-initial-packets" class="section-name selfRef">Abandoning Initial Packets</a>
            </h5>
<p id="section-17.2.2.1-1">A client stops both sending and processing Initial packets when it sends its
first Handshake packet.  A server stops sending and processing Initial packets
when it receives its first Handshake packet.  Though packets might still be in
flight or awaiting acknowledgment, no further Initial packets need to be
exchanged beyond this point.  Initial packet protection keys are discarded (see
Section 4.10.1 of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>) along with any loss recovery and congestion
control state; see Section 6.5 of <span>[<a href="#QUIC-RECOVERY" class="xref">QUIC-RECOVERY</a>]</span>.<a href="#section-17.2.2.1-1" class="pilcrow">¶</a></p>
<p id="section-17.2.2.1-2">Any data in CRYPTO frames is discarded - and no longer retransmitted - when
Initial keys are discarded.<a href="#section-17.2.2.1-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="packet-0rtt">
<section id="section-17.2.3">
          <h4 id="name-0-rtt">
<a href="#section-17.2.3" class="section-number selfRef">17.2.3. </a><a href="#name-0-rtt" class="section-name selfRef">0-RTT</a>
          </h4>
<p id="section-17.2.3-1">A 0-RTT packet uses long headers with a type value of 0x1, followed by the
Length and Packet Number fields. The first byte contains the Reserved and Packet
Number Length bits.  It is used to carry "early" data from the client to the
server as part of the first flight, prior to handshake completion. As part of
the TLS handshake, the server can accept or reject this early data.<a href="#section-17.2.3-1" class="pilcrow">¶</a></p>
<p id="section-17.2.3-2">See Section 2.3 of <span>[<a href="#TLS13" class="xref">TLS13</a>]</span> for a discussion of 0-RTT data and its
limitations.<a href="#section-17.2.3-2" class="pilcrow">¶</a></p>
<span id="name-0-rtt-packet"></span><figure id="figure-15">
            <div class="artwork art-text alignLeft" id="section-17.2.3-3.1">
<pre>
0-RTT Packet {
  Header Form (1) = 1,
  Fixed Bit (1) = 1,
  Long Packet Type (2) = 1,
  Reserved Bits (2),
  Packet Number Length (2),
  Version (32),
  DCID Length (8),
  Destination Connection ID (0..160),
  SCID Length (8),
  Source Connection ID (0..160),
  Length (i),
  Packet Number (8..32),
  Packet Payload (..),
}
</pre>
</div>
<figcaption><a href="#figure-15" class="selfRef">Figure 15</a>:
<a href="#name-0-rtt-packet" class="selfRef">0-RTT Packet</a>
            </figcaption></figure>
<p id="section-17.2.3-4">Packet numbers for 0-RTT protected packets use the same space as 1-RTT protected
packets.<a href="#section-17.2.3-4" class="pilcrow">¶</a></p>
<p id="section-17.2.3-5">After a client receives a Retry packet, 0-RTT packets are likely to have been
lost or discarded by the server.  A client SHOULD attempt to resend data in
0-RTT packets after it sends a new Initial packet.<a href="#section-17.2.3-5" class="pilcrow">¶</a></p>
<p id="section-17.2.3-6">A client MUST NOT reset the packet number it uses for 0-RTT packets, since the
keys used to protect 0-RTT packets will not change as a result of responding to
a Retry packet.  Sending packets with the same packet number in that case is
likely to compromise the packet protection for all 0-RTT packets because the
same key and nonce could be used to protect different content.<a href="#section-17.2.3-6" class="pilcrow">¶</a></p>
<p id="section-17.2.3-7">A client only receives acknowledgments for its 0-RTT packets once the handshake
is complete.  Consequently, a server might expect 0-RTT packets to start with a
packet number of 0.  Therefore, in determining the length of the packet number
encoding for 0-RTT packets, a client MUST assume that all packets up to the
current packet number are in flight, starting from a packet number of 0.  Thus,
0-RTT packets could need to use a longer packet number encoding.<a href="#section-17.2.3-7" class="pilcrow">¶</a></p>
<p id="section-17.2.3-8">A client MUST NOT send 0-RTT packets once it starts processing 1-RTT packets
from the server.  This means that 0-RTT packets cannot contain any response to
frames from 1-RTT packets.  For instance, a client cannot send an ACK frame in a
0-RTT packet, because that can only acknowledge a 1-RTT packet.  An
acknowledgment for a 1-RTT packet MUST be carried in a 1-RTT packet.<a href="#section-17.2.3-8" class="pilcrow">¶</a></p>
<p id="section-17.2.3-9">A server SHOULD treat a violation of remembered limits as a connection error of
an appropriate type (for instance, a FLOW_CONTROL_ERROR for exceeding stream
data limits).<a href="#section-17.2.3-9" class="pilcrow">¶</a></p>
</section>
</div>
<div id="packet-handshake">
<section id="section-17.2.4">
          <h4 id="name-handshake-packet">
<a href="#section-17.2.4" class="section-number selfRef">17.2.4. </a><a href="#name-handshake-packet" class="section-name selfRef">Handshake Packet</a>
          </h4>
<p id="section-17.2.4-1">A Handshake packet uses long headers with a type value of 0x2, followed by the
Length and Packet Number fields.  The first byte contains the Reserved and
Packet Number Length bits.  It is used to carry acknowledgments and
cryptographic handshake messages from the server and client.<a href="#section-17.2.4-1" class="pilcrow">¶</a></p>
<span id="name-handshake-protected-packet"></span><div id="handshake-format">
<figure id="figure-16">
            <div class="artwork art-text alignLeft" id="section-17.2.4-2.1">
<pre>
Handshake Packet {
  Header Form (1) = 1,
  Fixed Bit (1) = 1,
  Long Packet Type (2) = 2,
  Reserved Bits (2),
  Packet Number Length (2),
  Version (32),
  DCID Length (8),
  Destination Connection ID (0..160),
  SCID Length (8),
  Source Connection ID (0..160),
  Length (i),
  Packet Number (8..32),
  Packet Payload (..),
}
</pre>
</div>
<figcaption><a href="#figure-16" class="selfRef">Figure 16</a>:
<a href="#name-handshake-protected-packet" class="selfRef">Handshake Protected Packet</a>
            </figcaption></figure>
</div>
<p id="section-17.2.4-3">Once a client has received a Handshake packet from a server, it uses Handshake
packets to send subsequent cryptographic handshake messages and acknowledgments
to the server.<a href="#section-17.2.4-3" class="pilcrow">¶</a></p>
<p id="section-17.2.4-4">The Destination Connection ID field in a Handshake packet contains a connection
ID that is chosen by the recipient of the packet; the Source Connection ID
includes the connection ID that the sender of the packet wishes to use; see
<a href="#negotiating-connection-ids" class="xref">Section 7.2</a>.<a href="#section-17.2.4-4" class="pilcrow">¶</a></p>
<p id="section-17.2.4-5">Handshake packets are their own packet number space, and thus the first
Handshake packet sent by a server contains a packet number of 0.<a href="#section-17.2.4-5" class="pilcrow">¶</a></p>
<p id="section-17.2.4-6">The payload of this packet contains CRYPTO frames and could contain PING,
PADDING, or ACK frames. Handshake packets MAY contain CONNECTION_CLOSE frames.
Endpoints MUST treat receipt of Handshake packets with other frames as a
connection error.<a href="#section-17.2.4-6" class="pilcrow">¶</a></p>
<p id="section-17.2.4-7">Like Initial packets (see <a href="#discard-initial" class="xref">Section 17.2.2.1</a>), data in CRYPTO frames for
Handshake packets is discarded - and no longer retransmitted - when Handshake
protection keys are discarded.<a href="#section-17.2.4-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="packet-retry">
<section id="section-17.2.5">
          <h4 id="name-retry-packet">
<a href="#section-17.2.5" class="section-number selfRef">17.2.5. </a><a href="#name-retry-packet" class="section-name selfRef">Retry Packet</a>
          </h4>
<p id="section-17.2.5-1">A Retry packet uses a long packet header with a type value of 0x3. It carries
an address validation token created by the server. It is used by a server that
wishes to perform a retry; see <a href="#validate-handshake" class="xref">Section 8.1</a>.<a href="#section-17.2.5-1" class="pilcrow">¶</a></p>
<span id="name-retry-packet-2"></span><div id="retry-format">
<figure id="figure-17">
            <div class="artwork art-text alignLeft" id="section-17.2.5-2.1">
<pre>
Retry Packet {
  Header Form (1) = 1,
  Fixed Bit (1) = 1,
  Long Packet Type (2) = 3,
  Unused (4),
  Version (32),
  DCID Length (8),
  Destination Connection ID (0..160),
  SCID Length (8),
  Source Connection ID (0..160),
  Retry Token (..),
  Retry Integrity Tag (128),
}
</pre>
</div>
<figcaption><a href="#figure-17" class="selfRef">Figure 17</a>:
<a href="#name-retry-packet-2" class="selfRef">Retry Packet</a>
            </figcaption></figure>
</div>
<p id="section-17.2.5-3">A Retry packet (shown in <a href="#retry-format" class="xref">Figure 17</a>) does not contain any protected
fields. The value in the Unused field is selected randomly by the server. In
addition to the fields from the long header, it contains these additional
fields:<a href="#section-17.2.5-3" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-17.2.5-4">
            <dt id="section-17.2.5-4.1">Retry Token:</dt>
<dd id="section-17.2.5-4.2">
  An opaque token that the server can use to validate the client's address.<a href="#section-17.2.5-4.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.2.5-4.3">Retry Integrity Tag:</dt>
<dd id="section-17.2.5-4.4">
  See the Retry Packet Integrity section of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>.<a href="#section-17.2.5-4.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<div id="sending-a-retry-packet">
<section id="section-17.2.5.1">
            <h5 id="name-sending-a-retry-packet">
<a href="#section-17.2.5.1" class="section-number selfRef">17.2.5.1. </a><a href="#name-sending-a-retry-packet" class="section-name selfRef">Sending a Retry Packet</a>
            </h5>
<p id="section-17.2.5.1-1">The server populates the Destination Connection ID with the connection ID that
the client included in the Source Connection ID of the Initial packet.<a href="#section-17.2.5.1-1" class="pilcrow">¶</a></p>
<p id="section-17.2.5.1-2">The server includes a connection ID of its choice in the Source Connection ID
field.  This value MUST not be equal to the Destination Connection ID field of
the packet sent by the client.  A client MUST discard a Retry packet that
contains a Source Connection ID field that is identical to the Destination
Connection ID field of its Initial packet.  The client MUST use the value from
the Source Connection ID field of the Retry packet in the Destination Connection
ID field of subsequent packets that it sends.<a href="#section-17.2.5.1-2" class="pilcrow">¶</a></p>
<p id="section-17.2.5.1-3">A server MAY send Retry packets in response to Initial and 0-RTT packets.  A
server can either discard or buffer 0-RTT packets that it receives.  A server
can send multiple Retry packets as it receives Initial or 0-RTT packets.  A
server MUST NOT send more than one Retry packet in response to a single UDP
datagram.<a href="#section-17.2.5.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="handling-a-retry-packet">
<section id="section-17.2.5.2">
            <h5 id="name-handling-a-retry-packet">
<a href="#section-17.2.5.2" class="section-number selfRef">17.2.5.2. </a><a href="#name-handling-a-retry-packet" class="section-name selfRef">Handling a Retry Packet</a>
            </h5>
<p id="section-17.2.5.2-1">A client MUST accept and process at most one Retry packet for each connection
attempt.  After the client has received and processed an Initial or Retry packet
from the server, it MUST discard any subsequent Retry packets that it receives.<a href="#section-17.2.5.2-1" class="pilcrow">¶</a></p>
<p id="section-17.2.5.2-2">Clients MUST discard Retry packets that have a Retry Integrity Tag that cannot
be validated, see the Retry Packet Integrity section of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>. This
diminishes an off-path attacker's ability to inject a Retry packet and protects
against accidental corruption of Retry packets.  A client MUST discard a Retry
packet with a zero-length Retry Token field.<a href="#section-17.2.5.2-2" class="pilcrow">¶</a></p>
<p id="section-17.2.5.2-3">The client responds to a Retry packet with an Initial packet that includes the
provided Retry Token to continue connection establishment.<a href="#section-17.2.5.2-3" class="pilcrow">¶</a></p>
<p id="section-17.2.5.2-4">A client sets the Destination Connection ID field of this Initial packet to the
value from the Source Connection ID in the Retry packet. Changing Destination
Connection ID also results in a change to the keys used to protect the Initial
packet. It also sets the Token field to the token provided in the Retry. The
client MUST NOT change the Source Connection ID because the server could include
the connection ID as part of its token validation logic; see
<a href="#token-integrity" class="xref">Section 8.1.4</a>.<a href="#section-17.2.5.2-4" class="pilcrow">¶</a></p>
<p id="section-17.2.5.2-5">A Retry packet does not include a packet number and cannot be explicitly
acknowledged by a client.<a href="#section-17.2.5.2-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="continuing-a-handshake-after-retry">
<section id="section-17.2.5.3">
            <h5 id="name-continuing-a-handshake-afte">
<a href="#section-17.2.5.3" class="section-number selfRef">17.2.5.3. </a><a href="#name-continuing-a-handshake-afte" class="section-name selfRef">Continuing a Handshake After Retry</a>
            </h5>
<p id="section-17.2.5.3-1">The next Initial packet from the client uses the connection ID and token values
from the Retry packet; see <a href="#negotiating-connection-ids" class="xref">Section 7.2</a>.  Aside from this,
the Initial packet sent by the client is subject to the same restrictions as the
first Initial packet.  A client MUST use the same cryptographic handshake
message it includes in this packet.  A server MAY treat a packet that
contains a different cryptographic handshake message as a connection error or
discard it.<a href="#section-17.2.5.3-1" class="pilcrow">¶</a></p>
<p id="section-17.2.5.3-2">A client MAY attempt 0-RTT after receiving a Retry packet by sending 0-RTT
packets to the connection ID provided by the server.  A client MUST NOT change
the cryptographic handshake message it sends in response to receiving a Retry.<a href="#section-17.2.5.3-2" class="pilcrow">¶</a></p>
<p id="section-17.2.5.3-3">A client MUST NOT reset the packet number for any packet number space after
processing a Retry packet; <a href="#packet-0rtt" class="xref">Section 17.2.3</a> contains more information on this.<a href="#section-17.2.5.3-3" class="pilcrow">¶</a></p>
<p id="section-17.2.5.3-4">A server acknowledges the use of a Retry packet for a connection using the
retry_source_connection_id transport parameter; see
<a href="#transport-parameter-definitions" class="xref">Section 18.2</a>.  If the server sends a Retry packet, it
also subsequently includes the value of the Source Connection ID field from
the Retry packet in its retry_source_connection_id transport parameter.<a href="#section-17.2.5.3-4" class="pilcrow">¶</a></p>
<p id="section-17.2.5.3-5">If the client received and processed a Retry packet, it MUST validate that the
retry_source_connection_id transport parameter is present and correct;
otherwise, it MUST validate that the transport parameter is absent. A client
MUST treat a failed validation as a connection error of type
PROTOCOL_VIOLATION.<a href="#section-17.2.5.3-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="short-header">
<section id="section-17.3">
        <h3 id="name-short-header-packets">
<a href="#section-17.3" class="section-number selfRef">17.3. </a><a href="#name-short-header-packets" class="section-name selfRef">Short Header Packets</a>
        </h3>
<p id="section-17.3-1">This version of QUIC defines a single packet type which uses the
short packet header.<a href="#section-17.3-1" class="pilcrow">¶</a></p>
<span id="name-short-header-packet-format"></span><div id="fig-short-header">
<figure id="figure-18">
          <div class="artwork art-text alignLeft" id="section-17.3-2.1">
<pre>
Short Header Packet {
  Header Form (1) = 0,
  Fixed Bit (1) = 1,
  Spin Bit (1),
  Reserved Bits (2),
  Key Phase (1),
  Packet Number Length (2),
  Destination Connection ID (0..160),
  Packet Number (8..32),
  Packet Payload (..),
}
</pre>
</div>
<figcaption><a href="#figure-18" class="selfRef">Figure 18</a>:
<a href="#name-short-header-packet-format" class="selfRef">Short Header Packet Format</a>
          </figcaption></figure>
</div>
<p id="section-17.3-3">The short header can be used after the version and 1-RTT keys are negotiated.
Packets that use the short header contain the following fields:<a href="#section-17.3-3" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-17.3-4">
          <dt id="section-17.3-4.1">Header Form:</dt>
<dd id="section-17.3-4.2">
  The most significant bit (0x80) of byte 0 is set to 0 for the short header.<a href="#section-17.3-4.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.3-4.3">Fixed Bit:</dt>
<dd id="section-17.3-4.4">
  The next bit (0x40) of byte 0 is set to 1.  Packets containing a zero value
for this bit are not valid packets in this version and MUST be discarded.<a href="#section-17.3-4.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.3-4.5">Spin Bit:</dt>
<dd id="section-17.3-4.6">
  The third most significant bit (0x20) of byte 0 is the latency spin bit, set
as described in <a href="#spin-bit" class="xref">Section 17.3.1</a>.<a href="#section-17.3-4.6" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.3-4.7">Reserved Bits:</dt>
<dd id="section-17.3-4.8">
  The next two bits (those with a mask of 0x18) of byte 0 are reserved.  These
bits are protected using header protection; see Section 5.4 of
<span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>.  The value included prior to protection MUST be set to 0.  An
endpoint MUST treat receipt of a packet that has a non-zero value for these
bits, after removing both packet and header protection, as a connection error
of type PROTOCOL_VIOLATION. Discarding such a packet after only removing
header protection can expose the endpoint to attacks; see Section 9.3 of
<span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>.<a href="#section-17.3-4.8" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.3-4.9">Key Phase:</dt>
<dd id="section-17.3-4.10">
  The next bit (0x04) of byte 0 indicates the key phase, which allows a
recipient of a packet to identify the packet protection keys that are used to
protect the packet.  See <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span> for details.  This bit is protected
using header protection; see Section 5.4 of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>.<a href="#section-17.3-4.10" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.3-4.11">Packet Number Length:</dt>
<dd id="section-17.3-4.12">
  The least significant two bits (those with a mask of 0x03) of byte 0 contain
the length of the packet number, encoded as an unsigned, two-bit integer that
is one less than the length of the packet number field in bytes.  That is, the
length of the packet number field is the value of this field, plus one.  These
bits are protected using header protection; see Section 5.4 of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>.<a href="#section-17.3-4.12" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.3-4.13">Destination Connection ID:</dt>
<dd id="section-17.3-4.14">
  The Destination Connection ID is a connection ID that is chosen by the
intended recipient of the packet.  See <a href="#connection-id" class="xref">Section 5.1</a> for more details.<a href="#section-17.3-4.14" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.3-4.15">Packet Number:</dt>
<dd id="section-17.3-4.16">
  The packet number field is 1 to 4 bytes long. The packet number has
confidentiality protection separate from packet protection, as described in
Section 5.4 of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>. The length of the packet number field is encoded
in Packet Number Length field. See <a href="#packet-encoding" class="xref">Section 17.1</a> for details.<a href="#section-17.3-4.16" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-17.3-4.17">Packet Payload:</dt>
<dd id="section-17.3-4.18">
  Packets with a short header always include a 1-RTT protected payload.<a href="#section-17.3-4.18" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-17.3-5">The header form bit and the connection ID field of a short header packet are
version-independent.  The remaining fields are specific to the selected QUIC
version.  See <span>[<a href="#QUIC-INVARIANTS" class="xref">QUIC-INVARIANTS</a>]</span> for details on how packets from different
versions of QUIC are interpreted.<a href="#section-17.3-5" class="pilcrow">¶</a></p>
<div id="spin-bit">
<section id="section-17.3.1">
          <h4 id="name-latency-spin-bit">
<a href="#section-17.3.1" class="section-number selfRef">17.3.1. </a><a href="#name-latency-spin-bit" class="section-name selfRef">Latency Spin Bit</a>
          </h4>
<p id="section-17.3.1-1">The latency spin bit enables passive latency monitoring from observation points
on the network path throughout the duration of a connection. The spin bit is
only present in the short packet header, since it is possible to measure the
initial RTT of a connection by observing the handshake. Therefore, the spin bit
is available after version negotiation and connection establishment are
completed. On-path measurement and use of the latency spin bit is further
discussed in <span>[<a href="#QUIC-MANAGEABILITY" class="xref">QUIC-MANAGEABILITY</a>]</span>.<a href="#section-17.3.1-1" class="pilcrow">¶</a></p>
<p id="section-17.3.1-2">The spin bit is an OPTIONAL feature of QUIC. A QUIC stack that chooses to
support the spin bit MUST implement it as specified in this section.<a href="#section-17.3.1-2" class="pilcrow">¶</a></p>
<p id="section-17.3.1-3">Each endpoint unilaterally decides if the spin bit is enabled or disabled for a
connection. Implementations MUST allow administrators of clients and servers
to disable the spin bit either globally or on a per-connection basis. Even when
the spin bit is not disabled by the administrator, endpoints MUST disable their
use of the spin bit for a random selection of at least one in every 16 network
paths, or for one in every 16 connection IDs.  As each endpoint disables the
spin bit independently, this ensures that the spin bit signal is disabled on
approximately one in eight network paths.<a href="#section-17.3.1-3" class="pilcrow">¶</a></p>
<p id="section-17.3.1-4">When the spin bit is disabled, endpoints MAY set the spin bit to any value, and
MUST ignore any incoming value. It is RECOMMENDED that endpoints set the spin
bit to a random value either chosen independently for each packet or chosen
independently for each connection ID.<a href="#section-17.3.1-4" class="pilcrow">¶</a></p>
<p id="section-17.3.1-5">If the spin bit is enabled for the connection, the endpoint maintains a spin
value and sets the spin bit in the short header to the currently stored
value when a packet with a short header is sent out. The spin value is
initialized to 0 in the endpoint at connection start.  Each endpoint also
remembers the highest packet number seen from its peer on the connection.<a href="#section-17.3.1-5" class="pilcrow">¶</a></p>
<p id="section-17.3.1-6">When a server receives a short header packet that increments the highest
packet number seen by the server from the client, it sets the spin value to be
equal to the spin bit in the received packet.<a href="#section-17.3.1-6" class="pilcrow">¶</a></p>
<p id="section-17.3.1-7">When a client receives a short header packet that increments the highest
packet number seen by the client from the server, it sets the spin value to the
inverse of the spin bit in the received packet.<a href="#section-17.3.1-7" class="pilcrow">¶</a></p>
<p id="section-17.3.1-8">An endpoint resets its spin value to zero when sending the first packet of a
given connection with a new connection ID. This reduces the risk that transient
spin bit state can be used to link flows across connection migration or ID
change.<a href="#section-17.3.1-8" class="pilcrow">¶</a></p>
<p id="section-17.3.1-9">With this mechanism, the server reflects the spin value received, while the
client 'spins' it after one RTT. On-path observers can measure the time
between two spin bit toggle events to estimate the end-to-end RTT of a
connection.<a href="#section-17.3.1-9" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="transport-parameter-encoding">
<section id="section-18">
      <h2 id="name-transport-parameter-encodin">
<a href="#section-18" class="section-number selfRef">18. </a><a href="#name-transport-parameter-encodin" class="section-name selfRef">Transport Parameter Encoding</a>
      </h2>
<p id="section-18-1">The extension_data field of the quic_transport_parameters extension defined in
<span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span> contains the QUIC transport parameters. They are encoded as a
sequence of transport parameters, as shown in <a href="#transport-parameter-sequence" class="xref">Figure 19</a>:<a href="#section-18-1" class="pilcrow">¶</a></p>
<span id="name-sequence-of-transport-param"></span><div id="transport-parameter-sequence">
<figure id="figure-19">
        <div class="artwork art-text alignLeft" id="section-18-2.1">
<pre>
Transport Parameters {
  Transport Parameter (..) ...,
}
</pre>
</div>
<figcaption><a href="#figure-19" class="selfRef">Figure 19</a>:
<a href="#name-sequence-of-transport-param" class="selfRef">Sequence of Transport Parameters</a>
        </figcaption></figure>
</div>
<p id="section-18-3">Each transport parameter is encoded as an (identifier, length, value) tuple,
as shown in <a href="#transport-parameter-encoding-fig" class="xref">Figure 20</a>:<a href="#section-18-3" class="pilcrow">¶</a></p>
<span id="name-transport-parameter-encoding"></span><div id="transport-parameter-encoding-fig">
<figure id="figure-20">
        <div class="artwork art-text alignLeft" id="section-18-4.1">
<pre>
Transport Parameter {
  Transport Parameter ID (i),
  Transport Parameter Length (i),
  Transport Parameter Value (..),
}
</pre>
</div>
<figcaption><a href="#figure-20" class="selfRef">Figure 20</a>:
<a href="#name-transport-parameter-encoding" class="selfRef">Transport Parameter Encoding</a>
        </figcaption></figure>
</div>
<p id="section-18-5">The Transport Parameter Length field contains the length of the Transport
Parameter Value field.<a href="#section-18-5" class="pilcrow">¶</a></p>
<p id="section-18-6">QUIC encodes transport parameters into a sequence of bytes, which are then
included in the cryptographic handshake.<a href="#section-18-6" class="pilcrow">¶</a></p>
<div id="transport-parameter-grease">
<section id="section-18.1">
        <h3 id="name-reserved-transport-paramete">
<a href="#section-18.1" class="section-number selfRef">18.1. </a><a href="#name-reserved-transport-paramete" class="section-name selfRef">Reserved Transport Parameters</a>
        </h3>
<p id="section-18.1-1">Transport parameters with an identifier of the form <code>31 * N + 27</code> for integer
values of N are reserved to exercise the requirement that unknown transport
parameters be ignored.  These transport parameters have no semantics, and may
carry arbitrary values.<a href="#section-18.1-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="transport-parameter-definitions">
<section id="section-18.2">
        <h3 id="name-transport-parameter-definit">
<a href="#section-18.2" class="section-number selfRef">18.2. </a><a href="#name-transport-parameter-definit" class="section-name selfRef">Transport Parameter Definitions</a>
        </h3>
<p id="section-18.2-1">This section details the transport parameters defined in this document.<a href="#section-18.2-1" class="pilcrow">¶</a></p>
<p id="section-18.2-2">Many transport parameters listed here have integer values.  Those transport
parameters that are identified as integers use a variable-length integer
encoding; see <a href="#integer-encoding" class="xref">Section 16</a>.  Transport parameters have a default value
of 0 if the transport parameter is absent unless otherwise stated.<a href="#section-18.2-2" class="pilcrow">¶</a></p>
<p id="section-18.2-3">The following transport parameters are defined:<a href="#section-18.2-3" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-18.2-4">
          <dt id="section-18.2-4.1">original_destination_connection_id (0x00):</dt>
<dd id="section-18.2-4.2">
  The value of the Destination Connection ID field from the first Initial packet
sent by the client; see <a href="#cid-auth" class="xref">Section 7.3</a>.  This transport parameter is only sent
by a server.<a href="#section-18.2-4.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-4.3">max_idle_timeout (0x01):</dt>
<dd id="section-18.2-4.4">
  The max idle timeout is a value in milliseconds that is encoded as an integer;
see (<a href="#idle-timeout" class="xref">Section 10.2</a>).  Idle timeout is disabled when both endpoints omit
this transport parameter or specify a value of 0.<a href="#section-18.2-4.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-4.5">stateless_reset_token (0x02):</dt>
<dd id="section-18.2-4.6">
  A stateless reset token is used in verifying a stateless reset; see
<a href="#stateless-reset" class="xref">Section 10.4</a>.  This parameter is a sequence of 16 bytes.  This
transport parameter MUST NOT be sent by a client, but MAY be sent by a server.
A server that does not send this transport parameter cannot use stateless
reset (<a href="#stateless-reset" class="xref">Section 10.4</a>) for the connection ID negotiated during the
handshake.<a href="#section-18.2-4.6" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-4.7">max_udp_payload_size (0x03):</dt>
<dd id="section-18.2-4.8">
  The maximum UDP payload size parameter is an integer value that limits the
size of UDP payloads that the endpoint is willing to receive.  UDP packets
with payloads larger than this limit are not likely to be processed by the
receiver.<a href="#section-18.2-4.8" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-4.9"></dt>
<dd id="section-18.2-4.10">The default for this parameter is the maximum permitted UDP payload of 65527.
Values below 1200 are invalid.<a href="#section-18.2-4.10" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-4.11"></dt>
<dd id="section-18.2-4.12">This limit does act as an additional constraint on datagram size in the same
way as the path MTU, but it is a property of the endpoint and not the path. It
is expected that this is the space an endpoint dedicates to holding incoming
packets.<a href="#section-18.2-4.12" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-4.13">initial_max_data (0x04):</dt>
<dd id="section-18.2-4.14">
  The initial maximum data parameter is an integer value that contains the
initial value for the maximum amount of data that can be sent on the
connection.  This is equivalent to sending a MAX_DATA (<a href="#frame-max-data" class="xref">Section 19.9</a>) for
the connection immediately after completing the handshake.<a href="#section-18.2-4.14" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-4.15">initial_max_stream_data_bidi_local (0x05):</dt>
<dd id="section-18.2-4.16">
  This parameter is an integer value specifying the initial flow control limit
for locally-initiated bidirectional streams.  This limit applies to newly
created bidirectional streams opened by the endpoint that sends the transport
parameter.  In client transport parameters, this applies to streams with an
identifier with the least significant two bits set to 0x0; in server transport
parameters, this applies to streams with the least significant two bits set to
0x1.<a href="#section-18.2-4.16" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-4.17">initial_max_stream_data_bidi_remote (0x06):</dt>
<dd id="section-18.2-4.18">
  This parameter is an integer value specifying the initial flow control limit
for peer-initiated bidirectional streams.  This limit applies to newly created
bidirectional streams opened by the endpoint that receives the transport
parameter.  In client transport parameters, this applies to streams with an
identifier with the least significant two bits set to 0x1; in server transport
parameters, this applies to streams with the least significant two bits set to
0x0.<a href="#section-18.2-4.18" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-4.19">initial_max_stream_data_uni (0x07):</dt>
<dd id="section-18.2-4.20">
  This parameter is an integer value specifying the initial flow control limit
for unidirectional streams.  This limit applies to newly created
unidirectional streams opened by the endpoint that receives the transport
parameter.  In client transport parameters, this applies to streams with an
identifier with the least significant two bits set to 0x3; in server transport
parameters, this applies to streams with the least significant two bits set to
0x2.<a href="#section-18.2-4.20" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-4.21">initial_max_streams_bidi (0x08):</dt>
<dd id="section-18.2-4.22">
  The initial maximum bidirectional streams parameter is an integer value that
contains the initial maximum number of bidirectional streams the peer may
initiate.  If this parameter is absent or zero, the peer cannot open
bidirectional streams until a MAX_STREAMS frame is sent.  Setting this
parameter is equivalent to sending a MAX_STREAMS (<a href="#frame-max-streams" class="xref">Section 19.11</a>) of
the corresponding type with the same value.<a href="#section-18.2-4.22" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-4.23">initial_max_streams_uni (0x09):</dt>
<dd id="section-18.2-4.24">
  The initial maximum unidirectional streams parameter is an integer value that
contains the initial maximum number of unidirectional streams the peer may
initiate.  If this parameter is absent or zero, the peer cannot open
unidirectional streams until a MAX_STREAMS frame is sent.  Setting this
parameter is equivalent to sending a MAX_STREAMS (<a href="#frame-max-streams" class="xref">Section 19.11</a>) of
the corresponding type with the same value.<a href="#section-18.2-4.24" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-4.25">ack_delay_exponent (0x0a):</dt>
<dd id="section-18.2-4.26">
  The ACK delay exponent is an integer value indicating an
exponent used to decode the ACK Delay field in the ACK frame (<a href="#frame-ack" class="xref">Section 19.3</a>).
If this value is absent, a default value of 3 is assumed (indicating a
multiplier of 8). Values above 20 are invalid.<a href="#section-18.2-4.26" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-4.27">max_ack_delay (0x0b):</dt>
<dd id="section-18.2-4.28">
  The maximum ACK delay is an integer value indicating the
maximum amount of time in milliseconds by which the endpoint will delay
sending acknowledgments.  This value SHOULD include the receiver's expected
delays in alarms firing.  For example, if a receiver sets a timer for 5ms
and alarms commonly fire up to 1ms late, then it should send a max_ack_delay
of 6ms.  If this value is absent, a default of 25 milliseconds is assumed.
Values of 2^14 or greater are invalid.<a href="#section-18.2-4.28" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-4.29">disable_active_migration (0x0c):</dt>
<dd id="section-18.2-4.30">
  The disable active migration transport parameter is included if the endpoint
does not support active connection migration (<a href="#migration" class="xref">Section 9</a>). Peers of an
endpoint that sets this transport parameter MUST NOT send any packets,
including probing packets (<a href="#probing" class="xref">Section 9.1</a>), from a local address or port other
than that used to perform the handshake.  This parameter is a zero-length
value.<a href="#section-18.2-4.30" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-4.31">preferred_address (0x0d):</dt>
<dd id="section-18.2-4.32">
  The server's preferred address is used to effect a change in server address at
the end of the handshake, as described in <a href="#preferred-address" class="xref">Section 9.6</a>.  The format
of this transport parameter is shown in <a href="#fig-preferred-address" class="xref">Figure 21</a>.  This
transport parameter is only sent by a server. Servers MAY choose to only send
a preferred address of one address family by sending an all-zero address and
port (0.0.0.0:0 or ::.0) for the other family. IP addresses are encoded in
network byte order.<a href="#section-18.2-4.32" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-4.33"></dt>
<dd id="section-18.2-4.34">The Connection ID field and the Stateless Reset Token field contain an
alternative connection ID that has a sequence number of 1; see <a href="#issue-cid" class="xref">Section 5.1.1</a>.
Having these values bundled with the preferred address ensures that there will
be at least one unused active connection ID when the client initiates
migration to the preferred address.<a href="#section-18.2-4.34" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-4.35"></dt>
<dd id="section-18.2-4.36">The Connection ID and Stateless Reset Token fields of a preferred address are
identical in syntax and semantics to the corresponding fields of a
NEW_CONNECTION_ID frame (<a href="#frame-new-connection-id" class="xref">Section 19.15</a>).  A server that chooses
a zero-length connection ID MUST NOT provide a preferred address.  Similarly,
a server MUST NOT include a zero-length connection ID in this transport
parameter.  A client MUST treat violation of these requirements as a
connection error of type TRANSPORT_PARAMETER_ERROR.<a href="#section-18.2-4.36" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<span id="name-preferred-address-format"></span><div id="fig-preferred-address">
<figure id="figure-21">
          <div class="artwork art-text alignLeft" id="section-18.2-5.1">
<pre>
Preferred Address {
  IPv4 Address (32),
  IPv4 Port (16),
  IPv6 Address (128),
  IPv6 Port (16),
  CID Length (8),
  Connection ID (..),
  Stateless Reset Token (128),
}
</pre>
</div>
<figcaption><a href="#figure-21" class="selfRef">Figure 21</a>:
<a href="#name-preferred-address-format" class="selfRef">Preferred Address format</a>
          </figcaption></figure>
</div>
<dl class="dlParallel" id="section-18.2-6">
          <dt id="section-18.2-6.1">active_connection_id_limit (0x0e):</dt>
<dd id="section-18.2-6.2">
  The active connection ID limit is an integer value specifying the
maximum number of connection IDs from the peer that an endpoint is willing
to store. This value includes the connection ID received during the handshake,
that received in the preferred_address transport parameter, and those received
in NEW_CONNECTION_ID frames.
The value of the active_connection_id_limit parameter MUST be at least 2.
An endpoint that receives a value less than 2 MUST close the connection
with an error of type TRANSPORT_PARAMETER_ERROR.
If this transport parameter is absent, a default of 2 is assumed.  If an
endpoint issues a zero-length connection ID, it will never send a
NEW_CONNECTION_ID frame and therefore ignores the active_connection_id_limit
value received from its peer.<a href="#section-18.2-6.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-6.3">initial_source_connection_id (0x0f):</dt>
<dd id="section-18.2-6.4">
  The value that the endpoint included in the Source Connection ID field of the
first Initial packet it sends for the connection; see <a href="#cid-auth" class="xref">Section 7.3</a>.<a href="#section-18.2-6.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-18.2-6.5">retry_source_connection_id (0x10):</dt>
<dd id="section-18.2-6.6">
  The value that the the server included in the Source Connection ID field of a
Retry packet; see <a href="#cid-auth" class="xref">Section 7.3</a>.  This transport parameter is only sent by a
server.<a href="#section-18.2-6.6" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-18.2-7">If present, transport parameters that set initial flow control limits
(initial_max_stream_data_bidi_local, initial_max_stream_data_bidi_remote, and
initial_max_stream_data_uni) are equivalent to sending a MAX_STREAM_DATA frame
(<a href="#frame-max-stream-data" class="xref">Section 19.10</a>) on every stream of the corresponding type
immediately after opening.  If the transport parameter is absent, streams of
that type start with a flow control limit of 0.<a href="#section-18.2-7" class="pilcrow">¶</a></p>
<p id="section-18.2-8">A client MUST NOT include any server-only transport parameter:
original_destination_connection_id, preferred_address,
retry_source_connection_id, or stateless_reset_token. A server MUST treat
receipt of any of these transport parameters as a connection error of type
TRANSPORT_PARAMETER_ERROR.<a href="#section-18.2-8" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="frame-formats">
<section id="section-19">
      <h2 id="name-frame-types-and-formats">
<a href="#section-19" class="section-number selfRef">19. </a><a href="#name-frame-types-and-formats" class="section-name selfRef">Frame Types and Formats</a>
      </h2>
<p id="section-19-1">As described in <a href="#frames" class="xref">Section 12.4</a>, packets contain one or more frames. This section
describes the format and semantics of the core QUIC frame types.<a href="#section-19-1" class="pilcrow">¶</a></p>
<div id="frame-padding">
<section id="section-19.1">
        <h3 id="name-padding-frame">
<a href="#section-19.1" class="section-number selfRef">19.1. </a><a href="#name-padding-frame" class="section-name selfRef">PADDING Frame</a>
        </h3>
<p id="section-19.1-1">The PADDING frame (type=0x00) has no semantic value.  PADDING frames can be used
to increase the size of a packet.  Padding can be used to increase an initial
client packet to the minimum required size, or to provide protection against
traffic analysis for protected packets.<a href="#section-19.1-1" class="pilcrow">¶</a></p>
<p id="section-19.1-2">A PADDING frame has no content.  That is, a PADDING frame consists of the single
byte that identifies the frame as a PADDING frame.<a href="#section-19.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="frame-ping">
<section id="section-19.2">
        <h3 id="name-ping-frame">
<a href="#section-19.2" class="section-number selfRef">19.2. </a><a href="#name-ping-frame" class="section-name selfRef">PING Frame</a>
        </h3>
<p id="section-19.2-1">Endpoints can use PING frames (type=0x01) to verify that their peers are still
alive or to check reachability to the peer. The PING frame contains no
additional fields.<a href="#section-19.2-1" class="pilcrow">¶</a></p>
<p id="section-19.2-2">The receiver of a PING frame simply needs to acknowledge the packet containing
this frame.<a href="#section-19.2-2" class="pilcrow">¶</a></p>
<p id="section-19.2-3">The PING frame can be used to keep a connection alive when an application or
application protocol wishes to prevent the connection from timing out. An
application protocol SHOULD provide guidance about the conditions under which
generating a PING is recommended.  This guidance SHOULD indicate whether it is
the client or the server that is expected to send the PING.  Having both
endpoints send PING frames without coordination can produce an excessive number
of packets and poor performance.<a href="#section-19.2-3" class="pilcrow">¶</a></p>
<p id="section-19.2-4">A connection will time out if no packets are sent or received for a period
longer than the time negotiated using the max_idle_timeout transport parameter;
see <a href="#termination" class="xref">Section 10</a>.  However, state in middleboxes might time out earlier than
that.  Though REQ-5 in <span>[<a href="#RFC4787" class="xref">RFC4787</a>]</span> recommends a 2 minute timeout interval,
experience shows that sending packets every 15 to 30 seconds is necessary to
prevent the majority of middleboxes from losing state for UDP flows.<a href="#section-19.2-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="frame-ack">
<section id="section-19.3">
        <h3 id="name-ack-frames">
<a href="#section-19.3" class="section-number selfRef">19.3. </a><a href="#name-ack-frames" class="section-name selfRef">ACK Frames</a>
        </h3>
<p id="section-19.3-1">Receivers send ACK frames (types 0x02 and 0x03) to inform senders of packets
they have received and processed. The ACK frame contains one or more ACK Ranges.
ACK Ranges identify acknowledged packets. If the frame type is 0x03, ACK frames
also contain the sum of QUIC packets with associated ECN marks received on the
connection up until this point.  QUIC implementations MUST properly handle both
types and, if they have enabled ECN for packets they send, they SHOULD use the
information in the ECN section to manage their congestion state.<a href="#section-19.3-1" class="pilcrow">¶</a></p>
<p id="section-19.3-2">QUIC acknowledgements are irrevocable.  Once acknowledged, a packet remains
acknowledged, even if it does not appear in a future ACK frame.  This is unlike
TCP SACKs (<span>[<a href="#RFC2018" class="xref">RFC2018</a>]</span>).<a href="#section-19.3-2" class="pilcrow">¶</a></p>
<p id="section-19.3-3">Packets from different packet number spaces can be identified using the same
numeric value. An acknowledgment for a packet needs to indicate both a packet
number and a packet number space. This is accomplished by having each ACK frame
only acknowledge packet numbers in the same space as the packet in which the
ACK frame is contained.<a href="#section-19.3-3" class="pilcrow">¶</a></p>
<p id="section-19.3-4">Version Negotiation and Retry packets cannot be acknowledged because they do not
contain a packet number.  Rather than relying on ACK frames, these packets are
implicitly acknowledged by the next Initial packet sent by the client.<a href="#section-19.3-4" class="pilcrow">¶</a></p>
<p id="section-19.3-5">An ACK frame is shown in <a href="#ack-format" class="xref">Figure 22</a>.<a href="#section-19.3-5" class="pilcrow">¶</a></p>
<span id="name-ack-frame-format"></span><div id="ack-format">
<figure id="figure-22">
          <div class="artwork art-text alignLeft" id="section-19.3-6.1">
<pre>
ACK Frame {
  Type (i) = 0x02..0x03,
  Largest Acknowledged (i),
  ACK Delay (i),
  ACK Range Count (i),
  First ACK Range (i),
  ACK Range (..) ...,
  [ECN Counts (..)],
}
</pre>
</div>
<figcaption><a href="#figure-22" class="selfRef">Figure 22</a>:
<a href="#name-ack-frame-format" class="selfRef">ACK Frame Format</a>
          </figcaption></figure>
</div>
<p id="section-19.3-7">ACK frames contain the following fields:<a href="#section-19.3-7" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-19.3-8">
          <dt id="section-19.3-8.1">Largest Acknowledged:</dt>
<dd id="section-19.3-8.2">
  A variable-length integer representing the largest packet number the peer is
acknowledging; this is usually the largest packet number that the peer has
received prior to generating the ACK frame.  Unlike the packet number in the
QUIC long or short header, the value in an ACK frame is not truncated.<a href="#section-19.3-8.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.3-8.3">ACK Delay:</dt>
<dd id="section-19.3-8.4">
  A variable-length integer representing the time delta in microseconds between
when this ACK was sent and when the largest acknowledged packet, as indicated
in the Largest Acknowledged field, was received by this peer.  The value of
the ACK Delay field is scaled by multiplying the encoded value by 2 to the
power of the value of the ack_delay_exponent transport parameter set by the
sender of the ACK frame; see <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>.  Scaling in
this fashion allows for a larger range of values with a shorter encoding at
the cost of lower resolution.  Because the receiver doesn't use the ACK Delay
for Initial and Handshake packets, a sender SHOULD send a value of 0.<a href="#section-19.3-8.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.3-8.5">ACK Range Count:</dt>
<dd id="section-19.3-8.6">
  A variable-length integer specifying the number of Gap and ACK Range fields in
the frame.<a href="#section-19.3-8.6" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.3-8.7">First ACK Range:</dt>
<dd id="section-19.3-8.8">
  A variable-length integer indicating the number of contiguous packets
preceding the Largest Acknowledged that are being acknowledged.  The First ACK
Range is encoded as an ACK Range; see <a href="#ack-ranges" class="xref">Section 19.3.1</a> starting from the
Largest Acknowledged.  That is, the smallest packet acknowledged in the
range is determined by subtracting the First ACK Range value from the Largest
Acknowledged.<a href="#section-19.3-8.8" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.3-8.9">ACK Ranges:</dt>
<dd id="section-19.3-8.10">
  Contains additional ranges of packets which are alternately not
acknowledged (Gap) and acknowledged (ACK Range); see <a href="#ack-ranges" class="xref">Section 19.3.1</a>.<a href="#section-19.3-8.10" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.3-8.11">ECN Counts:</dt>
<dd id="section-19.3-8.12">
  The three ECN Counts; see <a href="#ack-ecn-counts" class="xref">Section 19.3.2</a>.<a href="#section-19.3-8.12" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<div id="ack-ranges">
<section id="section-19.3.1">
          <h4 id="name-ack-ranges">
<a href="#section-19.3.1" class="section-number selfRef">19.3.1. </a><a href="#name-ack-ranges" class="section-name selfRef">ACK Ranges</a>
          </h4>
<p id="section-19.3.1-1">Each ACK Range consists of alternating Gap and ACK Range values in descending
packet number order. ACK Ranges can be repeated. The number of Gap and ACK
Range values is determined by the ACK Range Count field; one of each value is
present for each value in the ACK Range Count field.<a href="#section-19.3.1-1" class="pilcrow">¶</a></p>
<p id="section-19.3.1-2">ACK Ranges are structured as shown in <a href="#ack-range-format" class="xref">Figure 23</a>.<a href="#section-19.3.1-2" class="pilcrow">¶</a></p>
<span id="name-ack-ranges-2"></span><div id="ack-range-format">
<figure id="figure-23">
            <div class="artwork art-text alignLeft" id="section-19.3.1-3.1">
<pre>
ACK Range {
  Gap (i),
  ACK Range Length (i),
}
</pre>
</div>
<figcaption><a href="#figure-23" class="selfRef">Figure 23</a>:
<a href="#name-ack-ranges-2" class="selfRef">ACK Ranges</a>
            </figcaption></figure>
</div>
<p id="section-19.3.1-4">The fields that form each ACK Range are:<a href="#section-19.3.1-4" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-19.3.1-5">
            <dt id="section-19.3.1-5.1">Gap:</dt>
<dd id="section-19.3.1-5.2">
  A variable-length integer indicating the number of contiguous unacknowledged
packets preceding the packet number one lower than the smallest in the
preceding ACK Range.<a href="#section-19.3.1-5.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.3.1-5.3">ACK Range Length:</dt>
<dd id="section-19.3.1-5.4">
  A variable-length integer indicating the number of contiguous acknowledged
packets preceding the largest packet number, as determined by the
preceding Gap.<a href="#section-19.3.1-5.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-19.3.1-6">Gap and ACK Range value use a relative integer encoding for efficiency.  Though
each encoded value is positive, the values are subtracted, so that each ACK
Range describes progressively lower-numbered packets.<a href="#section-19.3.1-6" class="pilcrow">¶</a></p>
<p id="section-19.3.1-7">Each ACK Range acknowledges a contiguous range of packets by indicating the
number of acknowledged packets that precede the largest packet number in that
range.  A value of zero indicates that only the largest packet number is
acknowledged.  Larger ACK Range values indicate a larger range, with
corresponding lower values for the smallest packet number in the range.  Thus,
given a largest packet number for the range, the smallest value is determined by
the formula:<a href="#section-19.3.1-7" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-19.3.1-8">
<pre>
   smallest = largest - ack_range
</pre><a href="#section-19.3.1-8" class="pilcrow">¶</a>
</div>
<p id="section-19.3.1-9">An ACK Range acknowledges all packets between the smallest packet number and the
largest, inclusive.<a href="#section-19.3.1-9" class="pilcrow">¶</a></p>
<p id="section-19.3.1-10">The largest value for an ACK Range is determined by cumulatively subtracting the
size of all preceding ACK Ranges and Gaps.<a href="#section-19.3.1-10" class="pilcrow">¶</a></p>
<p id="section-19.3.1-11">Each Gap indicates a range of packets that are not being acknowledged.  The
number of packets in the gap is one higher than the encoded value of the Gap
field.<a href="#section-19.3.1-11" class="pilcrow">¶</a></p>
<p id="section-19.3.1-12">The value of the Gap field establishes the largest packet number value for the
subsequent ACK Range using the following formula:<a href="#section-19.3.1-12" class="pilcrow">¶</a></p>
<div class="artwork art-text alignLeft" id="section-19.3.1-13">
<pre>
   largest = previous_smallest - gap - 2
</pre><a href="#section-19.3.1-13" class="pilcrow">¶</a>
</div>
<p id="section-19.3.1-14">If any computed packet number is negative, an endpoint MUST generate a
connection error of type FRAME_ENCODING_ERROR.<a href="#section-19.3.1-14" class="pilcrow">¶</a></p>
</section>
</div>
<div id="ack-ecn-counts">
<section id="section-19.3.2">
          <h4 id="name-ecn-counts-2">
<a href="#section-19.3.2" class="section-number selfRef">19.3.2. </a><a href="#name-ecn-counts-2" class="section-name selfRef">ECN Counts</a>
          </h4>
<p id="section-19.3.2-1">The ACK frame uses the least significant bit (that is, type 0x03) to indicate
ECN feedback and report receipt of QUIC packets with associated ECN codepoints
of ECT(0), ECT(1), or CE in the packet's IP header.  ECN Counts are only present
when the ACK frame type is 0x03.<a href="#section-19.3.2-1" class="pilcrow">¶</a></p>
<p id="section-19.3.2-2">ECN Counts are only parsed when the ACK frame type is 0x03.  There are 3 ECN
counts, as shown in <a href="#ecn-count-format" class="xref">Figure 24</a>.<a href="#section-19.3.2-2" class="pilcrow">¶</a></p>
<span id="name-ecn-count-format"></span><div id="ecn-count-format">
<figure id="figure-24">
            <div class="artwork art-text alignLeft" id="section-19.3.2-3.1">
<pre>
ECN Counts {
  ECT0 Count (i),
  ECT1 Count (i),
  ECN-CE Count (i),
}
</pre>
</div>
<figcaption><a href="#figure-24" class="selfRef">Figure 24</a>:
<a href="#name-ecn-count-format" class="selfRef">ECN Count Format</a>
            </figcaption></figure>
</div>
<p id="section-19.3.2-4">The three ECN Counts are:<a href="#section-19.3.2-4" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-19.3.2-5">
            <dt id="section-19.3.2-5.1">ECT0 Count:</dt>
<dd id="section-19.3.2-5.2">
  A variable-length integer representing the total number of packets received
with the ECT(0) codepoint in the packet number space of the ACK frame.<a href="#section-19.3.2-5.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.3.2-5.3">ECT1 Count:</dt>
<dd id="section-19.3.2-5.4">
  A variable-length integer representing the total number of packets received
with the ECT(1) codepoint in the packet number space of the ACK frame.<a href="#section-19.3.2-5.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.3.2-5.5">CE Count:</dt>
<dd id="section-19.3.2-5.6">
  A variable-length integer representing the total number of packets received
with the CE codepoint in the packet number space of the ACK frame.<a href="#section-19.3.2-5.6" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-19.3.2-6">ECN counts are maintained separately for each packet number space.<a href="#section-19.3.2-6" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="frame-reset-stream">
<section id="section-19.4">
        <h3 id="name-reset_stream-frame">
<a href="#section-19.4" class="section-number selfRef">19.4. </a><a href="#name-reset_stream-frame" class="section-name selfRef">RESET_STREAM Frame</a>
        </h3>
<p id="section-19.4-1">An endpoint uses a RESET_STREAM frame (type=0x04) to abruptly terminate the
sending part of a stream.<a href="#section-19.4-1" class="pilcrow">¶</a></p>
<p id="section-19.4-2">After sending a RESET_STREAM, an endpoint ceases transmission and retransmission
of STREAM frames on the identified stream.  A receiver of RESET_STREAM can
discard any data that it already received on that stream.<a href="#section-19.4-2" class="pilcrow">¶</a></p>
<p id="section-19.4-3">An endpoint that receives a RESET_STREAM frame for a send-only stream MUST
terminate the connection with error STREAM_STATE_ERROR.<a href="#section-19.4-3" class="pilcrow">¶</a></p>
<p id="section-19.4-4">The RESET_STREAM frame is shown in <a href="#fig-reset-stream" class="xref">Figure 25</a>.<a href="#section-19.4-4" class="pilcrow">¶</a></p>
<span id="name-reset_stream-frame-format"></span><div id="fig-reset-stream">
<figure id="figure-25">
          <div class="artwork art-text alignLeft" id="section-19.4-5.1">
<pre>
RESET_STREAM Frame {
  Type (i) = 0x04,
  Stream ID (i),
  Application Protocol Error Code (i),
  Final Size (i),
}
</pre>
</div>
<figcaption><a href="#figure-25" class="selfRef">Figure 25</a>:
<a href="#name-reset_stream-frame-format" class="selfRef">RESET_STREAM Frame Format</a>
          </figcaption></figure>
</div>
<p id="section-19.4-6">RESET_STREAM frames contain the following fields:<a href="#section-19.4-6" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-19.4-7">
          <dt id="section-19.4-7.1">Stream ID:</dt>
<dd id="section-19.4-7.2">
  A variable-length integer encoding of the Stream ID of the stream being
terminated.<a href="#section-19.4-7.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.4-7.3">Application Protocol Error Code:</dt>
<dd id="section-19.4-7.4">
  A variable-length integer containing the application protocol error
code (see <a href="#app-error-codes" class="xref">Section 20.1</a>) which indicates why the stream is being
closed.<a href="#section-19.4-7.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.4-7.5">Final Size:</dt>
<dd id="section-19.4-7.6">
  A variable-length integer indicating the final size of the stream by the
RESET_STREAM sender, in unit of bytes.<a href="#section-19.4-7.6" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
</section>
</div>
<div id="frame-stop-sending">
<section id="section-19.5">
        <h3 id="name-stop_sending-frame">
<a href="#section-19.5" class="section-number selfRef">19.5. </a><a href="#name-stop_sending-frame" class="section-name selfRef">STOP_SENDING Frame</a>
        </h3>
<p id="section-19.5-1">An endpoint uses a STOP_SENDING frame (type=0x05) to communicate that incoming
data is being discarded on receipt at application request.  STOP_SENDING
requests that a peer cease transmission on a stream.<a href="#section-19.5-1" class="pilcrow">¶</a></p>
<p id="section-19.5-2">A STOP_SENDING frame can be sent for streams in the Recv or Size Known states;
see <a href="#stream-send-states" class="xref">Section 3.1</a>.  Receiving a STOP_SENDING frame for a
locally-initiated stream that has not yet been created MUST be treated as a
connection error of type STREAM_STATE_ERROR.  An endpoint that receives a
STOP_SENDING frame for a receive-only stream MUST terminate the connection with
error STREAM_STATE_ERROR.<a href="#section-19.5-2" class="pilcrow">¶</a></p>
<p id="section-19.5-3">The STOP_SENDING frame is shown in <a href="#fig-stop-sending" class="xref">Figure 26</a>.<a href="#section-19.5-3" class="pilcrow">¶</a></p>
<span id="name-stop_sending-frame-format"></span><div id="fig-stop-sending">
<figure id="figure-26">
          <div class="artwork art-text alignLeft" id="section-19.5-4.1">
<pre>
STOP_SENDING Frame {
  Type (i) = 0x05,
  Stream ID (i),
  Application Protocol Error Code (i),
}
</pre>
</div>
<figcaption><a href="#figure-26" class="selfRef">Figure 26</a>:
<a href="#name-stop_sending-frame-format" class="selfRef">STOP_SENDING Frame Format</a>
          </figcaption></figure>
</div>
<p id="section-19.5-5">STOP_SENDING frames contain the following fields:<a href="#section-19.5-5" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-19.5-6">
          <dt id="section-19.5-6.1">Stream ID:</dt>
<dd id="section-19.5-6.2">
  A variable-length integer carrying the Stream ID of the stream being ignored.<a href="#section-19.5-6.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.5-6.3">Application Protocol Error Code:</dt>
<dd id="section-19.5-6.4">
  A variable-length integer containing the application-specified reason the
sender is ignoring the stream; see <a href="#app-error-codes" class="xref">Section 20.1</a>.<a href="#section-19.5-6.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
</section>
</div>
<div id="frame-crypto">
<section id="section-19.6">
        <h3 id="name-crypto-frame">
<a href="#section-19.6" class="section-number selfRef">19.6. </a><a href="#name-crypto-frame" class="section-name selfRef">CRYPTO Frame</a>
        </h3>
<p id="section-19.6-1">The CRYPTO frame (type=0x06) is used to transmit cryptographic handshake
messages. It can be sent in all packet types except 0-RTT. The CRYPTO frame
offers the cryptographic protocol an in-order stream of bytes.  CRYPTO frames
are functionally identical to STREAM frames, except that they do not bear a
stream identifier; they are not flow controlled; and they do not carry markers
for optional offset, optional length, and the end of the stream.<a href="#section-19.6-1" class="pilcrow">¶</a></p>
<p id="section-19.6-2">The CRYPTO frame is shown in <a href="#fig-crypto" class="xref">Figure 27</a>.<a href="#section-19.6-2" class="pilcrow">¶</a></p>
<span id="name-crypto-frame-format"></span><div id="fig-crypto">
<figure id="figure-27">
          <div class="artwork art-text alignLeft" id="section-19.6-3.1">
<pre>
CRYPTO Frame {
  Type (i) = 0x06,
  Offset (i),
  Length (i),
  Crypto Data (..),
}
</pre>
</div>
<figcaption><a href="#figure-27" class="selfRef">Figure 27</a>:
<a href="#name-crypto-frame-format" class="selfRef">CRYPTO Frame Format</a>
          </figcaption></figure>
</div>
<p id="section-19.6-4">CRYPTO frames contain the following fields:<a href="#section-19.6-4" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-19.6-5">
          <dt id="section-19.6-5.1">Offset:</dt>
<dd id="section-19.6-5.2">
  A variable-length integer specifying the byte offset in the stream for the
data in this CRYPTO frame.<a href="#section-19.6-5.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.6-5.3">Length:</dt>
<dd id="section-19.6-5.4">
  A variable-length integer specifying the length of the Crypto Data field in
this CRYPTO frame.<a href="#section-19.6-5.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.6-5.5">Crypto Data:</dt>
<dd id="section-19.6-5.6">
  The cryptographic message data.<a href="#section-19.6-5.6" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-19.6-6">There is a separate flow of cryptographic handshake data in each encryption
level, each of which starts at an offset of 0. This implies that each encryption
level is treated as a separate CRYPTO stream of data.<a href="#section-19.6-6" class="pilcrow">¶</a></p>
<p id="section-19.6-7">The largest offset delivered on a stream - the sum of the offset and data
length - cannot exceed 2^62-1.  Receipt of a frame that exceeds this limit MUST
be treated as a connection error of type FRAME_ENCODING_ERROR or
CRYPTO_BUFFER_EXCEEDED.<a href="#section-19.6-7" class="pilcrow">¶</a></p>
<p id="section-19.6-8">Unlike STREAM frames, which include a Stream ID indicating to which stream the
data belongs, the CRYPTO frame carries data for a single stream per encryption
level. The stream does not have an explicit end, so CRYPTO frames do not have a
FIN bit.<a href="#section-19.6-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="frame-new-token">
<section id="section-19.7">
        <h3 id="name-new_token-frame">
<a href="#section-19.7" class="section-number selfRef">19.7. </a><a href="#name-new_token-frame" class="section-name selfRef">NEW_TOKEN Frame</a>
        </h3>
<p id="section-19.7-1">A server sends a NEW_TOKEN frame (type=0x07) to provide the client with a token
to send in the header of an Initial packet for a future connection.<a href="#section-19.7-1" class="pilcrow">¶</a></p>
<p id="section-19.7-2">The NEW_TOKEN frame is shown in <a href="#fig-new-token" class="xref">Figure 28</a>.<a href="#section-19.7-2" class="pilcrow">¶</a></p>
<span id="name-new_token-frame-format"></span><div id="fig-new-token">
<figure id="figure-28">
          <div class="artwork art-text alignLeft" id="section-19.7-3.1">
<pre>
NEW_TOKEN Frame {
  Type (i) = 0x07,
  Token Length (i),
  Token (..),
}
</pre>
</div>
<figcaption><a href="#figure-28" class="selfRef">Figure 28</a>:
<a href="#name-new_token-frame-format" class="selfRef">NEW_TOKEN Frame Format</a>
          </figcaption></figure>
</div>
<p id="section-19.7-4">NEW_TOKEN frames contain the following fields:<a href="#section-19.7-4" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-19.7-5">
          <dt id="section-19.7-5.1">Token Length:</dt>
<dd id="section-19.7-5.2">
  A variable-length integer specifying the length of the token in bytes.<a href="#section-19.7-5.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.7-5.3">Token:</dt>
<dd id="section-19.7-5.4">
  An opaque blob that the client may use with a future Initial packet. The token
MUST NOT be empty.  An endpoint MUST treat receipt of a NEW_TOKEN frame with
an empty Token field as a connection error of type FRAME_ENCODING_ERROR.<a href="#section-19.7-5.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-19.7-6">An endpoint might receive multiple NEW_TOKEN frames that contain the same token
value if packets containing the frame are incorrectly determined to be lost.
Endpoints are responsible for discarding duplicate values, which might be used
to link connection attempts; see <a href="#validate-future" class="xref">Section 8.1.3</a>.<a href="#section-19.7-6" class="pilcrow">¶</a></p>
<p id="section-19.7-7">Clients MUST NOT send NEW_TOKEN frames.  Servers MUST treat receipt of a
NEW_TOKEN frame as a connection error of type PROTOCOL_VIOLATION.<a href="#section-19.7-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="frame-stream">
<section id="section-19.8">
        <h3 id="name-stream-frames">
<a href="#section-19.8" class="section-number selfRef">19.8. </a><a href="#name-stream-frames" class="section-name selfRef">STREAM Frames</a>
        </h3>
<p id="section-19.8-1">STREAM frames implicitly create a stream and carry stream data.  The STREAM
frame takes the form 0b00001XXX (or the set of values from 0x08 to 0x0f).  The
value of the three low-order bits of the frame type determines the fields that
are present in the frame.<a href="#section-19.8-1" class="pilcrow">¶</a></p>
<ul>
<li id="section-19.8-2.1">The OFF bit (0x04) in the frame type is set to indicate that there is an
Offset field present.  When set to 1, the Offset field is present.  When set
to 0, the Offset field is absent and the Stream Data starts at an offset of 0
(that is, the frame contains the first bytes of the stream, or the end of a
stream that includes no data).<a href="#section-19.8-2.1" class="pilcrow">¶</a>
</li>
<li id="section-19.8-2.2">The LEN bit (0x02) in the frame type is set to indicate that there is a Length
field present.  If this bit is set to 0, the Length field is absent and the
Stream Data field extends to the end of the packet.  If this bit is set to 1,
the Length field is present.<a href="#section-19.8-2.2" class="pilcrow">¶</a>
</li>
<li id="section-19.8-2.3">The FIN bit (0x01) of the frame type is set only on frames that contain the
final size of the stream.  Setting this bit indicates that the frame
marks the end of the stream.<a href="#section-19.8-2.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-19.8-3">An endpoint MUST terminate the connection with error STREAM_STATE_ERROR if it
receives a STREAM frame for a locally-initiated stream that has not yet been
created, or for a send-only stream.<a href="#section-19.8-3" class="pilcrow">¶</a></p>
<p id="section-19.8-4">The STREAM frames are shown in <a href="#fig-stream" class="xref">Figure 29</a>.<a href="#section-19.8-4" class="pilcrow">¶</a></p>
<span id="name-stream-frame-format"></span><div id="fig-stream">
<figure id="figure-29">
          <div class="artwork art-text alignLeft" id="section-19.8-5.1">
<pre>
STREAM Frame {
  Type (i) = 0x08..0x0f,
  Stream ID (i),
  [Offset (i)],
  [Length (i)],
  Stream Data (..),
}
</pre>
</div>
<figcaption><a href="#figure-29" class="selfRef">Figure 29</a>:
<a href="#name-stream-frame-format" class="selfRef">STREAM Frame Format</a>
          </figcaption></figure>
</div>
<p id="section-19.8-6">STREAM frames contain the following fields:<a href="#section-19.8-6" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-19.8-7">
          <dt id="section-19.8-7.1">Stream ID:</dt>
<dd id="section-19.8-7.2">
  A variable-length integer indicating the stream ID of the stream; see
<a href="#stream-id" class="xref">Section 2.1</a>.<a href="#section-19.8-7.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.8-7.3">Offset:</dt>
<dd id="section-19.8-7.4">
  A variable-length integer specifying the byte offset in the stream for the
data in this STREAM frame.  This field is present when the OFF bit is set to
1.  When the Offset field is absent, the offset is 0.<a href="#section-19.8-7.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.8-7.5">Length:</dt>
<dd id="section-19.8-7.6">
  A variable-length integer specifying the length of the Stream Data field in
this STREAM frame.  This field is present when the LEN bit is set to 1.  When
the LEN bit is set to 0, the Stream Data field consumes all the remaining
bytes in the packet.<a href="#section-19.8-7.6" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.8-7.7">Stream Data:</dt>
<dd id="section-19.8-7.8">
  The bytes from the designated stream to be delivered.<a href="#section-19.8-7.8" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-19.8-8">When a Stream Data field has a length of 0, the offset in the STREAM frame is
the offset of the next byte that would be sent.<a href="#section-19.8-8" class="pilcrow">¶</a></p>
<p id="section-19.8-9">The first byte in the stream has an offset of 0.  The largest offset delivered
on a stream - the sum of the offset and data length - cannot exceed 2^62-1, as
it is not possible to provide flow control credit for that data.  Receipt of a
frame that exceeds this limit MUST be treated as a connection error of type
FRAME_ENCODING_ERROR or FLOW_CONTROL_ERROR.<a href="#section-19.8-9" class="pilcrow">¶</a></p>
</section>
</div>
<div id="frame-max-data">
<section id="section-19.9">
        <h3 id="name-max_data-frame">
<a href="#section-19.9" class="section-number selfRef">19.9. </a><a href="#name-max_data-frame" class="section-name selfRef">MAX_DATA Frame</a>
        </h3>
<p id="section-19.9-1">The MAX_DATA frame (type=0x10) is used in flow control to inform the peer of
the maximum amount of data that can be sent on the connection as a whole.<a href="#section-19.9-1" class="pilcrow">¶</a></p>
<p id="section-19.9-2">The MAX_DATA frame is shown in <a href="#fig-max-data" class="xref">Figure 30</a>.<a href="#section-19.9-2" class="pilcrow">¶</a></p>
<span id="name-max_data-frame-format"></span><div id="fig-max-data">
<figure id="figure-30">
          <div class="artwork art-text alignLeft" id="section-19.9-3.1">
<pre>
MAX_DATA Frame {
  Type (i) = 0x10,
  Maximum Data (i),
}
</pre>
</div>
<figcaption><a href="#figure-30" class="selfRef">Figure 30</a>:
<a href="#name-max_data-frame-format" class="selfRef">MAX_DATA Frame Format</a>
          </figcaption></figure>
</div>
<p id="section-19.9-4">MAX_DATA frames contain the following fields:<a href="#section-19.9-4" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-19.9-5">
          <dt id="section-19.9-5.1">Maximum Data:</dt>
<dd id="section-19.9-5.2">
  A variable-length integer indicating the maximum amount of data that can be
sent on the entire connection, in units of bytes.<a href="#section-19.9-5.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-19.9-6">All data sent in STREAM frames counts toward this limit.  The sum of the largest
received offsets on all streams - including streams in terminal states - MUST
NOT exceed the value advertised by a receiver.  An endpoint MUST terminate a
connection with a FLOW_CONTROL_ERROR error if it receives more data than the
maximum data value that it has sent, unless this is a result of a change in
the initial limits; see <a href="#zerortt-parameters" class="xref">Section 7.4.1</a>.<a href="#section-19.9-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="frame-max-stream-data">
<section id="section-19.10">
        <h3 id="name-max_stream_data-frame">
<a href="#section-19.10" class="section-number selfRef">19.10. </a><a href="#name-max_stream_data-frame" class="section-name selfRef">MAX_STREAM_DATA Frame</a>
        </h3>
<p id="section-19.10-1">The MAX_STREAM_DATA frame (type=0x11) is used in flow control to inform a peer
of the maximum amount of data that can be sent on a stream.<a href="#section-19.10-1" class="pilcrow">¶</a></p>
<p id="section-19.10-2">A MAX_STREAM_DATA frame can be sent for streams in the Recv state; see
<a href="#stream-send-states" class="xref">Section 3.1</a>. Receiving a MAX_STREAM_DATA frame for a
locally-initiated stream that has not yet been created MUST be treated as a
connection error of type STREAM_STATE_ERROR.  An endpoint that receives a
MAX_STREAM_DATA frame for a receive-only stream MUST terminate the connection
with error STREAM_STATE_ERROR.<a href="#section-19.10-2" class="pilcrow">¶</a></p>
<p id="section-19.10-3">The MAX_STREAM_DATA frame is shown in <a href="#fig-max-stream-data" class="xref">Figure 31</a>.<a href="#section-19.10-3" class="pilcrow">¶</a></p>
<span id="name-max_stream_data-frame-forma"></span><div id="fig-max-stream-data">
<figure id="figure-31">
          <div class="artwork art-text alignLeft" id="section-19.10-4.1">
<pre>
MAX_STREAM_DATA Frame {
  Type (i) = 0x11,
  Stream ID (i),
  Maximum Stream Data (i),
}
</pre>
</div>
<figcaption><a href="#figure-31" class="selfRef">Figure 31</a>:
<a href="#name-max_stream_data-frame-forma" class="selfRef">MAX_STREAM_DATA Frame Format</a>
          </figcaption></figure>
</div>
<p id="section-19.10-5">MAX_STREAM_DATA frames contain the following fields:<a href="#section-19.10-5" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-19.10-6">
          <dt id="section-19.10-6.1">Stream ID:</dt>
<dd id="section-19.10-6.2">
  The stream ID of the stream that is affected encoded as a variable-length
integer.<a href="#section-19.10-6.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.10-6.3">Maximum Stream Data:</dt>
<dd id="section-19.10-6.4">
  A variable-length integer indicating the maximum amount of data that can be
sent on the identified stream, in units of bytes.<a href="#section-19.10-6.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-19.10-7">When counting data toward this limit, an endpoint accounts for the largest
received offset of data that is sent or received on the stream.  Loss or
reordering can mean that the largest received offset on a stream can be greater
than the total size of data received on that stream.  Receiving STREAM frames
might not increase the largest received offset.<a href="#section-19.10-7" class="pilcrow">¶</a></p>
<p id="section-19.10-8">The data sent on a stream MUST NOT exceed the largest maximum stream data value
advertised by the receiver.  An endpoint MUST terminate a connection with a
FLOW_CONTROL_ERROR error if it receives more data than the largest maximum
stream data that it has sent for the affected stream, unless this is a result of
a change in the initial limits; see <a href="#zerortt-parameters" class="xref">Section 7.4.1</a>.<a href="#section-19.10-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="frame-max-streams">
<section id="section-19.11">
        <h3 id="name-max_streams-frames">
<a href="#section-19.11" class="section-number selfRef">19.11. </a><a href="#name-max_streams-frames" class="section-name selfRef">MAX_STREAMS Frames</a>
        </h3>
<p id="section-19.11-1">The MAX_STREAMS frames (type=0x12 and 0x13) inform the peer of the cumulative
number of streams of a given type it is permitted to open.  A MAX_STREAMS frame
with a type of 0x12 applies to bidirectional streams, and a MAX_STREAMS frame
with a type of 0x13 applies to unidirectional streams.<a href="#section-19.11-1" class="pilcrow">¶</a></p>
<p id="section-19.11-2">The MAX_STREAMS frames are shown in <a href="#fig-max-streams" class="xref">Figure 32</a>;<a href="#section-19.11-2" class="pilcrow">¶</a></p>
<span id="name-max_streams-frame-format"></span><div id="fig-max-streams">
<figure id="figure-32">
          <div class="artwork art-text alignLeft" id="section-19.11-3.1">
<pre>
MAX_STREAMS Frame {
  Type (i) = 0x12..0x13,
  Maximum Streams (i),
}
</pre>
</div>
<figcaption><a href="#figure-32" class="selfRef">Figure 32</a>:
<a href="#name-max_streams-frame-format" class="selfRef">MAX_STREAMS Frame Format</a>
          </figcaption></figure>
</div>
<p id="section-19.11-4">MAX_STREAMS frames contain the following fields:<a href="#section-19.11-4" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-19.11-5">
          <dt id="section-19.11-5.1">Maximum Streams:</dt>
<dd id="section-19.11-5.2">
  A count of the cumulative number of streams of the corresponding type that
can be opened over the lifetime of the connection.  This value cannot exceed
2^60, as it is not possible to encode stream IDs larger than 2^62-1.
Receipt of a frame that permits opening of a stream larger than this limit
MUST be treated as a FRAME_ENCODING_ERROR.<a href="#section-19.11-5.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-19.11-6">Loss or reordering can cause a MAX_STREAMS frame to be received which states a
lower stream limit than an endpoint has previously received.  MAX_STREAMS frames
which do not increase the stream limit MUST be ignored.<a href="#section-19.11-6" class="pilcrow">¶</a></p>
<p id="section-19.11-7">An endpoint MUST NOT open more streams than permitted by the current stream
limit set by its peer.  For instance, a server that receives a unidirectional
stream limit of 3 is permitted to open stream 3, 7, and 11, but not stream 15.
An endpoint MUST terminate a connection with a STREAM_LIMIT_ERROR error if a
peer opens more streams than was permitted.<a href="#section-19.11-7" class="pilcrow">¶</a></p>
<p id="section-19.11-8">Note that these frames (and the corresponding transport parameters) do not
describe the number of streams that can be opened concurrently.  The limit
includes streams that have been closed as well as those that are open.<a href="#section-19.11-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="frame-data-blocked">
<section id="section-19.12">
        <h3 id="name-data_blocked-frame">
<a href="#section-19.12" class="section-number selfRef">19.12. </a><a href="#name-data_blocked-frame" class="section-name selfRef">DATA_BLOCKED Frame</a>
        </h3>
<p id="section-19.12-1">A sender SHOULD send a DATA_BLOCKED frame (type=0x14) when it wishes to send
data, but is unable to due to connection-level flow control; see
<a href="#flow-control" class="xref">Section 4</a>.  DATA_BLOCKED frames can be used as input to tuning of flow
control algorithms; see <a href="#fc-credit" class="xref">Section 4.2</a>.<a href="#section-19.12-1" class="pilcrow">¶</a></p>
<p id="section-19.12-2">The DATA_BLOCKED frame is shown in <a href="#fig-data-blocked" class="xref">Figure 33</a>.<a href="#section-19.12-2" class="pilcrow">¶</a></p>
<span id="name-data_blocked-frame-format"></span><div id="fig-data-blocked">
<figure id="figure-33">
          <div class="artwork art-text alignLeft" id="section-19.12-3.1">
<pre>
DATA_BLOCKED Frame {
  Type (i) = 0x14,
  Maximum Data (i),
}
</pre>
</div>
<figcaption><a href="#figure-33" class="selfRef">Figure 33</a>:
<a href="#name-data_blocked-frame-format" class="selfRef">DATA_BLOCKED Frame Format</a>
          </figcaption></figure>
</div>
<p id="section-19.12-4">DATA_BLOCKED frames contain the following fields:<a href="#section-19.12-4" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-19.12-5">
          <dt id="section-19.12-5.1">Maximum Data:</dt>
<dd id="section-19.12-5.2">
  A variable-length integer indicating the connection-level limit at which
blocking occurred.<a href="#section-19.12-5.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
</section>
</div>
<div id="frame-stream-data-blocked">
<section id="section-19.13">
        <h3 id="name-stream_data_blocked-frame">
<a href="#section-19.13" class="section-number selfRef">19.13. </a><a href="#name-stream_data_blocked-frame" class="section-name selfRef">STREAM_DATA_BLOCKED Frame</a>
        </h3>
<p id="section-19.13-1">A sender SHOULD send a STREAM_DATA_BLOCKED frame (type=0x15) when it wishes to
send data, but is unable to due to stream-level flow control.  This frame is
analogous to DATA_BLOCKED (<a href="#frame-data-blocked" class="xref">Section 19.12</a>).<a href="#section-19.13-1" class="pilcrow">¶</a></p>
<p id="section-19.13-2">An endpoint that receives a STREAM_DATA_BLOCKED frame for a send-only stream
MUST terminate the connection with error STREAM_STATE_ERROR.<a href="#section-19.13-2" class="pilcrow">¶</a></p>
<p id="section-19.13-3">The STREAM_DATA_BLOCKED frame is shown in <a href="#fig-stream-data-blocked" class="xref">Figure 34</a>.<a href="#section-19.13-3" class="pilcrow">¶</a></p>
<span id="name-stream_data_blocked-frame-f"></span><div id="fig-stream-data-blocked">
<figure id="figure-34">
          <div class="artwork art-text alignLeft" id="section-19.13-4.1">
<pre>
STREAM_DATA_BLOCKED Frame {
  Type (i) = 0x15,
  Stream ID (i),
  Maximum Stream Data (i),
}
</pre>
</div>
<figcaption><a href="#figure-34" class="selfRef">Figure 34</a>:
<a href="#name-stream_data_blocked-frame-f" class="selfRef">STREAM_DATA_BLOCKED Frame Format</a>
          </figcaption></figure>
</div>
<p id="section-19.13-5">STREAM_DATA_BLOCKED frames contain the following fields:<a href="#section-19.13-5" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-19.13-6">
          <dt id="section-19.13-6.1">Stream ID:</dt>
<dd id="section-19.13-6.2">
  A variable-length integer indicating the stream which is flow control blocked.<a href="#section-19.13-6.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.13-6.3">Maximum Stream Data:</dt>
<dd id="section-19.13-6.4">
  A variable-length integer indicating the offset of the stream at which the
blocking occurred.<a href="#section-19.13-6.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
</section>
</div>
<div id="frame-streams-blocked">
<section id="section-19.14">
        <h3 id="name-streams_blocked-frames">
<a href="#section-19.14" class="section-number selfRef">19.14. </a><a href="#name-streams_blocked-frames" class="section-name selfRef">STREAMS_BLOCKED Frames</a>
        </h3>
<p id="section-19.14-1">A sender SHOULD send a STREAMS_BLOCKED frame (type=0x16 or 0x17) when it wishes
to open a stream, but is unable to due to the maximum stream limit set by its
peer; see <a href="#frame-max-streams" class="xref">Section 19.11</a>.  A STREAMS_BLOCKED frame of type 0x16 is used
to indicate reaching the bidirectional stream limit, and a STREAMS_BLOCKED frame
of type 0x17 indicates reaching the unidirectional stream limit.<a href="#section-19.14-1" class="pilcrow">¶</a></p>
<p id="section-19.14-2">A STREAMS_BLOCKED frame does not open the stream, but informs the peer that a
new stream was needed and the stream limit prevented the creation of the stream.<a href="#section-19.14-2" class="pilcrow">¶</a></p>
<p id="section-19.14-3">The STREAMS_BLOCKED frames are shown in <a href="#fig-streams-blocked" class="xref">Figure 35</a>.<a href="#section-19.14-3" class="pilcrow">¶</a></p>
<span id="name-streams_blocked-frame-forma"></span><div id="fig-streams-blocked">
<figure id="figure-35">
          <div class="artwork art-text alignLeft" id="section-19.14-4.1">
<pre>
STREAMS_BLOCKED Frame {
  Type (i) = 0x16..0x17,
  Maximum Streams (i),
}
</pre>
</div>
<figcaption><a href="#figure-35" class="selfRef">Figure 35</a>:
<a href="#name-streams_blocked-frame-forma" class="selfRef">STREAMS_BLOCKED Frame Format</a>
          </figcaption></figure>
</div>
<p id="section-19.14-5">STREAMS_BLOCKED frames contain the following fields:<a href="#section-19.14-5" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-19.14-6">
          <dt id="section-19.14-6.1">Maximum Streams:</dt>
<dd id="section-19.14-6.2">
  A variable-length integer indicating the maximum number of streams allowed
at the time the frame was sent.  This value cannot exceed 2^60, as it is
not possible to encode stream IDs larger than 2^62-1.  Receipt of a frame
that encodes a larger stream ID MUST be treated as a STREAM_LIMIT_ERROR or a
FRAME_ENCODING_ERROR.<a href="#section-19.14-6.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
</section>
</div>
<div id="frame-new-connection-id">
<section id="section-19.15">
        <h3 id="name-new_connection_id-frame">
<a href="#section-19.15" class="section-number selfRef">19.15. </a><a href="#name-new_connection_id-frame" class="section-name selfRef">NEW_CONNECTION_ID Frame</a>
        </h3>
<p id="section-19.15-1">An endpoint sends a NEW_CONNECTION_ID frame (type=0x18) to provide its peer with
alternative connection IDs that can be used to break linkability when migrating
connections; see <a href="#migration-linkability" class="xref">Section 9.5</a>.<a href="#section-19.15-1" class="pilcrow">¶</a></p>
<p id="section-19.15-2">The NEW_CONNECTION_ID frame is shown in <a href="#fig-new-connection-id" class="xref">Figure 36</a>.<a href="#section-19.15-2" class="pilcrow">¶</a></p>
<span id="name-new_connection_id-frame-for"></span><div id="fig-new-connection-id">
<figure id="figure-36">
          <div class="artwork art-text alignLeft" id="section-19.15-3.1">
<pre>
NEW_CONNECTION_ID Frame {
  Type (i) = 0x18,
  Sequence Number (i),
  Retire Prior To (i),
  Length (8),
  Connection ID (8..160),
  Stateless Reset Token (128),
}
</pre>
</div>
<figcaption><a href="#figure-36" class="selfRef">Figure 36</a>:
<a href="#name-new_connection_id-frame-for" class="selfRef">NEW_CONNECTION_ID Frame Format</a>
          </figcaption></figure>
</div>
<p id="section-19.15-4">NEW_CONNECTION_ID frames contain the following fields:<a href="#section-19.15-4" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-19.15-5">
          <dt id="section-19.15-5.1">Sequence Number:</dt>
<dd id="section-19.15-5.2">
  The sequence number assigned to the connection ID by the sender.  See
<a href="#issue-cid" class="xref">Section 5.1.1</a>.<a href="#section-19.15-5.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.15-5.3">Retire Prior To:</dt>
<dd id="section-19.15-5.4">
  A variable-length integer indicating which connection IDs should be retired;
see <a href="#retire-cid" class="xref">Section 5.1.2</a>.<a href="#section-19.15-5.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.15-5.5">Length:</dt>
<dd id="section-19.15-5.6">
  An 8-bit unsigned integer containing the length of the connection ID.  Values
less than 1 and greater than 20 are invalid and MUST be treated as a
connection error of type FRAME_ENCODING_ERROR.<a href="#section-19.15-5.6" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.15-5.7">Connection ID:</dt>
<dd id="section-19.15-5.8">
  A connection ID of the specified length.<a href="#section-19.15-5.8" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.15-5.9">Stateless Reset Token:</dt>
<dd id="section-19.15-5.10">
  A 128-bit value that will be used for a stateless reset when the associated
connection ID is used; see <a href="#stateless-reset" class="xref">Section 10.4</a>.<a href="#section-19.15-5.10" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-19.15-6">An endpoint MUST NOT send this frame if it currently requires that its peer send
packets with a zero-length Destination Connection ID.  Changing the length of a
connection ID to or from zero-length makes it difficult to identify when the
value of the connection ID changed.  An endpoint that is sending packets with a
zero-length Destination Connection ID MUST treat receipt of a NEW_CONNECTION_ID
frame as a connection error of type PROTOCOL_VIOLATION.<a href="#section-19.15-6" class="pilcrow">¶</a></p>
<p id="section-19.15-7">Transmission errors, timeouts and retransmissions might cause the same
NEW_CONNECTION_ID frame to be received multiple times.  Receipt of the same
frame multiple times MUST NOT be treated as a connection error.  A receiver can
use the sequence number supplied in the NEW_CONNECTION_ID frame to identify new
connection IDs from old ones.<a href="#section-19.15-7" class="pilcrow">¶</a></p>
<p id="section-19.15-8">If an endpoint receives a NEW_CONNECTION_ID frame that repeats a previously
issued connection ID with a different Stateless Reset Token or a different
sequence number, or if a sequence number is used for different connection
IDs, the endpoint MAY treat that receipt as a connection error of type
PROTOCOL_VIOLATION.<a href="#section-19.15-8" class="pilcrow">¶</a></p>
<p id="section-19.15-9">The Retire Prior To field counts connection IDs established during connection
setup and the preferred_address transport parameter; see <a href="#retire-cid" class="xref">Section 5.1.2</a>. The
Retire Prior To field MUST be less than or equal to the Sequence Number field.
Receiving a value greater than the Sequence Number MUST be treated as a
connection error of type FRAME_ENCODING_ERROR.<a href="#section-19.15-9" class="pilcrow">¶</a></p>
<p id="section-19.15-10">Once a sender indicates a Retire Prior To value, smaller values sent in
subsequent NEW_CONNECTION_ID frames have no effect. A receiver MUST ignore any
Retire Prior To fields that do not increase the largest received Retire Prior To
value.<a href="#section-19.15-10" class="pilcrow">¶</a></p>
<p id="section-19.15-11">An endpoint that receives a NEW_CONNECTION_ID frame with a sequence number
smaller than the Retire Prior To field of a previously received
NEW_CONNECTION_ID frame MUST send a corresponding RETIRE_CONNECTION_ID frame
that retires the newly received connection ID, unless it has already done so
for that sequence number.<a href="#section-19.15-11" class="pilcrow">¶</a></p>
</section>
</div>
<div id="frame-retire-connection-id">
<section id="section-19.16">
        <h3 id="name-retire_connection_id-frame">
<a href="#section-19.16" class="section-number selfRef">19.16. </a><a href="#name-retire_connection_id-frame" class="section-name selfRef">RETIRE_CONNECTION_ID Frame</a>
        </h3>
<p id="section-19.16-1">An endpoint sends a RETIRE_CONNECTION_ID frame (type=0x19) to indicate that it
will no longer use a connection ID that was issued by its peer. This may include
the connection ID provided during the handshake.  Sending a RETIRE_CONNECTION_ID
frame also serves as a request to the peer to send additional connection IDs for
future use; see <a href="#connection-id" class="xref">Section 5.1</a>.  New connection IDs can be delivered to a
peer using the NEW_CONNECTION_ID frame (<a href="#frame-new-connection-id" class="xref">Section 19.15</a>).<a href="#section-19.16-1" class="pilcrow">¶</a></p>
<p id="section-19.16-2">Retiring a connection ID invalidates the stateless reset token associated with
that connection ID.<a href="#section-19.16-2" class="pilcrow">¶</a></p>
<p id="section-19.16-3">The RETIRE_CONNECTION_ID frame is shown in <a href="#fig-retire-connection-id" class="xref">Figure 37</a>.<a href="#section-19.16-3" class="pilcrow">¶</a></p>
<span id="name-retire_connection_id-frame-"></span><div id="fig-retire-connection-id">
<figure id="figure-37">
          <div class="artwork art-text alignLeft" id="section-19.16-4.1">
<pre>
RETIRE_CONNECTION_ID Frame {
  Type (i) = 0x19,
  Sequence Number (i),
}
</pre>
</div>
<figcaption><a href="#figure-37" class="selfRef">Figure 37</a>:
<a href="#name-retire_connection_id-frame-" class="selfRef">RETIRE_CONNECTION_ID Frame Format</a>
          </figcaption></figure>
</div>
<p id="section-19.16-5">RETIRE_CONNECTION_ID frames contain the following fields:<a href="#section-19.16-5" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-19.16-6">
          <dt id="section-19.16-6.1">Sequence Number:</dt>
<dd id="section-19.16-6.2">
  The sequence number of the connection ID being retired; see <a href="#retire-cid" class="xref">Section 5.1.2</a>.<a href="#section-19.16-6.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-19.16-7">Receipt of a RETIRE_CONNECTION_ID frame containing a sequence number greater
than any previously sent to the peer MUST be treated as a connection error of
type PROTOCOL_VIOLATION.<a href="#section-19.16-7" class="pilcrow">¶</a></p>
<p id="section-19.16-8">The sequence number specified in a RETIRE_CONNECTION_ID frame MUST NOT refer
to the Destination Connection ID field of the packet in which the frame is
contained.  The peer MAY treat this as a connection error of type
FRAME_ENCODING_ERROR.<a href="#section-19.16-8" class="pilcrow">¶</a></p>
<p id="section-19.16-9">An endpoint cannot send this frame if it was provided with a zero-length
connection ID by its peer.  An endpoint that provides a zero-length connection
ID MUST treat receipt of a RETIRE_CONNECTION_ID frame as a connection error of
type PROTOCOL_VIOLATION.<a href="#section-19.16-9" class="pilcrow">¶</a></p>
</section>
</div>
<div id="frame-path-challenge">
<section id="section-19.17">
        <h3 id="name-path_challenge-frame">
<a href="#section-19.17" class="section-number selfRef">19.17. </a><a href="#name-path_challenge-frame" class="section-name selfRef">PATH_CHALLENGE Frame</a>
        </h3>
<p id="section-19.17-1">Endpoints can use PATH_CHALLENGE frames (type=0x1a) to check reachability to the
peer and for path validation during connection migration.<a href="#section-19.17-1" class="pilcrow">¶</a></p>
<p id="section-19.17-2">The PATH_CHALLENGE frame is shown in <a href="#fig-path-challenge" class="xref">Figure 38</a>.<a href="#section-19.17-2" class="pilcrow">¶</a></p>
<span id="name-path_challenge-frame-format"></span><div id="fig-path-challenge">
<figure id="figure-38">
          <div class="artwork art-text alignLeft" id="section-19.17-3.1">
<pre>
PATH_CHALLENGE Frame {
  Type (i) = 0x1a,
  Data (64),
}
</pre>
</div>
<figcaption><a href="#figure-38" class="selfRef">Figure 38</a>:
<a href="#name-path_challenge-frame-format" class="selfRef">PATH_CHALLENGE Frame Format</a>
          </figcaption></figure>
</div>
<p id="section-19.17-4">PATH_CHALLENGE frames contain the following fields:<a href="#section-19.17-4" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-19.17-5">
          <dt id="section-19.17-5.1">Data:</dt>
<dd id="section-19.17-5.2">
  This 8-byte field contains arbitrary data.<a href="#section-19.17-5.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-19.17-6">A PATH_CHALLENGE frame containing 8 bytes that are hard to guess is sufficient
to ensure that it is easier to receive the packet than it is to guess the value
correctly.<a href="#section-19.17-6" class="pilcrow">¶</a></p>
<p id="section-19.17-7">The recipient of this frame MUST generate a PATH_RESPONSE frame
(<a href="#frame-path-response" class="xref">Section 19.18</a>) containing the same Data.<a href="#section-19.17-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="frame-path-response">
<section id="section-19.18">
        <h3 id="name-path_response-frame">
<a href="#section-19.18" class="section-number selfRef">19.18. </a><a href="#name-path_response-frame" class="section-name selfRef">PATH_RESPONSE Frame</a>
        </h3>
<p id="section-19.18-1">The PATH_RESPONSE frame (type=0x1b) is sent in response to a PATH_CHALLENGE
frame.  Its format, shown in <a href="#fig-path-response" class="xref">Figure 39</a> is identical to the
PATH_CHALLENGE frame (<a href="#frame-path-challenge" class="xref">Section 19.17</a>).<a href="#section-19.18-1" class="pilcrow">¶</a></p>
<span id="name-path_response-frame-format"></span><div id="fig-path-response">
<figure id="figure-39">
          <div class="artwork art-text alignLeft" id="section-19.18-2.1">
<pre>
PATH_RESPONSE Frame {
  Type (i) = 0x1b,
  Data (64),
}
</pre>
</div>
<figcaption><a href="#figure-39" class="selfRef">Figure 39</a>:
<a href="#name-path_response-frame-format" class="selfRef">PATH_RESPONSE Frame Format</a>
          </figcaption></figure>
</div>
<p id="section-19.18-3">If the content of a PATH_RESPONSE frame does not match the content of a
PATH_CHALLENGE frame previously sent by the endpoint, the endpoint MAY generate
a connection error of type PROTOCOL_VIOLATION.<a href="#section-19.18-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="frame-connection-close">
<section id="section-19.19">
        <h3 id="name-connection_close-frames">
<a href="#section-19.19" class="section-number selfRef">19.19. </a><a href="#name-connection_close-frames" class="section-name selfRef">CONNECTION_CLOSE Frames</a>
        </h3>
<p id="section-19.19-1">An endpoint sends a CONNECTION_CLOSE frame (type=0x1c or 0x1d) to notify its
peer that the connection is being closed.  The CONNECTION_CLOSE with a frame
type of 0x1c is used to signal errors at only the QUIC layer, or the absence of
errors (with the NO_ERROR code).  The CONNECTION_CLOSE frame with a type of 0x1d
is used to signal an error with the application that uses QUIC.<a href="#section-19.19-1" class="pilcrow">¶</a></p>
<p id="section-19.19-2">If there are open streams that haven't been explicitly closed, they are
implicitly closed when the connection is closed.<a href="#section-19.19-2" class="pilcrow">¶</a></p>
<p id="section-19.19-3">The CONNECTION_CLOSE frames are shown in <a href="#fig-connection-close" class="xref">Figure 40</a>.<a href="#section-19.19-3" class="pilcrow">¶</a></p>
<span id="name-connection_close-frame-form"></span><div id="fig-connection-close">
<figure id="figure-40">
          <div class="artwork art-text alignLeft" id="section-19.19-4.1">
<pre>
CONNECTION_CLOSE Frame {
  Type (i) = 0x1c..0x1d,
  Error Code (i),
  [Frame Type (i)],
  Reason Phrase Length (i),
  Reason Phrase (..),
}
</pre>
</div>
<figcaption><a href="#figure-40" class="selfRef">Figure 40</a>:
<a href="#name-connection_close-frame-form" class="selfRef">CONNECTION_CLOSE Frame Format</a>
          </figcaption></figure>
</div>
<p id="section-19.19-5">CONNECTION_CLOSE frames contain the following fields:<a href="#section-19.19-5" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-19.19-6">
          <dt id="section-19.19-6.1">Error Code:</dt>
<dd id="section-19.19-6.2">
  A variable length integer error code which indicates the reason for
closing this connection.  A CONNECTION_CLOSE frame of type 0x1c uses codes
from the space defined in <a href="#error-codes" class="xref">Section 20</a>.  A CONNECTION_CLOSE frame of
type 0x1d uses codes from the application protocol error code space;
see <a href="#app-error-codes" class="xref">Section 20.1</a><a href="#section-19.19-6.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.19-6.3">Frame Type:</dt>
<dd id="section-19.19-6.4">
  A variable-length integer encoding the type of frame that triggered the error.
A value of 0 (equivalent to the mention of the PADDING frame) is used when the
frame type is unknown.  The application-specific variant of CONNECTION_CLOSE
(type 0x1d) does not include this field.<a href="#section-19.19-6.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.19-6.5">Reason Phrase Length:</dt>
<dd id="section-19.19-6.6">
  A variable-length integer specifying the length of the reason phrase in bytes.
Because a CONNECTION_CLOSE frame cannot be split between packets, any limits
on packet size will also limit the space available for a reason phrase.<a href="#section-19.19-6.6" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-19.19-6.7">Reason Phrase:</dt>
<dd id="section-19.19-6.8">
  A human-readable explanation for why the connection was closed.  This can be
zero length if the sender chooses to not give details beyond the Error Code.
This SHOULD be a UTF-8 encoded string <span>[<a href="#RFC3629" class="xref">RFC3629</a>]</span>.<a href="#section-19.19-6.8" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-19.19-7">The application-specific variant of CONNECTION_CLOSE (type 0x1d) can only be
sent using 0-RTT or 1-RTT packets (<span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>, Section 4).  When an
application wishes to abandon a connection during the handshake, an endpoint
can send a CONNECTION_CLOSE frame (type 0x1c) with an error code of
APPLICATION_ERROR in an Initial or a Handshake packet.<a href="#section-19.19-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="frame-handshake-done">
<section id="section-19.20">
        <h3 id="name-handshake_done-frame">
<a href="#section-19.20" class="section-number selfRef">19.20. </a><a href="#name-handshake_done-frame" class="section-name selfRef">HANDSHAKE_DONE frame</a>
        </h3>
<p id="section-19.20-1">The server uses the HANDSHAKE_DONE frame (type=0x1e) to signal confirmation of
the handshake to the client.  The HANDSHAKE_DONE frame contains no additional
fields.<a href="#section-19.20-1" class="pilcrow">¶</a></p>
<p id="section-19.20-2">This frame can only be sent by the server. Servers MUST NOT send a
HANDSHAKE_DONE frame before completing the handshake.  A server MUST treat
receipt of a HANDSHAKE_DONE frame as a connection error of type
PROTOCOL_VIOLATION.<a href="#section-19.20-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="extension-frames">
<section id="section-19.21">
        <h3 id="name-extension-frames">
<a href="#section-19.21" class="section-number selfRef">19.21. </a><a href="#name-extension-frames" class="section-name selfRef">Extension Frames</a>
        </h3>
<p id="section-19.21-1">QUIC frames do not use a self-describing encoding.  An endpoint therefore needs
to understand the syntax of all frames before it can successfully process a
packet.  This allows for efficient encoding of frames, but it means that an
endpoint cannot send a frame of a type that is unknown to its peer.<a href="#section-19.21-1" class="pilcrow">¶</a></p>
<p id="section-19.21-2">An extension to QUIC that wishes to use a new type of frame MUST first ensure
that a peer is able to understand the frame.  An endpoint can use a transport
parameter to signal its willingness to receive one or more extension frame types
with the one transport parameter.<a href="#section-19.21-2" class="pilcrow">¶</a></p>
<p id="section-19.21-3">Extensions that modify or replace core protocol functionality (including frame
types) will be difficult to combine with other extensions which modify or
replace the same functionality unless the behavior of the combination is
explicitly defined.  Such extensions SHOULD define their interaction with
previously-defined extensions modifying the same protocol components.<a href="#section-19.21-3" class="pilcrow">¶</a></p>
<p id="section-19.21-4">Extension frames MUST be congestion controlled and MUST cause an ACK frame to
be sent.  The exception is extension frames that replace or supplement the ACK
frame.  Extension frames are not included in flow control unless specified
in the extension.<a href="#section-19.21-4" class="pilcrow">¶</a></p>
<p id="section-19.21-5">An IANA registry is used to manage the assignment of frame types; see
<a href="#iana-frames" class="xref">Section 22.3</a>.<a href="#section-19.21-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="error-codes">
<section id="section-20">
      <h2 id="name-transport-error-codes">
<a href="#section-20" class="section-number selfRef">20. </a><a href="#name-transport-error-codes" class="section-name selfRef">Transport Error Codes</a>
      </h2>
<p id="section-20-1">QUIC error codes are 62-bit unsigned integers.<a href="#section-20-1" class="pilcrow">¶</a></p>
<p id="section-20-2">This section lists the defined QUIC transport error codes that may be used in a
CONNECTION_CLOSE frame.  These errors apply to the entire connection.<a href="#section-20-2" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-20-3">
        <dt id="section-20-3.1">NO_ERROR (0x0):</dt>
<dd id="section-20-3.2">
  An endpoint uses this with CONNECTION_CLOSE to signal that the connection is
being closed abruptly in the absence of any error.<a href="#section-20-3.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-20-3.3">INTERNAL_ERROR (0x1):</dt>
<dd id="section-20-3.4">
  The endpoint encountered an internal error and cannot continue with the
connection.<a href="#section-20-3.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-20-3.5">SERVER_BUSY (0x2):</dt>
<dd id="section-20-3.6">
  The server is currently busy and does not accept any new connections.<a href="#section-20-3.6" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-20-3.7">FLOW_CONTROL_ERROR (0x3):</dt>
<dd id="section-20-3.8">
  An endpoint received more data than it permitted in its advertised data
limits; see <a href="#flow-control" class="xref">Section 4</a>.<a href="#section-20-3.8" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-20-3.9">STREAM_LIMIT_ERROR (0x4):</dt>
<dd id="section-20-3.10">
  An endpoint received a frame for a stream identifier that exceeded its
advertised stream limit for the corresponding stream type.<a href="#section-20-3.10" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-20-3.11">STREAM_STATE_ERROR (0x5):</dt>
<dd id="section-20-3.12">
  An endpoint received a frame for a stream that was not in a state that
permitted that frame; see <a href="#stream-states" class="xref">Section 3</a>.<a href="#section-20-3.12" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-20-3.13">FINAL_SIZE_ERROR (0x6):</dt>
<dd id="section-20-3.14">
  An endpoint received a STREAM frame containing data that exceeded the
previously established final size.  Or an endpoint received a STREAM frame or
a RESET_STREAM frame containing a final size that was lower than the size of
stream data that was already received.  Or an endpoint received a STREAM frame
or a RESET_STREAM frame containing a different final size to the one already
established.<a href="#section-20-3.14" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-20-3.15">FRAME_ENCODING_ERROR (0x7):</dt>
<dd id="section-20-3.16">
  An endpoint received a frame that was badly formatted.  For instance, a frame
of an unknown type, or an ACK frame that has more acknowledgment ranges than
the remainder of the packet could carry.<a href="#section-20-3.16" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-20-3.17">TRANSPORT_PARAMETER_ERROR (0x8):</dt>
<dd id="section-20-3.18">
  An endpoint received transport parameters that were badly formatted, included
an invalid value, was absent even though it is mandatory, was present though
it is forbidden, or is otherwise in error.<a href="#section-20-3.18" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-20-3.19">CONNECTION_ID_LIMIT_ERROR (0x9):</dt>
<dd id="section-20-3.20">
  The number of connection IDs provided by the peer exceeds the advertised
active_connection_id_limit.<a href="#section-20-3.20" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-20-3.21">PROTOCOL_VIOLATION (0xA):</dt>
<dd id="section-20-3.22">
  An endpoint detected an error with protocol compliance that was not covered by
more specific error codes.<a href="#section-20-3.22" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-20-3.23">INVALID_TOKEN (0xB):</dt>
<dd id="section-20-3.24">
  A server received a Retry Token in a client Initial that is invalid.<a href="#section-20-3.24" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-20-3.25">APPLICATION_ERROR (0xC):</dt>
<dd id="section-20-3.26">
  The application or application protocol caused the connection to be closed.<a href="#section-20-3.26" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-20-3.27">CRYPTO_BUFFER_EXCEEDED (0xD):</dt>
<dd id="section-20-3.28">
  An endpoint has received more data in CRYPTO frames than it can buffer.<a href="#section-20-3.28" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-20-3.29">CRYPTO_ERROR (0x1XX):</dt>
<dd id="section-20-3.30">
  The cryptographic handshake failed.  A range of 256 values is reserved for
carrying error codes specific to the cryptographic handshake that is used.
Codes for errors occurring when TLS is used for the crypto handshake are
described in Section 4.8 of <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span>.<a href="#section-20-3.30" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-20-4">See <a href="#iana-error-codes" class="xref">Section 22.4</a> for details of registering new error codes.<a href="#section-20-4" class="pilcrow">¶</a></p>
<p id="section-20-5">In defining these error codes, several principles are applied.  Error conditions
that might require specific action on the part of a recipient are given unique
codes.  Errors that represent common conditions are given specific codes.
Absent either of these conditions, error codes are used to identify a general
function of the stack, like flow control or transport parameter handling.
Finally, generic errors are provided for conditions where implementations are
unable or unwilling to use more specific codes.<a href="#section-20-5" class="pilcrow">¶</a></p>
<div id="app-error-codes">
<section id="section-20.1">
        <h3 id="name-application-protocol-error-">
<a href="#section-20.1" class="section-number selfRef">20.1. </a><a href="#name-application-protocol-error-" class="section-name selfRef">Application Protocol Error Codes</a>
        </h3>
<p id="section-20.1-1">Application protocol error codes are 62-bit unsigned integers, but the
management of application error codes is left to application protocols.
Application protocol error codes are used for the RESET_STREAM frame
(<a href="#frame-reset-stream" class="xref">Section 19.4</a>), the STOP_SENDING frame (<a href="#frame-stop-sending" class="xref">Section 19.5</a>), and
the CONNECTION_CLOSE frame with a type of 0x1d (<a href="#frame-connection-close" class="xref">Section 19.19</a>).<a href="#section-20.1-1" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="security-considerations">
<section id="section-21">
      <h2 id="name-security-considerations">
<a href="#section-21" class="section-number selfRef">21. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<div id="handshake-dos">
<section id="section-21.1">
        <h3 id="name-handshake-denial-of-service">
<a href="#section-21.1" class="section-number selfRef">21.1. </a><a href="#name-handshake-denial-of-service" class="section-name selfRef">Handshake Denial of Service</a>
        </h3>
<p id="section-21.1-1">As an encrypted and authenticated transport QUIC provides a range of protections
against denial of service.  Once the cryptographic handshake is complete, QUIC
endpoints discard most packets that are not authenticated, greatly limiting the
ability of an attacker to interfere with existing connections.<a href="#section-21.1-1" class="pilcrow">¶</a></p>
<p id="section-21.1-2">Once a connection is established QUIC endpoints might accept some
unauthenticated ICMP packets (see <a href="#icmp-pmtud" class="xref">Section 14.2</a>), but the use of these packets
is extremely limited.  The only other type of packet that an endpoint might
accept is a stateless reset (<a href="#stateless-reset" class="xref">Section 10.4</a>) which relies on the token
being kept secret until it is used.<a href="#section-21.1-2" class="pilcrow">¶</a></p>
<p id="section-21.1-3">During the creation of a connection, QUIC only provides protection against
attack from off the network path.  All QUIC packets contain proof that the
recipient saw a preceding packet from its peer.<a href="#section-21.1-3" class="pilcrow">¶</a></p>
<p id="section-21.1-4">Addresses cannot change during the handshake, so endpoints can discard packets
that are received on a different network path.<a href="#section-21.1-4" class="pilcrow">¶</a></p>
<p id="section-21.1-5">The Source and Destination Connection ID fields are the primary means of
protection against off-path attack during the handshake.  These are required to
match those set by a peer.  Except for an Initial and stateless reset packets,
an endpoint only accepts packets that include a Destination Connection ID field
that matches a value the endpoint previously chose.  This is the only protection
offered for Version Negotiation packets.<a href="#section-21.1-5" class="pilcrow">¶</a></p>
<p id="section-21.1-6">The Destination Connection ID field in an Initial packet is selected by a client
to be unpredictable, which serves an additional purpose.  The packets that carry
the cryptographic handshake are protected with a key that is derived from this
connection ID and salt specific to the QUIC version.  This allows endpoints to
use the same process for authenticating packets that they receive as they use
after the cryptographic handshake completes.  Packets that cannot be
authenticated are discarded.  Protecting packets in this fashion provides a
strong assurance that the sender of the packet saw the Initial packet and
understood it.<a href="#section-21.1-6" class="pilcrow">¶</a></p>
<p id="section-21.1-7">These protections are not intended to be effective against an attacker that is
able to receive QUIC packets prior to the connection being established.  Such an
attacker can potentially send packets that will be accepted by QUIC endpoints.
This version of QUIC attempts to detect this sort of attack, but it expects that
endpoints will fail to establish a connection rather than recovering.  For the
most part, the cryptographic handshake protocol <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span> is responsible for
detecting tampering during the handshake.<a href="#section-21.1-7" class="pilcrow">¶</a></p>
<p id="section-21.1-8">Endpoints are permitted to use other methods to detect and attempt to recover
from interference with the handshake.  Invalid packets may be identified and
discarded using other methods, but no specific method is mandated in this
document.<a href="#section-21.1-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="amplification-attack">
<section id="section-21.2">
        <h3 id="name-amplification-attack">
<a href="#section-21.2" class="section-number selfRef">21.2. </a><a href="#name-amplification-attack" class="section-name selfRef">Amplification Attack</a>
        </h3>
<p id="section-21.2-1">An attacker might be able to receive an address validation token
(<a href="#address-validation" class="xref">Section 8</a>) from a server and then release the IP address it used
to acquire that token.  At a later time, the attacker may initiate a 0-RTT
connection with a server by spoofing this same address, which might now address
a different (victim) endpoint.  The attacker can thus potentially cause the
server to send an initial congestion window's worth of data towards the victim.<a href="#section-21.2-1" class="pilcrow">¶</a></p>
<p id="section-21.2-2">Servers SHOULD provide mitigations for this attack by limiting the usage and
lifetime of address validation tokens; see <a href="#validate-future" class="xref">Section 8.1.3</a>.<a href="#section-21.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="optimistic-ack-attack">
<section id="section-21.3">
        <h3 id="name-optimistic-ack-attack">
<a href="#section-21.3" class="section-number selfRef">21.3. </a><a href="#name-optimistic-ack-attack" class="section-name selfRef">Optimistic ACK Attack</a>
        </h3>
<p id="section-21.3-1">An endpoint that acknowledges packets it has not received might cause a
congestion controller to permit sending at rates beyond what the network
supports.  An endpoint MAY skip packet numbers when sending packets to detect
this behavior.  An endpoint can then immediately close the connection with a
connection error of type PROTOCOL_VIOLATION; see <a href="#immediate-close" class="xref">Section 10.3</a>.<a href="#section-21.3-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="slowloris-attacks">
<section id="section-21.4">
        <h3 id="name-slowloris-attacks">
<a href="#section-21.4" class="section-number selfRef">21.4. </a><a href="#name-slowloris-attacks" class="section-name selfRef">Slowloris Attacks</a>
        </h3>
<p id="section-21.4-1">The attacks commonly known as Slowloris <span>[<a href="#SLOWLORIS" class="xref">SLOWLORIS</a>]</span> try to keep many
connections to the target endpoint open and hold them open as long as possible.
These attacks can be executed against a QUIC endpoint by generating the minimum
amount of activity necessary to avoid being closed for inactivity.  This might
involve sending small amounts of data, gradually opening flow control windows in
order to control the sender rate, or manufacturing ACK frames that simulate a
high loss rate.<a href="#section-21.4-1" class="pilcrow">¶</a></p>
<p id="section-21.4-2">QUIC deployments SHOULD provide mitigations for the Slowloris attacks, such as
increasing the maximum number of clients the server will allow, limiting the
number of connections a single IP address is allowed to make, imposing
restrictions on the minimum transfer speed a connection is allowed to have, and
restricting the length of time an endpoint is allowed to stay connected.<a href="#section-21.4-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="stream-fragmentation-and-reassembly-attacks">
<section id="section-21.5">
        <h3 id="name-stream-fragmentation-and-re">
<a href="#section-21.5" class="section-number selfRef">21.5. </a><a href="#name-stream-fragmentation-and-re" class="section-name selfRef">Stream Fragmentation and Reassembly Attacks</a>
        </h3>
<p id="section-21.5-1">An adversarial sender might intentionally send fragments of stream data in
order to cause disproportionate receive buffer memory commitment and/or
creation of a large and inefficient data structure.<a href="#section-21.5-1" class="pilcrow">¶</a></p>
<p id="section-21.5-2">An adversarial receiver might intentionally not acknowledge packets
containing stream data in order to force the sender to store the
unacknowledged stream data for retransmission.<a href="#section-21.5-2" class="pilcrow">¶</a></p>
<p id="section-21.5-3">The attack on receivers is mitigated if flow control windows correspond to
available memory.  However, some receivers will over-commit memory and
advertise flow control offsets in the aggregate that exceed actual available
memory.  The over-commitment strategy can lead to better performance when
endpoints are well behaved, but renders endpoints vulnerable to the stream
fragmentation attack.<a href="#section-21.5-3" class="pilcrow">¶</a></p>
<p id="section-21.5-4">QUIC deployments SHOULD provide mitigations against stream fragmentation
attacks.  Mitigations could consist of avoiding over-committing memory,
limiting the size of tracking data structures, delaying reassembly
of STREAM frames, implementing heuristics based on the age and
duration of reassembly holes, or some combination.<a href="#section-21.5-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="stream-commitment-attack">
<section id="section-21.6">
        <h3 id="name-stream-commitment-attack">
<a href="#section-21.6" class="section-number selfRef">21.6. </a><a href="#name-stream-commitment-attack" class="section-name selfRef">Stream Commitment Attack</a>
        </h3>
<p id="section-21.6-1">An adversarial endpoint can open lots of streams, exhausting state on an
endpoint.  The adversarial endpoint could repeat the process on a large number
of connections, in a manner similar to SYN flooding attacks in TCP.<a href="#section-21.6-1" class="pilcrow">¶</a></p>
<p id="section-21.6-2">Normally, clients will open streams sequentially, as explained in <a href="#stream-id" class="xref">Section 2.1</a>.
However, when several streams are initiated at short intervals, loss or
reordering may cause STREAM frames that open streams to be received out of
sequence.  On receiving a higher-numbered stream ID, a receiver is required to
open all intervening streams of the same type; see <a href="#stream-recv-states" class="xref">Section 3.2</a>.
Thus, on a new connection, opening stream 4000000 opens 1 million and 1
client-initiated bidirectional streams.<a href="#section-21.6-2" class="pilcrow">¶</a></p>
<p id="section-21.6-3">The number of active streams is limited by the initial_max_streams_bidi and
initial_max_streams_uni transport parameters, as explained in
<a href="#controlling-concurrency" class="xref">Section 4.5</a>.  If chosen judiciously, these limits mitigate the
effect of the stream commitment attack.  However, setting the limit too low
could affect performance when applications expect to open large number of
streams.<a href="#section-21.6-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="useless">
<section id="section-21.7">
        <h3 id="name-peer-denial-of-service">
<a href="#section-21.7" class="section-number selfRef">21.7. </a><a href="#name-peer-denial-of-service" class="section-name selfRef">Peer Denial of Service</a>
        </h3>
<p id="section-21.7-1">QUIC and TLS both contain messages that have legitimate uses in some contexts,
but that can be abused to cause a peer to expend processing resources without
having any observable impact on the state of the connection.<a href="#section-21.7-1" class="pilcrow">¶</a></p>
<p id="section-21.7-2">Messages can also be used to change and revert state in small or inconsequential
ways, such as by sending small increments to flow control limits.<a href="#section-21.7-2" class="pilcrow">¶</a></p>
<p id="section-21.7-3">If processing costs are disproportionately large in comparison to bandwidth
consumption or effect on state, then this could allow a malicious peer to
exhaust processing capacity.<a href="#section-21.7-3" class="pilcrow">¶</a></p>
<p id="section-21.7-4">While there are legitimate uses for all messages, implementations SHOULD track
cost of processing relative to progress and treat excessive quantities of any
non-productive packets as indicative of an attack.  Endpoints MAY respond to
this condition with a connection error, or by dropping packets.<a href="#section-21.7-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="security-ecn">
<section id="section-21.8">
        <h3 id="name-explicit-congestion-notifica">
<a href="#section-21.8" class="section-number selfRef">21.8. </a><a href="#name-explicit-congestion-notifica" class="section-name selfRef">Explicit Congestion Notification Attacks</a>
        </h3>
<p id="section-21.8-1">An on-path attacker could manipulate the value of ECN codepoints in the IP
header to influence the sender's rate. <span>[<a href="#RFC3168" class="xref">RFC3168</a>]</span> discusses manipulations and
their effects in more detail.<a href="#section-21.8-1" class="pilcrow">¶</a></p>
<p id="section-21.8-2">An on-the-side attacker can duplicate and send packets with modified ECN
codepoints to affect the sender's rate.  If duplicate packets are discarded by a
receiver, an off-path attacker will need to race the duplicate packet against
the original to be successful in this attack.  Therefore, QUIC endpoints ignore
the ECN codepoint field on an IP packet unless at least one QUIC packet in that
IP packet is successfully processed; see <a href="#ecn" class="xref">Section 13.4</a>.<a href="#section-21.8-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="reset-oracle">
<section id="section-21.9">
        <h3 id="name-stateless-reset-oracle">
<a href="#section-21.9" class="section-number selfRef">21.9. </a><a href="#name-stateless-reset-oracle" class="section-name selfRef">Stateless Reset Oracle</a>
        </h3>
<p id="section-21.9-1">Stateless resets create a possible denial of service attack analogous to a TCP
reset injection. This attack is possible if an attacker is able to cause a
stateless reset token to be generated for a connection with a selected
connection ID. An attacker that can cause this token to be generated can reset
an active connection with the same connection ID.<a href="#section-21.9-1" class="pilcrow">¶</a></p>
<p id="section-21.9-2">If a packet can be routed to different instances that share a static key, for
example by changing an IP address or port, then an attacker can cause the server
to send a stateless reset.  To defend against this style of denial service,
endpoints that share a static key for stateless reset (see <a href="#reset-token" class="xref">Section 10.4.2</a>) MUST
be arranged so that packets with a given connection ID always arrive at an
instance that has connection state, unless that connection is no longer active.<a href="#section-21.9-2" class="pilcrow">¶</a></p>
<p id="section-21.9-3">In the case of a cluster that uses dynamic load balancing, it's possible that a
change in load balancer configuration could happen while an active instance
retains connection state; even if an instance retains connection state, the
change in routing and resulting stateless reset will result in the connection
being terminated.  If there is no chance in the packet being routed to the
correct instance, it is better to send a stateless reset than wait for
connections to time out.  However, this is acceptable only if the routing cannot
be influenced by an attacker.<a href="#section-21.9-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="version-downgrade">
<section id="section-21.10">
        <h3 id="name-version-downgrade">
<a href="#section-21.10" class="section-number selfRef">21.10. </a><a href="#name-version-downgrade" class="section-name selfRef">Version Downgrade</a>
        </h3>
<p id="section-21.10-1">This document defines QUIC Version Negotiation packets in
<a href="#version-negotiation" class="xref">Section 6</a>, which can be used to negotiate the QUIC version used
between two endpoints. However, this document does not specify how this
negotiation will be performed between this version and subsequent future
versions.  In particular, Version Negotiation packets do not contain any
mechanism to prevent version downgrade attacks.  Future versions of QUIC that
use Version Negotiation packets MUST define a mechanism that is robust against
version downgrade attacks.<a href="#section-21.10-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="targeted-attacks-by-routing">
<section id="section-21.11">
        <h3 id="name-targeted-attacks-by-routing">
<a href="#section-21.11" class="section-number selfRef">21.11. </a><a href="#name-targeted-attacks-by-routing" class="section-name selfRef">Targeted Attacks by Routing</a>
        </h3>
<p id="section-21.11-1">Deployments should limit the ability of an attacker to target a new connection
to a particular server instance.  This means that client-controlled fields, such
as the initial Destination Connection ID used on Initial and 0-RTT packets
SHOULD NOT be used by themselves to make routing decisions.  Ideally, routing
decisions are made independently of client-selected values; a Source Connection
ID can be selected to route later packets to the same server.<a href="#section-21.11-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="security-properties">
<section id="section-21.12">
        <h3 id="name-overview-of-security-proper">
<a href="#section-21.12" class="section-number selfRef">21.12. </a><a href="#name-overview-of-security-proper" class="section-name selfRef">Overview of Security Properties</a>
        </h3>
<p id="section-21.12-1">A complete security analysis of QUIC is outside the scope of this document.
This section provides an informal description of the desired security properties
as an aid to implementors and to help guide protocol analysis.<a href="#section-21.12-1" class="pilcrow">¶</a></p>
<p id="section-21.12-2">QUIC assumes the threat model described in <span>[<a href="#SEC-CONS" class="xref">SEC-CONS</a>]</span> and provides
protections against many of the attacks that arise from that model.<a href="#section-21.12-2" class="pilcrow">¶</a></p>
<p id="section-21.12-3">For this purpose, attacks are divided into passive and active attacks.  Passive
attackers have the capability to read packets from the network, while active
attackers also have the capability to write packets into the network.  However,
a passive attack may involve an attacker with the ability to cause a routing
change or other modification in the path taken by packets that comprise a
connection.<a href="#section-21.12-3" class="pilcrow">¶</a></p>
<p id="section-21.12-4">Attackers are additionally categorized as either on-path attackers or off-path
attackers; see Section 3.5 of <span>[<a href="#SEC-CONS" class="xref">SEC-CONS</a>]</span>.  An on-path attacker can read,
modify, or remove any packet it observes such that it no longer reaches its
destination, while an off-path attacker observes the packets, but cannot prevent
the original packet from reaching its intended destination.  An off-path
attacker can also transmit arbitrary packets.<a href="#section-21.12-4" class="pilcrow">¶</a></p>
<p id="section-21.12-5">Properties of the handshake, protected packets, and connection migration are
considered separately.<a href="#section-21.12-5" class="pilcrow">¶</a></p>
<div id="handshake-properties">
<section id="section-21.12.1">
          <h4 id="name-handshake">
<a href="#section-21.12.1" class="section-number selfRef">21.12.1. </a><a href="#name-handshake" class="section-name selfRef">Handshake</a>
          </h4>
<p id="section-21.12.1-1">The QUIC handshake incorporates the TLS 1.3 handshake and inherits the
cryptographic properties described in Appendix E.1 of <span>[<a href="#TLS13" class="xref">TLS13</a>]</span>. Many
of the security properties of QUIC depend on the TLS handshake providing these
properties. Any attack on the TLS handshake could affect QUIC.<a href="#section-21.12.1-1" class="pilcrow">¶</a></p>
<p id="section-21.12.1-2">Any attack on the TLS handshake that compromises the secrecy or uniqueness
of session keys affects other security guarantees provided by QUIC that depends
on these keys. For instance, migration (<a href="#migration" class="xref">Section 9</a>) depends on the efficacy
of confidentiality protections, both for the negotiation of keys using the TLS
handshake and for QUIC packet protection, to avoid linkability across network
paths.<a href="#section-21.12.1-2" class="pilcrow">¶</a></p>
<p id="section-21.12.1-3">An attack on the integrity of the TLS handshake might allow an attacker to
affect the selection of application protocol or QUIC version.<a href="#section-21.12.1-3" class="pilcrow">¶</a></p>
<p id="section-21.12.1-4">In addition to the properties provided by TLS, the QUIC handshake provides some
defense against DoS attacks on the handshake.<a href="#section-21.12.1-4" class="pilcrow">¶</a></p>
<div id="anti-amplification">
<section id="section-21.12.1.1">
            <h5 id="name-anti-amplification">
<a href="#section-21.12.1.1" class="section-number selfRef">21.12.1.1. </a><a href="#name-anti-amplification" class="section-name selfRef">Anti-Amplification</a>
            </h5>
<p id="section-21.12.1.1-1">Address validation (<a href="#address-validation" class="xref">Section 8</a>) is used to verify that an entity
that claims a given address is able to receive packets at that address. Address
validation limits amplification attack targets to addresses for which an
attacker is either on-path or off-path.<a href="#section-21.12.1.1-1" class="pilcrow">¶</a></p>
<p id="section-21.12.1.1-2">Prior to validation, endpoints are limited in what they are able to send.
During the handshake, a server cannot send more than three times the data it
receives; clients that initiate new connections or migrate to a new network
path are limited.<a href="#section-21.12.1.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="server-side-dos">
<section id="section-21.12.1.2">
            <h5 id="name-server-side-dos">
<a href="#section-21.12.1.2" class="section-number selfRef">21.12.1.2. </a><a href="#name-server-side-dos" class="section-name selfRef">Server-Side DoS</a>
            </h5>
<p id="section-21.12.1.2-1">Computing the server's first flight for a full handshake is potentially
expensive, requiring both a signature and a key exchange computation. In order
to prevent computational DoS attacks, the Retry packet provides a cheap token
exchange mechanism which allows servers to validate a client's IP address prior
to doing any expensive computations at the cost of a single round trip. After a
successful handshake, servers can issue new tokens to a client which will allow
new connection establishment without incurring this cost.<a href="#section-21.12.1.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="on-path-handshake-termination">
<section id="section-21.12.1.3">
            <h5 id="name-on-path-handshake-terminati">
<a href="#section-21.12.1.3" class="section-number selfRef">21.12.1.3. </a><a href="#name-on-path-handshake-terminati" class="section-name selfRef">On-Path Handshake Termination</a>
            </h5>
<p id="section-21.12.1.3-1">An on-path or off-path attacker can force a handshake to fail by replacing or
racing Initial packets. Once valid Initial packets have been exchanged,
subsequent Handshake packets are protected with the handshake keys and an
on-path attacker cannot force handshake failure other than by dropping packets
to cause endpoints to abandon the attempt.<a href="#section-21.12.1.3-1" class="pilcrow">¶</a></p>
<p id="section-21.12.1.3-2">An on-path attacker can also replace the addresses of packets on either side and
therefore cause the client or server to have an incorrect view of the remote
addresses. Such an attack is indistinguishable from the functions performed by a
NAT.<a href="#section-21.12.1.3-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="parameter-negotiation">
<section id="section-21.12.1.4">
            <h5 id="name-parameter-negotiation">
<a href="#section-21.12.1.4" class="section-number selfRef">21.12.1.4. </a><a href="#name-parameter-negotiation" class="section-name selfRef">Parameter Negotiation</a>
            </h5>
<p id="section-21.12.1.4-1">The entire handshake is cryptographically protected, with the Initial packets
being encrypted with per-version keys and the Handshake and later packets being
encrypted with keys derived from the TLS key exchange.  Further, parameter
negotiation is folded into the TLS transcript and thus provides the same
integrity guarantees as ordinary TLS negotiation.  An attacker can observe
the client's transport parameters (as long as it knows the version-specific
keys) but cannot observe the server's transport parameters and cannot influence
parameter negotiation.<a href="#section-21.12.1.4-1" class="pilcrow">¶</a></p>
<p id="section-21.12.1.4-2">Connection IDs are unencrypted but integrity protected in all packets.<a href="#section-21.12.1.4-2" class="pilcrow">¶</a></p>
<p id="section-21.12.1.4-3">This version of QUIC does not incorporate a version negotiation mechanism;
implementations of incompatible versions will simply fail to establish a
connection.<a href="#section-21.12.1.4-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="protected-packet-properties">
<section id="section-21.12.2">
          <h4 id="name-protected-packets-2">
<a href="#section-21.12.2" class="section-number selfRef">21.12.2. </a><a href="#name-protected-packets-2" class="section-name selfRef">Protected Packets</a>
          </h4>
<p id="section-21.12.2-1">Packet protection (<a href="#packet-protected" class="xref">Section 12.1</a>) provides authentication and encryption
of all packets except Version Negotiation packets, though Initial and Retry
packets have limited encryption and authentication based on version-specific
keys; see <span>[<a href="#QUIC-TLS" class="xref">QUIC-TLS</a>]</span> for more details. This section considers passive and
active attacks against protected packets.<a href="#section-21.12.2-1" class="pilcrow">¶</a></p>
<p id="section-21.12.2-2">Both on-path and off-path attackers can mount a passive attack in which they
save observed packets for an offline attack against packet protection at a
future time; this is true for any observer of any packet on any network.<a href="#section-21.12.2-2" class="pilcrow">¶</a></p>
<p id="section-21.12.2-3">A blind attacker, one who injects packets without being able to observe valid
packets for a connection, is unlikely to be successful, since packet protection
ensures that valid packets are only generated by endpoints which possess the
key material established during the handshake; see <a href="#handshake" class="xref">Section 7</a> and
<a href="#handshake-properties" class="xref">Section 21.12.1</a>. Similarly, any active attacker that observes packets
and attempts to insert new data or modify existing data in those packets should
not be able to generate packets deemed valid by the receiving endpoint.<a href="#section-21.12.2-3" class="pilcrow">¶</a></p>
<p id="section-21.12.2-4">A spoofing attack, in which an active attacker rewrites unprotected parts of a
packet that it forwards or injects, such as the source or destination
address, is only effective if the attacker can forward packets to the original
endpoint.  Packet protection ensures that the packet payloads can only be
processed by the endpoints that completed the handshake, and invalid
packets are ignored by those endpoints.<a href="#section-21.12.2-4" class="pilcrow">¶</a></p>
<p id="section-21.12.2-5">An attacker can also modify the boundaries between packets and UDP datagrams,
causing multiple packets to be coalesced into a single datagram, or splitting
coalesced packets into multiple datagrams. Aside from datagrams containing
Initial packets, which require padding, modification of how packets are
arranged in datagrams has no functional effect on a connection, although it
might change some performance characteristics.<a href="#section-21.12.2-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="migration-properties">
<section id="section-21.12.3">
          <h4 id="name-connection-migration-2">
<a href="#section-21.12.3" class="section-number selfRef">21.12.3. </a><a href="#name-connection-migration-2" class="section-name selfRef">Connection Migration</a>
          </h4>
<p id="section-21.12.3-1">Connection Migration (<a href="#migration" class="xref">Section 9</a>) provides endpoints with the ability to
transition between IP addresses and ports on multiple paths, using one path at a
time for transmission and receipt of non-probing frames.  Path validation
(<a href="#migrate-validate" class="xref">Section 8.2</a>) establishes that a peer is both willing and able
to receive packets sent on a particular path.  This helps reduce the effects of
address spoofing by limiting the number of packets sent to a spoofed address.<a href="#section-21.12.3-1" class="pilcrow">¶</a></p>
<p id="section-21.12.3-2">This section describes the intended security properties of connection migration
when under various types of DoS attacks.<a href="#section-21.12.3-2" class="pilcrow">¶</a></p>
<div id="on-path-active-attacks">
<section id="section-21.12.3.1">
            <h5 id="name-on-path-active-attacks">
<a href="#section-21.12.3.1" class="section-number selfRef">21.12.3.1. </a><a href="#name-on-path-active-attacks" class="section-name selfRef">On-Path Active Attacks</a>
            </h5>
<p id="section-21.12.3.1-1">An attacker that can cause a packet it observes to no longer reach its intended
destination is considered an on-path attacker. When an attacker is present
between a client and server, endpoints are required to send packets through the
attacker to establish connectivity on a given path.<a href="#section-21.12.3.1-1" class="pilcrow">¶</a></p>
<p id="section-21.12.3.1-2">An on-path attacker can:<a href="#section-21.12.3.1-2" class="pilcrow">¶</a></p>
<ul>
<li id="section-21.12.3.1-3.1">Inspect packets<a href="#section-21.12.3.1-3.1" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.1-3.2">Modify IP and UDP packet headers<a href="#section-21.12.3.1-3.2" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.1-3.3">Inject new packets<a href="#section-21.12.3.1-3.3" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.1-3.4">Delay packets<a href="#section-21.12.3.1-3.4" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.1-3.5">Reorder packets<a href="#section-21.12.3.1-3.5" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.1-3.6">Drop packets<a href="#section-21.12.3.1-3.6" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.1-3.7">Split and merge datagrams along packet boundaries<a href="#section-21.12.3.1-3.7" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-21.12.3.1-4">An on-path attacker cannot:<a href="#section-21.12.3.1-4" class="pilcrow">¶</a></p>
<ul>
<li id="section-21.12.3.1-5.1">Modify an authenticated portion of a packet and cause the recipient to accept
that packet<a href="#section-21.12.3.1-5.1" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-21.12.3.1-6">An on-path attacker has the opportunity to modify the packets that it observes,
however any modifications to an authenticated portion of a packet will cause it
to be dropped by the receiving endpoint as invalid, as packet payloads are both
authenticated and encrypted.<a href="#section-21.12.3.1-6" class="pilcrow">¶</a></p>
<p id="section-21.12.3.1-7">In the presence of an on-path attacker, QUIC aims to provide the following
properties:<a href="#section-21.12.3.1-7" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-21.12.3.1-8">
              <li id="section-21.12.3.1-8.1">An on-path attacker can prevent use of a path for a connection, causing
it to fail if it cannot use a different path that does not contain the
attacker. This can be achieved by dropping all packets, modifying them so
that they fail to decrypt, or other methods.<a href="#section-21.12.3.1-8.1" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.1-8.2">An on-path attacker can prevent migration to a new path for which the
attacker is also on-path by causing path validation to fail on the new path.<a href="#section-21.12.3.1-8.2" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.1-8.3">An on-path attacker cannot prevent a client from migrating to a path for
which the attacker is not on-path.<a href="#section-21.12.3.1-8.3" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.1-8.4">An on-path attacker can reduce the throughput of a connection by delaying
packets or dropping them.<a href="#section-21.12.3.1-8.4" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.1-8.5">An on-path attacker cannot cause an endpoint to accept a packet for which it
has modified an authenticated portion of that packet.<a href="#section-21.12.3.1-8.5" class="pilcrow">¶</a>
</li>
</ol>
</section>
</div>
<div id="off-path-active-attacks">
<section id="section-21.12.3.2">
            <h5 id="name-off-path-active-attacks">
<a href="#section-21.12.3.2" class="section-number selfRef">21.12.3.2. </a><a href="#name-off-path-active-attacks" class="section-name selfRef">Off-Path Active Attacks</a>
            </h5>
<p id="section-21.12.3.2-1">An off-path attacker is not directly on the path between a client and server,
but could be able to obtain copies of some or all packets sent between the
client and the server. It is also able to send copies of those packets to
either endpoint.<a href="#section-21.12.3.2-1" class="pilcrow">¶</a></p>
<p id="section-21.12.3.2-2">An off-path attacker can:<a href="#section-21.12.3.2-2" class="pilcrow">¶</a></p>
<ul>
<li id="section-21.12.3.2-3.1">Inspect packets<a href="#section-21.12.3.2-3.1" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.2-3.2">Inject new packets<a href="#section-21.12.3.2-3.2" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.2-3.3">Reorder injected packets<a href="#section-21.12.3.2-3.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-21.12.3.2-4">An off-path attacker cannot:<a href="#section-21.12.3.2-4" class="pilcrow">¶</a></p>
<ul>
<li id="section-21.12.3.2-5.1">Modify any part of a packet<a href="#section-21.12.3.2-5.1" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.2-5.2">Delay packets<a href="#section-21.12.3.2-5.2" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.2-5.3">Drop packets<a href="#section-21.12.3.2-5.3" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.2-5.4">Reorder original packets<a href="#section-21.12.3.2-5.4" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-21.12.3.2-6">An off-path attacker can modify packets that it has observed and inject them
back into the network, potentially with spoofed source and destination
addresses.<a href="#section-21.12.3.2-6" class="pilcrow">¶</a></p>
<p id="section-21.12.3.2-7">For the purposes of this discussion, it is assumed that an off-path attacker
has the ability to observe, modify, and re-inject a packet into the network
that will reach the destination endpoint prior to the arrival of the original
packet observed by the attacker. In other words, an attacker has the ability to
consistently "win" a race with the legitimate packets between the endpoints,
potentially causing the original packet to be ignored by the recipient.<a href="#section-21.12.3.2-7" class="pilcrow">¶</a></p>
<p id="section-21.12.3.2-8">It is also assumed that an attacker has the resources necessary to affect NAT
state, potentially both causing an endpoint to lose its NAT binding, and an
attacker to obtain the same port for use with its traffic.<a href="#section-21.12.3.2-8" class="pilcrow">¶</a></p>
<p id="section-21.12.3.2-9">In the presence of an off-path attacker, QUIC aims to provide the following
properties:<a href="#section-21.12.3.2-9" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-21.12.3.2-10">
              <li id="section-21.12.3.2-10.1">An off-path attacker can race packets and attempt to become a "limited"
on-path attacker.<a href="#section-21.12.3.2-10.1" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.2-10.2">An off-path attacker can cause path validation to succeed for forwarded
packets with the source address listed as the off-path attacker as long as
it can provide improved connectivity between the client and the server.<a href="#section-21.12.3.2-10.2" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.2-10.3">An off-path attacker cannot cause a connection to close once the handshake
has completed.<a href="#section-21.12.3.2-10.3" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.2-10.4">An off-path attacker cannot cause migration to a new path to fail if it
cannot observe the new path.<a href="#section-21.12.3.2-10.4" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.2-10.5">An off-path attacker can become a limited on-path attacker during migration
to a new path for which it is also an off-path attacker.<a href="#section-21.12.3.2-10.5" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.2-10.6">An off-path attacker can become a limited on-path attacker by affecting
shared NAT state such that it sends packets to the server from the same IP
address and port that the client originally used.<a href="#section-21.12.3.2-10.6" class="pilcrow">¶</a>
</li>
</ol>
</section>
</div>
<div id="limited-on-path-active-attacks">
<section id="section-21.12.3.3">
            <h5 id="name-limited-on-path-active-atta">
<a href="#section-21.12.3.3" class="section-number selfRef">21.12.3.3. </a><a href="#name-limited-on-path-active-atta" class="section-name selfRef">Limited On-Path Active Attacks</a>
            </h5>
<p id="section-21.12.3.3-1">A limited on-path attacker is an off-path attacker that has offered improved
routing of packets by duplicating and forwarding original packets between the
server and the client, causing those packets to arrive before the original
copies such that the original packets are dropped by the destination endpoint.<a href="#section-21.12.3.3-1" class="pilcrow">¶</a></p>
<p id="section-21.12.3.3-2">A limited on-path attacker differs from an on-path attacker in that it is not on
the original path between endpoints, and therefore the original packets sent by
an endpoint are still reaching their destination.  This means that a future
failure to route copied packets to the destination faster than their original
path will not prevent the original packets from reaching the destination.<a href="#section-21.12.3.3-2" class="pilcrow">¶</a></p>
<p id="section-21.12.3.3-3">A limited on-path attacker can:<a href="#section-21.12.3.3-3" class="pilcrow">¶</a></p>
<ul>
<li id="section-21.12.3.3-4.1">Inspect packets<a href="#section-21.12.3.3-4.1" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.3-4.2">Inject new packets<a href="#section-21.12.3.3-4.2" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.3-4.3">Modify unencrypted packet headers<a href="#section-21.12.3.3-4.3" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.3-4.4">Reorder packets<a href="#section-21.12.3.3-4.4" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-21.12.3.3-5">A limited on-path attacker cannot:<a href="#section-21.12.3.3-5" class="pilcrow">¶</a></p>
<ul>
<li id="section-21.12.3.3-6.1">Delay packets so that they arrive later than packets sent on the original path<a href="#section-21.12.3.3-6.1" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.3-6.2">Drop packets<a href="#section-21.12.3.3-6.2" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.3-6.3">Modify the authenticated and encrypted portion of a packet and cause the
 recipient to accept that packet<a href="#section-21.12.3.3-6.3" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-21.12.3.3-7">A limited on-path attacker can only delay packets up to the point that the
original packets arrive before the duplicate packets, meaning that it cannot
offer routing with worse latency than the original path.  If a limited on-path
attacker drops packets, the original copy will still arrive at the destination
endpoint.<a href="#section-21.12.3.3-7" class="pilcrow">¶</a></p>
<p id="section-21.12.3.3-8">In the presence of a limited on-path attacker, QUIC aims to provide the
following properties:<a href="#section-21.12.3.3-8" class="pilcrow">¶</a></p>
<ol start="1" type="1" class="normal type-1" id="section-21.12.3.3-9">
              <li id="section-21.12.3.3-9.1">A limited on-path attacker cannot cause a connection to close once the
handshake has completed.<a href="#section-21.12.3.3-9.1" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.3-9.2">A limited on-path attacker cannot cause an idle connection to close if the
client is first to resume activity.<a href="#section-21.12.3.3-9.2" class="pilcrow">¶</a>
</li>
<li id="section-21.12.3.3-9.3">A limited on-path attacker can cause an idle connection to be deemed lost if
the server is the first to resume activity.<a href="#section-21.12.3.3-9.3" class="pilcrow">¶</a>
</li>
</ol>
<p id="section-21.12.3.3-10">Note that these guarantees are the same guarantees provided for any NAT, for the
same reasons.<a href="#section-21.12.3.3-10" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="iana">
<section id="section-22">
      <h2 id="name-iana-considerations">
<a href="#section-22" class="section-number selfRef">22. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-22-1">This document establishes several registries for the management of codepoints in
QUIC.  These registries operate on a common set of policies as defined in
<a href="#iana-policy" class="xref">Section 22.1</a>.<a href="#section-22-1" class="pilcrow">¶</a></p>
<div id="iana-policy">
<section id="section-22.1">
        <h3 id="name-registration-policies-for-q">
<a href="#section-22.1" class="section-number selfRef">22.1. </a><a href="#name-registration-policies-for-q" class="section-name selfRef">Registration Policies for QUIC Registries</a>
        </h3>
<p id="section-22.1-1">All QUIC registries allow for both provisional and permanent registration of
codepoints.  This section documents policies that are common to these
registries.<a href="#section-22.1-1" class="pilcrow">¶</a></p>
<div id="iana-provisional">
<section id="section-22.1.1">
          <h4 id="name-provisional-registrations">
<a href="#section-22.1.1" class="section-number selfRef">22.1.1. </a><a href="#name-provisional-registrations" class="section-name selfRef">Provisional Registrations</a>
          </h4>
<p id="section-22.1.1-1">Provisional registration of codepoints are intended to allow for private use and
experimentation with extensions to QUIC.  Provisional registrations only require
the inclusion of the codepoint value and contact information.  However,
provisional registrations could be reclaimed and reassigned for another purpose.<a href="#section-22.1.1-1" class="pilcrow">¶</a></p>
<p id="section-22.1.1-2">Provisional registrations require Expert Review, as defined in Section 4.5 of
<span>[<a href="#RFC8126" class="xref">RFC8126</a>]</span>.  Designated expert(s) are advised that only registrations for an
excessive proportion of remaining codepoint space or the very first unassigned
value (see <a href="#iana-random" class="xref">Section 22.1.2</a>) can be rejected.<a href="#section-22.1.1-2" class="pilcrow">¶</a></p>
<p id="section-22.1.1-3">Provisional registrations will include a date field that indicates when the
registration was last updated.  A request to update the date on any provisional
registration can be made without review from the designated expert(s).<a href="#section-22.1.1-3" class="pilcrow">¶</a></p>
<p id="section-22.1.1-4">All QUIC registries include the following fields to support provisional
registration:<a href="#section-22.1.1-4" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-22.1.1-5">
            <dt id="section-22.1.1-5.1">Value:</dt>
<dd id="section-22.1.1-5.2">
  The assigned codepoint.<a href="#section-22.1.1-5.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-22.1.1-5.3">Status:</dt>
<dd id="section-22.1.1-5.4">
  "Permanent" or "Provisional".<a href="#section-22.1.1-5.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-22.1.1-5.5">Specification:</dt>
<dd id="section-22.1.1-5.6">
  A reference to a publicly available specification for the value.<a href="#section-22.1.1-5.6" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-22.1.1-5.7">Date:</dt>
<dd id="section-22.1.1-5.8">
  The date of last update to the registration.<a href="#section-22.1.1-5.8" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-22.1.1-5.9">Contact:</dt>
<dd id="section-22.1.1-5.10">
  Contact details for the registrant.<a href="#section-22.1.1-5.10" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-22.1.1-5.11">Notes:</dt>
<dd id="section-22.1.1-5.12">
  Supplementary notes about the registration.<a href="#section-22.1.1-5.12" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-22.1.1-6">Provisional registrations MAY omit the Specification and Notes fields, plus any
additional fields that might be required for a permanent registration.  The Date
field is not required as part of requesting a registration as it is set to the
date the registration is created or updated.<a href="#section-22.1.1-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="iana-random">
<section id="section-22.1.2">
          <h4 id="name-selecting-codepoints">
<a href="#section-22.1.2" class="section-number selfRef">22.1.2. </a><a href="#name-selecting-codepoints" class="section-name selfRef">Selecting Codepoints</a>
          </h4>
<p id="section-22.1.2-1">New uses of codepoints from QUIC registries SHOULD use a randomly selected
codepoint that excludes both existing allocations and the first unallocated
codepoint in the selected space.  Requests for multiple codepoints MAY use a
contiguous range.  This minimizes the risk that differing semantics are
attributed to the same codepoint by different implementations.  Use of the first
codepoint in a range is intended for use by specifications that are developed
through the standards process <span>[<a href="#STD" class="xref">STD</a>]</span> and its allocation MUST be
negotiated with IANA before use.<a href="#section-22.1.2-1" class="pilcrow">¶</a></p>
<p id="section-22.1.2-2">For codepoints that are encoded in variable-length integers
(<a href="#integer-encoding" class="xref">Section 16</a>), such as frame types, codepoints that encode to four or
eight bytes (that is, values 2^14 and above) SHOULD be used unless the usage is
especially sensitive to having a longer encoding.<a href="#section-22.1.2-2" class="pilcrow">¶</a></p>
<p id="section-22.1.2-3">Applications to register codepoints in QUIC registries MAY include a codepoint
as part of the registration.  IANA MUST allocate the selected codepoint unless
that codepoint is already assigned or the codepoint is the first unallocated
codepoint in the registry.<a href="#section-22.1.2-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="reclaiming-provisional-codepoints">
<section id="section-22.1.3">
          <h4 id="name-reclaiming-provisional-code">
<a href="#section-22.1.3" class="section-number selfRef">22.1.3. </a><a href="#name-reclaiming-provisional-code" class="section-name selfRef">Reclaiming Provisional Codepoints</a>
          </h4>
<p id="section-22.1.3-1">A request might be made to remove an unused provisional registration from the
registry to reclaim space in a registry, or portion of the registry (such as the
64-16383 range for codepoints that use variable-length encodings).  This SHOULD
be done only for the codepoints with the earliest recorded date and entries that
have been updated less than a year prior SHOULD NOT be reclaimed.<a href="#section-22.1.3-1" class="pilcrow">¶</a></p>
<p id="section-22.1.3-2">A request to remove a codepoint MUST be reviewed by the designated expert(s).
The expert(s) MUST attempt to determine whether the codepoint is still in use.
Experts are advised to contact the listed contacts for the registration, plus as
wide a set of protocol implementers as possible in order to determine whether
any use of the codepoint is known.  The expert(s) are advised to allow at least
four weeks for responses.<a href="#section-22.1.3-2" class="pilcrow">¶</a></p>
<p id="section-22.1.3-3">If any use of the codepoints is identified by this search or a request to update
the registration is made, the codepoint MUST NOT be reclaimed.  Instead, the
date on the registration is updated.  A note might be added for the registration
recording relevant information that was learned.<a href="#section-22.1.3-3" class="pilcrow">¶</a></p>
<p id="section-22.1.3-4">If no use of the codepoint was identified and no request was made to update the
registration, the codepoint MAY be removed from the registry.<a href="#section-22.1.3-4" class="pilcrow">¶</a></p>
<p id="section-22.1.3-5">This process also applies to requests to change a provisional registration into
a permanent registration, except that the goal is not to determine whether there
is no use of the codepoint, but to determine that the registration is an
accurate representation of any deployed usage.<a href="#section-22.1.3-5" class="pilcrow">¶</a></p>
</section>
</div>
<div id="iana-permanent">
<section id="section-22.1.4">
          <h4 id="name-permanent-registrations">
<a href="#section-22.1.4" class="section-number selfRef">22.1.4. </a><a href="#name-permanent-registrations" class="section-name selfRef">Permanent Registrations</a>
          </h4>
<p id="section-22.1.4-1">Permanent registrations in QUIC registries use the Specification Required policy
<span>[<a href="#RFC8126" class="xref">RFC8126</a>]</span>, unless otherwise specified.  The designated expert(s) verify that
a specification exists and is readily accessible.  Expert(s) are encouraged to
be biased towards approving registrations unless they are abusive, frivolous, or
actively harmful (not merely aesthetically displeasing, or architecturally
dubious).  The creation of a registry MAY specify additional constraints on
permanent registrations.<a href="#section-22.1.4-1" class="pilcrow">¶</a></p>
<p id="section-22.1.4-2">The creation of a registries MAY identify a range of codepoints where
registrations are governed by a different registration policy.  For instance,
the registries for 62-bit codepoints in this document have stricter policies for
codepoints in the range from 0 to 63.<a href="#section-22.1.4-2" class="pilcrow">¶</a></p>
<p id="section-22.1.4-3">Any stricter requirements for permanent registrations do not prevent provisional
registrations for affected codepoints.  For instance, a provisional registration
for a frame type <a href="#iana-frames" class="xref">Section 22.3</a> of 61 could be requested.<a href="#section-22.1.4-3" class="pilcrow">¶</a></p>
<p id="section-22.1.4-4">All registrations made by Standards Track publications MUST be permanent.<a href="#section-22.1.4-4" class="pilcrow">¶</a></p>
<p id="section-22.1.4-5">All registrations in this document are assigned a permanent status and list as
contact both the IESG (ietf@ietf.org) and the QUIC working group
(<a href="mailto:quic@ietf.org">quic@ietf.org</a>).<a href="#section-22.1.4-5" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="iana-transport-parameters">
<section id="section-22.2">
        <h3 id="name-quic-transport-parameter-re">
<a href="#section-22.2" class="section-number selfRef">22.2. </a><a href="#name-quic-transport-parameter-re" class="section-name selfRef">QUIC Transport Parameter Registry</a>
        </h3>
<p id="section-22.2-1">IANA [SHALL add/has added] a registry for "QUIC Transport Parameters" under a
"QUIC" heading.<a href="#section-22.2-1" class="pilcrow">¶</a></p>
<p id="section-22.2-2">The "QUIC Transport Parameters" registry governs a 62-bit space.  This registry
follows the registration policy from <a href="#iana-policy" class="xref">Section 22.1</a>.  Permanent registrations
in this registry are assigned using the Specification Required policy
<span>[<a href="#RFC8126" class="xref">RFC8126</a>]</span>.<a href="#section-22.2-2" class="pilcrow">¶</a></p>
<p id="section-22.2-3">In addition to the fields in <a href="#iana-provisional" class="xref">Section 22.1.1</a>, permanent registrations in
this registry MUST include the following fields:<a href="#section-22.2-3" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-22.2-4">
          <dt id="section-22.2-4.1">Parameter Name:</dt>
<dd id="section-22.2-4.2">
  A short mnemonic for the parameter.<a href="#section-22.2-4.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-22.2-5">The initial contents of this registry are shown in <a href="#iana-tp-table" class="xref">Table 6</a>.<a href="#section-22.2-5" class="pilcrow">¶</a></p>
<span id="name-initial-quic-transport-para"></span><div id="iana-tp-table">
<table class="center" id="table-6">
          <caption>
<a href="#table-6" class="selfRef">Table 6</a>:
<a href="#name-initial-quic-transport-para" class="selfRef">Initial QUIC Transport Parameters Entries</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Value</th>
              <th class="text-left" rowspan="1" colspan="1">Parameter Name</th>
              <th class="text-left" rowspan="1" colspan="1">Specification</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x00</td>
              <td class="text-left" rowspan="1" colspan="1">original_destination_connection_id</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x01</td>
              <td class="text-left" rowspan="1" colspan="1">max_idle_timeout</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x02</td>
              <td class="text-left" rowspan="1" colspan="1">stateless_reset_token</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x03</td>
              <td class="text-left" rowspan="1" colspan="1">max_udp_payload_size</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x04</td>
              <td class="text-left" rowspan="1" colspan="1">initial_max_data</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x05</td>
              <td class="text-left" rowspan="1" colspan="1">initial_max_stream_data_bidi_local</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x06</td>
              <td class="text-left" rowspan="1" colspan="1">initial_max_stream_data_bidi_remote</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x07</td>
              <td class="text-left" rowspan="1" colspan="1">initial_max_stream_data_uni</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x08</td>
              <td class="text-left" rowspan="1" colspan="1">initial_max_streams_bidi</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x09</td>
              <td class="text-left" rowspan="1" colspan="1">initial_max_streams_uni</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x0a</td>
              <td class="text-left" rowspan="1" colspan="1">ack_delay_exponent</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x0b</td>
              <td class="text-left" rowspan="1" colspan="1">max_ack_delay</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x0c</td>
              <td class="text-left" rowspan="1" colspan="1">disable_active_migration</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x0d</td>
              <td class="text-left" rowspan="1" colspan="1">preferred_address</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x0e</td>
              <td class="text-left" rowspan="1" colspan="1">active_connection_id_limit</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x0f</td>
              <td class="text-left" rowspan="1" colspan="1">initial_source_connection_id</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x10</td>
              <td class="text-left" rowspan="1" colspan="1">retry_source_connection_id</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#transport-parameter-definitions" class="xref">Section 18.2</a>
</td>
            </tr>
          </tbody>
        </table>
</div>
<p id="section-22.2-7">Additionally, each value of the format <code>31 * N + 27</code> for integer values of N
(that is, 27, 58, 89, ...) are reserved and MUST NOT be assigned by IANA.<a href="#section-22.2-7" class="pilcrow">¶</a></p>
</section>
</div>
<div id="iana-frames">
<section id="section-22.3">
        <h3 id="name-quic-frame-type-registry">
<a href="#section-22.3" class="section-number selfRef">22.3. </a><a href="#name-quic-frame-type-registry" class="section-name selfRef">QUIC Frame Type Registry</a>
        </h3>
<p id="section-22.3-1">IANA [SHALL add/has added] a registry for "QUIC Frame Types" under a
"QUIC" heading.<a href="#section-22.3-1" class="pilcrow">¶</a></p>
<p id="section-22.3-2">The "QUIC Frame Types" registry governs a 62-bit space.  This registry follows
the registration policy from <a href="#iana-policy" class="xref">Section 22.1</a>.  Permanent registrations in this
registry are assigned using the Specification Required policy <span>[<a href="#RFC8126" class="xref">RFC8126</a>]</span>,
except for values between 0x00 and 0x3f (in hexadecimal; inclusive), which are
assigned using Standards Action or IESG Approval as defined in Section 4.9 and
4.10 of <span>[<a href="#RFC8126" class="xref">RFC8126</a>]</span>.<a href="#section-22.3-2" class="pilcrow">¶</a></p>
<p id="section-22.3-3">In addition to the fields in <a href="#iana-provisional" class="xref">Section 22.1.1</a>, permanent registrations in
this registry MUST include the following fields:<a href="#section-22.3-3" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-22.3-4">
          <dt id="section-22.3-4.1">Frame Name:</dt>
<dd id="section-22.3-4.2">
  A short mnemonic for the frame type.<a href="#section-22.3-4.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-22.3-5">In addition to the advice in <a href="#iana-policy" class="xref">Section 22.1</a>, specifications for new permanent
registrations SHOULD describe the means by which an endpoint might determine
that it can send the identified type of frame.  An accompanying transport
parameter registration is expected for most registrations; see
<a href="#iana-transport-parameters" class="xref">Section 22.2</a>.  Specifications for permanent registrations also
needs to describe the format and assigned semantics of any fields in the frame.<a href="#section-22.3-5" class="pilcrow">¶</a></p>
<p id="section-22.3-6">The initial contents of this registry are tabulated in <a href="#frame-types" class="xref">Table 3</a>.<a href="#section-22.3-6" class="pilcrow">¶</a></p>
</section>
</div>
<div id="iana-error-codes">
<section id="section-22.4">
        <h3 id="name-quic-transport-error-codes-">
<a href="#section-22.4" class="section-number selfRef">22.4. </a><a href="#name-quic-transport-error-codes-" class="section-name selfRef">QUIC Transport Error Codes Registry</a>
        </h3>
<p id="section-22.4-1">IANA [SHALL add/has added] a registry for "QUIC Transport Error Codes" under a
"QUIC" heading.<a href="#section-22.4-1" class="pilcrow">¶</a></p>
<p id="section-22.4-2">The "QUIC Transport Error Codes" registry governs a 62-bit space.  This space is
split into three spaces that are governed by different policies.  Permanent
registrations in this registry are assigned using the Specification Required
policy <span>[<a href="#RFC8126" class="xref">RFC8126</a>]</span>, except for values between 0x00 and 0x3f (in hexadecimal;
inclusive), which are assigned using Standards Action or IESG Approval as
defined in Section 4.9 and 4.10 of <span>[<a href="#RFC8126" class="xref">RFC8126</a>]</span>.<a href="#section-22.4-2" class="pilcrow">¶</a></p>
<p id="section-22.4-3">In addition to the fields in <a href="#iana-provisional" class="xref">Section 22.1.1</a>, permanent registrations in
this registry MUST include the following fields:<a href="#section-22.4-3" class="pilcrow">¶</a></p>
<dl class="dlParallel" id="section-22.4-4">
          <dt id="section-22.4-4.1">Code:</dt>
<dd id="section-22.4-4.2">
  A short mnemonic for the parameter.<a href="#section-22.4-4.2" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
<dt id="section-22.4-4.3">Description:</dt>
<dd id="section-22.4-4.4">
  A brief description of the error code semantics, which MAY be a summary if a
specification reference is provided.<a href="#section-22.4-4.4" class="pilcrow">¶</a>
</dd>
<dd class="break"></dd>
</dl>
<p id="section-22.4-5">The initial contents of this registry are shown in <a href="#iana-error-table" class="xref">Table 7</a>.<a href="#section-22.4-5" class="pilcrow">¶</a></p>
<span id="name-initial-quic-transport-erro"></span><div id="iana-error-table">
<table class="center" id="table-7">
          <caption>
<a href="#table-7" class="selfRef">Table 7</a>:
<a href="#name-initial-quic-transport-erro" class="selfRef">Initial QUIC Transport Error Codes Entries</a>
          </caption>
<thead>
            <tr>
              <th class="text-left" rowspan="1" colspan="1">Value</th>
              <th class="text-left" rowspan="1" colspan="1">Error</th>
              <th class="text-left" rowspan="1" colspan="1">Description</th>
              <th class="text-left" rowspan="1" colspan="1">Specification</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x0</td>
              <td class="text-left" rowspan="1" colspan="1">NO_ERROR</td>
              <td class="text-left" rowspan="1" colspan="1">No error</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#error-codes" class="xref">Section 20</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x1</td>
              <td class="text-left" rowspan="1" colspan="1">INTERNAL_ERROR</td>
              <td class="text-left" rowspan="1" colspan="1">Implementation error</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#error-codes" class="xref">Section 20</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x2</td>
              <td class="text-left" rowspan="1" colspan="1">SERVER_BUSY</td>
              <td class="text-left" rowspan="1" colspan="1">Server currently busy</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#error-codes" class="xref">Section 20</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x3</td>
              <td class="text-left" rowspan="1" colspan="1">FLOW_CONTROL_ERROR</td>
              <td class="text-left" rowspan="1" colspan="1">Flow control error</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#error-codes" class="xref">Section 20</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x4</td>
              <td class="text-left" rowspan="1" colspan="1">STREAM_LIMIT_ERROR</td>
              <td class="text-left" rowspan="1" colspan="1">Too many streams opened</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#error-codes" class="xref">Section 20</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x5</td>
              <td class="text-left" rowspan="1" colspan="1">STREAM_STATE_ERROR</td>
              <td class="text-left" rowspan="1" colspan="1">Frame received in invalid stream state</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#error-codes" class="xref">Section 20</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x6</td>
              <td class="text-left" rowspan="1" colspan="1">FINAL_SIZE_ERROR</td>
              <td class="text-left" rowspan="1" colspan="1">Change to final size</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#error-codes" class="xref">Section 20</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x7</td>
              <td class="text-left" rowspan="1" colspan="1">FRAME_ENCODING_ERROR</td>
              <td class="text-left" rowspan="1" colspan="1">Frame encoding error</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#error-codes" class="xref">Section 20</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x8</td>
              <td class="text-left" rowspan="1" colspan="1">TRANSPORT_PARAMETER_ERROR</td>
              <td class="text-left" rowspan="1" colspan="1">Error in transport parameters</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#error-codes" class="xref">Section 20</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0x9</td>
              <td class="text-left" rowspan="1" colspan="1">CONNECTION_ID_LIMIT_ERROR</td>
              <td class="text-left" rowspan="1" colspan="1">Too many connection IDs received</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#error-codes" class="xref">Section 20</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0xA</td>
              <td class="text-left" rowspan="1" colspan="1">PROTOCOL_VIOLATION</td>
              <td class="text-left" rowspan="1" colspan="1">Generic protocol violation</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#error-codes" class="xref">Section 20</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0xB</td>
              <td class="text-left" rowspan="1" colspan="1">INVALID_TOKEN</td>
              <td class="text-left" rowspan="1" colspan="1">Invalid Token Received</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#error-codes" class="xref">Section 20</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0xC</td>
              <td class="text-left" rowspan="1" colspan="1">APPLICATION_ERROR</td>
              <td class="text-left" rowspan="1" colspan="1">Application error</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#error-codes" class="xref">Section 20</a>
</td>
            </tr>
            <tr>
              <td class="text-left" rowspan="1" colspan="1">0xD</td>
              <td class="text-left" rowspan="1" colspan="1">CRYPTO_BUFFER_EXCEEDED</td>
              <td class="text-left" rowspan="1" colspan="1">CRYPTO data buffer overflowed</td>
              <td class="text-left" rowspan="1" colspan="1">
                <a href="#error-codes" class="xref">Section 20</a>
</td>
            </tr>
          </tbody>
        </table>
</div>
</section>
</div>
</section>
</div>
<section id="section-23">
      <h2 id="name-references">
<a href="#section-23" class="section-number selfRef">23. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<section id="section-23.1">
        <h3 id="name-normative-references">
<a href="#section-23.1" class="section-number selfRef">23.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="DPLPMTUD">[DPLPMTUD]</dt>
<dd>
<span class="refAuthor">Fairhurst, G.</span><span class="refAuthor">, Jones, T.</span><span class="refAuthor">, Tuexen, M.</span><span class="refAuthor">, Ruengeler, I.</span><span class="refAuthor">, and T. Voelker</span>, <span class="refTitle">"Packetization Layer Path MTU Discovery for Datagram Transports"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-tsvwg-datagram-plpmtud-21</span>, <time datetime="2020-05-12">12 May 2020</time>, <span>&lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-tsvwg-datagram-plpmtud-21.txt">http://www.ietf.org/internet-drafts/draft-ietf-tsvwg-datagram-plpmtud-21.txt</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="IPv4">[IPv4]</dt>
<dd>
<span class="refAuthor">Postel, J.</span>, <span class="refTitle">"Internet Protocol"</span>, <span class="seriesInfo">STD 5</span>, <span class="seriesInfo">RFC 791</span>, <span class="seriesInfo">DOI 10.17487/RFC0791</span>, <time datetime="1981-09">September 1981</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc791">https://www.rfc-editor.org/info/rfc791</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="QUIC-RECOVERY">[QUIC-RECOVERY]</dt>
<dd>
<span class="refAuthor">Iyengar, J., Ed.</span><span class="refAuthor"> and I. Swett, Ed.</span>, <span class="refTitle">"QUIC Loss Detection and Congestion Control"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-quic-recovery-28</span>, <time datetime="2020-05-20">20 May 2020</time>, <span>&lt;<a href="https://tools.ietf.org/html/draft-ietf-quic-recovery-28">https://tools.ietf.org/html/draft-ietf-quic-recovery-28</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="QUIC-TLS">[QUIC-TLS]</dt>
<dd>
<span class="refAuthor">Thomson, M., Ed.</span><span class="refAuthor"> and S. Turner, Ed.</span>, <span class="refTitle">"Using Transport Layer Security (TLS) to Secure QUIC"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-quic-tls-28</span>, <time datetime="2020-05-20">20 May 2020</time>, <span>&lt;<a href="https://tools.ietf.org/html/draft-ietf-quic-tls-28">https://tools.ietf.org/html/draft-ietf-quic-tls-28</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC1191">[RFC1191]</dt>
<dd>
<span class="refAuthor">Mogul, J.C.</span><span class="refAuthor"> and S.E. Deering</span>, <span class="refTitle">"Path MTU discovery"</span>, <span class="seriesInfo">RFC 1191</span>, <span class="seriesInfo">DOI 10.17487/RFC1191</span>, <time datetime="1990-11">November 1990</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc1191">https://www.rfc-editor.org/info/rfc1191</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2119">[RFC2119]</dt>
<dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3168">[RFC3168]</dt>
<dd>
<span class="refAuthor">Ramakrishnan, K.</span><span class="refAuthor">, Floyd, S.</span><span class="refAuthor">, and D. Black</span>, <span class="refTitle">"The Addition of Explicit Congestion Notification (ECN) to IP"</span>, <span class="seriesInfo">RFC 3168</span>, <span class="seriesInfo">DOI 10.17487/RFC3168</span>, <time datetime="2001-09">September 2001</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3168">https://www.rfc-editor.org/info/rfc3168</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3629">[RFC3629]</dt>
<dd>
<span class="refAuthor">Yergeau, F.</span>, <span class="refTitle">"UTF-8, a transformation format of ISO 10646"</span>, <span class="seriesInfo">STD 63</span>, <span class="seriesInfo">RFC 3629</span>, <span class="seriesInfo">DOI 10.17487/RFC3629</span>, <time datetime="2003-11">November 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3629">https://www.rfc-editor.org/info/rfc3629</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4086">[RFC4086]</dt>
<dd>
<span class="refAuthor">Eastlake 3rd, D.</span><span class="refAuthor">, Schiller, J.</span><span class="refAuthor">, and S. Crocker</span>, <span class="refTitle">"Randomness Requirements for Security"</span>, <span class="seriesInfo">BCP 106</span>, <span class="seriesInfo">RFC 4086</span>, <span class="seriesInfo">DOI 10.17487/RFC4086</span>, <time datetime="2005-06">June 2005</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4086">https://www.rfc-editor.org/info/rfc4086</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5116">[RFC5116]</dt>
<dd>
<span class="refAuthor">McGrew, D.</span>, <span class="refTitle">"An Interface and Algorithms for Authenticated Encryption"</span>, <span class="seriesInfo">RFC 5116</span>, <span class="seriesInfo">DOI 10.17487/RFC5116</span>, <time datetime="2008-01">January 2008</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5116">https://www.rfc-editor.org/info/rfc5116</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6437">[RFC6437]</dt>
<dd>
<span class="refAuthor">Amante, S.</span><span class="refAuthor">, Carpenter, B.</span><span class="refAuthor">, Jiang, S.</span><span class="refAuthor">, and J. Rajahalme</span>, <span class="refTitle">"IPv6 Flow Label Specification"</span>, <span class="seriesInfo">RFC 6437</span>, <span class="seriesInfo">DOI 10.17487/RFC6437</span>, <time datetime="2011-11">November 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6437">https://www.rfc-editor.org/info/rfc6437</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8085">[RFC8085]</dt>
<dd>
<span class="refAuthor">Eggert, L.</span><span class="refAuthor">, Fairhurst, G.</span><span class="refAuthor">, and G. Shepherd</span>, <span class="refTitle">"UDP Usage Guidelines"</span>, <span class="seriesInfo">BCP 145</span>, <span class="seriesInfo">RFC 8085</span>, <span class="seriesInfo">DOI 10.17487/RFC8085</span>, <time datetime="2017-03">March 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8085">https://www.rfc-editor.org/info/rfc8085</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8126">[RFC8126]</dt>
<dd>
<span class="refAuthor">Cotton, M.</span><span class="refAuthor">, Leiba, B.</span><span class="refAuthor">, and T. Narten</span>, <span class="refTitle">"Guidelines for Writing an IANA Considerations Section in RFCs"</span>, <span class="seriesInfo">BCP 26</span>, <span class="seriesInfo">RFC 8126</span>, <span class="seriesInfo">DOI 10.17487/RFC8126</span>, <time datetime="2017-06">June 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8126">https://www.rfc-editor.org/info/rfc8126</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
<dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8201">[RFC8201]</dt>
<dd>
<span class="refAuthor">McCann, J.</span><span class="refAuthor">, Deering, S.</span><span class="refAuthor">, Mogul, J.</span><span class="refAuthor">, and R. Hinden, Ed.</span>, <span class="refTitle">"Path MTU Discovery for IP version 6"</span>, <span class="seriesInfo">STD 87</span>, <span class="seriesInfo">RFC 8201</span>, <span class="seriesInfo">DOI 10.17487/RFC8201</span>, <time datetime="2017-07">July 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8201">https://www.rfc-editor.org/info/rfc8201</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8311">[RFC8311]</dt>
<dd>
<span class="refAuthor">Black, D.</span>, <span class="refTitle">"Relaxing Restrictions on Explicit Congestion Notification (ECN) Experimentation"</span>, <span class="seriesInfo">RFC 8311</span>, <span class="seriesInfo">DOI 10.17487/RFC8311</span>, <time datetime="2018-01">January 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8311">https://www.rfc-editor.org/info/rfc8311</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="TLS13">[TLS13]</dt>
<dd>
<span class="refAuthor">Rescorla, E.</span>, <span class="refTitle">"The Transport Layer Security (TLS) Protocol Version 1.3"</span>, <span class="seriesInfo">RFC 8446</span>, <span class="seriesInfo">DOI 10.17487/RFC8446</span>, <time datetime="2018-08">August 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8446">https://www.rfc-editor.org/info/rfc8446</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
<section id="section-23.2">
        <h3 id="name-informative-references">
<a href="#section-23.2" class="section-number selfRef">23.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="ALTSVC">[ALTSVC]</dt>
<dd>
<span class="refAuthor">Nottingham, M.</span><span class="refAuthor">, McManus, P.</span><span class="refAuthor">, and J. Reschke</span>, <span class="refTitle">"HTTP Alternative Services"</span>, <span class="seriesInfo">RFC 7838</span>, <span class="seriesInfo">DOI 10.17487/RFC7838</span>, <time datetime="2016-04">April 2016</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7838">https://www.rfc-editor.org/info/rfc7838</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="EARLY-DESIGN">[EARLY-DESIGN]</dt>
<dd>
<span class="refAuthor">Roskind, J.</span>, <span class="refTitle">"QUIC: Multiplexed Transport Over UDP"</span>, <time datetime="2013-12-02">2 December 2013</time>, <span>&lt;<a href="https://goo.gl/dMVtFi">https://goo.gl/dMVtFi</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="HTTP2">[HTTP2]</dt>
<dd>
<span class="refAuthor">Belshe, M.</span><span class="refAuthor">, Peon, R.</span><span class="refAuthor">, and M. Thomson, Ed.</span>, <span class="refTitle">"Hypertext Transfer Protocol Version 2 (HTTP/2)"</span>, <span class="seriesInfo">RFC 7540</span>, <span class="seriesInfo">DOI 10.17487/RFC7540</span>, <time datetime="2015-05">May 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7540">https://www.rfc-editor.org/info/rfc7540</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="QUIC-INVARIANTS">[QUIC-INVARIANTS]</dt>
<dd>
<span class="refAuthor">Thomson, M.</span>, <span class="refTitle">"Version-Independent Properties of QUIC"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-quic-invariants-08</span>, <time datetime="2020-05-20">20 May 2020</time>, <span>&lt;<a href="https://tools.ietf.org/html/draft-ietf-quic-invariants-08">https://tools.ietf.org/html/draft-ietf-quic-invariants-08</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="QUIC-MANAGEABILITY">[QUIC-MANAGEABILITY]</dt>
<dd>
<span class="refAuthor">Kuehlewind, M.</span><span class="refAuthor"> and B. Trammell</span>, <span class="refTitle">"Manageability of the QUIC Transport Protocol"</span>, <span class="refContent">Work in Progress</span>, <span class="seriesInfo">Internet-Draft, draft-ietf-quic-manageability-06</span>, <time datetime="2020-01-06">6 January 2020</time>, <span>&lt;<a href="http://www.ietf.org/internet-drafts/draft-ietf-quic-manageability-06.txt">http://www.ietf.org/internet-drafts/draft-ietf-quic-manageability-06.txt</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC1812">[RFC1812]</dt>
<dd>
<span class="refAuthor">Baker, F., Ed.</span>, <span class="refTitle">"Requirements for IP Version 4 Routers"</span>, <span class="seriesInfo">RFC 1812</span>, <span class="seriesInfo">DOI 10.17487/RFC1812</span>, <time datetime="1995-06">June 1995</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc1812">https://www.rfc-editor.org/info/rfc1812</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2018">[RFC2018]</dt>
<dd>
<span class="refAuthor">Mathis, M.</span><span class="refAuthor">, Mahdavi, J.</span><span class="refAuthor">, Floyd, S.</span><span class="refAuthor">, and A. Romanow</span>, <span class="refTitle">"TCP Selective Acknowledgment Options"</span>, <span class="seriesInfo">RFC 2018</span>, <span class="seriesInfo">DOI 10.17487/RFC2018</span>, <time datetime="1996-10">October 1996</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2018">https://www.rfc-editor.org/info/rfc2018</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC2104">[RFC2104]</dt>
<dd>
<span class="refAuthor">Krawczyk, H.</span><span class="refAuthor">, Bellare, M.</span><span class="refAuthor">, and R. Canetti</span>, <span class="refTitle">"HMAC: Keyed-Hashing for Message Authentication"</span>, <span class="seriesInfo">RFC 2104</span>, <span class="seriesInfo">DOI 10.17487/RFC2104</span>, <time datetime="1997-02">February 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2104">https://www.rfc-editor.org/info/rfc2104</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4303">[RFC4303]</dt>
<dd>
<span class="refAuthor">Kent, S.</span>, <span class="refTitle">"IP Encapsulating Security Payload (ESP)"</span>, <span class="seriesInfo">RFC 4303</span>, <span class="seriesInfo">DOI 10.17487/RFC4303</span>, <time datetime="2005-12">December 2005</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4303">https://www.rfc-editor.org/info/rfc4303</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4443">[RFC4443]</dt>
<dd>
<span class="refAuthor">Conta, A.</span><span class="refAuthor">, Deering, S.</span><span class="refAuthor">, and M. Gupta, Ed.</span>, <span class="refTitle">"Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification"</span>, <span class="seriesInfo">STD 89</span>, <span class="seriesInfo">RFC 4443</span>, <span class="seriesInfo">DOI 10.17487/RFC4443</span>, <time datetime="2006-03">March 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4443">https://www.rfc-editor.org/info/rfc4443</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4787">[RFC4787]</dt>
<dd>
<span class="refAuthor">Audet, F., Ed.</span><span class="refAuthor"> and C. Jennings</span>, <span class="refTitle">"Network Address Translation (NAT) Behavioral Requirements for Unicast UDP"</span>, <span class="seriesInfo">BCP 127</span>, <span class="seriesInfo">RFC 4787</span>, <span class="seriesInfo">DOI 10.17487/RFC4787</span>, <time datetime="2007-01">January 2007</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4787">https://www.rfc-editor.org/info/rfc4787</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5681">[RFC5681]</dt>
<dd>
<span class="refAuthor">Allman, M.</span><span class="refAuthor">, Paxson, V.</span><span class="refAuthor">, and E. Blanton</span>, <span class="refTitle">"TCP Congestion Control"</span>, <span class="seriesInfo">RFC 5681</span>, <span class="seriesInfo">DOI 10.17487/RFC5681</span>, <time datetime="2009-09">September 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5681">https://www.rfc-editor.org/info/rfc5681</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5869">[RFC5869]</dt>
<dd>
<span class="refAuthor">Krawczyk, H.</span><span class="refAuthor"> and P. Eronen</span>, <span class="refTitle">"HMAC-based Extract-and-Expand Key Derivation Function (HKDF)"</span>, <span class="seriesInfo">RFC 5869</span>, <span class="seriesInfo">DOI 10.17487/RFC5869</span>, <time datetime="2010-05">May 2010</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5869">https://www.rfc-editor.org/info/rfc5869</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7301">[RFC7301]</dt>
<dd>
<span class="refAuthor">Friedl, S.</span><span class="refAuthor">, Popov, A.</span><span class="refAuthor">, Langley, A.</span><span class="refAuthor">, and E. Stephan</span>, <span class="refTitle">"Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension"</span>, <span class="seriesInfo">RFC 7301</span>, <span class="seriesInfo">DOI 10.17487/RFC7301</span>, <time datetime="2014-07">July 2014</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7301">https://www.rfc-editor.org/info/rfc7301</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8200">[RFC8200]</dt>
<dd>
<span class="refAuthor">Deering, S.</span><span class="refAuthor"> and R. Hinden</span>, <span class="refTitle">"Internet Protocol, Version 6 (IPv6) Specification"</span>, <span class="seriesInfo">STD 86</span>, <span class="seriesInfo">RFC 8200</span>, <span class="seriesInfo">DOI 10.17487/RFC8200</span>, <time datetime="2017-07">July 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8200">https://www.rfc-editor.org/info/rfc8200</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="SEC-CONS">[SEC-CONS]</dt>
<dd>
<span class="refAuthor">Rescorla, E.</span><span class="refAuthor"> and B. Korver</span>, <span class="refTitle">"Guidelines for Writing RFC Text on Security Considerations"</span>, <span class="seriesInfo">BCP 72</span>, <span class="seriesInfo">RFC 3552</span>, <span class="seriesInfo">DOI 10.17487/RFC3552</span>, <time datetime="2003-07">July 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3552">https://www.rfc-editor.org/info/rfc3552</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="SLOWLORIS">[SLOWLORIS]</dt>
<dd>
<span class="refAuthor">RSnake Hansen, R.</span>, <span class="refTitle">"Welcome to Slowloris..."</span>, <time datetime="2009-06">June 2009</time>, <span>&lt;<a href="https://web.archive.org/web/20150315054838/http://ha.ckers.org/slowloris/">https://web.archive.org/web/20150315054838/http://ha.ckers.org/slowloris/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="STD">[STD]</dt>
<dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"The Internet Standards Process -- Revision 3"</span>, <span class="seriesInfo">BCP 9</span>, <span class="seriesInfo">RFC 2026</span>, <span class="seriesInfo">DOI 10.17487/RFC2026</span>, <time datetime="1996-10">October 1996</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2026">https://www.rfc-editor.org/info/rfc2026</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</section>
<div id="sample-packet-number-decoding">
<section id="section-appendix.a">
      <h2 id="name-sample-packet-number-decodi">
<a href="#section-appendix.a" class="section-number selfRef">Appendix A. </a><a href="#name-sample-packet-number-decodi" class="section-name selfRef">Sample Packet Number Decoding Algorithm</a>
      </h2>
<p id="section-appendix.a-1">The pseudo-code in <a href="#alg-decode-pn" class="xref">Figure 41</a> shows how an implementation can decode
packet numbers after header protection has been removed.<a href="#section-appendix.a-1" class="pilcrow">¶</a></p>
<span id="name-sample-packet-number-decodin"></span><div id="alg-decode-pn">
<figure id="figure-41">
        <div class="artwork art-text alignLeft" id="section-appendix.a-2.1">
<pre>
DecodePacketNumber(largest_pn, truncated_pn, pn_nbits):
   expected_pn  = largest_pn + 1
   pn_win       = 1 &lt;&lt; pn_nbits
   pn_hwin      = pn_win / 2
   pn_mask      = pn_win - 1
   // The incoming packet number should be greater than
   // expected_pn - pn_hwin and less than or equal to
   // expected_pn + pn_hwin
   //
   // This means we can't just strip the trailing bits from
   // expected_pn and add the truncated_pn because that might
   // yield a value outside the window.
   //
   // The following code calculates a candidate value and
   // makes sure it's within the packet number window.
   // Note the extra checks to prevent overflow and underflow.
   candidate_pn = (expected_pn &amp; ~pn_mask) | truncated_pn
   if candidate_pn &lt;= expected_pn - pn_hwin and
      candidate_pn &lt; (1 &lt;&lt; 62) - pn_win:
      return candidate_pn + pn_win
   if candidate_pn &gt; expected_pn + pn_hwin and
      candidate_pn &gt;= pn_win:
      return candidate_pn - pn_win
   return candidate_pn
</pre>
</div>
<figcaption><a href="#figure-41" class="selfRef">Figure 41</a>:
<a href="#name-sample-packet-number-decodin" class="selfRef">Sample Packet Number Decoding Algorithm</a>
        </figcaption></figure>
</div>
</section>
</div>
<div id="ecn-alg">
<section id="section-appendix.b">
      <h2 id="name-sample-ecn-validation-algor">
<a href="#section-appendix.b" class="section-number selfRef">Appendix B. </a><a href="#name-sample-ecn-validation-algor" class="section-name selfRef">Sample ECN Validation Algorithm</a>
      </h2>
<p id="section-appendix.b-1">Each time an endpoint commences sending on a new network path, it determines
whether the path supports ECN; see <a href="#ecn" class="xref">Section 13.4</a>.  If the path supports ECN, the goal
is to use ECN.  Endpoints might also periodically reassess a path that was
determined to not support ECN.<a href="#section-appendix.b-1" class="pilcrow">¶</a></p>
<p id="section-appendix.b-2">This section describes one method for testing new paths.  This algorithm is
intended to show how a path might be tested for ECN support.  Endpoints can
implement different methods.<a href="#section-appendix.b-2" class="pilcrow">¶</a></p>
<p id="section-appendix.b-3">The path is assigned an ECN state that is one of "testing", "unknown", "failed",
or "capable".  On paths with a "testing" or "capable" state the endpoint sends
packets with an ECT marking, by default ECT(0); otherwise, the endpoint sends
unmarked packets.<a href="#section-appendix.b-3" class="pilcrow">¶</a></p>
<p id="section-appendix.b-4">To start testing a path, the ECN state is set to "testing" and existing ECN
counts are remembered as a baseline.<a href="#section-appendix.b-4" class="pilcrow">¶</a></p>
<p id="section-appendix.b-5">The testing period runs for a number of packets or round-trip times, as
determined by the endpoint.  The goal is not to limit the duration of the
testing period, but to ensure that enough marked packets are sent for received
ECN counts to provide a clear indication of how the path treats marked packets.
<a href="#ecn-ack" class="xref">Section 13.4.2.2</a> suggests limiting this to 10 packets or 3 round-trip times.<a href="#section-appendix.b-5" class="pilcrow">¶</a></p>
<p id="section-appendix.b-6">After the testing period ends, the ECN state for the path becomes "unknown".
From the "unknown" state, successful validation of the ECN counts an ACK frame
(see <a href="#ecn-ack" class="xref">Section 13.4.2.2</a>) causes the ECN state for the path to become "capable", unless
no marked packet has been acknowledged.<a href="#section-appendix.b-6" class="pilcrow">¶</a></p>
<p id="section-appendix.b-7">If validation of ECN counts fails at any time, the ECN state for the affected
path becomes "failed".  An endpoint can also mark the ECN state for a path as
"failed" if marked packets are all declared lost or if they are all CE marked.<a href="#section-appendix.b-7" class="pilcrow">¶</a></p>
<p id="section-appendix.b-8">Following this algorithm ensures that ECN is rarely disabled for paths that
properly support ECN.  Any path that incorrectly modifies markings will cause
ECN to be disabled.  For those rare cases where marked packets are discarded by
the path, the short duration of the testing period limits the number of losses
incurred.<a href="#section-appendix.b-8" class="pilcrow">¶</a></p>
</section>
</div>
<div id="change-log">
<section id="section-appendix.c">
      <h2 id="name-change-log">
<a href="#section-appendix.c" class="section-number selfRef">Appendix C. </a><a href="#name-change-log" class="section-name selfRef">Change Log</a>
      </h2>
<ul class="ulEmpty">
<li class="ulEmpty" id="section-appendix.c-1.1">
          <strong>RFC Editor's Note:</strong> Please remove this section prior to publication of a
final version of this document.<a href="#section-appendix.c-1.1" class="pilcrow">¶</a>
</li>
</ul>
<p id="section-appendix.c-2">Issue and pull request numbers are listed with a leading octothorp.<a href="#section-appendix.c-2" class="pilcrow">¶</a></p>
<div id="since-draft-ietf-quic-transport-27">
<section id="section-c.1">
        <h2 id="name-since-draft-ietf-quic-trans">
<a href="#section-c.1" class="section-number selfRef">C.1. </a><a href="#name-since-draft-ietf-quic-trans" class="section-name selfRef">Since draft-ietf-quic-transport-27</a>
        </h2>
<ul>
<li id="section-c.1-1.1">Allowed CONNECTION_CLOSE in any packet number space, with a requirement to
use a new transport-level error for application-specific errors in Initial
and Handshake packets (#3430, #3435, #3440)<a href="#section-c.1-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.1-1.2">Clearer requirements for address validation (#2125, #3327)<a href="#section-c.1-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.1-1.3">Security analysis of handshake and migration (#2143, #2387, #2925)<a href="#section-c.1-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.1-1.4">The entire payload of a datagram is used when counting bytes for
mitigating amplification attacks (#3333, #3470)<a href="#section-c.1-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.1-1.5">Connection IDs can be used at any time, including in the handshake (#3348,
#3560, #3438, #3565)<a href="#section-c.1-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.1-1.6">Only one ACK should be sent for each instance of reordering (#3357, #3361)<a href="#section-c.1-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.1-1.7">Remove text allowing a server to proceed with a bad Retry token (#3396,
#3398)<a href="#section-c.1-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.1-1.8">Ignore active_connection_id_limit with a zero-length connection ID (#3427,
#3426)<a href="#section-c.1-1.8" class="pilcrow">¶</a>
</li>
<li id="section-c.1-1.9">Require active_connection_id_limit be remembered for 0-RTT (#3423, #3425)<a href="#section-c.1-1.9" class="pilcrow">¶</a>
</li>
<li id="section-c.1-1.10">Require ack_delay not be remembered for 0-RTT (#3433, #3545)<a href="#section-c.1-1.10" class="pilcrow">¶</a>
</li>
<li id="section-c.1-1.11">Redefined max_packet_size to max_udp_datagram_size (#3471, #3473)<a href="#section-c.1-1.11" class="pilcrow">¶</a>
</li>
<li id="section-c.1-1.12">Guidance on limiting outstanding attempts to retire connection IDs (#3489,
#3509, #3557, #3547)<a href="#section-c.1-1.12" class="pilcrow">¶</a>
</li>
<li id="section-c.1-1.13">Restored text on dropping bogus Version Negotiation packets (#3532, #3533)<a href="#section-c.1-1.13" class="pilcrow">¶</a>
</li>
<li id="section-c.1-1.14">Clarified that largest acknowledged needs to be saved, but not necessarily
signaled in all cases (#3541, #3581)<a href="#section-c.1-1.14" class="pilcrow">¶</a>
</li>
<li id="section-c.1-1.15">Addressed linkability risk with the use of preferred_address (#3559, #3563)<a href="#section-c.1-1.15" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-26">
<section id="section-c.2">
        <h2 id="name-since-draft-ietf-quic-transp">
<a href="#section-c.2" class="section-number selfRef">C.2. </a><a href="#name-since-draft-ietf-quic-transp" class="section-name selfRef">Since draft-ietf-quic-transport-26</a>
        </h2>
<ul>
<li id="section-c.2-1.1">Change format of transport parameters to use varints (#3294, #3169)<a href="#section-c.2-1.1" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-25">
<section id="section-c.3">
        <h2 id="name-since-draft-ietf-quic-transpo">
<a href="#section-c.3" class="section-number selfRef">C.3. </a><a href="#name-since-draft-ietf-quic-transpo" class="section-name selfRef">Since draft-ietf-quic-transport-25</a>
        </h2>
<ul>
<li id="section-c.3-1.1">Define the use of CONNECTION_CLOSE prior to establishing connection state
(#3269, #3297, #3292)<a href="#section-c.3-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.3-1.2">Allow use of address validation tokens after client address changes (#3307,
#3308)<a href="#section-c.3-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.3-1.3">Define the timer for address validation (#2910, #3339)<a href="#section-c.3-1.3" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-24">
<section id="section-c.4">
        <h2 id="name-since-draft-ietf-quic-transpor">
<a href="#section-c.4" class="section-number selfRef">C.4. </a><a href="#name-since-draft-ietf-quic-transpor" class="section-name selfRef">Since draft-ietf-quic-transport-24</a>
        </h2>
<ul>
<li id="section-c.4-1.1">Added HANDSHAKE_DONE to signal handshake confirmation (#2863, #3142, #3145)<a href="#section-c.4-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.4-1.2">Add integrity check to Retry packets (#3014, #3274, #3120)<a href="#section-c.4-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.4-1.3">Specify handling of reordered NEW_CONNECTION_ID frames (#3194, #3202)<a href="#section-c.4-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.4-1.4">Require checking of sequence numbers in RETIRE_CONNECTION_ID (#3037, #3036)<a href="#section-c.4-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.4-1.5">active_connection_id_limit is enforced (#3193, #3197, #3200, #3201)<a href="#section-c.4-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.4-1.6">Correct overflow in packet number decode algorithm (#3187, #3188)<a href="#section-c.4-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.4-1.7">Allow use of CRYPTO_BUFFER_EXCEEDED for CRYPTO frame errors (#3258, #3186)<a href="#section-c.4-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.4-1.8">Define applicability and scope of NEW_TOKEN (#3150, #3152, #3155, #3156)<a href="#section-c.4-1.8" class="pilcrow">¶</a>
</li>
<li id="section-c.4-1.9">Tokens from Retry and NEW_TOKEN must be differentiated (#3127, #3128)<a href="#section-c.4-1.9" class="pilcrow">¶</a>
</li>
<li id="section-c.4-1.10">Allow CONNECTION_CLOSE in response to invalid token (#3168, #3107)<a href="#section-c.4-1.10" class="pilcrow">¶</a>
</li>
<li id="section-c.4-1.11">Treat an invalid CONNECTION_CLOSE as an invalid frame (#2475, #3230, #3231)<a href="#section-c.4-1.11" class="pilcrow">¶</a>
</li>
<li id="section-c.4-1.12">Throttle when sending CONNECTION_CLOSE after discarding state (#3095, #3157)<a href="#section-c.4-1.12" class="pilcrow">¶</a>
</li>
<li id="section-c.4-1.13">Application-variant of CONNECTION_CLOSE can only be sent in 0-RTT or 1-RTT
packets (#3158, #3164)<a href="#section-c.4-1.13" class="pilcrow">¶</a>
</li>
<li id="section-c.4-1.14">Advise sending while blocked to avoid idle timeout (#2744, #3266)<a href="#section-c.4-1.14" class="pilcrow">¶</a>
</li>
<li id="section-c.4-1.15">Define error codes for invalid frames (#3027, #3042)<a href="#section-c.4-1.15" class="pilcrow">¶</a>
</li>
<li id="section-c.4-1.16">Idle timeout is symmetric (#2602, #3099)<a href="#section-c.4-1.16" class="pilcrow">¶</a>
</li>
<li id="section-c.4-1.17">Prohibit IP fragmentation (#3243, #3280)<a href="#section-c.4-1.17" class="pilcrow">¶</a>
</li>
<li id="section-c.4-1.18">Define the use of provisional registration for all registries (#3109, #3020,
#3102, #3170)<a href="#section-c.4-1.18" class="pilcrow">¶</a>
</li>
<li id="section-c.4-1.19">Packets on one path must not adjust values for a different path (#2909,
#3139)<a href="#section-c.4-1.19" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-23">
<section id="section-c.5">
        <h2 id="name-since-draft-ietf-quic-transport">
<a href="#section-c.5" class="section-number selfRef">C.5. </a><a href="#name-since-draft-ietf-quic-transport" class="section-name selfRef">Since draft-ietf-quic-transport-23</a>
        </h2>
<ul>
<li id="section-c.5-1.1">Allow ClientHello to span multiple packets (#2928, #3045)<a href="#section-c.5-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.5-1.2">Client Initial size constraints apply to UDP datagram payload (#3053, #3051)<a href="#section-c.5-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.5-1.3">
            <p id="section-c.5-1.3.1">Stateless reset changes (#2152, #2993)<a href="#section-c.5-1.3.1" class="pilcrow">¶</a></p>
<ul>
<li id="section-c.5-1.3.2.1">tokens need to be compared in constant time<a href="#section-c.5-1.3.2.1" class="pilcrow">¶</a>
</li>
<li id="section-c.5-1.3.2.2">detection uses UDP datagrams, not packets<a href="#section-c.5-1.3.2.2" class="pilcrow">¶</a>
</li>
<li id="section-c.5-1.3.2.3">tokens cannot be reused (#2785, #2968)<a href="#section-c.5-1.3.2.3" class="pilcrow">¶</a>
</li>
</ul>
</li>
<li id="section-c.5-1.4">Clearer rules for sharing of UDP ports and use of connection IDs when doing so
(#2844, #2851)<a href="#section-c.5-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.5-1.5">A new connection ID is necessary when responding to migration (#2778, #2969)<a href="#section-c.5-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.5-1.6">Stronger requirements for connection ID retirement (#3046, #3096)<a href="#section-c.5-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.5-1.7">NEW_TOKEN cannot be empty (#2978, #2977)<a href="#section-c.5-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.5-1.8">PING can be sent at any encryption level (#3034, #3035)<a href="#section-c.5-1.8" class="pilcrow">¶</a>
</li>
<li id="section-c.5-1.9">CONNECTION_CLOSE is not ack-eliciting (#3097, #3098)<a href="#section-c.5-1.9" class="pilcrow">¶</a>
</li>
<li id="section-c.5-1.10">Frame encoding error conditions updated (#3027, #3042)<a href="#section-c.5-1.10" class="pilcrow">¶</a>
</li>
<li id="section-c.5-1.11">Non-ack-eliciting packets cannot be sent in response to non-ack-eliciting
packets (#3100, #3104)<a href="#section-c.5-1.11" class="pilcrow">¶</a>
</li>
<li id="section-c.5-1.12">Servers have to change connection IDs in Retry (#2837, #3147)<a href="#section-c.5-1.12" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-22">
<section id="section-c.6">
        <h2 id="name-since-draft-ietf-quic-transport-">
<a href="#section-c.6" class="section-number selfRef">C.6. </a><a href="#name-since-draft-ietf-quic-transport-" class="section-name selfRef">Since draft-ietf-quic-transport-22</a>
        </h2>
<ul>
<li id="section-c.6-1.1">Rules for preventing correlation by connection ID tightened (#2084, #2929)<a href="#section-c.6-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.2">Clarified use of CONNECTION_CLOSE in Handshake packets (#2151, #2541, #2688)<a href="#section-c.6-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.3">Discourage regressions of largest acknowledged in ACK (#2205, #2752)<a href="#section-c.6-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.4">Improved robustness of validation process for ECN counts (#2534, #2752)<a href="#section-c.6-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.5">Require endpoints to ignore spurious migration attempts (#2342, #2893)<a href="#section-c.6-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.6">Transport parameter for disabling migration clarified to allow NAT rebinding
(#2389, #2893)<a href="#section-c.6-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.7">Document principles for defining new error codes (#2388, #2880)<a href="#section-c.6-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.8">Reserve transport parameters for greasing (#2550, #2873)<a href="#section-c.6-1.8" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.9">A maximum ACK delay of 0 is used for handshake packet number spaces (#2646,
#2638)<a href="#section-c.6-1.9" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.10">Improved rules for use of congestion control state on new paths (#2685, #2918)<a href="#section-c.6-1.10" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.11">Removed recommendation to coordinate spin for multiple connections that share
a path (#2763, #2882)<a href="#section-c.6-1.11" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.12">Allow smaller stateless resets and recommend a smaller minimum on packets
that might trigger a stateless reset (#2770, #2869, #2927, #3007).<a href="#section-c.6-1.12" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.13">Provide guidance around the interface to QUIC as used by application protocols
(#2805, #2857)<a href="#section-c.6-1.13" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.14">Frames other than STREAM can cause STREAM_LIMIT_ERROR (#2825, #2826)<a href="#section-c.6-1.14" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.15">Tighter rules about processing of rejected 0-RTT packets (#2829, #2840, #2841)<a href="#section-c.6-1.15" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.16">Explanation of the effect of Retry on 0-RTT packets (#2842, #2852)<a href="#section-c.6-1.16" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.17">Cryptographic handshake needs to provide server transport parameter encryption
(#2920, #2921)<a href="#section-c.6-1.17" class="pilcrow">¶</a>
</li>
<li id="section-c.6-1.18">Moved ACK generation guidance from recovery draft to transport draft (#1860,
#2916).<a href="#section-c.6-1.18" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-21">
<section id="section-c.7">
        <h2 id="name-since-draft-ietf-quic-transport-2">
<a href="#section-c.7" class="section-number selfRef">C.7. </a><a href="#name-since-draft-ietf-quic-transport-2" class="section-name selfRef">Since draft-ietf-quic-transport-21</a>
        </h2>
<ul>
<li id="section-c.7-1.1">Connection ID lengths are now one octet, but limited in version 1 to 20 octets
of length (#2736, #2749)<a href="#section-c.7-1.1" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-20">
<section id="section-c.8">
        <h2 id="name-since-draft-ietf-quic-transport-20">
<a href="#section-c.8" class="section-number selfRef">C.8. </a><a href="#name-since-draft-ietf-quic-transport-20" class="section-name selfRef">Since draft-ietf-quic-transport-20</a>
        </h2>
<ul>
<li id="section-c.8-1.1">Error codes are encoded as variable-length integers (#2672, #2680)<a href="#section-c.8-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.2">NEW_CONNECTION_ID includes a request to retire old connection IDs (#2645,
#2769)<a href="#section-c.8-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.3">Tighter rules for generating and explicitly eliciting ACK frames (#2546,
#2794)<a href="#section-c.8-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.4">Recommend having only one packet per encryption level in a datagram (#2308,
#2747)<a href="#section-c.8-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.5">More normative language about use of stateless reset (#2471, #2574)<a href="#section-c.8-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.6">Allow reuse of stateless reset tokens (#2732, #2733)<a href="#section-c.8-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.7">Allow, but not require, enforcing non-duplicate transport parameters (#2689,
#2691)<a href="#section-c.8-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.8">Added an active_connection_id_limit transport parameter (#1994, #1998)<a href="#section-c.8-1.8" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.9">max_ack_delay transport parameter defaults to 0 (#2638, #2646)<a href="#section-c.8-1.9" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.10">When sending 0-RTT, only remembered transport parameters apply (#2458, #2360,
#2466, #2461)<a href="#section-c.8-1.10" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.11">Define handshake completion and confirmation; define clearer rules when it
encryption keys should be discarded (#2214, #2267, #2673)<a href="#section-c.8-1.11" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.12">Prohibit path migration prior to handshake confirmation (#2309, #2370)<a href="#section-c.8-1.12" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.13">PATH_RESPONSE no longer needs to be received on the validated path (#2582,
#2580, #2579, #2637)<a href="#section-c.8-1.13" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.14">PATH_RESPONSE frames are not stored and retransmitted (#2724, #2729)<a href="#section-c.8-1.14" class="pilcrow">¶</a>
</li>
<li id="section-c.8-1.15">Document hack for enabling routing of ICMP when doing PMTU probing (#1243,
#2402)<a href="#section-c.8-1.15" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-19">
<section id="section-c.9">
        <h2 id="name-since-draft-ietf-quic-transport-1">
<a href="#section-c.9" class="section-number selfRef">C.9. </a><a href="#name-since-draft-ietf-quic-transport-1" class="section-name selfRef">Since draft-ietf-quic-transport-19</a>
        </h2>
<ul>
<li id="section-c.9-1.1">Refine discussion of 0-RTT transport parameters (#2467, #2464)<a href="#section-c.9-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.9-1.2">Fewer transport parameters need to be remembered for 0-RTT (#2624, #2467)<a href="#section-c.9-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.9-1.3">Spin bit text incorporated (#2564)<a href="#section-c.9-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.9-1.4">Close the connection when maximum stream ID in MAX_STREAMS exceeds 2^62 - 1
(#2499, #2487)<a href="#section-c.9-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.9-1.5">New connection ID required for intentional migration (#2414, #2413)<a href="#section-c.9-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.9-1.6">Connection ID issuance can be rate-limited (#2436, #2428)<a href="#section-c.9-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.9-1.7">The "QUIC bit" is ignored in Version Negotiation (#2400, #2561)<a href="#section-c.9-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.9-1.8">Initial packets from clients need to be padded to 1200 unless a Handshake
packet is sent as well (#2522, #2523)<a href="#section-c.9-1.8" class="pilcrow">¶</a>
</li>
<li id="section-c.9-1.9">CRYPTO frames can be discarded if too much data is buffered (#1834, #2524)<a href="#section-c.9-1.9" class="pilcrow">¶</a>
</li>
<li id="section-c.9-1.10">Stateless reset uses a short header packet (#2599, #2600)<a href="#section-c.9-1.10" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-18">
<section id="section-c.10">
        <h2 id="name-since-draft-ietf-quic-transport-18">
<a href="#section-c.10" class="section-number selfRef">C.10. </a><a href="#name-since-draft-ietf-quic-transport-18" class="section-name selfRef">Since draft-ietf-quic-transport-18</a>
        </h2>
<ul>
<li id="section-c.10-1.1">Removed version negotiation; version negotiation, including authentication of
the result, will be addressed in the next version of QUIC (#1773, #2313)<a href="#section-c.10-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.10-1.2">Added discussion of the use of IPv6 flow labels (#2348, #2399)<a href="#section-c.10-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.10-1.3">A connection ID can't be retired in a packet that uses that connection ID
(#2101, #2420)<a href="#section-c.10-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.10-1.4">Idle timeout transport parameter is in milliseconds (from seconds) (#2453,
#2454)<a href="#section-c.10-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.10-1.5">Endpoints are required to use new connection IDs when they use new network
paths (#2413, #2414)<a href="#section-c.10-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.10-1.6">Increased the set of permissible frames in 0-RTT (#2344, #2355)<a href="#section-c.10-1.6" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-17">
<section id="section-c.11">
        <h2 id="name-since-draft-ietf-quic-transport-17">
<a href="#section-c.11" class="section-number selfRef">C.11. </a><a href="#name-since-draft-ietf-quic-transport-17" class="section-name selfRef">Since draft-ietf-quic-transport-17</a>
        </h2>
<ul>
<li id="section-c.11-1.1">Stream-related errors now use STREAM_STATE_ERROR (#2305)<a href="#section-c.11-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.11-1.2">Endpoints discard initial keys as soon as handshake keys are available (#1951,
#2045)<a href="#section-c.11-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.11-1.3">Expanded conditions for ignoring ICMP packet too big messages (#2108, #2161)<a href="#section-c.11-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.11-1.4">Remove rate control from PATH_CHALLENGE/PATH_RESPONSE (#2129, #2241)<a href="#section-c.11-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.11-1.5">Endpoints are permitted to discard malformed initial packets (#2141)<a href="#section-c.11-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.11-1.6">Clarified ECN implementation and usage requirements (#2156, #2201)<a href="#section-c.11-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.11-1.7">Disable ECN count verification for packets that arrive out of order (#2198,
#2215)<a href="#section-c.11-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.11-1.8">Use Probe Timeout (PTO) instead of RTO (#2206, #2238)<a href="#section-c.11-1.8" class="pilcrow">¶</a>
</li>
<li id="section-c.11-1.9">Loosen constraints on retransmission of ACK ranges (#2199, #2245)<a href="#section-c.11-1.9" class="pilcrow">¶</a>
</li>
<li id="section-c.11-1.10">Limit Retry and Version Negotiation to once per datagram (#2259, #2303)<a href="#section-c.11-1.10" class="pilcrow">¶</a>
</li>
<li id="section-c.11-1.11">Set a maximum value for max_ack_delay transport parameter (#2282, #2301)<a href="#section-c.11-1.11" class="pilcrow">¶</a>
</li>
<li id="section-c.11-1.12">Allow server preferred address for both IPv4 and IPv6 (#2122, #2296)<a href="#section-c.11-1.12" class="pilcrow">¶</a>
</li>
<li id="section-c.11-1.13">Corrected requirements for migration to a preferred address (#2146, #2349)<a href="#section-c.11-1.13" class="pilcrow">¶</a>
</li>
<li id="section-c.11-1.14">ACK of non-existent packet is illegal (#2298, #2302)<a href="#section-c.11-1.14" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-16">
<section id="section-c.12">
        <h2 id="name-since-draft-ietf-quic-transport-16">
<a href="#section-c.12" class="section-number selfRef">C.12. </a><a href="#name-since-draft-ietf-quic-transport-16" class="section-name selfRef">Since draft-ietf-quic-transport-16</a>
        </h2>
<ul>
<li id="section-c.12-1.1">Stream limits are defined as counts, not maximums (#1850, #1906)<a href="#section-c.12-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.2">Require amplification attack defense after closing (#1905, #1911)<a href="#section-c.12-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.3">Remove reservation of application error code 0 for STOPPING (#1804, #1922)<a href="#section-c.12-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.4">Renumbered frames (#1945)<a href="#section-c.12-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.5">Renumbered transport parameters (#1946)<a href="#section-c.12-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.6">Numeric transport parameters are expressed as varints (#1608, #1947, #1955)<a href="#section-c.12-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.7">Reorder the NEW_CONNECTION_ID frame (#1952, #1963)<a href="#section-c.12-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.8">
            <p id="section-c.12-1.8.1">Rework the first byte (#2006)<a href="#section-c.12-1.8.1" class="pilcrow">¶</a></p>
<ul>
<li id="section-c.12-1.8.2.1">Fix the 0x40 bit<a href="#section-c.12-1.8.2.1" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.8.2.2">Change type values for long header<a href="#section-c.12-1.8.2.2" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.8.2.3">Add spin bit to short header (#631, #1988)<a href="#section-c.12-1.8.2.3" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.8.2.4">Encrypt the remainder of the first byte (#1322)<a href="#section-c.12-1.8.2.4" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.8.2.5">Move packet number length to first byte<a href="#section-c.12-1.8.2.5" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.8.2.6">Move ODCIL to first byte of retry packets<a href="#section-c.12-1.8.2.6" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.8.2.7">Simplify packet number protection (#1575)<a href="#section-c.12-1.8.2.7" class="pilcrow">¶</a>
</li>
</ul>
</li>
<li id="section-c.12-1.9">Allow STOP_SENDING to open a remote bidirectional stream (#1797, #2013)<a href="#section-c.12-1.9" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.10">Added mitigation for off-path migration attacks (#1278, #1749, #2033)<a href="#section-c.12-1.10" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.11">Don't let the PMTU to drop below 1280 (#2063, #2069)<a href="#section-c.12-1.11" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.12">Require peers to replace retired connection IDs (#2085)<a href="#section-c.12-1.12" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.13">Servers are required to ignore Version Negotiation packets (#2088)<a href="#section-c.12-1.13" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.14">Tokens are repeated in all Initial packets (#2089)<a href="#section-c.12-1.14" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.15">Clarified how PING frames are sent after loss (#2094)<a href="#section-c.12-1.15" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.16">Initial keys are discarded once Handshake are available (#1951, #2045)<a href="#section-c.12-1.16" class="pilcrow">¶</a>
</li>
<li id="section-c.12-1.17">ICMP PTB validation clarifications (#2161, #2109, #2108)<a href="#section-c.12-1.17" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-15">
<section id="section-c.13">
        <h2 id="name-since-draft-ietf-quic-transport-15">
<a href="#section-c.13" class="section-number selfRef">C.13. </a><a href="#name-since-draft-ietf-quic-transport-15" class="section-name selfRef">Since draft-ietf-quic-transport-15</a>
        </h2>
<p id="section-c.13-1">Substantial editorial reorganization; no technical changes.<a href="#section-c.13-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="since-draft-ietf-quic-transport-14">
<section id="section-c.14">
        <h2 id="name-since-draft-ietf-quic-transport-14">
<a href="#section-c.14" class="section-number selfRef">C.14. </a><a href="#name-since-draft-ietf-quic-transport-14" class="section-name selfRef">Since draft-ietf-quic-transport-14</a>
        </h2>
<ul>
<li id="section-c.14-1.1">Merge ACK and ACK_ECN (#1778, #1801)<a href="#section-c.14-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.14-1.2">Explicitly communicate max_ack_delay (#981, #1781)<a href="#section-c.14-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.14-1.3">Validate original connection ID after Retry packets (#1710, #1486, #1793)<a href="#section-c.14-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.14-1.4">Idle timeout is optional and has no specified maximum (#1765)<a href="#section-c.14-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.14-1.5">Update connection ID handling; add RETIRE_CONNECTION_ID type (#1464, #1468,
#1483, #1484, #1486, #1495, #1729, #1742, #1799, #1821)<a href="#section-c.14-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.14-1.6">Include a Token in all Initial packets (#1649, #1794)<a href="#section-c.14-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.14-1.7">Prevent handshake deadlock (#1764, #1824)<a href="#section-c.14-1.7" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-13">
<section id="section-c.15">
        <h2 id="name-since-draft-ietf-quic-transport-13">
<a href="#section-c.15" class="section-number selfRef">C.15. </a><a href="#name-since-draft-ietf-quic-transport-13" class="section-name selfRef">Since draft-ietf-quic-transport-13</a>
        </h2>
<ul>
<li id="section-c.15-1.1">Streams open when higher-numbered streams of the same type open (#1342, #1549)<a href="#section-c.15-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.15-1.2">Split initial stream flow control limit into 3 transport parameters (#1016,
#1542)<a href="#section-c.15-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.15-1.3">All flow control transport parameters are optional (#1610)<a href="#section-c.15-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.15-1.4">Removed UNSOLICITED_PATH_RESPONSE error code (#1265, #1539)<a href="#section-c.15-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.15-1.5">Permit stateless reset in response to any packet (#1348, #1553)<a href="#section-c.15-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.15-1.6">Recommended defense against stateless reset spoofing (#1386, #1554)<a href="#section-c.15-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.15-1.7">Prevent infinite stateless reset exchanges (#1443, #1627)<a href="#section-c.15-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.15-1.8">Forbid processing of the same packet number twice (#1405, #1624)<a href="#section-c.15-1.8" class="pilcrow">¶</a>
</li>
<li id="section-c.15-1.9">Added a packet number decoding example (#1493)<a href="#section-c.15-1.9" class="pilcrow">¶</a>
</li>
<li id="section-c.15-1.10">More precisely define idle timeout (#1429, #1614, #1652)<a href="#section-c.15-1.10" class="pilcrow">¶</a>
</li>
<li id="section-c.15-1.11">Corrected format of Retry packet and prevented looping (#1492, #1451, #1448,
#1498)<a href="#section-c.15-1.11" class="pilcrow">¶</a>
</li>
<li id="section-c.15-1.12">Permit 0-RTT after receiving Version Negotiation or Retry (#1507, #1514,
#1621)<a href="#section-c.15-1.12" class="pilcrow">¶</a>
</li>
<li id="section-c.15-1.13">Permit Retry in response to 0-RTT (#1547, #1552)<a href="#section-c.15-1.13" class="pilcrow">¶</a>
</li>
<li id="section-c.15-1.14">Looser verification of ECN counters to account for ACK loss (#1555, #1481,
#1565)<a href="#section-c.15-1.14" class="pilcrow">¶</a>
</li>
<li id="section-c.15-1.15">Remove frame type field from APPLICATION_CLOSE (#1508, #1528)<a href="#section-c.15-1.15" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-12">
<section id="section-c.16">
        <h2 id="name-since-draft-ietf-quic-transport-12">
<a href="#section-c.16" class="section-number selfRef">C.16. </a><a href="#name-since-draft-ietf-quic-transport-12" class="section-name selfRef">Since draft-ietf-quic-transport-12</a>
        </h2>
<ul>
<li id="section-c.16-1.1">
            <p id="section-c.16-1.1.1">Changes to integration of the TLS handshake (#829, #1018, #1094, #1165, #1190,
#1233, #1242, #1252, #1450, #1458)<a href="#section-c.16-1.1.1" class="pilcrow">¶</a></p>
<ul>
<li id="section-c.16-1.1.2.1">The cryptographic handshake uses CRYPTO frames, not stream 0<a href="#section-c.16-1.1.2.1" class="pilcrow">¶</a>
</li>
<li id="section-c.16-1.1.2.2">QUIC packet protection is used in place of TLS record protection<a href="#section-c.16-1.1.2.2" class="pilcrow">¶</a>
</li>
<li id="section-c.16-1.1.2.3">Separate QUIC packet number spaces are used for the handshake<a href="#section-c.16-1.1.2.3" class="pilcrow">¶</a>
</li>
<li id="section-c.16-1.1.2.4">Changed Retry to be independent of the cryptographic handshake<a href="#section-c.16-1.1.2.4" class="pilcrow">¶</a>
</li>
<li id="section-c.16-1.1.2.5">Added NEW_TOKEN frame and Token fields to Initial packet<a href="#section-c.16-1.1.2.5" class="pilcrow">¶</a>
</li>
<li id="section-c.16-1.1.2.6">Limit the use of HelloRetryRequest to address TLS needs (like key shares)<a href="#section-c.16-1.1.2.6" class="pilcrow">¶</a>
</li>
</ul>
</li>
<li id="section-c.16-1.2">Enable server to transition connections to a preferred address (#560, #1251,
#1373)<a href="#section-c.16-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.16-1.3">Added ECN feedback mechanisms and handling; new ACK_ECN frame (#804, #805,
#1372)<a href="#section-c.16-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.16-1.4">Changed rules and recommendations for use of new connection IDs (#1258, #1264,
#1276, #1280, #1419, #1452, #1453, #1465)<a href="#section-c.16-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.16-1.5">Added a transport parameter to disable intentional connection migration
(#1271, #1447)<a href="#section-c.16-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.16-1.6">Packets from different connection ID can't be coalesced (#1287, #1423)<a href="#section-c.16-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.16-1.7">Fixed sampling method for packet number encryption; the length field in long
headers includes the packet number field in addition to the packet payload
(#1387, #1389)<a href="#section-c.16-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.16-1.8">Stateless Reset is now symmetric and subject to size constraints (#466, #1346)<a href="#section-c.16-1.8" class="pilcrow">¶</a>
</li>
<li id="section-c.16-1.9">Added frame type extension mechanism (#58, #1473)<a href="#section-c.16-1.9" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-11">
<section id="section-c.17">
        <h2 id="name-since-draft-ietf-quic-transport-11">
<a href="#section-c.17" class="section-number selfRef">C.17. </a><a href="#name-since-draft-ietf-quic-transport-11" class="section-name selfRef">Since draft-ietf-quic-transport-11</a>
        </h2>
<ul>
<li id="section-c.17-1.1">Enable server to transition connections to a preferred address (#560, #1251)<a href="#section-c.17-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.17-1.2">Packet numbers are encrypted (#1174, #1043, #1048, #1034, #850, #990, #734,
#1317, #1267, #1079)<a href="#section-c.17-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.17-1.3">Packet numbers use a variable-length encoding (#989, #1334)<a href="#section-c.17-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.17-1.4">STREAM frames can now be empty (#1350)<a href="#section-c.17-1.4" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-10">
<section id="section-c.18">
        <h2 id="name-since-draft-ietf-quic-transport-10">
<a href="#section-c.18" class="section-number selfRef">C.18. </a><a href="#name-since-draft-ietf-quic-transport-10" class="section-name selfRef">Since draft-ietf-quic-transport-10</a>
        </h2>
<ul>
<li id="section-c.18-1.1">Swap payload length and packed number fields in long header (#1294)<a href="#section-c.18-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.18-1.2">Clarified that CONNECTION_CLOSE is allowed in Handshake packet (#1274)<a href="#section-c.18-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.18-1.3">Spin bit reserved (#1283)<a href="#section-c.18-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.18-1.4">Coalescing multiple QUIC packets in a UDP datagram (#1262, #1285)<a href="#section-c.18-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.18-1.5">A more complete connection migration (#1249)<a href="#section-c.18-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.18-1.6">Refine opportunistic ACK defense text (#305, #1030, #1185)<a href="#section-c.18-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.18-1.7">A Stateless Reset Token isn't mandatory (#818, #1191)<a href="#section-c.18-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.18-1.8">Removed implicit stream opening (#896, #1193)<a href="#section-c.18-1.8" class="pilcrow">¶</a>
</li>
<li id="section-c.18-1.9">An empty STREAM frame can be used to open a stream without sending data (#901,
#1194)<a href="#section-c.18-1.9" class="pilcrow">¶</a>
</li>
<li id="section-c.18-1.10">Define stream counts in transport parameters rather than a maximum stream ID
(#1023, #1065)<a href="#section-c.18-1.10" class="pilcrow">¶</a>
</li>
<li id="section-c.18-1.11">STOP_SENDING is now prohibited before streams are used (#1050)<a href="#section-c.18-1.11" class="pilcrow">¶</a>
</li>
<li id="section-c.18-1.12">Recommend including ACK in Retry packets and allow PADDING (#1067, #882)<a href="#section-c.18-1.12" class="pilcrow">¶</a>
</li>
<li id="section-c.18-1.13">Endpoints now become closing after an idle timeout (#1178, #1179)<a href="#section-c.18-1.13" class="pilcrow">¶</a>
</li>
<li id="section-c.18-1.14">Remove implication that Version Negotiation is sent when a packet of the wrong
version is received (#1197)<a href="#section-c.18-1.14" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-09">
<section id="section-c.19">
        <h2 id="name-since-draft-ietf-quic-transport-0">
<a href="#section-c.19" class="section-number selfRef">C.19. </a><a href="#name-since-draft-ietf-quic-transport-0" class="section-name selfRef">Since draft-ietf-quic-transport-09</a>
        </h2>
<ul>
<li id="section-c.19-1.1">Added PATH_CHALLENGE and PATH_RESPONSE frames to replace PING with Data and
PONG frame. Changed ACK frame type from 0x0e to 0x0d. (#1091, #725, #1086)<a href="#section-c.19-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.19-1.2">A server can now only send 3 packets without validating the client address
(#38, #1090)<a href="#section-c.19-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.19-1.3">Delivery order of stream data is no longer strongly specified (#252, #1070)<a href="#section-c.19-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.19-1.4">Rework of packet handling and version negotiation (#1038)<a href="#section-c.19-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.19-1.5">Stream 0 is now exempt from flow control until the handshake completes (#1074,
#725, #825, #1082)<a href="#section-c.19-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.19-1.6">Improved retransmission rules for all frame types: information is
retransmitted, not packets or frames (#463, #765, #1095, #1053)<a href="#section-c.19-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.19-1.7">Added an error code for server busy signals (#1137)<a href="#section-c.19-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.19-1.8">Endpoints now set the connection ID that their peer uses.  Connection IDs are
variable length.  Removed the omit_connection_id transport parameter and the
corresponding short header flag. (#1089, #1052, #1146, #821, #745, #821,
#1166, #1151)<a href="#section-c.19-1.8" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-08">
<section id="section-c.20">
        <h2 id="name-since-draft-ietf-quic-transport-08">
<a href="#section-c.20" class="section-number selfRef">C.20. </a><a href="#name-since-draft-ietf-quic-transport-08" class="section-name selfRef">Since draft-ietf-quic-transport-08</a>
        </h2>
<ul>
<li id="section-c.20-1.1">Clarified requirements for BLOCKED usage (#65,  #924)<a href="#section-c.20-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.20-1.2">BLOCKED frame now includes reason for blocking (#452, #924, #927, #928)<a href="#section-c.20-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.20-1.3">GAP limitation in ACK Frame (#613)<a href="#section-c.20-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.20-1.4">Improved PMTUD description (#614, #1036)<a href="#section-c.20-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.20-1.5">Clarified stream state machine (#634, #662, #743, #894)<a href="#section-c.20-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.20-1.6">Reserved versions don't need to be generated deterministically (#831, #931)<a href="#section-c.20-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.20-1.7">You don't always need the draining period (#871)<a href="#section-c.20-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.20-1.8">Stateless reset clarified as version-specific (#930, #986)<a href="#section-c.20-1.8" class="pilcrow">¶</a>
</li>
<li id="section-c.20-1.9">initial_max_stream_id_x transport parameters are optional (#970, #971)<a href="#section-c.20-1.9" class="pilcrow">¶</a>
</li>
<li id="section-c.20-1.10">Ack Delay assumes a default value during the handshake (#1007, #1009)<a href="#section-c.20-1.10" class="pilcrow">¶</a>
</li>
<li id="section-c.20-1.11">Removed transport parameters from NewSessionTicket (#1015)<a href="#section-c.20-1.11" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-07">
<section id="section-c.21">
        <h2 id="name-since-draft-ietf-quic-transport-07">
<a href="#section-c.21" class="section-number selfRef">C.21. </a><a href="#name-since-draft-ietf-quic-transport-07" class="section-name selfRef">Since draft-ietf-quic-transport-07</a>
        </h2>
<ul>
<li id="section-c.21-1.1">The long header now has version before packet number (#926, #939)<a href="#section-c.21-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.21-1.2">Rename and consolidate packet types (#846, #822, #847)<a href="#section-c.21-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.21-1.3">Packet types are assigned new codepoints and the Connection ID Flag is
inverted (#426, #956)<a href="#section-c.21-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.21-1.4">Removed type for Version Negotiation and use Version 0 (#963, #968)<a href="#section-c.21-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.21-1.5">
            <p id="section-c.21-1.5.1">Streams are split into unidirectional and bidirectional (#643, #656, #720,
#872, #175, #885)<a href="#section-c.21-1.5.1" class="pilcrow">¶</a></p>
<ul>
<li id="section-c.21-1.5.2.1">Stream limits now have separate uni- and bi-directional transport parameters
(#909, #958)<a href="#section-c.21-1.5.2.1" class="pilcrow">¶</a>
</li>
<li id="section-c.21-1.5.2.2">Stream limit transport parameters are now optional and default to 0 (#970,
#971)<a href="#section-c.21-1.5.2.2" class="pilcrow">¶</a>
</li>
</ul>
</li>
<li id="section-c.21-1.6">The stream state machine has been split into read and write (#634, #894)<a href="#section-c.21-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.21-1.7">Employ variable-length integer encodings throughout (#595)<a href="#section-c.21-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.21-1.8">
            <p id="section-c.21-1.8.1">Improvements to connection close<a href="#section-c.21-1.8.1" class="pilcrow">¶</a></p>
<ul>
<li id="section-c.21-1.8.2.1">Added distinct closing and draining states (#899, #871)<a href="#section-c.21-1.8.2.1" class="pilcrow">¶</a>
</li>
<li id="section-c.21-1.8.2.2">Draining period can terminate early (#869, #870)<a href="#section-c.21-1.8.2.2" class="pilcrow">¶</a>
</li>
<li id="section-c.21-1.8.2.3">Clarifications about stateless reset (#889, #890)<a href="#section-c.21-1.8.2.3" class="pilcrow">¶</a>
</li>
</ul>
</li>
<li id="section-c.21-1.9">Address validation for connection migration (#161, #732, #878)<a href="#section-c.21-1.9" class="pilcrow">¶</a>
</li>
<li id="section-c.21-1.10">Clearly defined retransmission rules for BLOCKED (#452, #65, #924)<a href="#section-c.21-1.10" class="pilcrow">¶</a>
</li>
<li id="section-c.21-1.11">negotiated_version is sent in server transport parameters (#710, #959)<a href="#section-c.21-1.11" class="pilcrow">¶</a>
</li>
<li id="section-c.21-1.12">Increased the range over which packet numbers are randomized (#864, #850,
#964)<a href="#section-c.21-1.12" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-06">
<section id="section-c.22">
        <h2 id="name-since-draft-ietf-quic-transport-06">
<a href="#section-c.22" class="section-number selfRef">C.22. </a><a href="#name-since-draft-ietf-quic-transport-06" class="section-name selfRef">Since draft-ietf-quic-transport-06</a>
        </h2>
<ul>
<li id="section-c.22-1.1">Replaced FNV-1a with AES-GCM for all "Cleartext" packets (#554)<a href="#section-c.22-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.22-1.2">Split error code space between application and transport (#485)<a href="#section-c.22-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.22-1.3">Stateless reset token moved to end (#820)<a href="#section-c.22-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.22-1.4">1-RTT-protected long header types removed (#848)<a href="#section-c.22-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.22-1.5">No acknowledgments during draining period (#852)<a href="#section-c.22-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.22-1.6">Remove "application close" as a separate close type (#854)<a href="#section-c.22-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.22-1.7">Remove timestamps from the ACK frame (#841)<a href="#section-c.22-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.22-1.8">Require transport parameters to only appear once (#792)<a href="#section-c.22-1.8" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-05">
<section id="section-c.23">
        <h2 id="name-since-draft-ietf-quic-transport-05">
<a href="#section-c.23" class="section-number selfRef">C.23. </a><a href="#name-since-draft-ietf-quic-transport-05" class="section-name selfRef">Since draft-ietf-quic-transport-05</a>
        </h2>
<ul>
<li id="section-c.23-1.1">Stateless token is server-only (#726)<a href="#section-c.23-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.23-1.2">Refactor section on connection termination (#733, #748, #328, #177)<a href="#section-c.23-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.23-1.3">Limit size of Version Negotiation packet (#585)<a href="#section-c.23-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.23-1.4">Clarify when and what to ack (#736)<a href="#section-c.23-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.23-1.5">Renamed STREAM_ID_NEEDED to STREAM_ID_BLOCKED<a href="#section-c.23-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.23-1.6">Clarify Keep-alive requirements (#729)<a href="#section-c.23-1.6" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-04">
<section id="section-c.24">
        <h2 id="name-since-draft-ietf-quic-transport-04">
<a href="#section-c.24" class="section-number selfRef">C.24. </a><a href="#name-since-draft-ietf-quic-transport-04" class="section-name selfRef">Since draft-ietf-quic-transport-04</a>
        </h2>
<ul>
<li id="section-c.24-1.1">Introduce STOP_SENDING frame, RESET_STREAM only resets in one direction (#165)<a href="#section-c.24-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.24-1.2">Removed GOAWAY; application protocols are responsible for graceful shutdown
(#696)<a href="#section-c.24-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.24-1.3">Reduced the number of error codes (#96, #177, #184, #211)<a href="#section-c.24-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.24-1.4">Version validation fields can't move or change (#121)<a href="#section-c.24-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.24-1.5">Removed versions from the transport parameters in a NewSessionTicket message
(#547)<a href="#section-c.24-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.24-1.6">Clarify the meaning of "bytes in flight" (#550)<a href="#section-c.24-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.24-1.7">Public reset is now stateless reset and not visible to the path (#215)<a href="#section-c.24-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.24-1.8">Reordered bits and fields in STREAM frame (#620)<a href="#section-c.24-1.8" class="pilcrow">¶</a>
</li>
<li id="section-c.24-1.9">Clarifications to the stream state machine (#572, #571)<a href="#section-c.24-1.9" class="pilcrow">¶</a>
</li>
<li id="section-c.24-1.10">Increased the maximum length of the Largest Acknowledged field in ACK frames
to 64 bits (#629)<a href="#section-c.24-1.10" class="pilcrow">¶</a>
</li>
<li id="section-c.24-1.11">truncate_connection_id is renamed to omit_connection_id (#659)<a href="#section-c.24-1.11" class="pilcrow">¶</a>
</li>
<li id="section-c.24-1.12">CONNECTION_CLOSE terminates the connection like TCP RST (#330, #328)<a href="#section-c.24-1.12" class="pilcrow">¶</a>
</li>
<li id="section-c.24-1.13">Update labels used in HKDF-Expand-Label to match TLS 1.3 (#642)<a href="#section-c.24-1.13" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-03">
<section id="section-c.25">
        <h2 id="name-since-draft-ietf-quic-transport-03">
<a href="#section-c.25" class="section-number selfRef">C.25. </a><a href="#name-since-draft-ietf-quic-transport-03" class="section-name selfRef">Since draft-ietf-quic-transport-03</a>
        </h2>
<ul>
<li id="section-c.25-1.1">Change STREAM and RESET_STREAM layout<a href="#section-c.25-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.25-1.2">Add MAX_STREAM_ID settings<a href="#section-c.25-1.2" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-02">
<section id="section-c.26">
        <h2 id="name-since-draft-ietf-quic-transport-02">
<a href="#section-c.26" class="section-number selfRef">C.26. </a><a href="#name-since-draft-ietf-quic-transport-02" class="section-name selfRef">Since draft-ietf-quic-transport-02</a>
        </h2>
<ul>
<li id="section-c.26-1.1">The size of the initial packet payload has a fixed minimum (#267, #472)<a href="#section-c.26-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.26-1.2">Define when Version Negotiation packets are ignored (#284, #294, #241, #143,
#474)<a href="#section-c.26-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.26-1.3">The 64-bit FNV-1a algorithm is used for integrity protection of unprotected
packets (#167, #480, #481, #517)<a href="#section-c.26-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.26-1.4">Rework initial packet types to change how the connection ID is chosen (#482,
#442, #493)<a href="#section-c.26-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.26-1.5">No timestamps are forbidden in unprotected packets (#542, #429)<a href="#section-c.26-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.26-1.6">Cryptographic handshake is now on stream 0 (#456)<a href="#section-c.26-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.26-1.7">Remove congestion control exemption for cryptographic handshake (#248, #476)<a href="#section-c.26-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.26-1.8">Version 1 of QUIC uses TLS; a new version is needed to use a different
handshake protocol (#516)<a href="#section-c.26-1.8" class="pilcrow">¶</a>
</li>
<li id="section-c.26-1.9">STREAM frames have a reduced number of offset lengths (#543, #430)<a href="#section-c.26-1.9" class="pilcrow">¶</a>
</li>
<li id="section-c.26-1.10">
            <p id="section-c.26-1.10.1">Split some frames into separate connection- and stream- level frames
(#443)<a href="#section-c.26-1.10.1" class="pilcrow">¶</a></p>
<ul>
<li id="section-c.26-1.10.2.1">WINDOW_UPDATE split into MAX_DATA and MAX_STREAM_DATA (#450)<a href="#section-c.26-1.10.2.1" class="pilcrow">¶</a>
</li>
<li id="section-c.26-1.10.2.2">BLOCKED split to match WINDOW_UPDATE split (#454)<a href="#section-c.26-1.10.2.2" class="pilcrow">¶</a>
</li>
<li id="section-c.26-1.10.2.3">Define STREAM_ID_NEEDED frame (#455)<a href="#section-c.26-1.10.2.3" class="pilcrow">¶</a>
</li>
</ul>
</li>
<li id="section-c.26-1.11">A NEW_CONNECTION_ID frame supports connection migration without linkability
(#232, #491, #496)<a href="#section-c.26-1.11" class="pilcrow">¶</a>
</li>
<li id="section-c.26-1.12">
            <p id="section-c.26-1.12.1">Transport parameters for 0-RTT are retained from a previous connection (#405,
#513, #512)<a href="#section-c.26-1.12.1" class="pilcrow">¶</a></p>
<ul>
<li id="section-c.26-1.12.2.1">A client in 0-RTT no longer required to reset excess streams (#425, #479)<a href="#section-c.26-1.12.2.1" class="pilcrow">¶</a>
</li>
</ul>
</li>
<li id="section-c.26-1.13">Expanded security considerations (#440, #444, #445, #448)<a href="#section-c.26-1.13" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-01">
<section id="section-c.27">
        <h2 id="name-since-draft-ietf-quic-transport-01">
<a href="#section-c.27" class="section-number selfRef">C.27. </a><a href="#name-since-draft-ietf-quic-transport-01" class="section-name selfRef">Since draft-ietf-quic-transport-01</a>
        </h2>
<ul>
<li id="section-c.27-1.1">Defined short and long packet headers (#40, #148, #361)<a href="#section-c.27-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.2">Defined a versioning scheme and stable fields (#51, #361)<a href="#section-c.27-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.3">Define reserved version values for "greasing" negotiation (#112, #278)<a href="#section-c.27-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.4">The initial packet number is randomized (#35, #283)<a href="#section-c.27-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.5">Narrow the packet number encoding range requirement (#67, #286, #299, #323,
#356)<a href="#section-c.27-1.5" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.6">Defined client address validation (#52, #118, #120, #275)<a href="#section-c.27-1.6" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.7">Define transport parameters as a TLS extension (#49, #122)<a href="#section-c.27-1.7" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.8">SCUP and COPT parameters are no longer valid (#116, #117)<a href="#section-c.27-1.8" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.9">Transport parameters for 0-RTT are either remembered from before, or assume
default values (#126)<a href="#section-c.27-1.9" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.10">The server chooses connection IDs in its final flight (#119, #349, #361)<a href="#section-c.27-1.10" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.11">The server echoes the Connection ID and packet number fields when sending a
Version Negotiation packet (#133, #295, #244)<a href="#section-c.27-1.11" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.12">Defined a minimum packet size for the initial handshake packet from the client
(#69, #136, #139, #164)<a href="#section-c.27-1.12" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.13">Path MTU Discovery (#64, #106)<a href="#section-c.27-1.13" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.14">The initial handshake packet from the client needs to fit in a single packet
(#338)<a href="#section-c.27-1.14" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.15">Forbid acknowledgment of packets containing only ACK and PADDING (#291)<a href="#section-c.27-1.15" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.16">Require that frames are processed when packets are acknowledged (#381, #341)<a href="#section-c.27-1.16" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.17">Removed the STOP_WAITING frame (#66)<a href="#section-c.27-1.17" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.18">Don't require retransmission of old timestamps for lost ACK frames (#308)<a href="#section-c.27-1.18" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.19">Clarified that frames are not retransmitted, but the information in them can
be (#157, #298)<a href="#section-c.27-1.19" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.20">Error handling definitions (#335)<a href="#section-c.27-1.20" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.21">Split error codes into four sections (#74)<a href="#section-c.27-1.21" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.22">Forbid the use of Public Reset where CONNECTION_CLOSE is possible (#289)<a href="#section-c.27-1.22" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.23">Define packet protection rules (#336)<a href="#section-c.27-1.23" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.24">Require that stream be entirely delivered or reset, including acknowledgment
of all STREAM frames or the RESET_STREAM, before it closes (#381)<a href="#section-c.27-1.24" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.25">Remove stream reservation from state machine (#174, #280)<a href="#section-c.27-1.25" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.26">Only stream 1 does not contribute to connection-level flow control (#204)<a href="#section-c.27-1.26" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.27">Stream 1 counts towards the maximum concurrent stream limit (#201, #282)<a href="#section-c.27-1.27" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.28">Remove connection-level flow control exclusion for some streams (except 1)
(#246)<a href="#section-c.27-1.28" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.29">RESET_STREAM affects connection-level flow control (#162, #163)<a href="#section-c.27-1.29" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.30">Flow control accounting uses the maximum data offset on each stream, rather
than bytes received (#378)<a href="#section-c.27-1.30" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.31">Moved length-determining fields to the start of STREAM and ACK (#168, #277)<a href="#section-c.27-1.31" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.32">Added the ability to pad between frames (#158, #276)<a href="#section-c.27-1.32" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.33">Remove error code and reason phrase from GOAWAY (#352, #355)<a href="#section-c.27-1.33" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.34">GOAWAY includes a final stream number for both directions (#347)<a href="#section-c.27-1.34" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.35">Error codes for RESET_STREAM and CONNECTION_CLOSE are now at a consistent
offset (#249)<a href="#section-c.27-1.35" class="pilcrow">¶</a>
</li>
<li id="section-c.27-1.36">Defined priority as the responsibility of the application protocol (#104,
#303)<a href="#section-c.27-1.36" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-ietf-quic-transport-00">
<section id="section-c.28">
        <h2 id="name-since-draft-ietf-quic-transport-00">
<a href="#section-c.28" class="section-number selfRef">C.28. </a><a href="#name-since-draft-ietf-quic-transport-00" class="section-name selfRef">Since draft-ietf-quic-transport-00</a>
        </h2>
<ul>
<li id="section-c.28-1.1">Replaced DIVERSIFICATION_NONCE flag with KEY_PHASE flag<a href="#section-c.28-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.28-1.2">Defined versioning<a href="#section-c.28-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.28-1.3">Reworked description of packet and frame layout<a href="#section-c.28-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.28-1.4">Error code space is divided into regions for each component<a href="#section-c.28-1.4" class="pilcrow">¶</a>
</li>
<li id="section-c.28-1.5">Use big endian for all numeric values<a href="#section-c.28-1.5" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="since-draft-hamilton-quic-transport-protocol-01">
<section id="section-c.29">
        <h2 id="name-since-draft-hamilton-quic-t">
<a href="#section-c.29" class="section-number selfRef">C.29. </a><a href="#name-since-draft-hamilton-quic-t" class="section-name selfRef">Since draft-hamilton-quic-transport-protocol-01</a>
        </h2>
<ul>
<li id="section-c.29-1.1">Adopted as base for draft-ietf-quic-tls<a href="#section-c.29-1.1" class="pilcrow">¶</a>
</li>
<li id="section-c.29-1.2">Updated authors/editors list<a href="#section-c.29-1.2" class="pilcrow">¶</a>
</li>
<li id="section-c.29-1.3">Added IANA Considerations section<a href="#section-c.29-1.3" class="pilcrow">¶</a>
</li>
<li id="section-c.29-1.4">Moved Contributors and Acknowledgments to appendices<a href="#section-c.29-1.4" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
</section>
</div>
<div id="contributors">
<section id="section-appendix.d">
      <h2 id="name-contributors">
<a href="#name-contributors" class="section-name selfRef">Contributors</a>
      </h2>
<p id="section-appendix.d-1">The original design and rationale behind this protocol draw significantly from
work by Jim Roskind <span>[<a href="#EARLY-DESIGN" class="xref">EARLY-DESIGN</a>]</span>.<a href="#section-appendix.d-1" class="pilcrow">¶</a></p>
<p id="section-appendix.d-2">The IETF QUIC Working Group received an enormous amount of support from many
people. The following people provided substantive contributions to this
document:<a href="#section-appendix.d-2" class="pilcrow">¶</a></p>
<ul>
<li id="section-appendix.d-3.1">Alessandro Ghedini<a href="#section-appendix.d-3.1" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.2">Alyssa Wilk<a href="#section-appendix.d-3.2" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.3">Antoine Delignat-Lavaud<a href="#section-appendix.d-3.3" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.4">Brian Trammell<a href="#section-appendix.d-3.4" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.5">Christian Huitema<a href="#section-appendix.d-3.5" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.6">Colin Perkins<a href="#section-appendix.d-3.6" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.7">David Schinazi<a href="#section-appendix.d-3.7" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.8">Dmitri Tikhonov<a href="#section-appendix.d-3.8" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.9">Eric Kinnear<a href="#section-appendix.d-3.9" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.10">Eric Rescorla<a href="#section-appendix.d-3.10" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.11">Gorry Fairhurst<a href="#section-appendix.d-3.11" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.12">Ian Swett<a href="#section-appendix.d-3.12" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.13">Igor Lubashev<a href="#section-appendix.d-3.13" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.14">
          <p id="section-appendix.d-3.14.1">        <span class="contact-name"><span class="non-ascii">奥 一穂</span> (<span class="ascii">Kazuho Oku</span>)</span><a href="#section-appendix.d-3.14.1" class="pilcrow">¶</a></p>
</li>
<li id="section-appendix.d-3.15">Lucas Pardue<a href="#section-appendix.d-3.15" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.16">Magnus Westerlund<a href="#section-appendix.d-3.16" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.17">Marten Seemann<a href="#section-appendix.d-3.17" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.18">Martin Duke<a href="#section-appendix.d-3.18" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.19">Mike Bishop<a href="#section-appendix.d-3.19" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.20">
          <p id="section-appendix.d-3.20.1">        <span class="contact-name">Mikkel Fahnøe Jørgensen</span><a href="#section-appendix.d-3.20.1" class="pilcrow">¶</a></p>
</li>
<li id="section-appendix.d-3.21">
          <p id="section-appendix.d-3.21.1">        <span class="contact-name">Mirja Kühlewind</span><a href="#section-appendix.d-3.21.1" class="pilcrow">¶</a></p>
</li>
<li id="section-appendix.d-3.22">Nick Banks<a href="#section-appendix.d-3.22" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.23">Nick Harper<a href="#section-appendix.d-3.23" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.24">Patrick McManus<a href="#section-appendix.d-3.24" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.25">Roberto Peon<a href="#section-appendix.d-3.25" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.26">Ryan Hamilton<a href="#section-appendix.d-3.26" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.27">Subodh Iyengar<a href="#section-appendix.d-3.27" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.28">Tatsuhiro Tsujikawa<a href="#section-appendix.d-3.28" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.29">Ted Hardie<a href="#section-appendix.d-3.29" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.30">Tom Jones<a href="#section-appendix.d-3.30" class="pilcrow">¶</a>
</li>
<li id="section-appendix.d-3.31">Victor Vasiliev<a href="#section-appendix.d-3.31" class="pilcrow">¶</a>
</li>
</ul>
</section>
</div>
<div id="authors-addresses">
<section id="section-appendix.e">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Jana Iyengar (<span class="role">editor</span>)</span></div>
<div dir="auto" class="left"><span class="org">Fastly</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:jri.ietf@gmail.com" class="email">jri.ietf@gmail.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Martin Thomson (<span class="role">editor</span>)</span></div>
<div dir="auto" class="left"><span class="org">Mozilla</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:mt@lowentropy.net" class="email">mt@lowentropy.net</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
