<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="robots" content="index,follow" />

        <link rel="icon" href="./css/images/rfc.png" type="image/png" />
        <link rel="shortcut icon" href="./css/images/rfc.png" type="image/png" />
        <title>rfc5784</title>
    
        <link rel="stylesheet" type="text/css" href="./css/errata-base.css"/>
        <link rel="stylesheet" type="text/css" href="./css/errata-color.css" title="Default: Basic Colors"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-monochrome.css" title="Monochrome"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-printer.css" title="Printer"/>

        <script src="./css/errata.js"></script>
    </head>
    <body>
        <div class='Verified-headnote-styling'>
<span style="font-weight: bold;">This is a purely informative rendering of an RFC that includes verified errata.  This rendering may not be used as a reference.</span>
<br/>
<br/>
The following 'Verified' errata have been incorporated in this document:
 <a href='#btn_2086'>EID 2086</a>
</div>

        <pre>
Internet Engineering Task Force (IETF)                          N. Freed
Request for Comments: 5784                                      S. Vedam
Category: Standards Track                               Sun Microsystems
ISSN: 2070-1721                                               March 2010


      Sieve Email Filtering:  Sieves and Display Directives in XML

Abstract

   This document describes a way to represent Sieve email filtering
   language scripts in XML.  Representing Sieves in XML is intended not
   as an alternate storage format for Sieve but rather as a means to
   facilitate manipulation of scripts using XML tools.

   The XML representation also defines additional elements that have no
   counterparts in the regular Sieve language.  These elements are
   intended for use by graphical user interfaces and provide facilities
   for labeling or grouping sections of a script so they can be
   displayed more conveniently.  These elements are represented as
   specially structured comments in regular Sieve format.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 5741.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc5784.

Copyright Notice

   Copyright (c) 2010 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3
   2.  Conventions Used in This Document  . . . . . . . . . . . . . .  4
   3.  Grammatical Structure of Sieve . . . . . . . . . . . . . . . .  4
   4.  XML Representation of Sieve  . . . . . . . . . . . . . . . . .  6
     4.1.  XML Display Directives . . . . . . . . . . . . . . . . . .  9
     4.2.  Structured Comments  . . . . . . . . . . . . . . . . . . . 10
     4.3.  Validation . . . . . . . . . . . . . . . . . . . . . . . . 11
   5.  Security Considerations  . . . . . . . . . . . . . . . . . . . 11
   6.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 11
   7.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 12
     7.1.  Normative References . . . . . . . . . . . . . . . . . . . 12
     7.2.  Informative References . . . . . . . . . . . . . . . . . . 13
   Appendix A.  Extended Example  . . . . . . . . . . . . . . . . . . 14
   Appendix B.  XML Schema for Sieves in XML  . . . . . . . . . . . . 21
   Appendix C.  Relax NG Schema for Sieves in XML . . . . . . . . . . 24
   Appendix D.  Stylesheet for Conversion from XML  . . . . . . . . . 26
   Appendix E.  Acknowledgements  . . . . . . . . . . . . . . . . . . 32

1.  Introduction

   Sieve [RFC5228] is a language for filtering email messages at or
   around the time of final delivery.  It is designed to be
   implementable on either a mail client or mail server.  It is meant to
   be extensible, simple, and independent of access protocol, mail
   architecture, and operating system, and it is intended to be
   manipulated by a variety of different user interfaces.

   Some user interface environments have extensive existing facilities
   for manipulating material represented in XML [XML].  While adding
   support for alternate data syntaxes may be possible in most if not
   all of these environments, it may not be particularly convenient to
   do so.  The obvious way to deal with this issue is to map Sieves into
   XML, possibly on a separate back-end system, manipulate the XML, and
   convert it back to normal Sieve format.

   The fact that conversion into and out of XML may be done as a
   separate operation on a different system argues strongly for defining
   a common XML representation for Sieve.  This way, different front-end
   user interfaces can be used with different back-end mapping and
   storage facilities.

   Another issue with the creation and manipulation of Sieve scripts by
   user interfaces is that the language is strictly focused on
   describing email filtering operations.  The language contains no
   mechanisms for indicating how a given script should be presented in a
   user interface.  Such information can be represented in XML very
   easily, so it makes sense to define a framework to do this as part of
   the XML format.  A structured comment convention is then used to
   retain this information when the script is converted to normal Sieve
   format.

   It should be noted, however, that the ability for different front
   ends to use the same mapping and storage facilities does not mean
   that the additional XML information produced by different front ends
   will interoperate.

   Various Sieve extensions have already been defined, e.g., [RFC5183],
   [RFC5229], [RFC5230], [RFC5231], [RFC5232], [RFC5233], [RFC5235],
   [RFC5293], and more are planned.  The set of extensions available
   varies from one implementation to the next and may even change as a
   result of configuration choices.  It is therefore essential that the
   XML representation of Sieve be able to accommodate Sieve extensions
   without requiring schema changes.  It is also desirable that Sieve
   extensions not require changes to the code that converts to and from
   the XML representation.

   This specification defines an XML representation for Sieve scripts
   and explains how the conversion process to and from XML works.  The
   XML representation is capable of accommodating any future Sieve
   extension as long as the underlying Sieve grammar remains unchanged.
   Furthermore, code that converts from XML to the normal Sieve format
   requires no changes to accommodate extensions, while code used to
   convert from normal Sieve format to XML only requires changes when
   new control commands are added -- a rare event.  An XML Schema, Relax
   NG Schema, and a sample stylesheet to convert from XML format are
   also provided in the appendices.

2.  Conventions Used in This Document

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

   The term &quot;processor&quot; is used throughout this document to refer to
   agents that convert Sieve to and from the XML representation.  The
   term &quot;editor&quot; refers to agents that operate on, possibly creating or
   modifying, Sieves in XML format.

3.  Grammatical Structure of Sieve

   The Sieve language is designed to be highly extensible without making
   any changes to the basic language syntax.  Accordingly, the syntax of
   Sieve, defined in Section 8 of [RFC5228], is entirely structural in
   nature and employs no reserved words of any sort.

   Structurally, a Sieve script consists of a series of commands.  Each
   command, in turn, consists of an identifier, zero or more arguments,
   an optional test or test-list, and finally an optional block
   containing another series of commands.  Commands are further broken
   down into controls and actions, although this distinction cannot be
   determined from the grammar.

   Some example Sieve controls are:

   stop;               &lt;-- No arguments, test, or command block
   require &quot;fileinto&quot;; &lt;-- Control with a single argument
   if true {stop;}     &lt;-- Control with test and command block

   Some examples of Sieve actions are:

discard;            &lt;-- Action with no arguments, test, or command block
fileinto &quot;folder&quot;;  &lt;-- Action with an argument

   At the time of this writing, there are no controls defined that
   accept both arguments and a test.  Similarly, there are currently no
   defined actions that allow either a test or a command block.
   Nevertheless, the Sieve grammar allows such constructs to be defined
   by some future extension.

   A test consists of an identifier followed by zero or more arguments,
   then another test or test-list.  Unlike commands, tests cannot be
   followed by a command block.

   Here are some examples of Sieve tests.  Note that such tests have to
   appear as part of a command in order to be syntactically valid:

   true                &lt;-- Test with no argument or subordinate test
   envelope &quot;to&quot; &quot;me@example.com&quot; &lt;-- Test with several arguments
   header :is &quot;from&quot; &quot;you@example.com&quot; &lt;-- Test with tagged argument

   Command or test arguments can be either string lists, whole numbers,
   or tags.  (Tags are simply identifiers preceded by a colon.)  Note
   that although the Sieve grammar treats single strings as a degenerate
   case of a string list, some tests or actions have arguments that can
   only be individual strings, not lists.

   Here is an example showing the use of both a test-list and a string
   list:

   if anyof (not exists [&quot;From&quot;, &quot;Date&quot;],
             header :contains &quot;from&quot; &quot;fool@example.edu&quot;) {
     discard;
   }

   Extensions can add new controls, actions, tests, or arguments to
   existing controls or actions.  Extensions have also changed how
   string content is interpreted, although this is not relevant to this
   specification.  However, it is especially important to note that so
   far, only one of the many defined Sieve extensions -- the
   foreverypart extension [RFC5703] -- has added new controls to the
   language.  It seems safe to assume that, due to their nature, future
   addition of controls will be relatively rare.

   Finally, comments are allowed between lexical elements in a Sieve
   script.  One important use case for comments is encoding meta-data
   about the script, a facility that is lacking in the Sieve language.
   Therefore, comments need to be preserved in the XML representation.

4.  XML Representation of Sieve

   Sieve controls and actions are represented in XML as &quot;control&quot; or
   &quot;action&quot; elements, respectively.  The command&#x27;s identifier appears as
   a name attribute on the element itself.  This is the only attribute
   allowed on controls and actions -- arguments, tests, test-lists, and
   nested command blocks are all represented as nested elements.  While
   naming the element after the control or action itself may seem like a
   better choice, doing so would result in extensions requiring frequent
   corresponding schema changes.

   The example Sieve controls shown in the previous section would be
   represented as these XML fragments:

    &lt;control name=&quot;stop&quot;/&gt;

    &lt;control name=&quot;require&quot;&gt;&lt;str&gt;fileinto&lt;/str&gt;&lt;/control&gt;

    &lt;control name=&quot;if&quot;&gt;
     &lt;test name=&quot;true&quot;/&gt;&lt;control name=&quot;stop&quot;/&gt;
    &lt;/control&gt;

   The example Sieve actions shown above would appear in XML as:

   &lt;action name=&quot;discard&quot;/&gt;
   &lt;action name=&quot;fileinto&quot;&gt;&lt;str&gt;folder&lt;/str&gt;&lt;/action&gt;

   The separation of controls from actions in the XML representation
   means that conversion from normal Sieve format to XML has to be able
   to distinguish between controls and actions.  This is easily done by
   maintaining a list of all known controls since experience indicates
   new controls are rarely added.  At the time of this writing, the list
   of defined controls consists of:

   1.  if [RFC5228],

   2.  stop [RFC5228],

   3.  require [RFC5228],

   4.  foreverypart [RFC5703], and

   5.  break [RFC5703].

   It should be noted that with this approach unknown controls will
   simply be treated as actions and can be passed back and forth between
   the two representations.  The treatment of a control as an action is

   unlikely to cause other issues since knowledge of a control&#x27;s
   language semantics is almost always required to take advantage of it.

   Tests are represented in the same basic way as controls and actions,
   that is, as a &quot;test&quot; element with a name attribute giving the test
   identifier.  For example, the following XML fragments show various
   types of tests:

   &lt;test name=&quot;true&quot;/&gt;

   &lt;test name=&quot;envelope&quot;/&gt;
     &lt;str&gt;to&lt;/str&gt;&lt;str&gt;me@example.com&lt;/str&gt;
   &lt;/test&gt;

   &lt;test name=&quot;header&quot;/&gt;
     &lt;tag&gt;is&lt;/tag&gt;&lt;str&gt;from&lt;/str&gt;&lt;str&gt;you@example.com&lt;/str&gt;
   &lt;/test&gt;

   String, number, and tag arguments are represented as &quot;str&quot;, &quot;num&quot;,
   and &quot;tag&quot; elements, respectively.  The actual string, number, or tag
   identifier appears as text inside the element.  None of these
   elements have any defined attributes.  Several examples of arguments
   have already appeared in the preceding control, action, and test
   examples.  Any whitespace in the str body content MUST be preserved
   by the processor.  Also, note that since strings and tags are
   represented as element text, any quotes or other syntactic elements
   required in the regular Sieve representation are dropped rather than
   being carried over into the XML.

   String list arguments are represented as a &quot;list&quot; element, which in
   turn contains one or more str elements.  Note that this allows the
   distinction between a single string and a string list containing a
   single string to be preserved.  This is not essential since a list
   containing a single string could simply be mapped to a string, but it
   seems prudent to maintain the distinction when mapping to and from
   XML.

   Nested command blocks appear as a series of control or action
   elements inside of an outer control or action element.  No block
   element is needed since an inner command block can only appear once
   and only after any arguments, tests, or test-lists.  For example:

   &lt;control name=&quot;if&quot;&gt;
     &lt;test name=&quot;anyof&quot;&gt;
       &lt;test name=&quot;not&quot;&gt;
         &lt;test name=&quot;exists&quot;&gt;
           &lt;list&gt;&lt;str&gt;From&lt;/str&gt;&lt;str&gt;Date&lt;/str&gt;&lt;/list&gt;
         &lt;/test&gt;
       &lt;/test&gt;
       &lt;test name=&quot;header&quot;&gt;
         &lt;tag&gt;contains&lt;/tag&gt;
         &lt;str&gt;from&lt;/str&gt;
         &lt;str&gt;fool@example.edu&lt;/str&gt;
       &lt;/test&gt;
     &lt;/test&gt;
     &lt;action name=&quot;discard&quot;/&gt;
   &lt;/control&gt;

   Sieve comments are mapped to a special &quot;comment&quot; element in XML.
   Both hash and bracketed comments are mapped to the same construct so
   the distinction between the two is lost in XML.  XML comments are not
   used because some XML tools do not make it convenient to access
   comment nodes.

   Comments are allowed between commands and inside &quot;test&quot; elements.
   But comments aren&#x27;t allowed directly inside commands -- due to
   limitations of XML Schema, special enclosing &quot;preamble&quot; and
   &quot;postamble&quot; elements are needed:

   &lt;control name=&quot;if&quot;&gt;
     &lt;preamble&gt;
       &lt;comment&gt;Check to see if message should be discarded&lt;/comment&gt;
     &lt;/preamble&gt;
     &lt;test name=&quot;anyof&quot;&gt;
       &lt;test name=&quot;not&quot;&gt;
         &lt;test name=&quot;exists&quot;&gt;
           &lt;list&gt;&lt;str&gt;From&lt;/str&gt;&lt;str&gt;Date&lt;/str&gt;&lt;/list&gt;
         &lt;/test&gt;
       &lt;/test&gt;
       &lt;test name=&quot;header&quot;&gt;
         &lt;tag&gt;contains&lt;/tag&gt;
         &lt;str&gt;from&lt;/str&gt;
         &lt;str&gt;fool@example.edu&lt;/str&gt;
       &lt;/test&gt;
     &lt;/test&gt;
     &lt;action name=&quot;discard&quot;/&gt;
     &lt;postamble&gt;
       &lt;comment&gt;End of discard check&lt;/comment&gt;
     &lt;/postamble&gt;
   &lt;/control&gt;

4.1.  XML Display Directives

   Sometimes graphical user interfaces are a convenient way to provide
   Sieve management functions to users.  These interfaces typically
   summarize/annotate/group/display Sieve script(s) in an intuitive way
   for end users.

   To do this effectively, the graphical user interface may require
   additional information about the Sieve script itself.  That
   information or &quot;meta-data&quot; might include, but is not limited to, a
   Sieve name (identifying the current Sieve), whether the Sieve is
   enabled or disabled, and the order in which the parts of the Sieve
   are presented to the user.  The graphical user interface may also
   choose to provide mechanisms to allow the user to modify the script.

   It is often useful for a graphical user interface to group related
   Sieve script elements and provide an interface that displays these
   groups separately so they can be managed as a single object.  Some
   examples include Sieve statements that together provide vacation
   responders, blacklists/whitelists, and other types of filtering
   controls.

   Some advanced graphical user interfaces may even provide a natural
   language representation of a Sieve script and/or an advanced
   interface to present Sieve statements directly to the user.

   A graphical user interface may also choose to support only a subset
   of action commands in the Sieve language (and its extensions), and so
   a mechanism to indicate the extent of support and characterize the
   relationships between those supported action commands and the test
   (with its arguments) is immensely useful and probably required for
   clients that may not have complete knowledge of Sieve grammar and
   semantics.

   The Sieve language contains no mechanisms for indicating how a given
   script should be presented in a user interface.  The language also
   does not contain any specific mechanisms to represent other sorts of
   meta-data about the script.  Providing support for such meta-data as
   part of a Sieve script is currently totally implementation specific
   and is usually done by imposing some type of structure on comments.

   However, such information can be represented in XML very easily, so
   it makes sense to define a framework to do this as part of the XML
   format.  Implementations MAY choose to use structured comments to
   retain this information when the script is converted to normal Sieve
   format.

   The sample schemata for the XML representation of Sieve allows XML in
   foreign namespaces to be inserted in the same places &quot;comment&quot;
   elements can appear in Sieve scripts.  This is the preferred means of
   including additional information.  Alternately, the schema defines
   two display directives -- displayblock and displaydata -- as
   containers for meta-data needed by graphical user interfaces.

   Editors MAY use displayblock, displaydata, and foreign namespaces to
   associate meta-data.  Some editors find it inconvenient to preserve
   this additional data during an editing session.  Editors MAY preserve
   this data during an editing session for compatibility with other
   editors.

   The displayblock element can be used to enclose any number of Sieve
   statements at any level.  It is semantically meaningless to the Sieve
   script itself.  It allows an arbitrary set of attributes.
   Implementations MAY use this to provide many simple, display-related
   meta-data for the Sieve such as Sieve identifier, group identifier,
   order of processing, etc.

   The displaydata element supports any number of arbitrary child
   elements.  Implementations MAY use this to represent complex data
   about that Sieve such as a natural language representation of Sieve
   or a way to provide the Sieve script directly.

4.2.  Structured Comments

   Since the XML representation is not intended as a storage format,
   there needs to be a way to preserve the additional information that
   can be included in the XML representation in the normal Sieve syntax.
   This is done through the use of three structured comment conventions:

   1.  XML content in other namespaces is placed in Sieve bracketed
       comments beginning with the string &quot;/* [/&quot; and ending with the
       string &quot;/] */&quot;.

   2.  The content of displaydata elements is placed in Sieve bracketed
       comments beginning with the string &quot;/* [|&quot; and ending with the
       string &quot;|] */&quot;.

   3.  The beginning of a displayblock element is mapped to a bracketed
       Sieve comment beginning with the string &quot;/* [*&quot;, which then lists
       any displayblock attribute names and values in XML format.  The
       end of a displayblock element is mapped to a comment of the form
       &quot;*] */&quot;.

   Processors MUST preserve the additional information allowed in the
   XML format and SHOULD use the structured comment format shown above.

   Note: If &quot;*/&quot; is found in the XML content, when mapped into a
   comment, it would prematurely terminate that comment.  Escaping this
   sequence would often be inconvenient for processors.  Editors SHALL
   NOT include &quot;*/&quot; within displayblock, displaydata, or foreign markup.
   Processors MAY regard documents containing &quot;*/&quot; in foreign markup,
   displayblock, or displaydata as invalid.

4.3.  Validation

   A processor MAY validate documents against a schema, and it MAY
   reject any that do not conform.  For any document that a processor
   does not reject as invalid, any markup that the processor cannot
   understand by reference to this specification MAY be discarded.

   Note that example Relax NG and XML Schema are given in the appendices
   below.

5.  Security Considerations

   Any syntactically valid Sieve script can be represented in XML.
   Accordingly, all security considerations applicable to Sieve and any
   extensions used also apply to the XML representation.

   The use of XML carries its own security risks.  Section 7 of RFC 3470
   [RFC3470] discusses these risks.

   It is axiomatic that a Sieve editor must be trusted to do what the
   user specifies.  If XML formats are used, this trust necessarily must
   extend to the components involved in converting to and from XML
   format.

   Arbitrary data can be included using other namespaces or placed in
   the extensible displayblock and displaydata constructs defined in
   this specification, possibly including entire scripts and other
   executable content in languages other than Sieve.  Such material will
   necessarily have its own security considerations, which are beyond
   the scope of this document.

6.  IANA Considerations

   This section registers a new XML namespace per the procedures in RFC
   3688 [RFC3688].

   URI:  urn:ietf:params:xml:ns:sieve

   <span class="Verified-inline-styling" id='inline-2086'>   Registrant Contact:  IETF Sieve working group <button id="btn_2086" target="expand_2086" onclick='hideFunction("expand_2086")'>Expand</button>
                        &lt;sieve@ietf.org&gt;
</span id__locate=2086>
<div class="nodeCloseClass" id='expand_2086'><div class='Verified-endnote-styling' id='eid2086'>
<pre>
<b><i><a href='https://www.rfc-editor.org/errata/eid2086'>EID 2086</a> (Verified) is as follows:</i></b>

<b>Section:</b> 6, pg.12

<b>Original Text:</b>

   Registrant Contact:  IETF Sieve working group
                        &lt;ietf-mta-filters@imc.org&gt;

<b>Corrected Text:</b>

   Registrant Contact:  IETF Sieve working group
                        &lt;sieve@ietf.org&gt;
</pre>
<b>Notes:</b><br/>
Rationale:<br/>The &#x27;sieve&#x27; mailing list has moved to the IETF.ORG site on 2009-08-19,<br/>according to:<br/>  &lt;http://www.IETF.ORG/mail-archive/web/sieve/current/msg00565.html&gt;.
</div>
</div>
   XML:

     BEGIN
     &lt;?xml version=&quot;1.0&quot;?&gt;
     &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML Basic 1.0//EN&quot;
       &quot;http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd&quot;&gt;
     &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
     &lt;head&gt;
       &lt;meta http-equiv=&quot;content-type&quot;
             content=&quot;text/html;charset=iso-8859-1&quot;/&gt;
       &lt;title&gt;Sieve Namespace&lt;/title&gt;
     &lt;/head&gt;
     &lt;body&gt;
       &lt;h1&gt;Namespace for Sieve Language objects expressed in XML&lt;/h1&gt;
       &lt;h2&gt;urn:ietf:params:xml:ns:sieve&lt;/h2&gt;
       &lt;p&gt;See &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc5784.txt&quot;&gt;
        RFC 5784&lt;/a&gt;.
       &lt;/p&gt;
     &lt;/body&gt;
     &lt;/html&gt;
     END

7.  References

7.1.  Normative References

   [OASISRNC]  Clark, J., &quot;RELAX NG Compact Syntax&quot;, OASIS Committee
               Specification rnc, November 2002.

   [RFC2119]   Bradner, S., &quot;Key words for use in RFCs to Indicate
               Requirement Levels&quot;, BCP 14, RFC 2119, March 1997.

   [RFC3470]   Hollenbeck, S., Rose, M., and L. Masinter, &quot;Guidelines
               for the Use of Extensible Markup Language (XML)
               within IETF Protocols&quot;, BCP 70, RFC 3470, January 2003.

   [RFC3688]   Mealling, M., &quot;The IETF XML Registry&quot;, BCP 81, RFC 3688,
               January 2004.

   [RFC5228]   Guenther, P. and T. Showalter, &quot;Sieve: An Email Filtering
               Language&quot;, RFC 5228, January 2008.

   [XML]       Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E., and
               F. Yergeau, &quot;Extensible Markup Language (XML) 1.0 (Fifth
               Edition)&quot;, W3C REC-xml-20081126, November 2008,
               &lt;http://www.w3.org/TR/2008/REC-xml-20081126/&gt;.

7.2.  Informative References

   [RFC5183]   Freed, N., &quot;Sieve Email Filtering: Environment
               Extension&quot;, RFC 5183, May 2008.

   [RFC5229]   Homme, K., &quot;Sieve Email Filtering: Variables Extension&quot;,
               RFC 5229, January 2008.

   [RFC5230]   Showalter, T. and N. Freed, &quot;Sieve Email Filtering:
               Vacation Extension&quot;, RFC 5230, January 2008.

   [RFC5231]   Segmuller, W. and B. Leiba, &quot;Sieve Email Filtering:
               Relational Extension&quot;, RFC 5231, January 2008.

   [RFC5232]   Melnikov, A., &quot;Sieve Email Filtering: Imap4flags
               Extension&quot;, RFC 5232, January 2008.

   [RFC5233]   Murchison, K., &quot;Sieve Email Filtering: Subaddress
               Extension&quot;, RFC 5233, January 2008.

   [RFC5235]   Daboo, C., &quot;Sieve Email Filtering: Spamtest and Virustest
               Extensions&quot;, RFC 5235, January 2008.

   [RFC5293]   Degener, J. and P. Guenther, &quot;Sieve Email Filtering:
               Editheader Extension&quot;, RFC 5293, August 2008.

   [RFC5703]   Hansen, T. and C. Daboo, &quot;Sieve Email Filtering: MIME
               Part Tests, Iteration, Extraction, Replacement, and
               Enclosure&quot;, RFC 5703, October 2009.

Appendix A.  Extended Example

   The example Sieve script given in Section 9 of [RFC5228] would be
   represented in XML as the following code component:

   &lt;sieve xmlns=&quot;urn:ietf:params:xml:ns:sieve&quot;&gt;
     &lt;comment&gt;
       Example Sieve Filter
       Declare any optional features or extensions used by the script
     &lt;/comment&gt;

     &lt;control name=&quot;require&quot;&gt;
       &lt;str&gt;fileinto&lt;/str&gt;
     &lt;/control&gt;
     &lt;comment&gt;
       Handle messages from known mailing lists.
       Move messages from IETF filter discussion list to filter mailbox.
     &lt;/comment&gt;
     &lt;control name=&quot;if&quot;&gt;
       &lt;test name=&quot;header&quot;&gt;
         &lt;tag&gt;is&lt;/tag&gt;
         &lt;str&gt;Sender&lt;/str&gt;
         &lt;str&gt;owner-ietf-mta-filters@imc.org&lt;/str&gt;
       &lt;/test&gt;
       &lt;action name=&quot;fileinto&quot;&gt;
         &lt;str&gt;filter&lt;/str&gt;
       &lt;/action&gt;
       &lt;postamble&gt;
         &lt;comment&gt;move to &quot;filter&quot; mailbox&lt;/comment&gt;
       &lt;/postamble&gt;
     &lt;/control&gt;

     &lt;comment&gt;
       Keep all messages to or from people in my company.
     &lt;/comment&gt;
     &lt;control name=&quot;elsif&quot;&gt;
       &lt;test name=&quot;address&quot;&gt;
         &lt;tag&gt;domain&lt;/tag&gt;
         &lt;tag&gt;is&lt;/tag&gt;
         &lt;list&gt;
           &lt;str&gt;From&lt;/str&gt;
           &lt;str&gt;To&lt;/str&gt;
         &lt;/list&gt;
         &lt;str&gt;example.com&lt;/str&gt;
       &lt;/test&gt;
       &lt;action name=&quot;keep&quot;/&gt;
     &lt;/control&gt;

     &lt;comment&gt;
       Try and catch unsolicited email.  If a message is not to me,
       or it contains a subject known to be spam, file it away.
     &lt;/comment&gt;
     &lt;control name=&quot;elsif&quot;&gt;
       &lt;test name=&quot;anyof&quot;&gt;
         &lt;test name=&quot;not&quot;&gt;
           &lt;test name=&quot;address&quot;&gt;
             &lt;tag&gt;all&lt;/tag&gt;
             &lt;tag&gt;contains&lt;/tag&gt;
             &lt;list&gt;
               &lt;str&gt;To&lt;/str&gt;
               &lt;str&gt;Cc&lt;/str&gt;
               &lt;str&gt;Bcc&lt;/str&gt;
             &lt;/list&gt;
             &lt;str&gt;me@example.com&lt;/str&gt;
           &lt;/test&gt;
         &lt;/test&gt;
         &lt;test name=&quot;header&quot;&gt;
           &lt;tag&gt;matches&lt;/tag&gt;
           &lt;str&gt;subject&lt;/str&gt;
           &lt;list&gt;
             &lt;str&gt;*make*money*fast*&lt;/str&gt;
             &lt;str&gt;*university*dipl*mas*&lt;/str&gt;
           &lt;/list&gt;
         &lt;/test&gt;
       &lt;/test&gt;
       &lt;action name=&quot;fileinto&quot;&gt;
         &lt;str&gt;spam&lt;/str&gt;
       &lt;/action&gt;
     &lt;/control&gt;
     &lt;control name=&quot;else&quot;&gt;
       &lt;preamble&gt;
         &lt;comment&gt;
           Move all other (non-company) mail to &quot;personal&quot;
           mailbox.
         &lt;/comment&gt;
       &lt;/preamble&gt;
       &lt;action name=&quot;fileinto&quot;&gt;
         &lt;str&gt;personal&lt;/str&gt;
       &lt;/action&gt;
     &lt;/control&gt;

   &lt;/sieve&gt;

   The same script could be annotated with graphical display hints in a
   variety of ways.  Three possible code components that do this are:

   &lt;sieve xmlns=&quot;urn:ietf:params:xml:ns:sieve&quot;&gt;

     &lt;control name=&quot;require&quot;&gt;
       &lt;str&gt;fileinto&lt;/str&gt;
     &lt;/control&gt;

     &lt;displayblock name=&quot;File filter list mail&quot; order=&quot;1&quot;
                   group=&quot;FILE_TO_FOLDER&quot; enable=&quot;true&quot;&gt;
       &lt;control name=&quot;if&quot;&gt;
         &lt;test name=&quot;header&quot;&gt;
           &lt;tag&gt;is&lt;/tag&gt;
           &lt;str&gt;Sender&lt;/str&gt;
           &lt;str&gt;owner-ietf-mta-filters@imc.org&lt;/str&gt;
         &lt;/test&gt;
         &lt;action name=&quot;fileinto&quot;&gt;
           &lt;str&gt;filter&lt;/str&gt;
         &lt;/action&gt;
       &lt;/control&gt;
     &lt;/displayblock&gt;

     &lt;displayblock name=&quot;Keep all company mail&quot; order=&quot;2&quot;
                   group=&quot;KEEP_MESSAGE&quot; enable=&quot;true&quot;&gt;
       &lt;control name=&quot;elsif&quot;&gt;
         &lt;test name=&quot;address&quot;&gt;
           &lt;tag&gt;domain&lt;/tag&gt;
           &lt;tag&gt;is&lt;/tag&gt;
           &lt;list&gt;
             &lt;str&gt;From&lt;/str&gt;
             &lt;str&gt;To&lt;/str&gt;
           &lt;/list&gt;
           &lt;str&gt;example.com&lt;/str&gt;
         &lt;/test&gt;
         &lt;action name=&quot;keep&quot;/&gt;
      &lt;/control&gt;
     &lt;/displayblock&gt;

     &lt;displayblock name=&quot;File suspected spam&quot; order=&quot;3&quot;
                   group=&quot;FILE_TO_FOLDER&quot; enable=&quot;true&quot;&gt;
        &lt;control name=&quot;elsif&quot;&gt;
          &lt;test name=&quot;anyof&quot;&gt;
            &lt;test name=&quot;not&quot;&gt;
              &lt;test name=&quot;address&quot;&gt;
                &lt;tag&gt;all&lt;/tag&gt;
                &lt;tag&gt;contains&lt;/tag&gt;
                &lt;list&gt;

                  &lt;str&gt;To&lt;/str&gt;
                  &lt;str&gt;Cc&lt;/str&gt;
                  &lt;str&gt;Bcc&lt;/str&gt;
                &lt;/list&gt;
                &lt;str&gt;me@example.com&lt;/str&gt;
              &lt;/test&gt;
            &lt;/test&gt;
            &lt;test name=&quot;header&quot;&gt;
              &lt;tag&gt;matches&lt;/tag&gt;
              &lt;str&gt;subject&lt;/str&gt;
              &lt;list&gt;
                &lt;str&gt;*make*money*fast*&lt;/str&gt;
                &lt;str&gt;*university*dipl*mas*&lt;/str&gt;
              &lt;/list&gt;
            &lt;/test&gt;
          &lt;/test&gt;
          &lt;action name=&quot;fileinto&quot;&gt;
            &lt;str&gt;spam&lt;/str&gt;
          &lt;/action&gt;
        &lt;/control&gt;
      &lt;/displayblock&gt;

     &lt;displayblock name=&quot;File noncompany mail as personal&quot; order=&quot;4&quot;
                   group=&quot;FILE_TO_FOLDER&quot; enable=&quot;true&quot;&gt;
       &lt;control name=&quot;else&quot;&gt;
         &lt;action name=&quot;fileinto&quot;&gt;
           &lt;str&gt;personal&lt;/str&gt;
         &lt;/action&gt;
       &lt;/control&gt;
     &lt;/displayblock&gt;

   &lt;/sieve&gt;

   Note that since displayblock elements are semantically null as far as
   the script itself is concerned, they can be used to group structures
   like elsif and else that are tied to statements in other groups.

   The representation of this script in regular Sieve syntax uses
   structured comments:

   require &quot;fileinto&quot;;
   /* [* name=&quot;File filter list mail&quot; order=&quot;1&quot;
         group=&quot;FILE_TO_FOLDER&quot; enable=&quot;true&quot; */
   if header :is &quot;Sender&quot; &quot;owner-ietf-mta-filters@imc.org&quot;
   {
     fileinto &quot;filter&quot;;
   }
   /* *] */
   /* [* name=&quot;Keep all company mail&quot; order=&quot;2&quot;
         group=&quot;KEEP_MESSAGE&quot; enable=&quot;true&quot; */
   elsif address :domain :is [ &quot;From&quot;, &quot;To&quot; ] &quot;example.com&quot;
   {
     keep;
   }
   /* *] */
   /* [* name=&quot;File suspected spam&quot; order=&quot;3&quot;
         group=&quot;FILE_TO_FOLDER&quot; enable=&quot;true&quot; */
   elsif anyof ( not ( address :all :contains [ &quot;To&quot;, &quot;Cc&quot;, &quot;Bcc&quot; ]
                       &quot;me@example.com&quot; ),
                 header :matches &quot;subject&quot; [ &quot;*make*money*fast*&quot;,
                                             &quot;*university*dipl*mas*&quot; ] )
   {
     fileinto &quot;spam&quot;;
   }
   /* *] */
   /* [* name=&quot;File noncompany mail as personal&quot; order=&quot;4&quot;
         group=&quot;FILE_TO_FOLDER&quot; enable=&quot;true&quot; */
   else
   {
     fileinto &quot;personal&quot;;
   }
   /* *] */

   A separate namespace can be used to embed text or structured
   information:

   &lt;sieve xmlns=&quot;urn:ietf:params:xml:ns:sieve&quot;
          xmlns:nls=&quot;http://example.com/nls&quot;&gt;

     &lt;nls:interpretation&gt;
       If the email header &quot;Sender&quot; is owner-ietf-mta-filters@imc.org,
       then file it into the &quot;filter&quot; folder.

       Otherwise, if the address in the &quot;From&quot; or &quot;To&quot; has a domain
       that is &quot;example.com&quot;, then keep it.

       Otherwise, messages meeting with any of these conditions:

       (1) None of the addresses in &quot;To&quot;, &quot;Cc&quot;, or &quot;Bcc&quot; contain
           the domain &quot;example.com&quot;.

       (2) The &quot;Subject&quot; field matches the pattern *make*money*fast*
           or *university*dipl*mas*, then file it into the &quot;spam&quot;
           folder.

       If all else fails, then file the message in the &quot;personal&quot;
       folder.
     &lt;/nls:interpretation&gt;

     ... the actual Sieve script ...

   &lt;/sieve&gt;

   Alternately, displaydata elements can be used to accomplish the same
   thing:

   &lt;sieve xmlns=&quot;urn:ietf:params:xml:ns:sieve&quot;&gt;

     &lt;displaydata&gt;
       &lt;nls-interpretation&gt;
         If the email header &quot;Sender&quot; is owner-ietf-mta-filters@imc.org,
         then file it into the &quot;filter&quot; folder.

         Otherwise, if the address in the &quot;From&quot; or &quot;To&quot; has a domain
         that is &quot;example.com&quot;, then keep it.

         Otherwise, messages meeting with any of these conditions:

         (1) None of the addresses in &quot;To&quot;,&quot;Cc&quot;, or &quot;Bcc&quot; contain
             the domain &quot;example.com&quot;.

         (2) The &quot;Subject&quot; field matches the pattern *make*money*fast*
             or *university*dipl*mas*, then file it into the &quot;spam&quot;
             folder.

         If all else fails, then file the message in the &quot;personal&quot;
         folder.
       &lt;/nls-interpretation&gt;
     &lt;/displaydata&gt;

     ... the actual Sieve script ...

   &lt;/sieve&gt;

   Again, structured comments are used to represent this in regular
   Sieve syntax:

     /* [|
       &lt;nls-interpretation&gt;
         If the email header &quot;Sender&quot; is owner-ietf-mta-filters@imc.org,
         then file it into the &quot;filter&quot; folder.

         Otherwise, if the address in the &quot;From&quot; or &quot;To&quot; has a domain
         that is &quot;example.com&quot;, then keep it.

         Otherwise, messages meeting with any of these conditions:

         (1) None of the addresses in &quot;To&quot;,&quot;Cc&quot;, or &quot;Bcc&quot; contain
             the domain &quot;example.com&quot;.

         (2) The &quot;Subject&quot; field matches the pattern *make*money*fast*
             or *university*dipl*mas*, then file it into the &quot;spam&quot;
             folder.

         If all else fails, then file the message in the &quot;personal&quot;
         folder.
       &lt;/nls-interpretation&gt;
     |] */

     ... the actual Sieve script ...

Appendix B.  XML Schema for Sieves in XML

   This appendix is informative.  The following code component is an XML
   Schema for the XML representation of Sieve scripts.  Most of the
   elements employing a complex content model allow use of elements in
   other namespaces, subject to lax XML Schema validation rules.
   Additionally, displaydata elements can be used to encapsulate
   arbitrary XML content.  Finally, displayblock elements can be used as
   a general-purpose grouping mechanism -- arbitrary attributes are
   allowed on displayblock elements.

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

   &lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;
               xmlns=&quot;urn:ietf:params:xml:ns:sieve&quot;
               targetNamespace=&quot;urn:ietf:params:xml:ns:sieve&quot;&gt;

     &lt;xsd:element name=&quot;sieve&quot;&gt;
       &lt;xsd:complexType&gt;
         &lt;xsd:sequence&gt;
           &lt;xsd:choice maxOccurs=&quot;unbounded&quot; minOccurs=&quot;0&quot;&gt;

             &lt;xsd:element ref=&quot;control&quot;/&gt;
             &lt;xsd:element ref=&quot;action&quot;/&gt;
             &lt;xsd:element ref=&quot;displayblock&quot;/&gt;
             &lt;xsd:element ref=&quot;displaydata&quot;/&gt;
             &lt;xsd:element ref=&quot;comment&quot;/&gt;
             &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;
           &lt;/xsd:choice&gt;
         &lt;/xsd:sequence&gt;
       &lt;/xsd:complexType&gt;
     &lt;/xsd:element&gt;

     &lt;xsd:element name=&quot;comment&quot; type=&quot;xsd:string&quot;/&gt;

     &lt;xsd:complexType name=&quot;ambles&quot;&gt;
       &lt;xsd:choice minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
         &lt;xsd:element ref=&quot;displaydata&quot;/&gt;
         &lt;xsd:element ref=&quot;comment&quot;/&gt;
         &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;
      &lt;/xsd:choice&gt;
     &lt;/xsd:complexType&gt;

     &lt;xsd:element name=&quot;preamble&quot; type=&quot;ambles&quot;/&gt;
     &lt;xsd:element name=&quot;postamble&quot; type=&quot;ambles&quot;/&gt;

     &lt;xsd:complexType name=&quot;command&quot;&gt;
       &lt;xsd:sequence&gt;
         &lt;xsd:element ref=&quot;preamble&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
         &lt;xsd:choice minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
           &lt;xsd:element ref=&quot;str&quot;/&gt;
           &lt;xsd:element ref=&quot;num&quot;/&gt;
           &lt;xsd:element ref=&quot;list&quot;/&gt;
           &lt;xsd:element ref=&quot;tag&quot;/&gt;
         &lt;/xsd:choice&gt;
         &lt;xsd:element ref=&quot;test&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
         &lt;xsd:choice minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
           &lt;xsd:element ref=&quot;control&quot;/&gt;
           &lt;xsd:element ref=&quot;action&quot;/&gt;
           &lt;xsd:element ref=&quot;displayblock&quot;/&gt;
         &lt;/xsd:choice&gt;
         &lt;xsd:element ref=&quot;postamble&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
       &lt;/xsd:sequence&gt;
       &lt;xsd:attribute use=&quot;required&quot; name=&quot;name&quot; type=&quot;identifier&quot;/&gt;
     &lt;/xsd:complexType&gt;

     &lt;xsd:element name=&quot;control&quot; type=&quot;command&quot;/&gt;
     &lt;xsd:element name=&quot;action&quot; type=&quot;command&quot;/&gt;

     &lt;xsd:element name=&quot;test&quot;&gt;

       &lt;xsd:complexType&gt;
         &lt;xsd:sequence&gt;
           &lt;xsd:choice minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
             &lt;xsd:element ref=&quot;str&quot;/&gt;
             &lt;xsd:element ref=&quot;num&quot;/&gt;
             &lt;xsd:element ref=&quot;list&quot;/&gt;
             &lt;xsd:element ref=&quot;tag&quot;/&gt;
             &lt;xsd:element ref=&quot;displaydata&quot;/&gt;
             &lt;xsd:element ref=&quot;comment&quot;/&gt;
             &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;
           &lt;/xsd:choice&gt;
           &lt;xsd:element ref=&quot;test&quot; minOccurs=&quot;0&quot;
                        maxOccurs=&quot;unbounded&quot;/&gt;
         &lt;/xsd:sequence&gt;
         &lt;xsd:attribute use=&quot;required&quot; name=&quot;name&quot; type=&quot;identifier&quot;/&gt;
       &lt;/xsd:complexType&gt;
     &lt;/xsd:element&gt;

     &lt;xsd:element name=&quot;list&quot;&gt;
       &lt;xsd:complexType&gt;
         &lt;xsd:sequence&gt;
           &lt;xsd:element ref=&quot;str&quot; minOccurs=&quot;1&quot;
                        maxOccurs=&quot;unbounded&quot;/&gt;
         &lt;/xsd:sequence&gt;
       &lt;/xsd:complexType&gt;
     &lt;/xsd:element&gt;

     &lt;xsd:element name=&quot;tag&quot; type=&quot;identifier&quot;/&gt;

     &lt;xsd:element name=&quot;str&quot; type=&quot;xsd:string&quot;/&gt;

     &lt;xsd:element name=&quot;num&quot; type=&quot;xsd:nonNegativeInteger&quot;/&gt;

     &lt;xsd:simpleType name=&quot;identifier&quot;&gt;
       &lt;xsd:restriction base=&quot;xsd:token&quot;&gt;
         &lt;xsd:pattern value=&quot;[A-Za-z_][A-Za-z0-9_]*&quot;/&gt;
       &lt;/xsd:restriction&gt;
     &lt;/xsd:simpleType&gt;

     &lt;xsd:element name=&quot;displayblock&quot;&gt;
       &lt;xsd:complexType&gt;
         &lt;xsd:sequence&gt;
           &lt;xsd:choice minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
             &lt;xsd:element ref=&quot;control&quot;/&gt;
             &lt;xsd:element ref=&quot;action&quot;/&gt;
             &lt;xsd:element ref=&quot;displayblock&quot;/&gt;
             &lt;xsd:element ref=&quot;displaydata&quot;/&gt;
             &lt;xsd:element ref=&quot;comment&quot;/&gt;

             &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;
           &lt;/xsd:choice&gt;
         &lt;/xsd:sequence&gt;
         &lt;xsd:anyAttribute processContents=&quot;skip&quot;/&gt;
       &lt;/xsd:complexType&gt;
     &lt;/xsd:element&gt;

     &lt;xsd:element name=&quot;displaydata&quot;&gt;
       &lt;xsd:complexType&gt;
         &lt;xsd:sequence minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
           &lt;xsd:any processContents=&quot;skip&quot;/&gt;
         &lt;/xsd:sequence&gt;
       &lt;/xsd:complexType&gt;
     &lt;/xsd:element&gt;

   &lt;/xsd:schema&gt;

Appendix C.  Relax NG Schema for Sieves in XML

   This appendix is informative.  The following code component defines a
   Relax NG Schema using compact notation OASISRNC [OASISRNC] for the
   XML representation of Sieve scripts.  Most of the elements employing
   a complex content model allow unrestricted use of elements in other
   namespaces.  Additionally, displaydata elements can be used to
   encapsulate arbitrary XML content.  Finally, displayblock elements
   can be used as a general-purpose grouping mechanism -- arbitrary
   attributes are allowed on displayblock elements.

   namespace sieve = &quot;urn:ietf:params:xml:ns:sieve&quot;

   start = element sieve:sieve { ( control | action | displayblock |
                                   displaydata | comment | ext )* }

   comment = element sieve:comment { xsd:string }

   ambles =
      (
         ( displaydata | comment | ext )*
      ),
      empty

   preamble = element sieve:preamble { ambles }
   postamble = element sieve:postamble { ambles }

   command =
      (
         attribute name {
           xsd:token {

             pattern = &quot;[A-Za-z_][A-Za-z0-9_]*&quot; } },
         preamble?,
         ( str | num | \list | tag )*,
         test?,
         ( control | action | displayblock)*,
         postamble?
      ),
      empty

   control = element sieve:control { command }
   action = element sieve:action { command }

   test =
      element sieve:test
      {
         attribute name {
           xsd:token {
             pattern = &quot;[A-Za-z_][A-Za-z0-9_]*&quot; } },
         ( str | num | \list | tag | comment | ext )*,
         test*
      }

   \list = element sieve:list { str+ }

   tag = element sieve:tag {
           xsd:token {
             pattern = &quot;[A-Za-z_][A-Za-z0-9_]*&quot; } }

   str = element sieve:str { xsd:string }

   num = element sieve:num { xsd:nonNegativeInteger }

   any = ( element * { any } | attribute * { text } | text )*

   ext = element * - sieve:* { any }*

   displayblock =
      element sieve:displayblock
      {
         ( control | action | displayblock |
           displaydata | comment | ext )*,
         attribute * { text }*
      }

   displaydata = element sieve:displaydata { any* }

Appendix D.  Stylesheet for Conversion from XML

   This appendix is informative.  The following code component is a
   stylesheet that can be used to convert the Sieve in XML
   representation to regular Sieve format.  Content in other namespaces,
   displaydata, and displayblock elements are converted to structured
   comments as appropriate.

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;

   &lt;!-- Convert Sieve in XML to standard Sieve syntax --&gt;

   &lt;xsl:stylesheet version=&quot;1.0&quot;
                   xmlns:xsl=&quot;http://www.w3.org/1999/XSL/Transform&quot;
                   xmlns:sieve=&quot;urn:ietf:params:xml:ns:sieve&quot;&gt;

     &lt;xsl:output method=&quot;text&quot; encoding=&quot;UTF-8&quot;
                 media-type=&quot;application/sieve&quot;/&gt;

     &lt;!-- Only preserve whitespace in str elements --&gt;
     &lt;xsl:strip-space elements=&quot;*&quot;/&gt;
     &lt;xsl:preserve-space elements=&quot;sieve:str&quot;/&gt;

     &lt;!-- Match top level sieve node,
          start processing in sieve mode --&gt;

     &lt;xsl:template match=&quot;sieve:sieve&quot;&gt;
       &lt;xsl:apply-templates select=&quot;*&quot; mode=&quot;sieve&quot;&gt;
         &lt;xsl:with-param name=&quot;prefix&quot; select=&quot;&#x27;&#x27;&quot;/&gt;
       &lt;/xsl:apply-templates&gt;
     &lt;/xsl:template&gt;

     &lt;!-- Routine to properly literalize quotes in Sieve strings --&gt;

     &lt;xsl:template name=&quot;quote-string&quot;&gt;
       &lt;xsl:param name=&quot;str&quot;/&gt;
       &lt;xsl:choose&gt;
         &lt;xsl:when test=&quot;not($str)&quot;/&gt;
         &lt;xsl:when test=&quot;contains($str, &#x27;&amp;quot;&#x27;)&quot;&gt;
           &lt;xsl:call-template name=&quot;quote-string&quot;&gt;
             &lt;xsl:with-param name=&quot;str&quot;
                select=&quot;substring-before($str, &#x27;&amp;quot;&#x27;)&quot;/&gt;
           &lt;/xsl:call-template&gt;
           &lt;xsl:text&gt;\&amp;quot;&lt;/xsl:text&gt;
           &lt;xsl:call-template name=&quot;quote-string&quot;&gt;
             &lt;xsl:with-param name=&quot;str&quot;
                select=&quot;substring-after($str, &#x27;&amp;quot;&#x27;)&quot;/&gt;
           &lt;/xsl:call-template&gt;

         &lt;/xsl:when&gt;
         &lt;xsl:when test=&quot;contains($str, &#x27;\&#x27;)&quot;&gt;
           &lt;xsl:call-template name=&quot;quote-string&quot;&gt;
             &lt;xsl:with-param name=&quot;str&quot;
                select=&quot;substring-before($str, &#x27;\&#x27;)&quot;/&gt;
           &lt;/xsl:call-template&gt;
           &lt;xsl:text&gt;\\&lt;/xsl:text&gt;
           &lt;xsl:call-template name=&quot;quote-string&quot;&gt;
             &lt;xsl:with-param name=&quot;str&quot;
                select=&quot;substring-after($str, &#x27;\&#x27;)&quot;/&gt;
           &lt;/xsl:call-template&gt;
         &lt;/xsl:when&gt;
         &lt;xsl:otherwise&gt;
           &lt;xsl:value-of select=&quot;$str&quot;/&gt;
         &lt;/xsl:otherwise&gt;
       &lt;/xsl:choose&gt;
     &lt;/xsl:template&gt;

     &lt;!-- Sieve mode processing templates --&gt;

     &lt;xsl:template match=&quot;sieve:control|sieve:action&quot; mode=&quot;sieve&quot;&gt;
       &lt;xsl:param name=&quot;prefix&quot;/&gt;
       &lt;xsl:text xml:space=&quot;preserve&quot;&gt;
   &lt;/xsl:text&gt;
       &lt;xsl:value-of select=&quot;$prefix&quot;/&gt;
       &lt;xsl:value-of select=&quot;@name&quot;/&gt;
       &lt;xsl:variable name=&quot;blockbegin&quot;
               select=&quot;generate-id(sieve:control|sieve:action)&quot;/&gt;
       &lt;xsl:for-each select=&quot;*&quot;&gt;
         &lt;xsl:choose&gt;
           &lt;xsl:when test=&quot;self::sieve:str|self::sieve:num|
                           self::sieve:list|self::sieve:tag|
                           self::sieve:test&quot;&gt;
             &lt;xsl:apply-templates select=&quot;.&quot; mode=&quot;sieve&quot;/&gt;
           &lt;/xsl:when&gt;
           &lt;xsl:when test=&quot;generate-id(.) = $blockbegin&quot;&gt;
             &lt;xsl:text xml:space=&quot;preserve&quot;&gt;
   &lt;/xsl:text&gt;
             &lt;xsl:value-of select=&quot;$prefix&quot;/&gt;
             &lt;xsl:text&gt;{&lt;/xsl:text&gt;
             &lt;xsl:apply-templates select=&quot;.&quot; mode=&quot;sieve&quot;&gt;
               &lt;xsl:with-param name=&quot;prefix&quot;
                  select=&quot;concat($prefix, &#x27;  &#x27;)&quot;/&gt;
             &lt;/xsl:apply-templates&gt;
           &lt;/xsl:when&gt;
           &lt;xsl:otherwise&gt;
             &lt;xsl:apply-templates select=&quot;.&quot; mode=&quot;sieve&quot;&gt;
               &lt;xsl:with-param name=&quot;prefix&quot;

                  select=&quot;concat($prefix, &#x27;  &#x27;)&quot;/&gt;
             &lt;/xsl:apply-templates&gt;
           &lt;/xsl:otherwise&gt;
         &lt;/xsl:choose&gt;
       &lt;/xsl:for-each&gt;
       &lt;xsl:choose&gt;
         &lt;xsl:when test=&quot;count(sieve:control|sieve:action) &amp;gt; 0&quot;&gt;
           &lt;xsl:text xml:space=&quot;preserve&quot;&gt;
   &lt;/xsl:text&gt;
           &lt;xsl:value-of select=&quot;$prefix&quot;/&gt;
           &lt;xsl:text&gt;}&lt;/xsl:text&gt;
         &lt;/xsl:when&gt;
         &lt;xsl:otherwise&gt;
           &lt;xsl:text&gt;;&lt;/xsl:text&gt;
         &lt;/xsl:otherwise&gt;
       &lt;/xsl:choose&gt;
     &lt;/xsl:template&gt;

     &lt;xsl:template match=&quot;sieve:preamble|sieve:postamble&quot; mode=&quot;sieve&quot;&gt;
       &lt;xsl:param name=&quot;prefix&quot;/&gt;
       &lt;xsl:apply-templates mode=&quot;sieve&quot;&gt;
         &lt;xsl:with-param name=&quot;prefix&quot; select=&quot;$prefix&quot;/&gt;
       &lt;/xsl:apply-templates&gt;
     &lt;/xsl:template&gt;

     &lt;xsl:template match=&quot;sieve:test&quot; mode=&quot;sieve&quot;&gt;
       &lt;xsl:text xml:space=&quot;preserve&quot;&gt; &lt;/xsl:text&gt;
       &lt;xsl:value-of select=&quot;@name&quot;/&gt;
       &lt;xsl:apply-templates select=&quot;*[not(self::sieve:test)]&quot;
                            mode=&quot;sieve&quot;/&gt;
       &lt;xsl:if test=&quot;count(descendant::sieve:test) &amp;gt; 0&quot;&gt;
         &lt;xsl:text&gt; (&lt;/xsl:text&gt;
         &lt;xsl:for-each select=&quot;sieve:test&quot;&gt;
           &lt;xsl:apply-templates select=&quot;.&quot; mode=&quot;sieve&quot;/&gt;
           &lt;xsl:if test=&quot;count(following-sibling::sieve:test) &amp;gt; 0&quot;&gt;
             &lt;xsl:text&gt;,&lt;/xsl:text&gt;
           &lt;/xsl:if&gt;
         &lt;/xsl:for-each&gt;
         &lt;xsl:text&gt; )&lt;/xsl:text&gt;
       &lt;/xsl:if&gt;
     &lt;/xsl:template&gt;

     &lt;xsl:template match=&quot;sieve:str&quot; mode=&quot;sieve&quot;&gt;
       &lt;xsl:text&gt; &amp;quot;&lt;/xsl:text&gt;
       &lt;xsl:call-template name=&quot;quote-string&quot;&gt;
         &lt;xsl:with-param name=&quot;str&quot; select=&quot;text()&quot;/&gt;
       &lt;/xsl:call-template&gt;
       &lt;xsl:text&gt;&amp;quot;&lt;/xsl:text&gt;

     &lt;/xsl:template&gt;

     &lt;xsl:template match=&quot;sieve:num&quot; mode=&quot;sieve&quot;&gt;
       &lt;xsl:text xml:space=&quot;preserve&quot;&gt; &lt;/xsl:text&gt;
       &lt;!-- Use numeric suffixes when possible --&gt;
       &lt;xsl:choose&gt;
         &lt;xsl:when test=&quot;(number(text()) mod 1073741824) = 0&quot;&gt;
           &lt;xsl:value-of select=&quot;number(text()) div 1073741824&quot;/&gt;
           &lt;xsl:text&gt;G&lt;/xsl:text&gt;
         &lt;/xsl:when&gt;
         &lt;xsl:when test=&quot;(number(text()) mod 1048576) = 0&quot;&gt;
           &lt;xsl:value-of select=&quot;number(text()) div 1048576&quot;/&gt;
           &lt;xsl:text&gt;M&lt;/xsl:text&gt;
         &lt;/xsl:when&gt;
         &lt;xsl:when test=&quot;(number(text()) mod 1024) = 0&quot;&gt;
           &lt;xsl:value-of select=&quot;number(text()) div 1024&quot;/&gt;
           &lt;xsl:text&gt;K&lt;/xsl:text&gt;
         &lt;/xsl:when&gt;
         &lt;xsl:otherwise&gt;
           &lt;xsl:value-of select=&quot;text()&quot;/&gt;
         &lt;/xsl:otherwise&gt;
       &lt;/xsl:choose&gt;
     &lt;/xsl:template&gt;

     &lt;xsl:template match=&quot;sieve:list&quot; mode=&quot;sieve&quot;&gt;
       &lt;xsl:text&gt; [&lt;/xsl:text&gt;
       &lt;xsl:for-each select=&quot;sieve:str&quot;&gt;
         &lt;xsl:apply-templates select=&quot;.&quot; mode=&quot;sieve&quot;/&gt;
         &lt;xsl:if test=&quot;count(following-sibling::sieve:str) &amp;gt; 0&quot;&gt;
           &lt;xsl:text&gt;,&lt;/xsl:text&gt;
         &lt;/xsl:if&gt;
       &lt;/xsl:for-each&gt;
       &lt;xsl:text&gt; ]&lt;/xsl:text&gt;
     &lt;/xsl:template&gt;

     &lt;xsl:template match=&quot;sieve:tag&quot; mode=&quot;sieve&quot;&gt;
       &lt;xsl:text&gt; :&lt;/xsl:text&gt;
       &lt;xsl:value-of select=&quot;text()&quot;/&gt;
     &lt;/xsl:template&gt;

     &lt;xsl:template match=&quot;sieve:comment&quot; mode=&quot;sieve&quot;&gt;
       &lt;xsl:param name=&quot;prefix&quot;/&gt;
       &lt;xsl:text xml:space=&quot;preserve&quot;&gt;
   &lt;/xsl:text&gt;
       &lt;xsl:value-of select=&quot;$prefix&quot;/&gt;
       &lt;xsl:text&gt;/*&lt;/xsl:text&gt;
       &lt;xsl:value-of select=&quot;.&quot;/&gt;
       &lt;xsl:value-of select=&quot;$prefix&quot;/&gt;

       &lt;xsl:text&gt;*/&lt;/xsl:text&gt;
     &lt;/xsl:template&gt;

     &lt;!-- Convert display information into structured comments --&gt;

     &lt;xsl:template match=&quot;sieve:displayblock&quot; mode=&quot;sieve&quot;&gt;
       &lt;xsl:param name=&quot;prefix&quot;/&gt;
       &lt;xsl:text xml:space=&quot;preserve&quot;&gt;
   &lt;/xsl:text&gt;
       &lt;xsl:value-of select=&quot;$prefix&quot;/&gt;
       &lt;xsl:text&gt;/* [*&lt;/xsl:text&gt;
       &lt;xsl:apply-templates select=&quot;@*&quot; mode=&quot;copy&quot;/&gt;
       &lt;xsl:text&gt; */&lt;/xsl:text&gt;
       &lt;xsl:apply-templates select=&quot;*&quot; mode=&quot;sieve&quot;&gt;
         &lt;xsl:with-param name=&quot;prefix&quot; select=&quot;$prefix&quot;/&gt;
       &lt;/xsl:apply-templates&gt;
       &lt;xsl:text xml:space=&quot;preserve&quot;&gt;
   &lt;/xsl:text&gt;
       &lt;xsl:value-of select=&quot;$prefix&quot;/&gt;
       &lt;xsl:text&gt;/* *] */&lt;/xsl:text&gt;
     &lt;/xsl:template&gt;

     &lt;xsl:template match=&quot;sieve:displaydata&quot; mode=&quot;sieve&quot;&gt;
       &lt;xsl:param name=&quot;prefix&quot;/&gt;
       &lt;xsl:text xml:space=&quot;preserve&quot;&gt;
   &lt;/xsl:text&gt;
       &lt;xsl:value-of select=&quot;$prefix&quot;/&gt;
       &lt;xsl:text&gt;/* [|&lt;/xsl:text&gt;
       &lt;xsl:apply-templates mode=&quot;copy&quot;&gt;
         &lt;xsl:with-param name=&quot;prefix&quot;
                         select=&quot;concat($prefix, &#x27;  &#x27;)&quot;/&gt;
       &lt;/xsl:apply-templates&gt;
       &lt;xsl:text xml:space=&quot;preserve&quot;&gt;
   &lt;/xsl:text&gt;
       &lt;xsl:value-of select=&quot;$prefix&quot;/&gt;
       &lt;xsl:text&gt;   |] */&lt;/xsl:text&gt;
     &lt;/xsl:template&gt;

     &lt;!-- Copy unrecnognized nodes and their descendants --&gt;

     &lt;xsl:template match=&quot;*&quot; mode=&quot;sieve&quot;&gt;
       &lt;xsl:param name=&quot;prefix&quot;/&gt;
       &lt;xsl:text xml:space=&quot;preserve&quot;&gt;
   &lt;/xsl:text&gt;
       &lt;xsl:value-of select=&quot;$prefix&quot;/&gt;
       &lt;xsl:text&gt;/* [/&lt;/xsl:text&gt;
       &lt;xsl:apply-templates select=&quot;.&quot; mode=&quot;copy&quot;&gt;
         &lt;xsl:with-param name=&quot;prefix&quot;

                         select=&quot;concat($prefix, &#x27;  &#x27;)&quot;/&gt;
       &lt;/xsl:apply-templates&gt;
       &lt;xsl:text xml:space=&quot;preserve&quot;&gt;
   &lt;/xsl:text&gt;
       &lt;xsl:value-of select=&quot;$prefix&quot;/&gt;
       &lt;xsl:text&gt;   /] */&lt;/xsl:text&gt;
     &lt;/xsl:template&gt;

     &lt;!-- Copy mode processing templates --&gt;

     &lt;xsl:template match=&quot;*[not(node())]&quot; mode=&quot;copy&quot;&gt;
       &lt;xsl:param name=&quot;prefix&quot;/&gt;
       &lt;xsl:text xml:space=&quot;preserve&quot;&gt;
   &lt;/xsl:text&gt;
       &lt;xsl:value-of select=&quot;$prefix&quot;/&gt;
       &lt;xsl:text&gt;&amp;lt;&lt;/xsl:text&gt;
       &lt;xsl:value-of select=&quot;name()&quot;/&gt;
       &lt;xsl:apply-templates select=&quot;@*&quot; mode=&quot;copy&quot;/&gt;
       &lt;xsl:text&gt;/&amp;gt;&lt;/xsl:text&gt;
     &lt;/xsl:template&gt;

     &lt;xsl:template match=&quot;*[node()]&quot; mode=&quot;copy&quot;&gt;
       &lt;xsl:param name=&quot;prefix&quot;/&gt;
       &lt;xsl:text xml:space=&quot;preserve&quot;&gt;
   &lt;/xsl:text&gt;
       &lt;xsl:value-of select=&quot;$prefix&quot;/&gt;
       &lt;xsl:text&gt;&amp;lt;&lt;/xsl:text&gt;
       &lt;xsl:value-of select=&quot;name()&quot;/&gt;
       &lt;xsl:apply-templates select=&quot;@*&quot; mode=&quot;copy&quot;/&gt;
       &lt;xsl:text&gt;&amp;gt;&lt;/xsl:text&gt;
       &lt;xsl:apply-templates mode=&quot;copy&quot;&gt;
         &lt;xsl:with-param name=&quot;prefix&quot;
                         select=&quot;concat($prefix, &#x27;  &#x27;)&quot;/&gt;
       &lt;/xsl:apply-templates&gt;
       &lt;xsl:if test=&quot;*[last()][not(text())]&quot;&gt;
         &lt;xsl:text xml:space=&quot;preserve&quot;&gt;
   &lt;/xsl:text&gt;
         &lt;xsl:value-of select=&quot;$prefix&quot;/&gt;
       &lt;/xsl:if&gt;
       &lt;xsl:text&gt;&amp;lt;/&lt;/xsl:text&gt;
       &lt;xsl:value-of select=&quot;name()&quot;/&gt;
       &lt;xsl:text&gt;&amp;gt;&lt;/xsl:text&gt;
     &lt;/xsl:template&gt;

     &lt;xsl:template match=&quot;@*&quot; mode=&quot;copy&quot;&gt;
       &lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;xsl:value-of select=&quot;name()&quot;/&gt;
       &lt;xsl:text&gt;=&quot;&lt;/xsl:text&gt;

       &lt;xsl:value-of select=&quot;.&quot;/&gt;
       &lt;xsl:text&gt;&quot;&lt;/xsl:text&gt;
     &lt;/xsl:template&gt;

   &lt;/xsl:stylesheet&gt;

Appendix E.  Acknowledgements

   The stylesheet copy mode code is loosely based on a sample code
   posted to the xsl-list list by Americo Albuquerque.  Jari Arkko,
   Robert Burrell Donkin, Andrew McKeon, Alexey Melnikov, and Aaron
   Stone provided useful comments on the document.

Authors&#x27; Addresses

   Ned Freed
   Sun Microsystems
   800 Royal Oaks
   Monrovia, CA  91016-6347
   USA

   Phone: +1 909 457 4293
   EMail: ned.freed@mrochek.com


   Srinivas Saisatish Vedam
   Sun Microsystems

   Phone: +91 80669 27577
   EMail: Srinivas.Sv@Sun.COM


        </re>
        
    </body>
</html>
