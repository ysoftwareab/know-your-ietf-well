<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="robots" content="index,follow" />

        <link rel="icon" href="./css/images/rfc.png" type="image/png" />
        <link rel="shortcut icon" href="./css/images/rfc.png" type="image/png" />
        <title>rfc6241</title>
    
        <link rel="stylesheet" type="text/css" href="./css/errata-base.css"/>
        <link rel="stylesheet" type="text/css" href="./css/errata-color.css" title="Default: Basic Colors"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-monochrome.css" title="Monochrome"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-printer.css" title="Printer"/>

        <script src="./css/errata.js"></script>
    </head>
    <body>
        <div class='Verified-headnote-styling'>
<span style="font-weight: bold;">This is a purely informative rendering of an RFC that includes verified errata.  This rendering may not be used as a reference.</span>
<br/>
<br/>
The following 'Verified' errata have been incorporated in this document:
 <a href='#eid3980'>EID 3980</a>,  <a href='#btn_4066'>EID 4066</a>,  <a href='#btn_5388'>EID 5388</a>,  <a href='#eid5790'>EID 5790</a>
</div>

        <pre>
Internet Engineering Task Force (IETF)                      R. Enns, Ed.
Request for Comments: 6241                              Juniper Networks
Obsoletes: 4741                                        M. Bjorklund, Ed.
Category: Standards Track                                 Tail-f Systems
ISSN: 2070-1721                                    J. Schoenwaelder, Ed.
                                                       Jacobs University
                                                         A. Bierman, Ed.
                                                                 Brocade
                                                               June 2011


                Network Configuration Protocol (NETCONF)

Abstract

   The Network Configuration Protocol (NETCONF) defined in this document
   provides mechanisms to install, manipulate, and delete the
   configuration of network devices.  It uses an Extensible Markup
   Language (XML)-based data encoding for the configuration data as well
   as the protocol messages.  The NETCONF protocol operations are
   realized as remote procedure calls (RPCs).  This document obsoletes
   RFC 4741.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 5741.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc6241.

Copyright Notice

   Copyright (c) 2011 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   6
     1.1.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   7
     1.2.  Protocol Overview . . . . . . . . . . . . . . . . . . . .   8
     1.3.  Capabilities  . . . . . . . . . . . . . . . . . . . . . .  10
     1.4.  Separation of Configuration and State Data  . . . . . . .  10
   2.  Transport Protocol Requirements . . . . . . . . . . . . . . .  11
     2.1.  Connection-Oriented Operation . . . . . . . . . . . . . .  11
     2.2.  Authentication, Integrity, and Confidentiality  . . . . .  12
     2.3.  Mandatory Transport Protocol  . . . . . . . . . . . . . .  12
   3.  XML Considerations  . . . . . . . . . . . . . . . . . . . . .  13
     3.1.  Namespace . . . . . . . . . . . . . . . . . . . . . . . .  13
     3.2.  Document Type Declarations  . . . . . . . . . . . . . . .  13
   4.  RPC Model . . . . . . . . . . . . . . . . . . . . . . . . . .  13
     4.1.  &lt;rpc&gt; Element . . . . . . . . . . . . . . . . . . . . . .  13
     4.2.  &lt;rpc-reply&gt; Element . . . . . . . . . . . . . . . . . . .  15
     4.3.  &lt;rpc-error&gt; Element . . . . . . . . . . . . . . . . . . .  16
     4.4.  &lt;ok&gt; Element  . . . . . . . . . . . . . . . . . . . . . .  19
     4.5.  Pipelining  . . . . . . . . . . . . . . . . . . . . . . .  19
   5.  Configuration Model . . . . . . . . . . . . . . . . . . . . .  19
     5.1.  Configuration Datastores  . . . . . . . . . . . . . . . .  19
     5.2.  Data Modeling . . . . . . . . . . . . . . . . . . . . . .  20
   6.  Subtree Filtering . . . . . . . . . . . . . . . . . . . . . .  20
     6.1.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .  20
     6.2.  Subtree Filter Components . . . . . . . . . . . . . . . .  21
       6.2.1.  Namespace Selection . . . . . . . . . . . . . . . . .  21
       6.2.2.  Attribute Match Expressions . . . . . . . . . . . . .  22
       6.2.3.  Containment Nodes . . . . . . . . . . . . . . . . . .  23
       6.2.4.  Selection Nodes . . . . . . . . . . . . . . . . . . .  23
       6.2.5.  Content Match Nodes . . . . . . . . . . . . . . . . .  24
     6.3.  Subtree Filter Processing . . . . . . . . . . . . . . . .  25
     6.4.  Subtree Filtering Examples  . . . . . . . . . . . . . . .  26
       6.4.1.  No Filter . . . . . . . . . . . . . . . . . . . . . .  26
       6.4.2.  Empty Filter  . . . . . . . . . . . . . . . . . . . .  26
       6.4.3.  Select the Entire &lt;users&gt; Subtree . . . . . . . . . .  27
       6.4.4.  Select All &lt;name&gt; Elements within the &lt;users&gt;
               Subtree . . . . . . . . . . . . . . . . . . . . . . .  29
       6.4.5.  One Specific &lt;user&gt; Entry . . . . . . . . . . . . . .  30
       6.4.6.  Specific Elements from a Specific &lt;user&gt; Entry  . . .  31
       6.4.7.  Multiple Subtrees . . . . . . . . . . . . . . . . . .  32
       6.4.8.  Elements with Attribute Naming  . . . . . . . . . . .  33
   7.  Protocol Operations . . . . . . . . . . . . . . . . . . . . .  35
     7.1.  &lt;get-config&gt;  . . . . . . . . . . . . . . . . . . . . . .  35
     7.2.  &lt;edit-config&gt; . . . . . . . . . . . . . . . . . . . . . .  37
     7.3.  &lt;copy-config&gt; . . . . . . . . . . . . . . . . . . . . . .  43
     7.4.  &lt;delete-config&gt; . . . . . . . . . . . . . . . . . . . . .  44
     7.5.  &lt;lock&gt;  . . . . . . . . . . . . . . . . . . . . . . . . .  44

     7.6.  &lt;unlock&gt;  . . . . . . . . . . . . . . . . . . . . . . . .  47
     7.7.  &lt;get&gt; . . . . . . . . . . . . . . . . . . . . . . . . . .  48
     7.8.  &lt;close-session&gt; . . . . . . . . . . . . . . . . . . . . .  49
     7.9.  &lt;kill-session&gt;  . . . . . . . . . . . . . . . . . . . . .  50
   8.  Capabilities  . . . . . . . . . . . . . . . . . . . . . . . .  51
     8.1.  Capabilities Exchange . . . . . . . . . . . . . . . . . .  51
     8.2.  Writable-Running Capability . . . . . . . . . . . . . . .  53
       8.2.1.  Description . . . . . . . . . . . . . . . . . . . . .  53
       8.2.2.  Dependencies  . . . . . . . . . . . . . . . . . . . .  53
       8.2.3.  Capability Identifier . . . . . . . . . . . . . . . .  53
       8.2.4.  New Operations  . . . . . . . . . . . . . . . . . . .  53
       8.2.5.  Modifications to Existing Operations  . . . . . . . .  53
     8.3.  Candidate Configuration Capability  . . . . . . . . . . .  53
       8.3.1.  Description . . . . . . . . . . . . . . . . . . . . .  53
       8.3.2.  Dependencies  . . . . . . . . . . . . . . . . . . . .  54
       8.3.3.  Capability Identifier . . . . . . . . . . . . . . . .  54
       8.3.4.  New Operations  . . . . . . . . . . . . . . . . . . .  54
       8.3.5.  Modifications to Existing Operations  . . . . . . . .  56
     8.4.  Confirmed Commit Capability . . . . . . . . . . . . . . .  57
       8.4.1.  Description . . . . . . . . . . . . . . . . . . . . .  57
       8.4.2.  Dependencies  . . . . . . . . . . . . . . . . . . . .  58
       8.4.3.  Capability Identifier . . . . . . . . . . . . . . . .  58
       8.4.4.  New Operations  . . . . . . . . . . . . . . . . . . .  59
       8.4.5.  Modifications to Existing Operations  . . . . . . . .  60
     8.5.  Rollback-on-Error Capability  . . . . . . . . . . . . . .  61
       8.5.1.  Description . . . . . . . . . . . . . . . . . . . . .  61
       8.5.2.  Dependencies  . . . . . . . . . . . . . . . . . . . .  62
       8.5.3.  Capability Identifier . . . . . . . . . . . . . . . .  62
       8.5.4.  New Operations  . . . . . . . . . . . . . . . . . . .  62
       8.5.5.  Modifications to Existing Operations  . . . . . . . .  62
     8.6.  Validate Capability . . . . . . . . . . . . . . . . . . .  63
       8.6.1.  Description . . . . . . . . . . . . . . . . . . . . .  63
       8.6.2.  Dependencies  . . . . . . . . . . . . . . . . . . . .  63
       8.6.3.  Capability Identifier . . . . . . . . . . . . . . . .  63
       8.6.4.  New Operations  . . . . . . . . . . . . . . . . . . .  63
       8.6.5.  Modifications to Existing Operations  . . . . . . . .  64
     8.7.  Distinct Startup Capability . . . . . . . . . . . . . . .  64
       8.7.1.  Description . . . . . . . . . . . . . . . . . . . . .  64
       8.7.2.  Dependencies  . . . . . . . . . . . . . . . . . . . .  65
       8.7.3.  Capability Identifier . . . . . . . . . . . . . . . .  65
       8.7.4.  New Operations  . . . . . . . . . . . . . . . . . . .  65
       8.7.5.  Modifications to Existing Operations  . . . . . . . .  65
     8.8.  URL Capability  . . . . . . . . . . . . . . . . . . . . .  66
       8.8.1.  Description . . . . . . . . . . . . . . . . . . . . .  66
       8.8.2.  Dependencies  . . . . . . . . . . . . . . . . . . . .  66
       8.8.3.  Capability Identifier . . . . . . . . . . . . . . . .  66
       8.8.4.  New Operations  . . . . . . . . . . . . . . . . . . .  66
       8.8.5.  Modifications to Existing Operations  . . . . . . . .  66

     8.9.  XPath Capability  . . . . . . . . . . . . . . . . . . . .  67
       8.9.1.  Description . . . . . . . . . . . . . . . . . . . . .  67
       8.9.2.  Dependencies  . . . . . . . . . . . . . . . . . . . .  68
       8.9.3.  Capability Identifier . . . . . . . . . . . . . . . .  68
       8.9.4.  New Operations  . . . . . . . . . . . . . . . . . . .  68
       8.9.5.  Modifications to Existing Operations  . . . . . . . .  68
   9.  Security Considerations . . . . . . . . . . . . . . . . . . .  69
   10. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  71
     10.1. NETCONF XML Namespace . . . . . . . . . . . . . . . . . .  71
     10.2. NETCONF XML Schema  . . . . . . . . . . . . . . . . . . .  71
     10.3. NETCONF YANG Module . . . . . . . . . . . . . . . . . . .  72
     10.4. NETCONF Capability URNs . . . . . . . . . . . . . . . . .  72
   11. Contributors  . . . . . . . . . . . . . . . . . . . . . . . .  73
   12. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  73
   13. References  . . . . . . . . . . . . . . . . . . . . . . . . .  74
     13.1. Normative References  . . . . . . . . . . . . . . . . . .  74
     13.2. Informative References  . . . . . . . . . . . . . . . . .  75
   Appendix A.  NETCONF Error List . . . . . . . . . . . . . . . . .  76
   Appendix B.  XML Schema for NETCONF Messages Layer  . . . . . . .  80
   Appendix C.  YANG Module for NETCONF Protocol Operations  . . . .  85
   Appendix D.  Capability Template  . . . . . . . . . . . . . . . . 105
     D.1.  capability-name (template)  . . . . . . . . . . . . . . . 105
       D.1.1.  Overview  . . . . . . . . . . . . . . . . . . . . . . 105
       D.1.2.  Dependencies  . . . . . . . . . . . . . . . . . . . . 105
       D.1.3.  Capability Identifier . . . . . . . . . . . . . . . . 105
       D.1.4.  New Operations  . . . . . . . . . . . . . . . . . . . 105
       D.1.5.  Modifications to Existing Operations  . . . . . . . . 105
       D.1.6.  Interactions with Other Capabilities  . . . . . . . . 105
   Appendix E.  Configuring Multiple Devices with NETCONF  . . . . . 106
     E.1.  Operations on Individual Devices  . . . . . . . . . . . . 106
       E.1.1.  Acquiring the Configuration Lock  . . . . . . . . . . 106
       E.1.2.  Checkpointing the Running Configuration . . . . . . . 107
       E.1.3.  Loading and Validating the Incoming Configuration . . 108
       E.1.4.  Changing the Running Configuration  . . . . . . . . . 108
       E.1.5.  Testing the New Configuration . . . . . . . . . . . . 109
       E.1.6.  Making the Change Permanent . . . . . . . . . . . . . 109
       E.1.7.  Releasing the Configuration Lock  . . . . . . . . . . 110
     E.2.  Operations on Multiple Devices  . . . . . . . . . . . . . 111
   Appendix F.  Changes from RFC 4741  . . . . . . . . . . . . . . . 112

1.  Introduction

   The NETCONF protocol defines a simple mechanism through which a
   network device can be managed, configuration data information can be
   retrieved, and new configuration data can be uploaded and
   manipulated.  The protocol allows the device to expose a full, formal
   application programming interface (API).  Applications can use this
   straightforward API to send and receive full and partial
   configuration data sets.

   The NETCONF protocol uses a remote procedure call (RPC) paradigm.  A
   client encodes an RPC in XML [W3C.REC-xml-20001006] and sends it to a
   server using a secure, connection-oriented session.  The server
   responds with a reply encoded in XML.  The contents of both the
   request and the response are fully described in XML DTDs or XML
   schemas, or both, allowing both parties to recognize the syntax
   constraints imposed on the exchange.

   A key aspect of NETCONF is that it allows the functionality of the
   management protocol to closely mirror the native functionality of the
   device.  This reduces implementation costs and allows timely access
   to new features.  In addition, applications can access both the
   syntactic and semantic content of the device&#x27;s native user interface.

   NETCONF allows a client to discover the set of protocol extensions
   supported by a server.  These &quot;capabilities&quot; permit the client to
   adjust its behavior to take advantage of the features exposed by the
   device.  The capability definitions can be easily extended in a
   noncentralized manner.  Standard and non-standard capabilities can be
   defined with semantic and syntactic rigor.  Capabilities are
   discussed in Section 8.

   The NETCONF protocol is a building block in a system of automated
   configuration.  XML is the lingua franca of interchange, providing a
   flexible but fully specified encoding mechanism for hierarchical
   content.  NETCONF can be used in concert with XML-based
   transformation technologies, such as XSLT [W3C.REC-xslt-19991116], to
   provide a system for automated generation of full and partial
   configurations.  The system can query one or more databases for data
   about networking topologies, links, policies, customers, and
   services.  This data can be transformed using one or more XSLT
   scripts from a task-oriented, vendor-independent data schema into a
   form that is specific to the vendor, product, operating system, and
   software release.  The resulting data can be passed to the device
   using the NETCONF protocol.

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in RFC 2119 [RFC2119].

1.1.  Terminology

   o  candidate configuration datastore: A configuration datastore that
      can be manipulated without impacting the device&#x27;s current
      configuration and that can be committed to the running
      configuration datastore.  Not all devices support a candidate
      configuration datastore.

   o  capability: A functionality that supplements the base NETCONF
      specification.

   o  client: Invokes protocol operations on a server.  In addition, a
      client can subscribe to receive notifications from a server.

   o  configuration data: The set of writable data that is required to
      transform a system from its initial default state into its current
      state.

   o  datastore: A conceptual place to store and access information.  A
      datastore might be implemented, for example, using files, a
      database, flash memory locations, or combinations thereof.

   o  configuration datastore: The datastore holding the complete set of
      configuration data that is required to get a device from its
      initial default state into a desired operational state.

   o  message: A protocol element sent over a session.  Messages are
      well-formed XML documents.

   o  notification: A server-initiated message indicating that a certain
      event has been recognized by the server.

   o  protocol operation: A specific remote procedure call, as used
      within the NETCONF protocol.

   o  remote procedure call (RPC): Realized by exchanging &lt;rpc&gt; and
      &lt;rpc-reply&gt; messages.

   o  running configuration datastore: A configuration datastore holding
      the complete configuration currently active on the device.  The
      running configuration datastore always exists.

   o  server: Executes protocol operations invoked by a client.  In
      addition, a server can send notifications to a client.

   o  session: Client and server exchange messages using a secure,
      connection-oriented session.

   o  startup configuration datastore: The configuration datastore
      holding the configuration loaded by the device when it boots.
      Only present on devices that separate the startup configuration
      datastore from the running configuration datastore.

   o  state data: The additional data on a system that is not
      configuration data such as read-only status information and
      collected statistics.

   o  user: The authenticated identity of the client.  The authenticated
      identity of a client is commonly referred to as the NETCONF
      username.

1.2.  Protocol Overview

   NETCONF uses a simple RPC-based mechanism to facilitate communication
   between a client and a server.  The client can be a script or
   application typically running as part of a network manager.  The
   server is typically a network device.  The terms &quot;device&quot; and
   &quot;server&quot; are used interchangeably in this document, as are &quot;client&quot;
   and &quot;application&quot;.

   A NETCONF session is the logical connection between a network
   administrator or network configuration application and a network
   device.  A device MUST support at least one NETCONF session and
   SHOULD support multiple sessions.  Global configuration attributes
   can be changed during any authorized session, and the effects are
   visible in all sessions.  Session-specific attributes affect only the
   session in which they are changed.

   NETCONF can be conceptually partitioned into four layers as shown in
   Figure 1.

            Layer                 Example
       +-------------+      +-----------------+      +----------------+
   (4) |   Content   |      |  Configuration  |      |  Notification  |
       |             |      |      data       |      |      data      |
       +-------------+      +-----------------+      +----------------+
              |                       |                      |
       +-------------+      +-----------------+              |
   (3) | Operations  |      |  &lt;edit-config&gt;  |              |
       |             |      |                 |              |
       +-------------+      +-----------------+              |
              |                       |                      |
       +-------------+      +-----------------+      +----------------+
   (2) |  Messages   |      |     &lt;rpc&gt;,      |      | &lt;notification&gt; |
       |             |      |   &lt;rpc-reply&gt;   |      |                |
       +-------------+      +-----------------+      +----------------+
              |                       |                      |
       +-------------+      +-----------------------------------------+
   (1) |   Secure    |      |  SSH, TLS, BEEP/TLS, SOAP/HTTP/TLS, ... |
       |  Transport  |      |                                         |
       +-------------+      +-----------------------------------------+

                     Figure 1: NETCONF Protocol Layers

   (1)  The Secure Transport layer provides a communication path between
        the client and server.  NETCONF can be layered over any
        transport protocol that provides a set of basic requirements.
        Section 2 discusses these requirements.

   (2)  The Messages layer provides a simple, transport-independent
        framing mechanism for encoding RPCs and notifications.
        Section 4 documents the RPC messages, and [RFC5717] documents
        notifications.

   (3)  The Operations layer defines a set of base protocol operations
        invoked as RPC methods with XML-encoded parameters.  Section 7
        details the list of base protocol operations.

   (4)  The Content layer is outside the scope of this document.  It is
        expected that separate efforts to standardize NETCONF data
        models will be undertaken.

   The YANG data modeling language [RFC6020] has been developed for
   specifying NETCONF data models and protocol operations, covering the
   Operations and the Content layers of Figure 1.

1.3.  Capabilities

   A NETCONF capability is a set of functionality that supplements the
   base NETCONF specification.  The capability is identified by a
   uniform resource identifier (URI) [RFC3986].

   Capabilities augment the base operations of the device, describing
   both additional operations and the content allowed inside operations.
   The client can discover the server&#x27;s capabilities and use any
   additional operations, parameters, and content defined by those
   capabilities.

   The capability definition might name one or more dependent
   capabilities.  To support a capability, the server MUST support any
   capabilities upon which it depends.

   Section 8 defines the capabilities exchange that allows the client to
   discover the server&#x27;s capabilities.  Section 8 also lists the set of
   capabilities defined in this document.

   Additional capabilities can be defined at any time in external
   documents, allowing the set of capabilities to expand over time.
   Standards bodies can define standardized capabilities, and
   implementations can define proprietary ones.  A capability URI MUST
   sufficiently distinguish the naming authority to avoid naming
   collisions.

1.4.  Separation of Configuration and State Data

   The information that can be retrieved from a running system is
   separated into two classes, configuration data and state data.
   Configuration data is the set of writable data that is required to
   transform a system from its initial default state into its current
   state.  State data is the additional data on a system that is not
   configuration data such as read-only status information and collected
   statistics.  When a device is performing configuration operations, a
   number of problems would arise if state data were included:

   o  Comparisons of configuration data sets would be dominated by
      irrelevant entries such as different statistics.

   o  Incoming data could contain nonsensical requests, such as attempts
      to write read-only data.

   o  The data sets would be large.

   o  Archived data could contain values for read-only data items,
      complicating the processing required to restore archived data.

   To account for these issues, the NETCONF protocol recognizes the
   difference between configuration data and state data and provides
   operations for each.  The &lt;get-config&gt; operation retrieves
   configuration data only, while the &lt;get&gt; operation retrieves
   configuration and state data.

   Note that the NETCONF protocol is focused on the information required
   to get the device into its desired running state.  The inclusion of
   other important, persistent data is implementation specific.  For
   example, user files and databases are not treated as configuration
   data by the NETCONF protocol.

   For example, if a local database of user authentication data is
   stored on the device, it is an implementation-dependent matter
   whether it is included in configuration data.

2.  Transport Protocol Requirements

   NETCONF uses an RPC-based communication paradigm.  A client sends a
   series of one or more RPC request messages, which cause the server to
   respond with a corresponding series of RPC reply messages.

   The NETCONF protocol can be layered on any transport protocol that
   provides the required set of functionality.  It is not bound to any
   particular transport protocol, but allows a mapping to define how it
   can be implemented over any specific protocol.

   The transport protocol MUST provide a mechanism to indicate the
   session type (client or server) to the NETCONF protocol layer.

   This section details the characteristics that NETCONF requires from
   the underlying transport protocol.

2.1.  Connection-Oriented Operation

   NETCONF is connection-oriented, requiring a persistent connection
   between peers.  This connection MUST provide reliable, sequenced data
   delivery.  NETCONF connections are long-lived, persisting between
   protocol operations.

   In addition, resources requested from the server for a particular
   connection MUST be automatically released when the connection closes,
   making failure recovery simpler and more robust.  For example, when a
   lock is acquired by a client, the lock persists until either it is
   explicitly released or the server determines that the connection has
   been terminated.  If a connection is terminated while the client
   holds a lock, the server can perform any appropriate recovery.  The
   &lt;lock&gt; operation is further discussed in Section 7.5.

2.2.  Authentication, Integrity, and Confidentiality

   NETCONF connections MUST provide authentication, data integrity,
   confidentiality, and replay protection.  NETCONF depends on the
   transport protocol for this capability.  A NETCONF peer assumes that
   appropriate levels of security and confidentiality are provided
   independently of this document.  For example, connections could be
   encrypted using Transport Layer Security (TLS) [RFC5246] or Secure
   Shell (SSH) [RFC4251], depending on the underlying protocol.

   NETCONF connections MUST be authenticated.  The transport protocol is
   responsible for authentication of the server to the client and
   authentication of the client to the server.  A NETCONF peer assumes
   that the connection&#x27;s authentication information has been validated
   by the underlying transport protocol using sufficiently trustworthy
   mechanisms and that the peer&#x27;s identity has been sufficiently proven.

   One goal of NETCONF is to provide a programmatic interface to the
   device that closely follows the functionality of the device&#x27;s native
   interface.  Therefore, it is expected that the underlying protocol
   uses existing authentication mechanisms available on the device.  For
   example, a NETCONF server on a device that supports RADIUS [RFC2865]
   might allow the use of RADIUS to authenticate NETCONF sessions.

   The authentication process MUST result in an authenticated client
   identity whose permissions are known to the server.  The
   authenticated identity of a client is commonly referred to as the
   NETCONF username.  The username is a string of characters that match
   the &quot;Char&quot; production from Section 2.2 of [W3C.REC-xml-20001006].
   The algorithm used to derive the username is transport protocol
   specific and in addition specific to the authentication mechanism
   used by the transport protocol.  The transport protocol MUST provide
   a username to be used by the other NETCONF layers.

   The access permissions of a given client, identified by its NETCONF
   username, are part of the configuration of the NETCONF server.  These
   permissions MUST be enforced during the remainder of the NETCONF
   session.  The details of how access control is configured is outside
   the scope of this document.

2.3.  Mandatory Transport Protocol

   A NETCONF implementation MUST support the SSH transport protocol
   mapping [RFC6242].

3.  XML Considerations

   XML serves as the encoding format for NETCONF, allowing complex
   hierarchical data to be expressed in a text format that can be read,
   saved, and manipulated with both traditional text tools and tools
   specific to XML.

   All NETCONF messages MUST be well-formed XML, encoded in UTF-8
   [RFC3629].  If a peer receives an &lt;rpc&gt; message that is not well-
   formed XML or not encoded in UTF-8, it SHOULD reply with a
   &quot;malformed-message&quot; error.  If a reply cannot be sent for any reason,
   the server MUST terminate the session.

   A NETCONF message MAY begin with an XML declaration (see Section 2.8
   of [W3C.REC-xml-20001006]).

   This section discusses a small number of XML-related considerations
   pertaining to NETCONF.

3.1.  Namespace

   All NETCONF protocol elements are defined in the following namespace:

      urn:ietf:params:xml:ns:netconf:base:1.0

   NETCONF capability names MUST be URIs [RFC3986].  NETCONF
   capabilities are discussed in Section 8.

3.2.  Document Type Declarations

   Document type declarations (see Section 2.8 of
   [W3C.REC-xml-20001006]) MUST NOT appear in NETCONF content.

4.  RPC Model

   The NETCONF protocol uses an RPC-based communication model.  NETCONF
   peers use &lt;rpc&gt; and &lt;rpc-reply&gt; elements to provide transport-
   protocol-independent framing of NETCONF requests and responses.

   The syntax and XML encoding of the Messages-layer RPCs are formally
   defined in the XML schema in Appendix B.

4.1.  &lt;rpc&gt; Element

   The &lt;rpc&gt; element is used to enclose a NETCONF request sent from the
   client to the server.

   The &lt;rpc&gt; element has a mandatory attribute &quot;message-id&quot;, which is a
   string chosen by the sender of the RPC that will commonly encode a
   monotonically increasing integer.  The receiver of the RPC does not
   decode or interpret this string but simply saves it to be used as a
   &quot;message-id&quot; attribute in any resulting &lt;rpc-reply&gt; message.  The
   sender MUST ensure that the &quot;message-id&quot; value is normalized
   according to the XML attribute value normalization rules defined in
   [W3C.REC-xml-20001006] if the sender wants the string to be returned
   unmodified.  For example:

       &lt;rpc message-id=&quot;101&quot;
            xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
         &lt;some-method&gt;
           &lt;!-- method parameters here... --&gt;
         &lt;/some-method&gt;
       &lt;/rpc&gt;

   If additional attributes are present in an &lt;rpc&gt; element, a NETCONF
   peer MUST return them unmodified in the &lt;rpc-reply&gt; element.  This
   includes any &quot;xmlns&quot; attributes.

   The name and parameters of an RPC are encoded as the contents of the
   &lt;rpc&gt; element.  The name of the RPC is an element directly inside the
   &lt;rpc&gt; element, and any parameters are encoded inside this element.

   The following example invokes a method called &lt;my-own-method&gt;, which
   has two parameters, &lt;my-first-parameter&gt;, with a value of &quot;14&quot;, and
   &lt;another-parameter&gt;, with a value of &quot;fred&quot;:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;my-own-method xmlns=&quot;http://example.net/me/my-own/1.0&quot;&gt;
         &lt;my-first-parameter&gt;14&lt;/my-first-parameter&gt;
         &lt;another-parameter&gt;fred&lt;/another-parameter&gt;
       &lt;/my-own-method&gt;
     &lt;/rpc&gt;

   The following example invokes a &lt;rock-the-house&gt; method with a
   &lt;zip-code&gt; parameter of &quot;27606-0100&quot;:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;rock-the-house xmlns=&quot;http://example.net/rock/1.0&quot;&gt;
         &lt;zip-code&gt;27606-0100&lt;/zip-code&gt;
       &lt;/rock-the-house&gt;
     &lt;/rpc&gt;

   The following example invokes the NETCONF &lt;get&gt; method with no
   parameters:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;get/&gt;
     &lt;/rpc&gt;

4.2.  &lt;rpc-reply&gt; Element

   The &lt;rpc-reply&gt; message is sent in response to an &lt;rpc&gt; message.

   The &lt;rpc-reply&gt; element has a mandatory attribute &quot;message-id&quot;, which
   is equal to the &quot;message-id&quot; attribute of the &lt;rpc&gt; for which this is
   a response.

   A NETCONF server MUST also return any additional attributes included
   in the &lt;rpc&gt; element unmodified in the &lt;rpc-reply&gt; element.

   The response data is encoded as one or more child elements to the
   &lt;rpc-reply&gt; element.

   For example:

   The following &lt;rpc&gt; element invokes the NETCONF &lt;get&gt; method and
   includes an additional attribute called &quot;user-id&quot;.  Note that the
   &quot;user-id&quot; attribute is not in the NETCONF namespace.  The returned
   &lt;rpc-reply&gt; element returns the &quot;user-id&quot; attribute, as well as the
   requested content.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
          xmlns:ex=&quot;http://example.net/content/1.0&quot;
          ex:user-id=&quot;fred&quot;&gt;
       &lt;get/&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
          xmlns:ex=&quot;http://example.net/content/1.0&quot;
          ex:user-id=&quot;fred&quot;&gt;
       &lt;data&gt;
         &lt;!-- contents here... --&gt;
       &lt;/data&gt;
     &lt;/rpc-reply&gt;

4.3.  &lt;rpc-error&gt; Element

   The &lt;rpc-error&gt; element is sent in &lt;rpc-reply&gt; messages if an error
   occurs during the processing of an &lt;rpc&gt; request.

   If a server encounters multiple errors during the processing of an
   &lt;rpc&gt; request, the &lt;rpc-reply&gt; MAY contain multiple &lt;rpc-error&gt;
   elements.  However, a server is not required to detect or report more
   than one &lt;rpc-error&gt; element, if a request contains multiple errors.
   A server is not required to check for particular error conditions in
   a specific sequence.  A server MUST return an &lt;rpc-error&gt; element if
   any error conditions occur during processing.

   A server MUST NOT return application-level- or data-model-specific
   error information in an &lt;rpc-error&gt; element for which the client does
   not have sufficient access rights.

   The &lt;rpc-error&gt; element includes the following information:

   error-type:  Defines the conceptual layer that the error occurred.
      Enumeration.  One of:

      *  transport (layer: Secure Transport)

      *  rpc (layer: Messages)

      *  protocol (layer: Operations)

      *  application (layer: Content)

   error-tag:  Contains a string identifying the error condition.  See
      Appendix A for allowed values.

   error-severity:  Contains a string identifying the error severity, as
      determined by the device.  One of:

      *  error

      *  warning

      Note that there are no &lt;error-tag&gt; values defined in this document
      that utilize the &quot;warning&quot; enumeration.  This is reserved for
      future use.

   error-app-tag:  Contains a string identifying the data-model-specific
      or implementation-specific error condition, if one exists.  This
      element will not be present if no appropriate application error-
      tag can be associated with a particular error condition.  If a

      data-model-specific and an implementation-specific error-app-tag
      both exist, then the data-model-specific value MUST be used by the
      server.

   error-path:  Contains the absolute XPath [W3C.REC-xpath-19991116]
      expression identifying the element path to the node that is
      associated with the error being reported in a particular
      &lt;rpc-error&gt; element.  This element will not be present if no
      appropriate payload element or datastore node can be associated
      with a particular error condition.

      The XPath expression is interpreted in the following context:

      *  The set of namespace declarations are those in scope on the
         &lt;rpc-error&gt; element.

      *  The set of variable bindings is empty.

      *  The function library is the core function library.

      The context node depends on the node associated with the error
      being reported:

      *  If a payload element can be associated with the error, the
         context node is the rpc request&#x27;s document node (i.e., the
         &lt;rpc&gt; element).

      *  Otherwise, the context node is the root of all data models,
         i.e., the node that has the top-level nodes from all data
         models as children.

   error-message:  Contains a string suitable for human display that
      describes the error condition.  This element will not be present
      if no appropriate message is provided for a particular error
      condition.  This element SHOULD include an &quot;xml:lang&quot; attribute as
      defined in [W3C.REC-xml-20001006] and discussed in [RFC3470].

   error-info:  Contains protocol- or data-model-specific error content.
      This element will not be present if no such error content is
      provided for a particular error condition.  The list in Appendix A
      defines any mandatory error-info content for each error.  After
      any protocol-mandated content, a data model definition MAY mandate
      that certain application-layer error information be included in
      the error-info container.  An implementation MAY include
      additional elements to provide extended and/or implementation-
      specific debugging information.

   Appendix A enumerates the standard NETCONF errors.

   Example:  An error is returned if an &lt;rpc&gt; element is received
      without a &quot;message-id&quot; attribute.  Note that only in this case is
      it acceptable for the NETCONF peer to omit the &quot;message-id&quot;
      attribute in the &lt;rpc-reply&gt; element.

     &lt;rpc xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;get-config&gt;
         &lt;source&gt;
           &lt;running/&gt;
         &lt;/source&gt;
       &lt;/get-config&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;rpc-error&gt;
         &lt;error-type&gt;rpc&lt;/error-type&gt;
         &lt;error-tag&gt;missing-attribute&lt;/error-tag&gt;
         &lt;error-severity&gt;error&lt;/error-severity&gt;
         &lt;error-info&gt;
           &lt;bad-attribute&gt;message-id&lt;/bad-attribute&gt;
           &lt;bad-element&gt;rpc&lt;/bad-element&gt;
         &lt;/error-info&gt;
       &lt;/rpc-error&gt;
     &lt;/rpc-reply&gt;

   The following &lt;rpc-reply&gt; illustrates the case of returning multiple
   &lt;rpc-error&gt; elements.

   Note that the data models used in the examples in this section use
   the &lt;name&gt; element to distinguish between multiple instances of the
   &lt;interface&gt; element.

     &lt;rpc-reply message-id=&quot;101&quot;
       xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
       xmlns:xc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;rpc-error&gt;
         &lt;error-type&gt;application&lt;/error-type&gt;
         &lt;error-tag&gt;invalid-value&lt;/error-tag&gt;
         &lt;error-severity&gt;error&lt;/error-severity&gt;
         &lt;error-path xmlns:t=&quot;http://example.com/schema/1.2/config&quot;&gt;
           /t:top/t:interface[t:name=&quot;Ethernet0/0&quot;]/t:mtu
         &lt;/error-path&gt;
         &lt;error-message xml:lang=&quot;en&quot;&gt;
           MTU value 25000 is not within range 256..9192
         &lt;/error-message&gt;
       &lt;/rpc-error&gt;
       &lt;rpc-error&gt;
         &lt;error-type&gt;application&lt;/error-type&gt;

         &lt;error-tag&gt;invalid-value&lt;/error-tag&gt;
         &lt;error-severity&gt;error&lt;/error-severity&gt;
         &lt;error-path xmlns:t=&quot;http://example.com/schema/1.2/config&quot;&gt;
           /t:top/t:interface[t:name=&quot;Ethernet1/0&quot;]/t:address/t:name
         &lt;/error-path&gt;
         &lt;error-message xml:lang=&quot;en&quot;&gt;
           Invalid IP address for interface Ethernet1/0
         &lt;/error-message&gt;
       &lt;/rpc-error&gt;
     &lt;/rpc-reply&gt;

4.4.  &lt;ok&gt; Element

   The &lt;ok&gt; element is sent in &lt;rpc-reply&gt; messages if no errors or
   warnings occurred during the processing of an &lt;rpc&gt; request, and no
   data was returned from the operation.  For example:

     &lt;rpc-reply message-id=&quot;101&quot;
                xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

4.5.  Pipelining

   NETCONF &lt;rpc&gt; requests MUST be processed serially by the managed
   device.  Additional &lt;rpc&gt; requests MAY be sent before previous ones
   have been completed.  The managed device MUST send responses only in
   the order the requests were received.

5.  Configuration Model

   NETCONF provides an initial set of operations and a number of
   capabilities that can be used to extend the base.  NETCONF peers
   exchange device capabilities when the session is initiated as
   described in Section 8.1.

5.1.  Configuration Datastores

   NETCONF defines the existence of one or more configuration datastores
   and allows configuration operations on them.  A configuration
   datastore is defined as the complete set of configuration data that
   is required to get a device from its initial default state into a
   desired operational state.  The configuration datastore does not
   include state data or executive commands.

   The running configuration datastore holds the complete configuration
   currently active on the network device.  Only one configuration
   datastore of this type exists on the device, and it is always
   present.  NETCONF protocol operations refer to this datastore using
   the &lt;running&gt; element.

   Only the &lt;running&gt; configuration datastore is present in the base
   model.  Additional configuration datastores MAY be defined by
   capabilities.  Such configuration datastores are available only on
   devices that advertise the capabilities.

   The capabilities in Sections 8.3 and 8.7 define the &lt;candidate&gt; and
   &lt;startup&gt; configuration datastores, respectively.

5.2.  Data Modeling

   Data modeling and content issues are outside the scope of the NETCONF
   protocol.  An assumption is made that the device&#x27;s data model is
   well-known to the application and that both parties are aware of
   issues such as the layout, containment, keying, lookup, replacement,
   and management of the data, as well as any other constraints imposed
   by the data model.

   NETCONF carries configuration data inside the &lt;config&gt; element that
   is specific to the device&#x27;s data model.  The protocol treats the
   contents of that element as opaque data.  The device uses
   capabilities to announce the set of data models that the device
   implements.  The capability definition details the operation and
   constraints imposed by data model.

   Devices and managers can support multiple data models, including both
   standard and proprietary data models.

6.  Subtree Filtering

6.1.  Overview

   XML subtree filtering is a mechanism that allows an application to
   select particular XML subtrees to include in the &lt;rpc-reply&gt; for a
   &lt;get&gt; or &lt;get-config&gt; operation.  A small set of filters for
   inclusion, simple content exact-match, and selection is provided,
   which allows some useful, but also very limited, selection
   mechanisms.  The server does not need to utilize any data-model-
   specific semantics during processing, allowing for simple and
   centralized implementation strategies.

   Conceptually, a subtree filter is comprised of zero or more element
   subtrees, which represent the filter selection criteria.  At each
   containment level within a subtree, the set of sibling nodes is
   logically processed by the server to determine if its subtree and
   path of elements to the root are included in the filter output.

   Each node specified in a subtree filter represents an inclusive
   filter.  Only associated nodes in underlying data model(s) within the
   specified datastore on the server are selected by the filter.  A node
   is selected if it matches the selection criteria and hierarchy of
   elements given in the filter data, except that the filter absolute
   path name is adjusted to start from the layer below &lt;filter&gt;.

   Response messages contain only the subtrees selected by the filter.
   Any selection criteria that were present in the request, within a
   particular selected subtree, are also included in the response.  Note
   that some elements expressed in the filter as leaf nodes will be
   expanded (i.e., subtrees included) in the filter output.  Specific
   data instances are not duplicated in the response in the event that
   the request contains multiple filter subtree expressions that select
   the same data.

6.2.  Subtree Filter Components

   A subtree filter is comprised of XML elements and their XML
   attributes.  There are five types of components that can be present
   in a subtree filter:

   o  Namespace Selection

   o  Attribute Match Expressions

   o  Containment Nodes

   o  Selection Nodes

   o  Content Match Nodes

6.2.1.  Namespace Selection

   A namespace is considered to match (for filter purposes) if the XML
   namespace associated with a particular node within the &lt;filter&gt;
   element is the same as in the underlying data model.  Note that
   namespace selection cannot be used by itself.  At least one element
   MUST be specified in the filter if any elements are to be included in
   the filter output.

   An XML namespace wildcard mechanism is defined for subtree filtering.
   If an element within the &lt;filter&gt; element is not qualified by a
   namespace (e.g., xmlns=&quot;&quot;), then the server MUST evaluate all the XML
   namespaces it supports, when processing that subtree filter node.
   This wildcard mechanism is not applicable to XML attributes.

   Note that prefix values for qualified namespaces are not relevant
   when comparing filter elements to elements in the underlying data
   model.

   Example:

     &lt;filter type=&quot;subtree&quot;&gt;
       &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;/&gt;
     &lt;/filter&gt;

   In this example, the &lt;top&gt; element is a selection node, and only this
   node in the &quot;http://example.com/schema/1.2/config&quot; namespace and any
   child nodes (from the underlying data model) will be included in the
   filter output.

6.2.2.  Attribute Match Expressions

   An attribute that appears in a subtree filter is part of an
   &quot;attribute match expression&quot;.  Any number of (unqualified or
   qualified) XML attributes MAY be present in any type of filter node.
   In addition to the selection criteria normally applicable to that
   node, the selected data MUST have matching values for every attribute
   specified in the node.  If an element is not defined to include a
   specified attribute, then it is not selected in the filter output.

   Example:

     &lt;filter type=&quot;subtree&quot;&gt;
       &lt;t:top xmlns:t=&quot;http://example.com/schema/1.2/config&quot;&gt;
         &lt;t:interfaces&gt;
           &lt;t:interface t:ifName=&quot;eth0&quot;/&gt;
         &lt;/t:interfaces&gt;
       &lt;/t:top&gt;
     &lt;/filter&gt;

   In this example, the &lt;top&gt; and &lt;interfaces&gt; elements are containment
   nodes, the &lt;interface&gt; element is a selection node, and &quot;ifName&quot; is
   an attribute match expression.  Only &quot;interface&quot; nodes in the
   &quot;http://example.com/schema/1.2/config&quot; namespace that have an
   &quot;ifName&quot; attribute with the value &quot;eth0&quot; and occur within
   &quot;interfaces&quot; nodes within &quot;top&quot; nodes will be included in the filter
   output.

6.2.3.  Containment Nodes

   Nodes that contain child elements within a subtree filter are called
   &quot;containment nodes&quot;.  Each child element can be any type of node,
   including another containment node.  For each containment node
   specified in a subtree filter, all data model instances that exactly
   match the specified namespaces, element hierarchy, and any attribute
   match expressions are included in the filter output.

   Example:

     &lt;filter type=&quot;subtree&quot;&gt;
       &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
         &lt;users/&gt;
       &lt;/top&gt;
     &lt;/filter&gt;

   In this example, the &lt;top&gt; element is a containment node.

6.2.4.  Selection Nodes

   An empty leaf node within a filter is called a &quot;selection node&quot;, and
   it represents an &quot;explicit selection&quot; filter on the underlying data
   model.  Presence of any selection nodes within a set of sibling nodes
   will cause the filter to select the specified subtree(s) and suppress
   automatic selection of the entire set of sibling nodes in the
   underlying data model.  For filtering purposes, an empty leaf node
   can be declared either with an empty tag (e.g., &lt;foo/&gt;) or with
   explicit start and end tags (e.g., &lt;foo&gt; &lt;/foo&gt;).  Any whitespace
   characters are ignored in this form.

   Example:

     &lt;filter type=&quot;subtree&quot;&gt;
       &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
         &lt;users/&gt;
       &lt;/top&gt;
     &lt;/filter&gt;

   In this example, the &lt;top&gt; element is a containment node, and the
   &lt;users&gt; element is a selection node.  Only &quot;users&quot; nodes in the
   &quot;http://example.com/schema/1.2/config&quot; namespace that occur within a
   &lt;top&gt; element that is the root of the configuration datastore will be
   included in the filter output.

6.2.5.  Content Match Nodes

   A leaf node that contains simple content is called a &quot;content match
   node&quot;.  It is used to select some or all of its sibling nodes for
   filter output, and it represents an exact-match filter on the leaf
   node element content.  The following constraints apply to content
   match nodes:

   o  A content match node MUST NOT contain nested elements.

   o  Multiple content match nodes (i.e., sibling nodes) are logically
      combined in an &quot;AND&quot; expression.

   o  Filtering of mixed content is not supported.

   o  Filtering of list content is not supported.

   o  Filtering of whitespace-only content is not supported.

   o  A content match node MUST contain non-whitespace characters.  An
      empty element (e.g., &lt;foo&gt;&lt;/foo&gt;) will be interpreted as a
      selection node (e.g., &lt;foo/&gt;).

   o  Leading and trailing whitespace characters are ignored, but any
      whitespace characters within a block of text characters are not
      ignored or modified.

   If all specified sibling content match nodes in a subtree filter
   expression are &quot;true&quot;, then the filter output nodes are selected in
   the following manner:

   o  Each content match node in the sibling set is included in the
      filter output.

   o  If any containment nodes are present in the sibling set, then they
      are processed further and included if any nested filter criteria
      are also met.

   o  If any selection nodes are present in the sibling set, then all of
      them are included in the filter output.

   o  If any sibling nodes of the selection node are instance identifier
      components for a conceptual data structure (e.g., list key leaf),
      then they MAY also be included in the filter output.

   o  Otherwise (i.e., there are no selection or containment nodes in
      the filter sibling set), all the nodes defined at this level in
      the underlying data model (and their subtrees, if any) are
      returned in the filter output.

   If any of the sibling content match node tests are &quot;false&quot;, then no
   further filter processing is performed on that sibling set, and none
   of the sibling subtrees are selected by the filter, including the
   content match node(s).

   Example:

     &lt;filter type=&quot;subtree&quot;&gt;
       &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
         &lt;users&gt;
           &lt;user&gt;
             &lt;name&gt;fred&lt;/name&gt;
           &lt;/user&gt;
         &lt;/users&gt;
       &lt;/top&gt;
     &lt;/filter&gt;

   In this example, the &lt;users&gt; and &lt;user&gt; nodes are both containment
   nodes, and &lt;name&gt; is a content match node.  Since no sibling nodes of
   &lt;name&gt; are specified (and therefore no containment or selection
   nodes), all of the sibling nodes of &lt;name&gt; are returned in the filter
   output.  Only &quot;user&quot; nodes in the
   &quot;http://example.com/schema/1.2/config&quot; namespace that match the
   element hierarchy and for which the &lt;name&gt; element is equal to &quot;fred&quot;
   will be included in the filter output.

6.3.  Subtree Filter Processing

   The filter output (the set of selected nodes) is initially empty.

   Each subtree filter can contain one or more data model fragments,
   which represent portions of the data model that will be selected
   (with all child nodes) in the filter output.

   Each subtree data fragment is compared by the server to the internal
   data models supported by the server.  If the entire subtree data-
   fragment filter (starting from the root to the innermost element
   specified in the filter) exactly matches a corresponding portion of
   the supported data model, then that node and all its children are
   included in the result data.

   The server processes all nodes with the same parent node (sibling
   set) together, starting from the root to the leaf nodes.  The root

   elements in the filter are considered in the same sibling set
   (assuming they are in the same namespace), even though they do not
   have a common parent.

   For each sibling set, the server determines which nodes are included
   (or potentially included) in the filter output, and which sibling
   subtrees are excluded (pruned) from the filter output.  The server
   first determines which types of nodes are present in the sibling set
   and processes the nodes according to the rules for their type.  If
   any nodes in the sibling set are selected, then the process is
   recursively applied to the sibling sets of each selected node.  The
   algorithm continues until all sibling sets in all subtrees specified
   in the filter have been processed.

6.4.  Subtree Filtering Examples

6.4.1.  No Filter

   Leaving out the filter on the &lt;get&gt; operation returns the entire data
   model.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;get/&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;data&gt;
         &lt;!-- ... entire set of data returned ... --&gt;
       &lt;/data&gt;
     &lt;/rpc-reply&gt;

6.4.2.  Empty Filter

   An empty filter will select nothing because no content match or
   selection nodes are present.  This is not an error.  The &lt;filter&gt;
   element&#x27;s &quot;type&quot; attribute used in these examples is discussed
   further in Section 7.1.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;get&gt;
         &lt;filter type=&quot;subtree&quot;&gt;
         &lt;/filter&gt;
       &lt;/get&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;data&gt;
       &lt;/data&gt;
     &lt;/rpc-reply&gt;

6.4.3.  Select the Entire &lt;users&gt; Subtree

   The filter in this example contains one selection node (&lt;users&gt;), so
   just that subtree is selected by the filter.  This example represents
   the fully populated &lt;users&gt; data model in most of the filter examples
   that follow.  In a real data model, the &lt;company-info&gt; would not
   likely be returned with the list of users for a particular host or
   network.

   NOTE: The filtering and configuration examples used in this document
   appear in the namespace &quot;http://example.com/schema/1.2/config&quot;.  The
   root element of this namespace is &lt;top&gt;.  The &lt;top&gt; element and its
   descendents represent an example configuration data model only.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;get-config&gt;
         &lt;source&gt;
           &lt;running/&gt;
         &lt;/source&gt;
         &lt;filter type=&quot;subtree&quot;&gt;
           &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
             &lt;users/&gt;
           &lt;/top&gt;
         &lt;/filter&gt;
       &lt;/get-config&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;data&gt;
         &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
           &lt;users&gt;
             &lt;user&gt;
               &lt;name&gt;root&lt;/name&gt;
               &lt;type&gt;superuser&lt;/type&gt;
               &lt;full-name&gt;Charlie Root&lt;/full-name&gt;
               &lt;company-info&gt;
                 &lt;dept&gt;1&lt;/dept&gt;
                 &lt;id&gt;1&lt;/id&gt;
               &lt;/company-info&gt;
             &lt;/user&gt;

             &lt;user&gt;
               &lt;name&gt;fred&lt;/name&gt;
               &lt;type&gt;admin&lt;/type&gt;
               &lt;full-name&gt;Fred Flintstone&lt;/full-name&gt;
               &lt;company-info&gt;
                 &lt;dept&gt;2&lt;/dept&gt;
                 &lt;id&gt;2&lt;/id&gt;
               &lt;/company-info&gt;
             &lt;/user&gt;
             &lt;user&gt;
               &lt;name&gt;barney&lt;/name&gt;
               &lt;type&gt;admin&lt;/type&gt;
               &lt;full-name&gt;Barney Rubble&lt;/full-name&gt;
               &lt;company-info&gt;
                 &lt;dept&gt;2&lt;/dept&gt;
                 &lt;id&gt;3&lt;/id&gt;
               &lt;/company-info&gt;
             &lt;/user&gt;
           &lt;/users&gt;
         &lt;/top&gt;
       &lt;/data&gt;
     &lt;/rpc-reply&gt;

   The following filter request would have produced the same result, but
   only because the container &lt;users&gt; defines one child element
   (&lt;user&gt;).

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;get-config&gt;
         &lt;source&gt;
           &lt;running/&gt;
         &lt;/source&gt;
         &lt;filter type=&quot;subtree&quot;&gt;
           &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
             &lt;users&gt;
               &lt;user/&gt;
             &lt;/users&gt;
           &lt;/top&gt;
         &lt;/filter&gt;
       &lt;/get-config&gt;
     &lt;/rpc&gt;

6.4.4.  Select All &lt;name&gt; Elements within the &lt;users&gt; Subtree

   This filter contains two containment nodes (&lt;users&gt;, &lt;user&gt;) and one
   selection node (&lt;name&gt;).  All instances of the &lt;name&gt; element in the
   same sibling set are selected in the filter output.  The client might
   need to know that &lt;name&gt; is used as an instance identifier in this
   particular data structure, but the server does not need to know that
   meta-data in order to process the request.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;get-config&gt;
         &lt;source&gt;
           &lt;running/&gt;
         &lt;/source&gt;
         &lt;filter type=&quot;subtree&quot;&gt;
           &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
             &lt;users&gt;
               &lt;user&gt;
                 &lt;name/&gt;
               &lt;/user&gt;
             &lt;/users&gt;
           &lt;/top&gt;
         &lt;/filter&gt;
       &lt;/get-config&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;data&gt;
         &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
           &lt;users&gt;
             &lt;user&gt;
               &lt;name&gt;root&lt;/name&gt;
             &lt;/user&gt;
             &lt;user&gt;
               &lt;name&gt;fred&lt;/name&gt;
             &lt;/user&gt;
             &lt;user&gt;
               &lt;name&gt;barney&lt;/name&gt;
             &lt;/user&gt;
           &lt;/users&gt;
         &lt;/top&gt;
       &lt;/data&gt;
     &lt;/rpc-reply&gt;

6.4.5.  One Specific &lt;user&gt; Entry

   This filter contains two containment nodes (&lt;users&gt;, &lt;user&gt;) and one
   content match node (&lt;name&gt;).  All instances of the sibling set
   containing &lt;name&gt; for which the value of &lt;name&gt; equals &quot;fred&quot; are
   selected in the filter output.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;get-config&gt;
         &lt;source&gt;
           &lt;running/&gt;
         &lt;/source&gt;
         &lt;filter type=&quot;subtree&quot;&gt;
           &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
             &lt;users&gt;
               &lt;user&gt;
                 &lt;name&gt;fred&lt;/name&gt;
               &lt;/user&gt;
             &lt;/users&gt;
           &lt;/top&gt;
         &lt;/filter&gt;
       &lt;/get-config&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;data&gt;
         &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
           &lt;users&gt;
             &lt;user&gt;
               &lt;name&gt;fred&lt;/name&gt;
               &lt;type&gt;admin&lt;/type&gt;
               &lt;full-name&gt;Fred Flintstone&lt;/full-name&gt;
               &lt;company-info&gt;
                 &lt;dept&gt;2&lt;/dept&gt;
                 &lt;id&gt;2&lt;/id&gt;
               &lt;/company-info&gt;
             &lt;/user&gt;
           &lt;/users&gt;
         &lt;/top&gt;
       &lt;/data&gt;
     &lt;/rpc-reply&gt;

6.4.6.  Specific Elements from a Specific &lt;user&gt; Entry

   This filter contains two containment nodes (&lt;users&gt;, &lt;user&gt;), one
   content match node (&lt;name&gt;), and two selection nodes (&lt;type&gt;,
   &lt;full-name&gt;).  All instances of the &lt;type&gt; and &lt;full-name&gt; elements
   in the same sibling set containing &lt;name&gt; for which the value of
   &lt;name&gt; equals &quot;fred&quot; are selected in the filter output.  The
   &lt;company-info&gt; element is not included because the sibling set
   contains selection nodes.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;get-config&gt;
         &lt;source&gt;
           &lt;running/&gt;
         &lt;/source&gt;
         &lt;filter type=&quot;subtree&quot;&gt;
           &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
             &lt;users&gt;
               &lt;user&gt;
                 &lt;name&gt;fred&lt;/name&gt;
                 &lt;type/&gt;
                 &lt;full-name/&gt;
               &lt;/user&gt;
             &lt;/users&gt;
           &lt;/top&gt;
         &lt;/filter&gt;
       &lt;/get-config&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;data&gt;
         &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
           &lt;users&gt;
             &lt;user&gt;
               &lt;name&gt;fred&lt;/name&gt;
               &lt;type&gt;admin&lt;/type&gt;
               &lt;full-name&gt;Fred Flintstone&lt;/full-name&gt;
             &lt;/user&gt;
           &lt;/users&gt;
         &lt;/top&gt;
       &lt;/data&gt;
     &lt;/rpc-reply&gt;

6.4.7.  Multiple Subtrees

   This filter contains three subtrees (name=root, fred, barney).

   The &quot;root&quot; subtree filter contains two containment nodes (&lt;users&gt;,
   &lt;user&gt;), one content match node (&lt;name&gt;), and one selection node
   (&lt;company-info&gt;).  The subtree selection criteria are met, and just
   the company-info subtree for &quot;root&quot; is selected in the filter output.

   The &quot;fred&quot; subtree filter contains three containment nodes (&lt;users&gt;,
   &lt;user&gt;, &lt;company-info&gt;), one content match node (&lt;name&gt;), and one
   selection node (&lt;id&gt;).  The subtree selection criteria are met, and
   just the &lt;id&gt; element within the company-info subtree for &quot;fred&quot; is
   selected in the filter output.

   The &quot;barney&quot; subtree filter contains three containment nodes
   (&lt;users&gt;, &lt;user&gt;, &lt;company-info&gt;), two content match nodes (&lt;name&gt;,
   &lt;type&gt;), and one selection node (&lt;dept&gt;).  The subtree selection
   criteria are not met because user &quot;barney&quot; is not a &quot;superuser&quot;, and
   the entire subtree for &quot;barney&quot; (including its parent &lt;user&gt; entry)
   is excluded from the filter output.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;get-config&gt;
         &lt;source&gt;
           &lt;running/&gt;
         &lt;/source&gt;
         &lt;filter type=&quot;subtree&quot;&gt;
           &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
             &lt;users&gt;
               &lt;user&gt;
                 &lt;name&gt;root&lt;/name&gt;
                 &lt;company-info/&gt;
               &lt;/user&gt;
               &lt;user&gt;
                 &lt;name&gt;fred&lt;/name&gt;
                 &lt;company-info&gt;
                   &lt;id/&gt;
                 &lt;/company-info&gt;
               &lt;/user&gt;
               &lt;user&gt;
                 &lt;name&gt;barney&lt;/name&gt;
                 &lt;type&gt;superuser&lt;/type&gt;
                 &lt;company-info&gt;
                   &lt;dept/&gt;
                 &lt;/company-info&gt;
               &lt;/user&gt;

             &lt;/users&gt;
           &lt;/top&gt;
         &lt;/filter&gt;
       &lt;/get-config&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
                xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;data&gt;
         &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
           &lt;users&gt;
             &lt;user&gt;
               &lt;name&gt;root&lt;/name&gt;
               &lt;company-info&gt;
                 &lt;dept&gt;1&lt;/dept&gt;
                 &lt;id&gt;1&lt;/id&gt;
               &lt;/company-info&gt;
             &lt;/user&gt;
             &lt;user&gt;
               &lt;name&gt;fred&lt;/name&gt;
               &lt;company-info&gt;
                 &lt;id&gt;2&lt;/id&gt;
               &lt;/company-info&gt;
             &lt;/user&gt;
           &lt;/users&gt;
         &lt;/top&gt;
       &lt;/data&gt;
     &lt;/rpc-reply&gt;

6.4.8.  Elements with Attribute Naming

   In this example, the filter contains one containment node
   (&lt;interfaces&gt;), one attribute match expression (&quot;ifName&quot;), and one
   selection node (&lt;interface&gt;).  All instances of the &lt;interface&gt;
   subtree that have an &quot;ifName&quot; attribute equal to &quot;eth0&quot; are selected
   in the filter output.  The filter data elements and attributes are
   qualified because the &quot;ifName&quot; attribute will not be considered part
   of the &quot;schema/1.2&quot; namespace if it is unqualified.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;get&gt;
         &lt;filter type=&quot;subtree&quot;&gt;
           &lt;t:top xmlns:t=&quot;http://example.com/schema/1.2/stats&quot;&gt;
             &lt;t:interfaces&gt;
               &lt;t:interface t:ifName=&quot;eth0&quot;/&gt;
             &lt;/t:interfaces&gt;
           &lt;/t:top&gt;
         &lt;/filter&gt;
       &lt;/get&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;data&gt;
         &lt;t:top xmlns:t=&quot;http://example.com/schema/1.2/stats&quot;&gt;
           &lt;t:interfaces&gt;
             &lt;t:interface t:ifName=&quot;eth0&quot;&gt;
               &lt;t:ifInOctets&gt;45621&lt;/t:ifInOctets&gt;
               &lt;t:ifOutOctets&gt;774344&lt;/t:ifOutOctets&gt;
             &lt;/t:interface&gt;
           &lt;/t:interfaces&gt;
         &lt;/t:top&gt;
       &lt;/data&gt;
     &lt;/rpc-reply&gt;

   If &quot;ifName&quot; were a child node instead of an attribute, then the
   following request would produce similar results.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;get&gt;
         &lt;filter type=&quot;subtree&quot;&gt;
           &lt;top xmlns=&quot;http://example.com/schema/1.2/stats&quot;&gt;
             &lt;interfaces&gt;
               &lt;interface&gt;
                 &lt;ifName&gt;eth0&lt;/ifName&gt;
               &lt;/interface&gt;
             &lt;/interfaces&gt;
           &lt;/top&gt;
         &lt;/filter&gt;
       &lt;/get&gt;
     &lt;/rpc&gt;

7.  Protocol Operations

   The NETCONF protocol provides a small set of low-level operations to
   manage device configurations and retrieve device state information.
   The base protocol provides operations to retrieve, configure, copy,
   and delete configuration datastores.  Additional operations are
   provided, based on the capabilities advertised by the device.

   The base protocol includes the following protocol operations:

   o  get

   o  get-config

   o  edit-config

   o  copy-config

   o  delete-config

   o  lock

   o  unlock

   o  close-session

   o  kill-session

   A protocol operation can fail for various reasons, including
   &quot;operation not supported&quot;.  An initiator SHOULD NOT assume that any
   operation will always succeed.  The return values in any RPC reply
   SHOULD be checked for error responses.

   The syntax and XML encoding of the protocol operations are formally
   defined in the YANG module in Appendix C.  The following sections
   describe the semantics of each protocol operation.

7.1.  &lt;get-config&gt;

   Description:  Retrieve all or part of a specified configuration
      datastore.

   Parameters:

      source:  Name of the configuration datastore being queried, such
         as &lt;running/&gt;.

      filter:  This parameter identifies the portions of the device
         configuration datastore to retrieve.  If this parameter is not
         present, the entire configuration is returned.

         The &lt;filter&gt; element MAY optionally contain a &quot;type&quot; attribute.
         This attribute indicates the type of filtering syntax used
         within the &lt;filter&gt; element.  The default filtering mechanism
         in NETCONF is referred to as subtree filtering and is described
         in Section 6.  The value &quot;subtree&quot; explicitly identifies this
         type of filtering.

         If the NETCONF peer supports the :xpath capability
         (Section 8.9), the value &quot;xpath&quot; MAY be used to indicate that
         the &quot;select&quot; attribute on the &lt;filter&gt; element contains an
         XPath expression.

   Positive Response:  If the device can satisfy the request, the server
      sends an &lt;rpc-reply&gt; element containing a &lt;data&gt; element with the
      results of the query.

   Negative Response:  An &lt;rpc-error&gt; element is included in the
      &lt;rpc-reply&gt; if the request cannot be completed for any reason.

   Example:  To retrieve the entire &lt;users&gt; subtree:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;get-config&gt;
         &lt;source&gt;
           &lt;running/&gt;
         &lt;/source&gt;
         &lt;filter type=&quot;subtree&quot;&gt;
           &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
             &lt;users/&gt;
           &lt;/top&gt;
         &lt;/filter&gt;
       &lt;/get-config&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;data&gt;
         &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
           &lt;users&gt;
             &lt;user&gt;
               &lt;name&gt;root&lt;/name&gt;
               &lt;type&gt;superuser&lt;/type&gt;
               &lt;full-name&gt;Charlie Root&lt;/full-name&gt;

               &lt;company-info&gt;
                 &lt;dept&gt;1&lt;/dept&gt;
                 &lt;id&gt;1&lt;/id&gt;
               &lt;/company-info&gt;
             &lt;/user&gt;
             &lt;!-- additional &lt;user&gt; elements appear here... --&gt;
           &lt;/users&gt;
         &lt;/top&gt;
       &lt;/data&gt;
     &lt;/rpc-reply&gt;

      Section 6 contains additional examples of subtree filtering.

7.2.  &lt;edit-config&gt;

   Description:

      The &lt;edit-config&gt; operation loads all or part of a specified
      configuration to the specified target configuration datastore.
      This operation allows the new configuration to be expressed in
      several ways, such as using a local file, a remote file, or
      inline.  If the target configuration datastore does not exist, it
      will be created.

      If a NETCONF peer supports the :url capability (Section 8.8), the
      &lt;url&gt; element can appear instead of the &lt;config&gt; parameter.

      The device analyzes the source and target configurations and
      performs the requested changes.  The target configuration is not
      necessarily replaced, as with the &lt;copy-config&gt; message.  Instead,
      the target configuration is changed in accordance with the
      source&#x27;s data and requested operations.

      If the &lt;edit-config&gt; operation contains multiple sub-operations
      that apply to the same conceptual node in the underlying data
      model, then the result of the operation is undefined (i.e.,
      outside the scope of the NETCONF protocol).

   Attributes:

      operation:  Elements in the &lt;config&gt; subtree MAY contain an
         &quot;operation&quot; attribute, which belongs to the NETCONF namespace
         defined in Section 3.1.  The attribute identifies the point in
         the configuration to perform the operation and MAY appear on
         multiple elements throughout the &lt;config&gt; subtree.

         <span class="Verified-inline-styling" id='inline-4066'>If the &quot;operation&quot; attribute is not specified, then the  <button id="btn_4066" target="expand_4066" onclick='hideFunction("expand_4066")'>Expand</button>
operation applied to the parent data node of the configuration
is used. If no parent data node is available, then the value of 
the &lt;default-operation&gt; parameter is used.  If the 
&lt;default-operation&gt; parameter is not given, the configuration 
is merged into the configuration datastore.
</span id__locate=4066>
<div class="nodeCloseClass" id='expand_4066'><div class='Verified-endnote-styling' id='eid4066'>
<pre>
<b><i><a href='https://www.rfc-editor.org/errata/eid4066'>EID 4066</a> (Verified) is as follows:</i></b>

<b>Section:</b> 7.2

<b>Original Text:</b>

If the &quot;operation&quot; attribute is not specified, the
configuration is merged into the configuration datastore.

<b>Corrected Text:</b>

If the &quot;operation&quot; attribute is not specified, then the 
operation applied to the parent data node of the configuration
is used. If no parent data node is available, then the value of 
the &lt;default-operation&gt; parameter is used.  If the 
&lt;default-operation&gt; parameter is not given, the configuration 
is merged into the configuration datastore.
</pre>
<b>Notes:</b><br/>
sentence in para 6 is not correct.<br/>The default-operation value is used, not the value &quot;merge&quot;.<br/><br/>Discussion on the NETCONF mailing list. See http://www.ietf.org/mail-archive/web/netconf/current/msg09169.html
</div>
</div>
         The &quot;operation&quot; attribute has one of the following values:

         merge:  The configuration data identified by the element
            containing this attribute is merged with the configuration
            at the corresponding level in the configuration datastore
            identified by the &lt;target&gt; parameter.  This is the default
            behavior.

         replace:  The configuration data identified by the element
            containing this attribute replaces any related configuration
            in the configuration datastore identified by the &lt;target&gt;
            parameter.  If no such configuration data exists in the
            configuration datastore, it is created.  Unlike a
            &lt;copy-config&gt; operation, which replaces the entire target
            configuration, only the configuration actually present in
            the &lt;config&gt; parameter is affected.

         create:  The configuration data identified by the element
            containing this attribute is added to the configuration if
            and only if the configuration data does not already exist in
            the configuration datastore.  If the configuration data
            exists, an &lt;rpc-error&gt; element is returned with an
            &lt;error-tag&gt; value of &quot;data-exists&quot;.

         delete:  The configuration data identified by the element
            containing this attribute is deleted from the configuration
            if and only if the configuration data currently exists in
            the configuration datastore.  If the configuration data does
            not exist, an &lt;rpc-error&gt; element is returned with an
            &lt;error-tag&gt; value of &quot;data-missing&quot;.

         remove:  The configuration data identified by the element
            containing this attribute is deleted from the configuration
            if the configuration data currently exists in the
            configuration datastore.  If the configuration data does not
            exist, the &quot;remove&quot; operation is silently ignored by the
            server.

   Parameters:

      target:  Name of the configuration datastore being edited, such as
         &lt;running/&gt; or &lt;candidate/&gt;.

      default-operation:  Selects the default operation (as described in
         the &quot;operation&quot; attribute) for this &lt;edit-config&gt; request.  The
         default value for the &lt;default-operation&gt; parameter is &quot;merge&quot;.

         The &lt;default-operation&gt; parameter is optional, but if provided,
         it has one of the following values:

         merge:  The configuration data in the &lt;config&gt; parameter is
            merged with the configuration at the corresponding level in
            the target datastore.  This is the default behavior.

         replace:  The configuration data in the &lt;config&gt; parameter
            completely replaces the configuration in the target
            datastore.  This is useful for loading previously saved
            configuration data.

         none:  The target datastore is unaffected by the configuration
            in the &lt;config&gt; parameter, unless and until the incoming
            configuration data uses the &quot;operation&quot; attribute to request
            a different operation.  If the configuration in the &lt;config&gt;
            parameter contains data for which there is not a
            corresponding level in the target datastore, an &lt;rpc-error&gt;
            is returned with an &lt;error-tag&gt; value of data-missing.
            Using &quot;none&quot; allows operations like &quot;delete&quot; to avoid
            unintentionally creating the parent hierarchy of the element
            to be deleted.

      test-option:  The &lt;test-option&gt; element MAY be specified only if
         the device advertises the :validate:1.1 capability
         (Section 8.6).

         The &lt;test-option&gt; element has one of the following values:

         test-then-set:  Perform a validation test before attempting to
            set.  If validation errors occur, do not perform the
            &lt;edit-config&gt; operation.  This is the default test-option.

         set:  Perform a set without a validation test first.

         test-only:  Perform only the validation test, without
            attempting to set.

      error-option:  The &lt;error-option&gt; element has one of the following
         values:

         stop-on-error:  Abort the &lt;edit-config&gt; operation on first
            error.  This is the default error-option.

         continue-on-error:  Continue to process configuration data on
            error; error is recorded, and negative response is generated
            if any errors occur.

         rollback-on-error:  If an error condition occurs such that an
            error severity &lt;rpc-error&gt; element is generated, the server
            will stop processing the &lt;edit-config&gt; operation and restore
            the specified configuration to its complete state at the
            start of this &lt;edit-config&gt; operation.  This option requires
            the server to support the :rollback-on-error capability
            described in Section 8.5.

      config:  A hierarchy of configuration data as defined by one of
         the device&#x27;s data models.  The contents MUST be placed in an
         appropriate namespace, to allow the device to detect the
         appropriate data model, and the contents MUST follow the
         constraints of that data model, as defined by its capability
         definition.  Capabilities are discussed in Section 8.

   Positive Response:  If the device was able to satisfy the request, an
      &lt;rpc-reply&gt; is sent containing an &lt;ok&gt; element.

   Negative Response:  An &lt;rpc-error&gt; response is sent if the request
      cannot be completed for any reason.

   Example:  The &lt;edit-config&gt; examples in this section utilize a simple
      data model, in which multiple instances of the &lt;interface&gt; element
      can be present, and an instance is distinguished by the &lt;name&gt;
      element within each &lt;interface&gt; element.

      Set the MTU to 1500 on an interface named &quot;Ethernet0/0&quot; in the
      running configuration:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;edit-config&gt;
         &lt;target&gt;
           &lt;running/&gt;
         &lt;/target&gt;
         &lt;config&gt;
           &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
             &lt;interface&gt;
               &lt;name&gt;Ethernet0/0&lt;/name&gt;
               &lt;mtu&gt;1500&lt;/mtu&gt;
             &lt;/interface&gt;
           &lt;/top&gt;
         &lt;/config&gt;
       &lt;/edit-config&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

   Add an interface named &quot;Ethernet0/0&quot; to the running configuration,
   replacing any previous interface with that name:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;edit-config&gt;
         &lt;target&gt;
           &lt;running/&gt;
         &lt;/target&gt;
         &lt;config xmlns:xc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
           &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
             &lt;interface xc:operation=&quot;replace&quot;&gt;
               &lt;name&gt;Ethernet0/0&lt;/name&gt;
               &lt;mtu&gt;1500&lt;/mtu&gt;
               &lt;address&gt;
                 &lt;name&gt;192.0.2.4&lt;/name&gt;
                 &lt;prefix-length&gt;24&lt;/prefix-length&gt;
               &lt;/address&gt;
             &lt;/interface&gt;
           &lt;/top&gt;
         &lt;/config&gt;
       &lt;/edit-config&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

   Delete the configuration for an interface named &quot;Ethernet0/0&quot; from
   the running configuration:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;edit-config&gt;
         &lt;target&gt;
           &lt;running/&gt;
         &lt;/target&gt;
         &lt;default-operation&gt;none&lt;/default-operation&gt;
         &lt;config xmlns:xc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
           &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
             &lt;interface xc:operation=&quot;delete&quot;&gt;
               &lt;name&gt;Ethernet0/0&lt;/name&gt;

             &lt;/interface&gt;
           &lt;/top&gt;
         &lt;/config&gt;
       &lt;/edit-config&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

   Delete interface 192.0.2.4 from an OSPF area (other interfaces
   configured in the same area are unaffected):

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;edit-config&gt;
         &lt;target&gt;
           &lt;running/&gt;
         &lt;/target&gt;
         &lt;default-operation&gt;none&lt;/default-operation&gt;
         &lt;config xmlns:xc=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
           &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
             &lt;protocols&gt;
               &lt;ospf&gt;
                 &lt;area&gt;
                   &lt;name&gt;0.0.0.0&lt;/name&gt;
                   &lt;interfaces&gt;
                     &lt;interface xc:operation=&quot;delete&quot;&gt;
                       &lt;name&gt;192.0.2.4&lt;/name&gt;
                     &lt;/interface&gt;
                   &lt;/interfaces&gt;
                 &lt;/area&gt;
               &lt;/ospf&gt;
             &lt;/protocols&gt;
           &lt;/top&gt;
         &lt;/config&gt;
       &lt;/edit-config&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

7.3.  &lt;copy-config&gt;

   Description:  Create or replace an entire configuration datastore
      with the contents of another complete configuration datastore.  If
      the target datastore exists, it is overwritten.  Otherwise, a new
      one is created, if allowed.

      If a NETCONF peer supports the :url capability (Section 8.8), the
      &lt;url&gt; element can appear as the &lt;source&gt; or &lt;target&gt; parameter.

      Even if it advertises the :writable-running capability, a device
      MAY choose not to support the &lt;running/&gt; configuration datastore
      as the &lt;target&gt; parameter of a &lt;copy-config&gt; operation.  A device
      MAY choose not to support remote-to-remote copy operations, where
      both the &lt;source&gt; and &lt;target&gt; parameters use the &lt;url&gt; element.
      If the &lt;source&gt; and &lt;target&gt; parameters identify the same URL or
      configuration datastore, an error MUST be returned with an error-
      tag containing &quot;invalid-value&quot;.

   Parameters:

      target:  Name of the configuration datastore to use as the
         destination of the &lt;copy-config&gt; operation.

      source:  Name of the configuration datastore to use as the source
         of the &lt;copy-config&gt; operation, or the &lt;config&gt; element
         containing the complete configuration to copy.

   Positive Response:  If the device was able to satisfy the request, an
      &lt;rpc-reply&gt; is sent that includes an &lt;ok&gt; element.

   Negative Response:  An &lt;rpc-error&gt; element is included within the
      &lt;rpc-reply&gt; if the request cannot be completed for any reason.

   Example:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;copy-config&gt;
         &lt;target&gt;
           &lt;running/&gt;
         &lt;/target&gt;
         &lt;source&gt;
           &lt;url&gt;https://user:password@example.com/cfg/new.txt&lt;/url&gt;
         &lt;/source&gt;
       &lt;/copy-config&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
         xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

7.4.  &lt;delete-config&gt;

   Description:  Delete a configuration datastore.  The &lt;running&gt;
      configuration datastore cannot be deleted.

      If a NETCONF peer supports the :url capability (Section 8.8), the
      &lt;url&gt; element can appear as the &lt;target&gt; parameter.

   Parameters:

      target:  Name of the configuration datastore to delete.

   Positive Response:  If the device was able to satisfy the request, an
      &lt;rpc-reply&gt; is sent that includes an &lt;ok&gt; element.

   Negative Response:  An &lt;rpc-error&gt; element is included within the
      &lt;rpc-reply&gt; if the request cannot be completed for any reason.

   Example:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;delete-config&gt;
         &lt;target&gt;
           &lt;startup/&gt;
         &lt;/target&gt;
       &lt;/delete-config&gt;
     &lt;/rpc&gt;

      &lt;rpc-reply message-id=&quot;101&quot;
           xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

7.5.  &lt;lock&gt;

   Description:  The &lt;lock&gt; operation allows the client to lock the
      entire configuration datastore system of a device.  Such locks are
      intended to be short-lived and allow a client to make a change
      without fear of interaction with other NETCONF clients, non-
      NETCONF clients (e.g., SNMP and command line interface (CLI)
      scripts), and human users.

      An attempt to lock the configuration datastore MUST fail if an
      existing session or other entity holds a lock on any portion of
      the lock target.

      When the lock is acquired, the server MUST prevent any changes to
      the locked resource other than those requested by this session.
      SNMP and CLI requests to modify the resource MUST fail with an
      appropriate error.

      The duration of the lock is defined as beginning when the lock is
      acquired and lasting until either the lock is released or the
      NETCONF session closes.  The session closure can be explicitly
      performed by the client, or implicitly performed by the server
      based on criteria such as failure of the underlying transport,
      simple inactivity timeout, or detection of abusive behavior on the
      part of the client.  These criteria are dependent on the
      implementation and the underlying transport.

      The &lt;lock&gt; operation takes a mandatory parameter, &lt;target&gt;.  The
      &lt;target&gt; parameter names the configuration datastore that will be
      locked.  When a lock is active, using the &lt;edit-config&gt; operation
      on the locked configuration datastore and using the locked
      configuration as a target of the &lt;copy-config&gt; operation will be
      disallowed by any other NETCONF session.  Additionally, the system
      will ensure that these locked configuration resources will not be
      modified by other non-NETCONF management operations such as SNMP
      and CLI.  The &lt;kill-session&gt; operation can be used to force the
      release of a lock owned by another NETCONF session.  It is beyond
      the scope of this document to define how to break locks held by
      other entities.

      A lock MUST NOT be granted if any of the following conditions is
      true:

      *  A lock is already held by any NETCONF session or another
         entity.

      *  The target configuration is &lt;candidate&gt;, it has already been
         modified, and these changes have not been committed or rolled
         back.

      *  The target configuration is &lt;running&gt;, and another NETCONF
         session has an ongoing confirmed commit (Section 8.4).

      The server MUST respond with either an &lt;ok&gt; element or an
      &lt;rpc-error&gt;.

      A lock will be released by the system if the session holding the
      lock is terminated for any reason.

   Parameters:

      target:  Name of the configuration datastore to lock.

   Positive Response:  If the device was able to satisfy the request, an
      &lt;rpc-reply&gt; is sent that contains an &lt;ok&gt; element.

   Negative Response:  An &lt;rpc-error&gt; element is included in the
      &lt;rpc-reply&gt; if the request cannot be completed for any reason.

      If the lock is already held, the &lt;error-tag&gt; element will be
      &quot;lock-denied&quot; and the &lt;error-info&gt; element will include the
      &lt;session-id&gt; of the lock owner.  If the lock is held by a non-
      NETCONF entity, a &lt;session-id&gt; of 0 (zero) is included.  Note that
      any other entity performing a lock on even a partial piece of a
      target will prevent a NETCONF lock (which is global) from being
      obtained on that target.

   Example:  The following example shows a successful acquisition of a
      lock.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;lock&gt;
         &lt;target&gt;
           &lt;running/&gt;
         &lt;/target&gt;
       &lt;/lock&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt; &lt;!-- lock succeeded --&gt;
     &lt;/rpc-reply&gt;

   Example:  The following example shows a failed attempt to acquire a
      lock when the lock is already in use.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;lock&gt;
         &lt;target&gt;
           &lt;running/&gt;
         &lt;/target&gt;
       &lt;/lock&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;rpc-error&gt; &lt;!-- lock failed --&gt;
         &lt;error-type&gt;protocol&lt;/error-type&gt;
         &lt;error-tag&gt;lock-denied&lt;/error-tag&gt;
         &lt;error-severity&gt;error&lt;/error-severity&gt;
         &lt;error-message&gt;
           Lock failed, lock is already held
         &lt;/error-message&gt;
         &lt;error-info&gt;
           &lt;session-id&gt;454&lt;/session-id&gt;
           &lt;!-- lock is held by NETCONF session 454 --&gt;
         &lt;/error-info&gt;
       &lt;/rpc-error&gt;
     &lt;/rpc-reply&gt;

7.6.  &lt;unlock&gt;

   Description:  The &lt;unlock&gt; operation is used to release a
      configuration lock, previously obtained with the &lt;lock&gt; operation.

      An &lt;unlock&gt; operation will not succeed if either of the following
      conditions is true:

      *  The specified lock is not currently active.

      *  The session issuing the &lt;unlock&gt; operation is not the same
         session that obtained the lock.

      The server MUST respond with either an &lt;ok&gt; element or an
      &lt;rpc-error&gt;.

   Parameters:

      target:  Name of the configuration datastore to unlock.

         A NETCONF client is not permitted to unlock a configuration
         datastore that it did not lock.

   Positive Response:  If the device was able to satisfy the request, an
      &lt;rpc-reply&gt; is sent that contains an &lt;ok&gt; element.

   Negative Response:  An &lt;rpc-error&gt; element is included in the
      &lt;rpc-reply&gt; if the request cannot be completed for any reason.

   Example:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;unlock&gt;
         &lt;target&gt;
          &lt;running/&gt;
         &lt;/target&gt;
       &lt;/unlock&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

7.7.  &lt;get&gt;

   Description:  Retrieve running configuration and device state
      information.

   Parameters:

      filter:  This parameter specifies the portion of the system
         configuration and state data to retrieve.  If this parameter is
         not present, all the device configuration and state information
         is returned.

         The &lt;filter&gt; element MAY optionally contain a &quot;type&quot; attribute.
         This attribute indicates the type of filtering syntax used
         within the &lt;filter&gt; element.  The default filtering mechanism
         in NETCONF is referred to as subtree filtering and is described
         in Section 6.  The value &quot;subtree&quot; explicitly identifies this
         type of filtering.

         If the NETCONF peer supports the :xpath capability
         (Section 8.9), the value &quot;xpath&quot; MAY be used to indicate that
         the &quot;select&quot; attribute of the &lt;filter&gt; element contains an
         XPath expression.

   Positive Response:  If the device was able to satisfy the request, an
      &lt;rpc-reply&gt; is sent.  The &lt;data&gt; section contains the appropriate
      subset.

   Negative Response:  An &lt;rpc-error&gt; element is included in the
      &lt;rpc-reply&gt; if the request cannot be completed for any reason.

   Example:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;get&gt;
         &lt;filter type=&quot;subtree&quot;&gt;
           &lt;top xmlns=&quot;http://example.com/schema/1.2/stats&quot;&gt;
             &lt;interfaces&gt;
               &lt;interface&gt;
                 &lt;ifName&gt;eth0&lt;/ifName&gt;
               &lt;/interface&gt;
             &lt;/interfaces&gt;
           &lt;/top&gt;
         &lt;/filter&gt;
       &lt;/get&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;data&gt;
         &lt;top xmlns=&quot;http://example.com/schema/1.2/stats&quot;&gt;
           &lt;interfaces&gt;
             &lt;interface&gt;
               &lt;ifName&gt;eth0&lt;/ifName&gt;
               &lt;ifInOctets&gt;45621&lt;/ifInOctets&gt;
               &lt;ifOutOctets&gt;774344&lt;/ifOutOctets&gt;
             &lt;/interface&gt;
           &lt;/interfaces&gt;
         &lt;/top&gt;
       &lt;/data&gt;
     &lt;/rpc-reply&gt;

7.8.  &lt;close-session&gt;

   Description:  Request graceful termination of a NETCONF session.

      When a NETCONF server receives a &lt;close-session&gt; request, it will
      gracefully close the session.  The server will release any locks
      and resources associated with the session and gracefully close any
      associated connections.  Any NETCONF requests received after a
      &lt;close-session&gt; request will be ignored.

   Positive Response:  If the device was able to satisfy the request, an
      &lt;rpc-reply&gt; is sent that includes an &lt;ok&gt; element.

   Negative Response:  An &lt;rpc-error&gt; element is included in the
      &lt;rpc-reply&gt; if the request cannot be completed for any reason.

   Example:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;close-session/&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

7.9.  &lt;kill-session&gt;

   Description:  Force the termination of a NETCONF session.

      When a NETCONF entity receives a &lt;kill-session&gt; request for an
      open session, it will abort any operations currently in process,
      release any locks and resources associated with the session, and
      close any associated connections.

      If a NETCONF server receives a &lt;kill-session&gt; request while
      processing a confirmed commit (Section 8.4), it MUST restore the
      configuration to its state before the confirmed commit was issued.

      Otherwise, the &lt;kill-session&gt; operation does not roll back
      configuration or other device state modifications made by the
      entity holding the lock.

   Parameters:

      session-id:  Session identifier of the NETCONF session to be
         terminated.  If this value is equal to the current session ID,
         an &quot;invalid-value&quot; error is returned.

   Positive Response:  If the device was able to satisfy the request, an
      &lt;rpc-reply&gt; is sent that includes an &lt;ok&gt; element.

   Negative Response:  An &lt;rpc-error&gt; element is included in the
      &lt;rpc-reply&gt; if the request cannot be completed for any reason.

   Example:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;kill-session&gt;
         &lt;session-id&gt;4&lt;/session-id&gt;
       &lt;/kill-session&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

8.  Capabilities

   This section defines a set of capabilities that a client or a server
   MAY implement.  Each peer advertises its capabilities by sending them
   during an initial capabilities exchange.  Each peer needs to
   understand only those capabilities that it might use and MUST ignore
   any capability received from the other peer that it does not require
   or does not understand.

   Additional capabilities can be defined using the template in
   Appendix D.  Future capability definitions can be published as
   standards by standards bodies or published as proprietary extensions.

   A NETCONF capability is identified with a URI.  The base capabilities
   are defined using URNs following the method described in RFC 3553
   [RFC3553].  Capabilities defined in this document have the following
   format:

      urn:ietf:params:netconf:capability:{name}:1.x

   where {name} is the name of the capability.  Capabilities are often
   referenced in discussions and email using the shorthand :{name}, or
   :{name}:{version} if the capability exists in multiple versions.  For
   example, the foo capability would have the formal name
   &quot;urn:ietf:params:netconf:capability:foo:1.0&quot; and be called &quot;:foo&quot;.
   The shorthand form MUST NOT be used inside the protocol.

8.1.  Capabilities Exchange

   Capabilities are advertised in messages sent by each peer during
   session establishment.  When the NETCONF session is opened, each peer
   (both client and server) MUST send a &lt;hello&gt; element containing a
   list of that peer&#x27;s capabilities.  Each peer MUST send at least the

   base NETCONF capability, &quot;urn:ietf:params:netconf:base:1.1&quot;.  A peer
   MAY include capabilities for previous NETCONF versions, to indicate
   that it supports multiple protocol versions.

   Both NETCONF peers MUST verify that the other peer has advertised a
   common protocol version.  When comparing protocol version capability
   URIs, only the base part is used, in the event any parameters are
   encoded at the end of the URI string.  If no protocol version
   capability in common is found, the NETCONF peer MUST NOT continue the
   session.  If more than one protocol version URI in common is present,
   then the highest numbered (most recent) protocol version MUST be used
   by both peers.

   A server sending the &lt;hello&gt; element MUST include a &lt;session-id&gt;
   element containing the session ID for this NETCONF session.  A client
   sending the &lt;hello&gt; element MUST NOT include a &lt;session-id&gt; element.

   A server receiving a &lt;hello&gt; message with a &lt;session-id&gt; element MUST
   terminate the NETCONF session.  Similarly, a client that does not
   receive a &lt;session-id&gt; element in the server&#x27;s &lt;hello&gt; message MUST
   terminate the NETCONF session (without first sending a
   &lt;close-session&gt;).

   In the following example, a server advertises the base NETCONF
   capability, one NETCONF capability defined in the base NETCONF
   document, and one implementation-specific capability.

   &lt;hello xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
     &lt;capabilities&gt;
       &lt;capability&gt;
         urn:ietf:params:netconf:base:1.1
       &lt;/capability&gt;
       &lt;capability&gt;
         urn:ietf:params:netconf:capability:startup:1.0
       &lt;/capability&gt;
       &lt;capability&gt;
         http://example.net/router/2.3/myfeature
       &lt;/capability&gt;
     &lt;/capabilities&gt;
     &lt;session-id&gt;4&lt;/session-id&gt;
   &lt;/hello&gt;

   Each peer sends its &lt;hello&gt; element simultaneously as soon as the
   connection is open.  A peer MUST NOT wait to receive the capability
   set from the other side before sending its own set.

8.2.  Writable-Running Capability

8.2.1.  Description

   The :writable-running capability indicates that the device supports
   direct writes to the &lt;running&gt; configuration datastore.  In other
   words, the device supports &lt;edit-config&gt; and &lt;copy-config&gt; operations
   where the &lt;running&gt; configuration is the target.

8.2.2.  Dependencies

   None.

8.2.3.  Capability Identifier

   The :writable-running capability is identified by the following
   capability string:

      urn:ietf:params:netconf:capability:writable-running:1.0

8.2.4.  New Operations

   None.

8.2.5.  Modifications to Existing Operations

8.2.5.1.  &lt;edit-config&gt;

   The :writable-running capability modifies the &lt;edit-config&gt; operation
   to accept the &lt;running&gt; element as a &lt;target&gt;.

8.2.5.2.  &lt;copy-config&gt;

   The :writable-running capability modifies the &lt;copy-config&gt; operation
   to accept the &lt;running&gt; element as a &lt;target&gt;.

8.3.  Candidate Configuration Capability

8.3.1.  Description

   The candidate configuration capability, :candidate, indicates that
   the device supports a candidate configuration datastore, which is
   used to hold configuration data that can be manipulated without
   impacting the device&#x27;s current configuration.  The candidate
   configuration is a full configuration data set that serves as a work
   place for creating and manipulating configuration data.  Additions,
   deletions, and changes can be made to this data to construct the

   desired configuration data.  A &lt;commit&gt; operation MAY be performed at
   any time that causes the device&#x27;s running configuration to be set to
   the value of the candidate configuration.

   The &lt;commit&gt; operation effectively sets the running configuration to
   the current contents of the candidate configuration.  While it could
   be modeled as a simple copy, it is done as a distinct operation for a
   number of reasons.  In keeping high-level concepts as first-class
   operations, we allow developers to see more clearly both what the
   client is requesting and what the server must perform.  This keeps
   the intentions more obvious, the special cases less complex, and the
   interactions between operations more straightforward.  For example,
   the :confirmed-commit:1.1 capability (Section 8.4) would make no
   sense as a &quot;copy confirmed&quot; operation.

   The candidate configuration can be shared among multiple sessions.
   Unless a client has specific information that the candidate
   configuration is not shared, it MUST assume that other sessions are
   able to modify the candidate configuration at the same time.  It is
   therefore prudent for a client to lock the candidate configuration
   before modifying it.

   The client can discard any uncommitted changes to the candidate
   configuration by executing the &lt;discard-changes&gt; operation.  This
   operation reverts the contents of the candidate configuration to the
   contents of the running configuration.

8.3.2.  Dependencies

   None.

8.3.3.  Capability Identifier

   The :candidate capability is identified by the following capability
   string:

      urn:ietf:params:netconf:capability:candidate:1.0

8.3.4.  New Operations

8.3.4.1.  &lt;commit&gt;

   Description:

         When the candidate configuration&#x27;s content is complete, the
         configuration data can be committed, publishing the data set to
         the rest of the device and requesting the device to conform to
         the behavior described in the new configuration.

         To commit the candidate configuration as the device&#x27;s new
         current configuration, use the &lt;commit&gt; operation.

         The &lt;commit&gt; operation instructs the device to implement the
         configuration data contained in the candidate configuration.
         If the device is unable to commit all of the changes in the
         candidate configuration datastore, then the running
         configuration MUST remain unchanged.  If the device does
         succeed in committing, the running configuration MUST be
         updated with the contents of the candidate configuration.

         If the running or candidate configuration is currently locked
         by a different session, the &lt;commit&gt; operation MUST fail with
         an &lt;error-tag&gt; value of &quot;in-use&quot;.

         If the system does not have the :candidate capability, the
         &lt;commit&gt; operation is not available.

   Positive Response:

         If the device was able to satisfy the request, an &lt;rpc-reply&gt;
         is sent that contains an &lt;ok&gt; element.

   Negative Response:

         An &lt;rpc-error&gt; element is included in the &lt;rpc-reply&gt; if the
         request cannot be completed for any reason.

   Example:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;commit/&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

<span class="Verified-inline-styling" id='inline-5388'>8.3.4.2.  &lt;discard-changes&gt; <button id="btn_5388" target="expand_5388" onclick='hideFunction("expand_5388")'>Expand</button>

   Description:

         If the client decides that the candidate configuration is not
         to be committed, the &lt;discard-changes&gt; operation can be used to
         revert the candidate configuration to the current running
         configuration.

         This operation discards any uncommitted changes by resetting
         the candidate configuration with the content of the running
         configuration.

   Positive Response:

         If the device was able to satisfy the request, an &lt;rpc-reply&gt;
         is sent that contains an &lt;ok&gt; element.

   Negative Response:

         An &lt;rpc-error&gt; element is included in the &lt;rpc-reply&gt; if the
         request cannot be completed for any reason.

   Example:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;discard-changes/&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;</span id__locate=5388>
<div class="nodeCloseClass" id='expand_5388'><div class='Verified-endnote-styling' id='eid5388'>
<pre>
<b><i><a href='https://www.rfc-editor.org/errata/eid5388'>EID 5388</a> (Verified) is as follows:</i></b>

<b>Section:</b> 8.3.4.2

<b>Original Text:</b>

8.3.4.2.  &lt;discard-changes&gt;

   If the client decides that the candidate configuration is not to be
   committed, the &lt;discard-changes&gt; operation can be used to revert the
   candidate configuration to the current running configuration.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;discard-changes/&gt;
     &lt;/rpc&gt;

   This operation discards any uncommitted changes by resetting the
   candidate configuration with the content of the running
   configuration.

<b>Corrected Text:</b>

8.3.4.2.  &lt;discard-changes&gt;

   Description:

         If the client decides that the candidate configuration is not
         to be committed, the &lt;discard-changes&gt; operation can be used to
         revert the candidate configuration to the current running
         configuration.

         This operation discards any uncommitted changes by resetting
         the candidate configuration with the content of the running
         configuration.

   Positive Response:

         If the device was able to satisfy the request, an &lt;rpc-reply&gt;
         is sent that contains an &lt;ok&gt; element.

   Negative Response:

         An &lt;rpc-error&gt; element is included in the &lt;rpc-reply&gt; if the
         request cannot be completed for any reason.

   Example:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;discard-changes/&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;
</pre>
<b>Notes:</b><br/>
RFC 6241 section 1.1 includes the following two definitions:<br/><br/>   o  protocol operation: A specific remote procedure call, as used<br/>      within the NETCONF protocol.<br/><br/>   o  remote procedure call (RPC): Realized by exchanging &lt;rpc&gt; and<br/>      &lt;rpc-reply&gt; messages.<br/><br/>Positive and negative responses are detailed for all instances of an operation within the RFC with the exception of &lt;discard-changes&gt;.<br/><br/>Section 8.3.4.2 identifies &lt;discard-changes&gt; as an operation, and appendices A and C identify &quot;rollback-failed&quot; as an error-tag to be used when the &quot;Request to roll back some configuration change (via rollback-on-error or &lt;discard-changes&gt; operations) was not completed for some reason.&quot;<br/><br/>This change clarifies that &lt;discard-changes&gt; requires an &lt;rpc-reply&gt;.
</div>
</div>
8.3.5.  Modifications to Existing Operations

8.3.5.1.  &lt;get-config&gt;, &lt;edit-config&gt;, &lt;copy-config&gt;, and &lt;validate&gt;

   The candidate configuration can be used as a source or target of any
   &lt;get-config&gt;, &lt;edit-config&gt;, &lt;copy-config&gt;, or &lt;validate&gt; operation
   as a &lt;source&gt; or &lt;target&gt; parameter.  The &lt;candidate&gt; element is used
   to indicate the candidate configuration:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;get-config&gt;
         &lt;source&gt;
           &lt;candidate/&gt;
         &lt;/source&gt;
       &lt;/get-config&gt;
     &lt;/rpc&gt;

8.3.5.2.  &lt;lock&gt; and &lt;unlock&gt;

   The candidate configuration can be locked using the &lt;lock&gt; operation
   with the &lt;candidate&gt; element as the &lt;target&gt; parameter:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;lock&gt;
         &lt;target&gt;
           &lt;candidate/&gt;
         &lt;/target&gt;
       &lt;/lock&gt;
     &lt;/rpc&gt;

   Similarly, the candidate configuration is unlocked using the
   &lt;candidate&gt; element as the &lt;target&gt; parameter:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;unlock&gt;
         &lt;target&gt;
           &lt;candidate/&gt;
         &lt;/target&gt;
       &lt;/unlock&gt;
     &lt;/rpc&gt;

   When a client fails with outstanding changes to the candidate
   configuration, recovery can be difficult.  To facilitate easy
   recovery, any outstanding changes are discarded when the lock is
   released, whether explicitly with the &lt;unlock&gt; operation or
   implicitly from session failure.

8.4.  Confirmed Commit Capability

8.4.1.  Description

   The :confirmed-commit:1.1 capability indicates that the server will
   support the &lt;cancel-commit&gt; operation and the &lt;confirmed&gt;,
   &lt;confirm-timeout&gt;, &lt;persist&gt;, and &lt;persist-id&gt; parameters for the
   &lt;commit&gt; operation.  See Section 8.3 for further details on the
   &lt;commit&gt; operation.

   A confirmed &lt;commit&gt; operation MUST be reverted if a confirming
   commit is not issued within the timeout period (by default 600
   seconds = 10 minutes).  The confirming commit is a &lt;commit&gt; operation
   without the &lt;confirmed&gt; parameter.  The timeout period can be
   adjusted with the &lt;confirm-timeout&gt; parameter.  If a follow-up
   confirmed &lt;commit&gt; operation is issued before the timer expires, the
   timer is reset to the new value (600 seconds by default).  Both the
   confirming commit and a follow-up confirmed &lt;commit&gt; operation MAY
   introduce additional changes to the configuration.

   If the &lt;persist&gt; element is not given in the confirmed commit
   operation, any follow-up commit and the confirming commit MUST be
   issued on the same session that issued the confirmed commit.  If the
   &lt;persist&gt; element is given in the confirmed &lt;commit&gt; operation, a
   follow-up commit and the confirming commit can be given on any
   session, and they MUST include a &lt;persist-id&gt; element with a value
   equal to the given value of the &lt;persist&gt; element.

   If the server also advertises the :startup capability, a
   &lt;copy-config&gt; from running to startup is also necessary to save the
   changes to startup.

   If the session issuing the confirmed commit is terminated for any
   reason before the confirm timeout expires, the server MUST restore
   the configuration to its state before the confirmed commit was
   issued, unless the confirmed commit also included a &lt;persist&gt;
   element.

   If the device reboots for any reason before the confirm timeout
   expires, the server MUST restore the configuration to its state
   before the confirmed commit was issued.

   If a confirming commit is not issued, the device will revert its
   configuration to the state prior to the issuance of the confirmed
   commit.  To cancel a confirmed commit and revert changes without
   waiting for the confirm timeout to expire, the client can explicitly
   restore the configuration to its state before the confirmed commit
   was issued, by using the &lt;cancel-commit&gt; operation.

   For shared configurations, this feature can cause other configuration
   changes (for example, via other NETCONF sessions) to be inadvertently
   altered or removed, unless the configuration locking feature is used
   (in other words, the lock is obtained before the &lt;edit-config&gt;
   operation is started).  Therefore, it is strongly suggested that in
   order to use this feature with shared configuration datastores,
   configuration locking SHOULD also be used.

   Version 1.0 of this capability was defined in [RFC4741].  Version 1.1
   is defined in this document, and extends version 1.0 by adding a new
   operation, &lt;cancel-commit&gt;, and two new optional parameters,
   &lt;persist&gt; and &lt;persist-id&gt;.  For backwards compatibility with old
   clients, servers conforming to this specification MAY advertise
   version 1.0 in addition to version 1.1.

8.4.2.  Dependencies

   The :confirmed-commit:1.1 capability is only relevant if the
   :candidate capability is also supported.

8.4.3.  Capability Identifier

   The :confirmed-commit:1.1 capability is identified by the following
   capability string:

      urn:ietf:params:netconf:capability:confirmed-commit:1.1

8.4.4.  New Operations

8.4.4.1.  &lt;cancel-commit&gt;

   Description:

         Cancels an ongoing confirmed commit.  If the &lt;persist-id&gt;
         parameter is not given, the &lt;cancel-commit&gt; operation MUST be
         issued on the same session that issued the confirmed commit.

   Parameters:

      persist-id:

            Cancels a persistent confirmed commit.  The value MUST be
            equal to the value given in the &lt;persist&gt; parameter to the
            &lt;commit&gt; operation.  If the value does not match, the
            operation fails with an &quot;invalid-value&quot; error.

   Positive Response:

         If the device was able to satisfy the request, an &lt;rpc-reply&gt;
         is sent that contains an &lt;ok&gt; element.

   Negative Response:

         An &lt;rpc-error&gt; element is included in the &lt;rpc-reply&gt; if the
         request cannot be completed for any reason.

   Example:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;commit&gt;
         &lt;confirmed/&gt;
       &lt;/commit&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

     &lt;rpc message-id=&quot;102&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;cancel-commit/&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;102&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

8.4.5.  Modifications to Existing Operations

8.4.5.1.  &lt;commit&gt;

   The :confirmed-commit:1.1 capability allows 4 additional parameters
   to the &lt;commit&gt; operation.

   Parameters:

      confirmed:

            Perform a confirmed &lt;commit&gt; operation.

      confirm-timeout:

            Timeout period for confirmed commit, in seconds.  If
            unspecified, the confirm timeout defaults to 600 seconds.

      persist:

            Make the confirmed commit survive a session termination, and
            set a token on the ongoing confirmed commit.

      persist-id:

            Used to issue a follow-up confirmed commit or a confirming
            commit from any session, with the token from the previous
            &lt;commit&gt; operation.

   Example:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;commit&gt;
         &lt;confirmed/&gt;
         &lt;confirm-timeout&gt;120&lt;/confirm-timeout&gt;
       &lt;/commit&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

   Example:

     &lt;!-- start a persistent confirmed-commit --&gt;
     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;commit&gt;
         &lt;confirmed/&gt;
         &lt;persist&gt;IQ,d4668&lt;/persist&gt;
       &lt;/commit&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

     &lt;!-- confirm the persistent confirmed-commit,
          possibly from another session --&gt;
     &lt;rpc message-id=&quot;102&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;commit&gt;
         &lt;persist-id&gt;IQ,d4668&lt;/persist-id&gt;
       &lt;/commit&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;102&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

8.5.  Rollback-on-Error Capability

8.5.1.  Description

   This capability indicates that the server will support the
   &quot;rollback-on-error&quot; value in the &lt;error-option&gt; parameter to the
   &lt;edit-config&gt; operation.

   For shared configurations, this feature can cause other configuration
   changes (for example, via other NETCONF sessions) to be inadvertently
   altered or removed, unless the configuration locking feature is used
   (in other words, the lock is obtained before the &lt;edit-config&gt;
   operation is started).  Therefore, it is strongly suggested that in
   order to use this feature with shared configuration datastores,
   configuration locking also be used.

8.5.2.  Dependencies

   None.

8.5.3.  Capability Identifier

   The :rollback-on-error capability is identified by the following
   capability string:

      urn:ietf:params:netconf:capability:rollback-on-error:1.0

8.5.4.  New Operations

   None.

8.5.5.  Modifications to Existing Operations

8.5.5.1.  &lt;edit-config&gt;

   The :rollback-on-error capability allows the &quot;rollback-on-error&quot;
   value to the &lt;error-option&gt; parameter on the &lt;edit-config&gt; operation.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;edit-config&gt;
         &lt;target&gt;
           &lt;running/&gt;
         &lt;/target&gt;
         &lt;error-option&gt;rollback-on-error&lt;/error-option&gt;
         &lt;config&gt;
           &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
             &lt;interface&gt;
               &lt;name&gt;Ethernet0/0&lt;/name&gt;
               &lt;mtu&gt;100000&lt;/mtu&gt;
             &lt;/interface&gt;
           &lt;/top&gt;
         &lt;/config&gt;
       &lt;/edit-config&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

8.6.  Validate Capability

8.6.1.  Description

   Validation consists of checking a complete configuration for
   syntactical and semantic errors before applying the configuration to
   the device.

   If this capability is advertised, the device supports the &lt;validate&gt;
   protocol operation and checks at least for syntax errors.  In
   addition, this capability supports the &lt;test-option&gt; parameter to the
   &lt;edit-config&gt; operation and, when it is provided, checks at least for
   syntax errors.

   Version 1.0 of this capability was defined in [RFC4741].  Version 1.1
   is defined in this document, and extends version 1.0 by adding a new
   value, &quot;test-only&quot;, to the &lt;test-option&gt; parameter of the
   &lt;edit-config&gt; operation.  For backwards compatibility with old
   clients, servers conforming to this specification MAY advertise
   version 1.0 in addition to version 1.1.

8.6.2.  Dependencies

   None.

8.6.3.  Capability Identifier

   The :validate:1.1 capability is identified by the following
   capability string:

      urn:ietf:params:netconf:capability:validate:1.1

8.6.4.  New Operations

8.6.4.1.  &lt;validate&gt;

   Description:

         This protocol operation validates the contents of the specified
         configuration.

   Parameters:

      source:

            Name of the configuration datastore to validate, such as
            &lt;candidate&gt;, or the &lt;config&gt; element containing the complete
            configuration to validate.

   Positive Response:

         If the device was able to satisfy the request, an &lt;rpc-reply&gt;
         is sent that contains an &lt;ok&gt; element.

   Negative Response:

         An &lt;rpc-error&gt; element is included in the &lt;rpc-reply&gt; if the
         request cannot be completed for any reason.

         A &lt;validate&gt; operation can fail for a number of reasons, such
         as syntax errors, missing parameters, references to undefined
         configuration data, or any other violations of rules
         established by the underlying data model.

   Example:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;validate&gt;
         &lt;source&gt;
           &lt;candidate/&gt;
         &lt;/source&gt;
       &lt;/validate&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

8.6.5.  Modifications to Existing Operations

8.6.5.1.  &lt;edit-config&gt;

   The :validate:1.1 capability modifies the &lt;edit-config&gt; operation to
   accept the &lt;test-option&gt; parameter.

8.7.  Distinct Startup Capability

8.7.1.  Description

   The device supports separate running and startup configuration
   datastores.  The startup configuration is loaded by the device when
   it boots.  Operations that affect the running configuration will not
   be automatically copied to the startup configuration.  An explicit
   &lt;copy-config&gt; operation from the &lt;running&gt; to the &lt;startup&gt; is used
   to update the startup configuration to the current contents of the

   running configuration.  NETCONF protocol operations refer to the
   startup datastore using the &lt;startup&gt; element.

8.7.2.  Dependencies

   None.

8.7.3.  Capability Identifier

   The :startup capability is identified by the following capability
   string:

      urn:ietf:params:netconf:capability:startup:1.0

8.7.4.  New Operations

   None.

8.7.5.  Modifications to Existing Operations

8.7.5.1.  General

   The :startup capability adds the &lt;startup/&gt; configuration datastore
   to arguments of several NETCONF operations.  The server MUST support
   the following additional values:

   +--------------------+--------------------------+-------------------+
   | Operation          | Parameters               | Notes             |
   +--------------------+--------------------------+-------------------+
   | &lt;get-config&gt;       | &lt;source&gt;                 |                   |
   |                    |                          |                   |
   | &lt;copy-config&gt;      | &lt;source&gt; &lt;target&gt;        |                   |
   |                    |                          |                   |
   | &lt;lock&gt;             | &lt;target&gt;                 |                   |
   |                    |                          |                   |
   | &lt;unlock&gt;           | &lt;target&gt;                 |                   |
   |                    |                          |                   |
   | &lt;validate&gt;         | &lt;source&gt;                 | If :validate:1.1  |
   |                    |                          | is advertised     |
   |                    |                          |                   |
   | &lt;delete-config&gt;    | &lt;target&gt;                 | Resets the device |
   |                    |                          | to its factory    |
   |                    |                          | defaults          |
   +--------------------+--------------------------+-------------------+

   To save the startup configuration, use the &lt;copy-config&gt; operation to
   copy the &lt;running&gt; configuration datastore to the &lt;startup&gt;
   configuration datastore.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;copy-config&gt;
         &lt;target&gt;
           &lt;startup/&gt;
         &lt;/target&gt;
         &lt;source&gt;
           &lt;running/&gt;
         &lt;/source&gt;
       &lt;/copy-config&gt;
     &lt;/rpc&gt;

8.8.  URL Capability

8.8.1.  Description

   The NETCONF peer has the ability to accept the &lt;url&gt; element in
   &lt;source&gt; and &lt;target&gt; parameters.  The capability is further
   identified by URL arguments indicating the URL schemes supported.

8.8.2.  Dependencies

   None.

8.8.3.  Capability Identifier

   The :url capability is identified by the following capability string:

      urn:ietf:params:netconf:capability:url:1.0?scheme={name,...}

   The :url capability URI MUST contain a &quot;scheme&quot; argument assigned a
   comma-separated list of scheme names indicating which schemes the
   NETCONF peer supports.  For example:

      urn:ietf:params:netconf:capability:url:1.0?scheme=http,ftp,file

8.8.4.  New Operations

   None.

8.8.5.  Modifications to Existing Operations

8.8.5.1.  &lt;edit-config&gt;

   The :url capability modifies the &lt;edit-config&gt; operation to accept
   the &lt;url&gt; element as an alternative to the &lt;config&gt; parameter.

   The file that the url refers to contains the configuration data
   hierarchy to be modified, encoded in XML under the element &lt;config&gt;
   in the &quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot; namespace.

8.8.5.2.  &lt;copy-config&gt;

   The :url capability modifies the &lt;copy-config&gt; operation to accept
   the &lt;url&gt; element as the value of the &lt;source&gt; and the &lt;target&gt;
   parameters.

   The file that the url refers to contains the complete datastore,
   encoded in XML under the element &lt;config&gt; in the
   &quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot; namespace.

8.8.5.3.  &lt;delete-config&gt;

   The :url capability modifies the &lt;delete-config&gt; operation to accept
   the &lt;url&gt; element as the value of the &lt;target&gt; parameters.

8.8.5.4.  &lt;validate&gt;

   The :url capability modifies the &lt;validate&gt; operation to accept the
   &lt;url&gt; element as the value of the &lt;source&gt; parameter.

8.9.  XPath Capability

8.9.1.  Description

   The XPath capability indicates that the NETCONF peer supports the use
   of XPath expressions in the &lt;filter&gt; element.  XPath is described in
   [W3C.REC-xpath-19991116].

   The data model used in the XPath expression is the same as that used
   in XPath 1.0 [W3C.REC-xpath-19991116], with the same extension for
   root node children as used by XSLT 1.0 ([W3C.REC-xslt-19991116],
   Section 3.1).  Specifically, it means that the root node MAY have any
   number of element nodes as its children.

   The XPath expression is evaluated in the following context:

   o  The set of namespace declarations are those in scope on the
      &lt;filter&gt; element.

   o  The set of variable bindings is defined by the data model.  If no
      such variable bindings are defined, the set is empty.

   o  The function library is the core function library, plus any
      functions defined by the data model.

   o  The context node is the root node.

   The XPath expression MUST return a node set.  If it does not return a
   node set, the operation fails with an &quot;invalid-value&quot; error.

   The response message contains the subtrees selected by the filter
   expression.  For each such subtree, the path from the data model root
   node down to the subtree, including any elements or attributes
   necessary to uniquely identify the subtree, are included in the
   response message.  Specific data instances are not duplicated in the
   response.

8.9.2.  Dependencies

   None.

8.9.3.  Capability Identifier

   The :xpath capability is identified by the following capability
   string:

      urn:ietf:params:netconf:capability:xpath:1.0

8.9.4.  New Operations

   None.

8.9.5.  Modifications to Existing Operations

8.9.5.1.  &lt;get-config&gt; and &lt;get&gt;

   The :xpath capability modifies the &lt;get&gt; and &lt;get-config&gt; operations
   to accept the value &quot;xpath&quot; in the &quot;type&quot; attribute of the &lt;filter&gt;
   element.  When the &quot;type&quot; attribute is set to &quot;xpath&quot;, a &quot;select&quot;
   attribute MUST be present on the &lt;filter&gt; element.  The &quot;select&quot;
   attribute will be treated as an XPath expression and used to filter
   the returned data.  The &lt;filter&gt; element itself MUST be empty in this
   case.

   The XPath result for the select expression MUST be a node-set.  Each
   node in the node-set MUST correspond to a node in the underlying data
   model.  In order to properly identify each node, the following
   encoding rules are defined:

   o  All ancestor nodes of the result node MUST be encoded first, so
      the &lt;data&gt; element returned in the reply contains only fully
      specified subtrees, according to the underlying data model.

   o  If any sibling or ancestor nodes of the result node are needed to
      identify a particular instance within a conceptual data structure,
      then these nodes MUST also be encoded in the response.

   For example:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;get-config&gt;
         &lt;source&gt;
           &lt;running/&gt;
         &lt;/source&gt;
         &lt;!-- get the user named fred --&gt;
         &lt;filter xmlns:t=&quot;http://example.com/schema/1.2/config&quot;
                 type=&quot;xpath&quot;
                 select=&quot;/t:top/t:users/t:user[t:name=&#x27;fred&#x27;]&quot;/&gt;
        &lt;/get-config&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
                xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;data&gt;
         &lt;top xmlns=&quot;http://example.com/schema/1.2/config&quot;&gt;
           &lt;users&gt;
             &lt;user&gt;
               &lt;name&gt;fred&lt;/name&gt;
               &lt;company-info&gt;
                 &lt;id&gt;2&lt;/id&gt;
               &lt;/company-info&gt;
             &lt;/user&gt;
           &lt;/users&gt;
         &lt;/top&gt;
       &lt;/data&gt;
     &lt;/rpc-reply&gt;

9.  Security Considerations

   This section provides security considerations for the base NETCONF
   message layer and the base operations of the NETCONF protocol.
   Security considerations for the NETCONF transports are provided in
   the transport documents, and security considerations for the content
   manipulated by NETCONF can be found in the documents defining data
   models.

   This document does not specify an authorization scheme, as such a
   scheme will likely be tied to a meta-data model or a data model.
   Implementors SHOULD provide a comprehensive authorization scheme with
   NETCONF.

   Authorization of individual users via the NETCONF server may or may
   not map 1:1 to other interfaces.  First, the data models might be
   incompatible.  Second, it could be desirable to authorize based on
   mechanisms available in the Secure Transport layer (e.g., SSH, Blocks
   Extensible Exchange Protocol (BEEP), etc.).

   In addition, operations on configurations could have unintended
   consequences if those operations are also not guarded by the global
   lock on the files or objects being operated upon.  For instance, if
   the running configuration is not locked, a partially complete access
   list could be committed from the candidate configuration unbeknownst
   to the owner of the lock of the candidate configuration, leading to
   either an insecure or inaccessible device.

   Configuration information is by its very nature sensitive.  Its
   transmission in the clear and without integrity checking leaves
   devices open to classic eavesdropping and false data injection
   attacks.  Configuration information often contains passwords, user
   names, service descriptions, and topological information, all of
   which are sensitive.  Because of this, this protocol SHOULD be
   implemented carefully with adequate attention to all manner of attack
   one might expect to experience with other management interfaces.

   The protocol, therefore, MUST minimally support options for both
   confidentiality and authentication.  It is anticipated that the
   underlying protocol (SSH, BEEP, etc.) will provide for both
   confidentiality and authentication, as is required.  It is further
   expected that the identity of each end of a NETCONF session will be
   available to the other in order to determine authorization for any
   given request.  One could also easily envision additional
   information, such as transport and encryption methods, being made
   available for purposes of authorization.  NETCONF itself provides no
   means to re-authenticate, much less authenticate.  All such actions
   occur at lower layers.

   Different environments may well allow different rights prior to and
   then after authentication.  Thus, an authorization model is not
   specified in this document.  When an operation is not properly
   authorized, a simple &quot;access denied&quot; is sufficient.  Note that
   authorization information can be exchanged in the form of
   configuration information, which is all the more reason to ensure the
   security of the connection.

   That having been said, it is important to recognize that some
   operations are clearly more sensitive by nature than others.  For
   instance, &lt;copy-config&gt; to the startup or running configurations is
   clearly not a normal provisioning operation, whereas &lt;edit-config&gt;
   is.  Such global operations MUST disallow the changing of information

   that an individual does not have authorization to perform.  For
   example, if user A is not allowed to configure an IP address on an
   interface but user B has configured an IP address on an interface in
   the &lt;candidate&gt; configuration, user A MUST NOT be allowed to commit
   the &lt;candidate&gt; configuration.

   Similarly, just because someone says &quot;go write a configuration
   through the URL capability at a particular place&quot;, this does not mean
   that an element will do it without proper authorization.

   The &lt;lock&gt; operation will demonstrate that NETCONF is intended for
   use by systems that have at least some trust of the administrator.
   As specified in this document, it is possible to lock portions of a
   configuration that a principal might not otherwise have access to.
   After all, the entire configuration is locked.  To mitigate this
   problem, there are two approaches.  It is possible to kill another
   NETCONF session programmatically from within NETCONF if one knows the
   session identifier of the offending session.  The other possible way
   to break a lock is to provide a function within the device&#x27;s native
   user interface.  These two mechanisms suffer from a race condition
   that could be ameliorated by removing the offending user from an
   Authentication, Authorization, and Accounting (AAA) server.  However,
   such a solution is not useful in all deployment scenarios, such as
   those where SSH public/private key pairs are used.

10.  IANA Considerations

10.1.  NETCONF XML Namespace

   This document registers a URI for the NETCONF XML namespace in the
   IETF XML registry [RFC3688].

   IANA has updated the following URI to reference this document.

   URI: urn:ietf:params:xml:ns:netconf:base:1.0

   Registrant Contact: The IESG.

   XML: N/A, the requested URI is an XML namespace.

10.2.  NETCONF XML Schema

   This document registers a URI for the NETCONF XML schema in the IETF
   XML registry [RFC3688].

   IANA has updated the following URI to reference this document.

   URI: urn:ietf:params:xml:schema:netconf

   Registrant Contact: The IESG.

   XML: Appendix B of this document.

10.3.  NETCONF YANG Module

   This document registers a YANG module in the YANG Module Names
   registry [RFC6020].

     name:        ietf-netconf
     namespace:   urn:ietf:params:xml:ns:netconf:base:1.0
     prefix:      nc
     reference:   RFC 6241

10.4.  NETCONF Capability URNs

   IANA has created and now maintains a registry &quot;Network Configuration
   Protocol (NETCONF) Capability URNs&quot; that allocates NETCONF capability
   identifiers.  Additions to the registry require IETF Standards
   Action.

   IANA has updated the allocations of the following capabilities to
   reference this document.

      Index
         Capability Identifier
      ------------------------

      :writable-running
         urn:ietf:params:netconf:capability:writable-running:1.0

      :candidate
         urn:ietf:params:netconf:capability:candidate:1.0

      :rollback-on-error
         urn:ietf:params:netconf:capability:rollback-on-error:1.0

      :startup
         urn:ietf:params:netconf:capability:startup:1.0

      :url
         urn:ietf:params:netconf:capability:url:1.0

      :xpath
         urn:ietf:params:netconf:capability:xpath:1.0

   IANA has added the following capabilities to the registry:

      Index
         Capability Identifier
      ------------------------

      :base:1.1
         urn:ietf:params:netconf:base:1.1

      :confirmed-commit:1.1
         urn:ietf:params:netconf:capability:confirmed-commit:1.1

      :validate:1.1
         urn:ietf:params:netconf:capability:validate:1.1

11.  Contributors

   In addition to the editors, this document was written by:

      Ken Crozier, Cisco Systems

      Ted Goddard, IceSoft

      Eliot Lear, Cisco Systems

      Phil Shafer, Juniper Networks

      Steve Waldbusser

      Margaret Wasserman, Painless Security, LLC

12.  Acknowledgements

   The authors would like to acknowledge the members of the NETCONF
   working group.  In particular, we would like to thank Wes Hardaker
   for his persistence and patience in assisting us with security
   considerations.  We would also like to thank Randy Presuhn, Sharon
   Chisholm, Glenn Waters, David Perkins, Weijing Chen, Simon Leinen,
   Keith Allen, Dave Harrington, Ladislav Lhotka, Tom Petch, and Kent
   Watsen for all of their valuable advice.

13.  References

13.1.  Normative References

   [RFC2119]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, BCP 14, RFC 2119, March 1997.

   [RFC3553]  Mealling, M., Masinter, L., Hardie, T., and G. Klyne, &quot;An
              IETF URN Sub-namespace for Registered Protocol
              Parameters&quot;, BCP 73, RFC 3553, June 2003.

   [RFC3629]  Yergeau, F., &quot;UTF-8, a transformation format of ISO
              10646&quot;, STD 63, RFC 3629, November 2003.

   [RFC3688]  Mealling, M., &quot;The IETF XML Registry&quot;, BCP 81, RFC 3688,
              January 2004.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, &quot;Uniform
              Resource Identifier (URI): Generic Syntax&quot;, STD 66,
              RFC 3986, January 2005.

   [RFC5717]  Lengyel, B. and M. Bjorklund, &quot;Partial Lock Remote
              Procedure Call (RPC) for NETCONF&quot;, RFC 5717,
              December 2009.

   [RFC6020]  Bjorklund, M., &quot;YANG - A Data Modeling Language for the
              Network Configuration Protocol (NETCONF)&quot;, RFC 6020,
              October 2010.

   [RFC6021]  Schoenwaelder, J., &quot;Common YANG Data Types&quot;, RFC 6021,
              October 2010.

   [RFC6242]  Wasserman, M., &quot;Using the NETCONF Configuration Protocol
              over Secure Shell (SSH)&quot;, RFC 6242, June 2011.

   [W3C.REC-xml-20001006]
              Sperberg-McQueen, C., Bray, T., Paoli, J., and E. Maler,
              &quot;Extensible Markup Language (XML) 1.0 (Second Edition)&quot;,
              World Wide Web Consortium REC-xml-20001006, October 2000,
              &lt;http://www.w3.org/TR/2000/REC-xml-20001006&gt;.

   [W3C.REC-xpath-19991116]
              DeRose, S. and J. Clark, &quot;XML Path Language (XPath)
              Version 1.0&quot;, World Wide Web Consortium
              Recommendation REC-xpath-19991116, November 1999,
              &lt;http://www.w3.org/TR/1999/REC-xpath-19991116&gt;.

13.2.  Informative References

   [RFC2865]  Rigney, C., Willens, S., Rubens, A., and W. Simpson,
              &quot;Remote Authentication Dial In User Service (RADIUS)&quot;,
              RFC 2865, June 2000.

   [RFC3470]  Hollenbeck, S., Rose, M., and L. Masinter, &quot;Guidelines for
              the Use of Extensible Markup Language (XML)
              within IETF Protocols&quot;, BCP 70, RFC 3470, January 2003.

   [RFC4251]  Ylonen, T. and C. Lonvick, &quot;The Secure Shell (SSH)
              Protocol Architecture&quot;, RFC 4251, January 2006.

   [RFC4741]  Enns, R., &quot;NETCONF Configuration Protocol&quot;, RFC 4741,
              December 2006.

   [RFC5246]  Dierks, T. and E. Rescorla, &quot;The Transport Layer Security
              (TLS) Protocol Version 1.2&quot;, RFC 5246, August 2008.

   [W3C.REC-xslt-19991116]
              Clark, J., &quot;XSL Transformations (XSLT) Version 1.0&quot;, World
              Wide Web Consortium Recommendation REC-xslt-19991116,
              November 1999,
              &lt;http://www.w3.org/TR/1999/REC-xslt-19991116&gt;.

Appendix A.  NETCONF Error List

   This section is normative.

   For each error-tag, the valid error-type and error-severity values
   are listed, together with any mandatory error-info, if any.

   error-tag:      in-use
   error-type:     protocol, application
   error-severity: error
   error-info:     none
   Description:    The request requires a resource that already is in
                   use.

   error-tag:      invalid-value
   error-type:     protocol, application
   error-severity: error
   error-info:     none
   Description:    The request specifies an unacceptable value for one
                   or more parameters.

   error-tag:      too-big
   error-type:     transport, rpc, protocol, application
   error-severity: error
   error-info:     none
   Description:    The request or response (that would be generated) is
                   too large for the implementation to handle.

   error-tag:      missing-attribute
   error-type:     rpc, protocol, application
   error-severity: error
   error-info:     &lt;bad-attribute&gt; : name of the missing attribute
                   &lt;bad-element&gt; : name of the element that is supposed
                     to contain the missing attribute
   Description:    An expected attribute is missing.

   error-tag:      bad-attribute
   error-type:     rpc, protocol, application
   error-severity: error
   error-info:     &lt;bad-attribute&gt; : name of the attribute w/ bad value
                   &lt;bad-element&gt; : name of the element that contains
                     the attribute with the bad value
   Description:    An attribute value is not correct; e.g., wrong type,
                   out of range, pattern mismatch.

   error-tag:      unknown-attribute
   error-type:     rpc, protocol, application
   error-severity: error
   error-info:     &lt;bad-attribute&gt; : name of the unexpected attribute
                   &lt;bad-element&gt; : name of the element that contains
                     the unexpected attribute
   Description:    An unexpected attribute is present.

   error-tag:      missing-element
   error-type:     protocol, application
   error-severity: error
   error-info:     &lt;bad-element&gt; : name of the missing element
   Description:    An expected element is missing.

   error-tag:      bad-element
   error-type:     protocol, application
   error-severity: error
   error-info:     &lt;bad-element&gt; : name of the element w/ bad value
   Description:    An element value is not correct; e.g., wrong type,
                   out of range, pattern mismatch.

   error-tag:      unknown-element
   error-type:     protocol, application
   error-severity: error
   error-info:     &lt;bad-element&gt; : name of the unexpected element
   Description:    An unexpected element is present.

   error-tag:      unknown-namespace
   error-type:     protocol, application
   error-severity: error
   error-info:     &lt;bad-element&gt; : name of the element that contains
                     the unexpected namespace
                   &lt;bad-namespace&gt; : name of the unexpected namespace
   Description:    An unexpected namespace is present.

   error-tag:      access-denied
   error-type:     protocol, application
   error-severity: error
   error-info:     none
   Description:    Access to the requested protocol operation or
                   data model is denied because authorization failed.

   error-tag:      lock-denied
   error-type:     protocol
   error-severity: error
   error-info:     &lt;session-id&gt; : session ID of session holding the
                     requested lock, or zero to indicate a non-NETCONF
                     entity holds the lock
   Description:    Access to the requested lock is denied because the
                   lock is currently held by another entity.

   error-tag:      resource-denied
   error-type:     transport, rpc, protocol, application
   error-severity: error
   error-info:     none
   Description:    Request could not be completed because of
                   insufficient resources.

   error-tag:      rollback-failed
   error-type:     protocol, application
   error-severity: error
   error-info:     none
   Description:    Request to roll back some configuration change (via
                   rollback-on-error or &lt;discard-changes&gt; operations)
                   was not completed for some reason.

   error-tag:      data-exists
   error-type:     application
   error-severity: error
   error-info:     none
   Description:    Request could not be completed because the relevant
                   data model content already exists.  For example,
                   a &quot;create&quot; operation was attempted on data that
                   already exists.

   error-tag:      data-missing
   error-type:     application
   error-severity: error
   error-info:     none
   Description:    Request could not be completed because the relevant
                   data model content does not exist.  For example,
                   a &quot;delete&quot; operation was attempted on
                   data that does not exist.

   error-tag:      operation-not-supported
   error-type:     protocol, application
   error-severity: error
   error-info:     none
   Description:    Request could not be completed because the requested
                   operation is not supported by this implementation.

   error-tag:      operation-failed
   error-type:     rpc, protocol, application
   error-severity: error
   error-info:     none
   Description:    Request could not be completed because the requested
                   operation failed for some reason not covered by
                   any other error condition.

   error-tag:      partial-operation
   error-type:     application
   error-severity: error
   error-info:     &lt;ok-element&gt; : identifies an element in the data
                     model for which the requested operation has been
                     completed for that node and all its child nodes.
                     This element can appear zero or more times in the
                     &lt;error-info&gt; container.

                   &lt;err-element&gt; : identifies an element in the data
                     model for which the requested operation has failed
                     for that node and all its child nodes.
                     This element can appear zero or more times in the
                     &lt;error-info&gt; container.

                   &lt;noop-element&gt; : identifies an element in the data
                     model for which the requested operation was not
                     attempted for that node and all its child nodes.
                     This element can appear zero or more times in the
                     &lt;error-info&gt; container.

   Description:    This error-tag is obsolete, and SHOULD NOT be sent
                   by servers conforming to this document.

                   Some part of the requested operation failed or was
                   not attempted for some reason.  Full cleanup has
                   not been performed (e.g., rollback not supported)
                   by the server.  The error-info container is used
                   to identify which portions of the application
                   data model content for which the requested operation
                   has succeeded (&lt;ok-element&gt;), failed (&lt;bad-element&gt;),
                   or not been attempted (&lt;noop-element&gt;).

   error-tag:      malformed-message
   error-type:     rpc
   error-severity: error
   error-info:     none
   Description:    A message could not be handled because it failed to
                   be parsed correctly.  For example, the message is not
                   well-formed XML or it uses an invalid character set.

                   This error-tag is new in :base:1.1 and MUST NOT be
                   sent to old clients.

Appendix B.  XML Schema for NETCONF Messages Layer

   This section is normative.

   &lt;CODE BEGINS&gt; file &quot;netconf.xsd&quot;

   &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
   &lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
              xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
              targetNamespace=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;
              elementFormDefault=&quot;qualified&quot;
              attributeFormDefault=&quot;unqualified&quot;
              xml:lang=&quot;en&quot;
              version=&quot;1.1&quot;&gt;

     &lt;xs:annotation&gt;
       &lt;xs:documentation&gt;
         This schema defines the syntax for the NETCONF Messages layer
         messages &#x27;hello&#x27;, &#x27;rpc&#x27;, and &#x27;rpc-reply&#x27;.
       &lt;/xs:documentation&gt;
     &lt;/xs:annotation&gt;

     &lt;!--
        import standard XML definitions
       --&gt;
     &lt;xs:import namespace=&quot;http://www.w3.org/XML/1998/namespace&quot;
                schemaLocation=&quot;http://www.w3.org/2001/xml.xsd&quot;&gt;
       &lt;xs:annotation&gt;
         &lt;xs:documentation&gt;
           This import accesses the xml: attribute groups for the
           xml:lang as declared on the error-message element.
         &lt;/xs:documentation&gt;
       &lt;/xs:annotation&gt;
     &lt;/xs:import&gt;
     &lt;!--
        message-id attribute
       --&gt;

     &lt;xs:simpleType name=&quot;messageIdType&quot;&gt;
       &lt;xs:restriction base=&quot;xs:string&quot;&gt;
         &lt;xs:maxLength value=&quot;4095&quot;/&gt;
       &lt;/xs:restriction&gt;
     &lt;/xs:simpleType&gt;
     &lt;!--
        Types used for session-id
       --&gt;
     &lt;xs:simpleType name=&quot;SessionId&quot;&gt;
       &lt;xs:restriction base=&quot;xs:unsignedInt&quot;&gt;
         &lt;xs:minInclusive value=&quot;1&quot;/&gt;
       &lt;/xs:restriction&gt;
     &lt;/xs:simpleType&gt;
     &lt;xs:simpleType name=&quot;SessionIdOrZero&quot;&gt;
       &lt;xs:restriction base=&quot;xs:unsignedInt&quot;/&gt;
     &lt;/xs:simpleType&gt;
     &lt;!--
        &lt;rpc&gt; element
       --&gt;
     &lt;xs:complexType name=&quot;rpcType&quot;&gt;
       &lt;xs:sequence&gt;
         &lt;xs:element ref=&quot;rpcOperation&quot;/&gt;
       &lt;/xs:sequence&gt;
       &lt;xs:attribute name=&quot;message-id&quot; type=&quot;messageIdType&quot;
                     use=&quot;required&quot;/&gt;
       &lt;!--
          Arbitrary attributes can be supplied with &lt;rpc&gt; element.
         --&gt;
       &lt;xs:anyAttribute processContents=&quot;lax&quot;/&gt;
     &lt;/xs:complexType&gt;
     &lt;xs:element name=&quot;rpc&quot; type=&quot;rpcType&quot;/&gt;
     &lt;!--
        data types and elements used to construct rpc-errors
       --&gt;
     &lt;xs:simpleType name=&quot;ErrorType&quot;&gt;
       &lt;xs:restriction base=&quot;xs:string&quot;&gt;
         &lt;xs:enumeration value=&quot;transport&quot;/&gt;
         &lt;xs:enumeration value=&quot;rpc&quot;/&gt;
         &lt;xs:enumeration value=&quot;protocol&quot;/&gt;
         &lt;xs:enumeration value=&quot;application&quot;/&gt;
       &lt;/xs:restriction&gt;
     &lt;/xs:simpleType&gt;
     &lt;xs:simpleType name=&quot;ErrorTag&quot;&gt;
       &lt;xs:restriction base=&quot;xs:string&quot;&gt;
         &lt;xs:enumeration value=&quot;in-use&quot;/&gt;
         &lt;xs:enumeration value=&quot;invalid-value&quot;/&gt;
         &lt;xs:enumeration value=&quot;too-big&quot;/&gt;
         &lt;xs:enumeration value=&quot;missing-attribute&quot;/&gt;

         &lt;xs:enumeration value=&quot;bad-attribute&quot;/&gt;
         &lt;xs:enumeration value=&quot;unknown-attribute&quot;/&gt;
         &lt;xs:enumeration value=&quot;missing-element&quot;/&gt;
         &lt;xs:enumeration value=&quot;bad-element&quot;/&gt;
         &lt;xs:enumeration value=&quot;unknown-element&quot;/&gt;
         &lt;xs:enumeration value=&quot;unknown-namespace&quot;/&gt;
         &lt;xs:enumeration value=&quot;access-denied&quot;/&gt;
         &lt;xs:enumeration value=&quot;lock-denied&quot;/&gt;
         &lt;xs:enumeration value=&quot;resource-denied&quot;/&gt;
         &lt;xs:enumeration value=&quot;rollback-failed&quot;/&gt;
         &lt;xs:enumeration value=&quot;data-exists&quot;/&gt;
         &lt;xs:enumeration value=&quot;data-missing&quot;/&gt;
         &lt;xs:enumeration value=&quot;operation-not-supported&quot;/&gt;
         &lt;xs:enumeration value=&quot;operation-failed&quot;/&gt;
         &lt;xs:enumeration value=&quot;partial-operation&quot;/&gt;
         &lt;xs:enumeration value=&quot;malformed-message&quot;/&gt;
       &lt;/xs:restriction&gt;
     &lt;/xs:simpleType&gt;
     &lt;xs:simpleType name=&quot;ErrorSeverity&quot;&gt;
       &lt;xs:restriction base=&quot;xs:string&quot;&gt;
         &lt;xs:enumeration value=&quot;error&quot;/&gt;
         &lt;xs:enumeration value=&quot;warning&quot;/&gt;
       &lt;/xs:restriction&gt;
     &lt;/xs:simpleType&gt;
     &lt;xs:complexType name=&quot;errorInfoType&quot;&gt;
       &lt;xs:sequence&gt;
         &lt;xs:choice&gt;
           &lt;xs:element name=&quot;session-id&quot; type=&quot;SessionIdOrZero&quot;/&gt;
           &lt;xs:sequence minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;&gt;
             &lt;xs:sequence&gt;
               &lt;xs:element name=&quot;bad-attribute&quot; type=&quot;xs:QName&quot;
                           minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
               &lt;xs:element name=&quot;bad-element&quot; type=&quot;xs:QName&quot;
                           minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
               &lt;xs:element name=&quot;ok-element&quot; type=&quot;xs:QName&quot;
                           minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
               &lt;xs:element name=&quot;err-element&quot; type=&quot;xs:QName&quot;
                           minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
               &lt;xs:element name=&quot;noop-element&quot; type=&quot;xs:QName&quot;
                           minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
               &lt;xs:element name=&quot;bad-namespace&quot; type=&quot;xs:string&quot;
                           minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt;
             &lt;/xs:sequence&gt;
           &lt;/xs:sequence&gt;
         &lt;/xs:choice&gt;
         &lt;!-- elements from any other namespace are also allowed
              to follow the NETCONF elements --&gt;
         &lt;xs:any namespace=&quot;##other&quot; processContents=&quot;lax&quot;

                 minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
       &lt;/xs:sequence&gt;
     &lt;/xs:complexType&gt;
     &lt;xs:complexType name=&quot;rpcErrorType&quot;&gt;
       &lt;xs:sequence&gt;
         &lt;xs:element name=&quot;error-type&quot; type=&quot;ErrorType&quot;/&gt;
         &lt;xs:element name=&quot;error-tag&quot; type=&quot;ErrorTag&quot;/&gt;
         &lt;xs:element name=&quot;error-severity&quot; type=&quot;ErrorSeverity&quot;/&gt;
         &lt;xs:element name=&quot;error-app-tag&quot; type=&quot;xs:string&quot;
                     minOccurs=&quot;0&quot;/&gt;
         &lt;xs:element name=&quot;error-path&quot; type=&quot;xs:string&quot; minOccurs=&quot;0&quot;/&gt;
         &lt;xs:element name=&quot;error-message&quot; minOccurs=&quot;0&quot;&gt;
           &lt;xs:complexType&gt;
             &lt;xs:simpleContent&gt;
               &lt;xs:extension base=&quot;xs:string&quot;&gt;
                 &lt;xs:attribute ref=&quot;xml:lang&quot; use=&quot;optional&quot;/&gt;
               &lt;/xs:extension&gt;
             &lt;/xs:simpleContent&gt;
           &lt;/xs:complexType&gt;
         &lt;/xs:element&gt;
         &lt;xs:element name=&quot;error-info&quot; type=&quot;errorInfoType&quot;
                     minOccurs=&quot;0&quot;/&gt;
       &lt;/xs:sequence&gt;
     &lt;/xs:complexType&gt;
     &lt;!--
        operation attribute used in &lt;edit-config&gt;
       --&gt;
     &lt;xs:simpleType name=&quot;editOperationType&quot;&gt;
       &lt;xs:restriction base=&quot;xs:string&quot;&gt;
         &lt;xs:enumeration value=&quot;merge&quot;/&gt;
         &lt;xs:enumeration value=&quot;replace&quot;/&gt;
         &lt;xs:enumeration value=&quot;create&quot;/&gt;
         &lt;xs:enumeration value=&quot;delete&quot;/&gt;
         &lt;xs:enumeration value=&quot;remove&quot;/&gt;
       &lt;/xs:restriction&gt;
     &lt;/xs:simpleType&gt;
     &lt;xs:attribute name=&quot;operation&quot; type=&quot;editOperationType&quot;/&gt;
     &lt;!--
        &lt;rpc-reply&gt; element
       --&gt;
     &lt;xs:complexType name=&quot;rpcReplyType&quot;&gt;
       &lt;xs:choice&gt;
         &lt;xs:element name=&quot;ok&quot;/&gt;
         &lt;xs:sequence&gt;
           &lt;xs:element ref=&quot;rpc-error&quot;
                       minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;
           &lt;xs:element ref=&quot;rpcResponse&quot;
                       minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;

         &lt;/xs:sequence&gt;
       &lt;/xs:choice&gt;
       &lt;xs:attribute name=&quot;message-id&quot; type=&quot;messageIdType&quot;
                     use=&quot;optional&quot;/&gt;
       &lt;!--
          Any attributes supplied with &lt;rpc&gt; element must be returned
          on &lt;rpc-reply&gt;.
         --&gt;
       &lt;xs:anyAttribute processContents=&quot;lax&quot;/&gt;
     &lt;/xs:complexType&gt;
     &lt;xs:element name=&quot;rpc-reply&quot; type=&quot;rpcReplyType&quot;/&gt;
     &lt;!--
        &lt;rpc-error&gt; element
          --&gt;
     &lt;xs:element name=&quot;rpc-error&quot; type=&quot;rpcErrorType&quot;/&gt;
     &lt;!--
        rpcOperationType: used as a base type for all
        NETCONF operations
       --&gt;
     &lt;xs:complexType name=&quot;rpcOperationType&quot;/&gt;
     &lt;xs:element name=&quot;rpcOperation&quot; type=&quot;rpcOperationType&quot;
                 abstract=&quot;true&quot;/&gt;
     &lt;!--
        rpcResponseType: used as a base type for all
        NETCONF responses
       --&gt;
     &lt;xs:complexType name=&quot;rpcResponseType&quot;/&gt;
     &lt;xs:element name=&quot;rpcResponse&quot; type=&quot;rpcResponseType&quot;
                 abstract=&quot;true&quot;/&gt;
     &lt;!--
        &lt;hello&gt; element
       --&gt;
     &lt;xs:element name=&quot;hello&quot;&gt;
       &lt;xs:complexType&gt;
         &lt;xs:sequence&gt;
           &lt;xs:element name=&quot;capabilities&quot;&gt;
             &lt;xs:complexType&gt;
               &lt;xs:sequence&gt;
                 &lt;xs:element name=&quot;capability&quot; type=&quot;xs:anyURI&quot;
                             maxOccurs=&quot;unbounded&quot;/&gt;
               &lt;/xs:sequence&gt;
             &lt;/xs:complexType&gt;
           &lt;/xs:element&gt;
           &lt;xs:element name=&quot;session-id&quot; type=&quot;SessionId&quot;
                       minOccurs=&quot;0&quot;/&gt;

         &lt;/xs:sequence&gt;
       &lt;/xs:complexType&gt;
     &lt;/xs:element&gt;
   &lt;/xs:schema&gt;

   &lt;CODE ENDS&gt;

Appendix C.  YANG Module for NETCONF Protocol Operations

   This section is normative.

   The ietf-netconf YANG module imports typedefs from [RFC6021].

  &lt;CODE BEGINS&gt; file &quot;ietf-netconf@2011-06-01.yang&quot;

  module ietf-netconf {

    // the namespace for NETCONF XML definitions is unchanged
    // from RFC 4741, which this document replaces
    namespace &quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;;

    prefix nc;

    import ietf-inet-types {
      prefix inet;
    }

    organization
      &quot;IETF NETCONF (Network Configuration) Working Group&quot;;

    contact
      &quot;WG Web:   &lt;http://tools.ietf.org/wg/netconf/&gt;
       WG List:  &lt;netconf@ietf.org&gt;

       WG Chair: Bert Wijnen
                 &lt;bertietf@bwijnen.net&gt;

       WG Chair: Mehmet Ersue
                 &lt;mehmet.ersue@nsn.com&gt;

       Editor:   Martin Bjorklund
                 &lt;mbj@tail-f.com&gt;

       Editor:   Juergen Schoenwaelder
                 &lt;j.schoenwaelder@jacobs-university.de&gt;

       Editor:   Andy Bierman
                 &lt;andy.bierman@brocade.com&gt;&quot;;

    description
      &quot;NETCONF Protocol Data Types and Protocol Operations.

       Copyright (c) 2011 IETF Trust and the persons identified as
       the document authors.  All rights reserved.

       Redistribution and use in source and binary forms, with or
       without modification, is permitted pursuant to, and subject
       to the license terms contained in, the Simplified BSD License
       set forth in Section 4.c of the IETF Trust&#x27;s Legal Provisions
       Relating to IETF Documents
       (http://trustee.ietf.org/license-info).

       This version of this YANG module is part of RFC 6241; see
       the RFC itself for full legal notices.&quot;;
    revision 2011-06-01 {
      description
        &quot;Initial revision&quot;;
      reference
        &quot;RFC 6241: Network Configuration Protocol&quot;;
    }

    extension get-filter-element-attributes {
      description
        &quot;If this extension is present within an &#x27;anyxml&#x27;
         statement named &#x27;filter&#x27;, which must be conceptually
         defined within the RPC input section for the &lt;get&gt;
         and &lt;get-config&gt; protocol operations, then the
         following unqualified XML attribute is supported
         within the &lt;filter&gt; element, within a &lt;get&gt; or
         &lt;get-config&gt; protocol operation:

           type : optional attribute with allowed
                  value strings &#x27;subtree&#x27; and &#x27;xpath&#x27;.
                  If missing, the default value is &#x27;subtree&#x27;.

         If the &#x27;xpath&#x27; feature is supported, then the
         following unqualified XML attribute is
         also supported:

           select: optional attribute containing a
                   string representing an XPath expression.
                   The &#x27;type&#x27; attribute must be equal to &#x27;xpath&#x27;
                   if this attribute is present.&quot;;
    }

    // NETCONF capabilities defined as features
    feature writable-running {

      description
        &quot;NETCONF :writable-running capability;
         If the server advertises the :writable-running
         capability for a session, then this feature must
         also be enabled for that session.  Otherwise,
         this feature must not be enabled.&quot;;
      reference &quot;RFC 6241, Section 8.2&quot;;
    }

    feature candidate {
      description
        &quot;NETCONF :candidate capability;
         If the server advertises the :candidate
         capability for a session, then this feature must
         also be enabled for that session.  Otherwise,
         this feature must not be enabled.&quot;;
      reference &quot;RFC 6241, Section 8.3&quot;;
    }

    feature confirmed-commit {
      if-feature candidate;
      description
        &quot;NETCONF :confirmed-commit:1.1 capability;
         If the server advertises the :confirmed-commit:1.1
         capability for a session, then this feature must
         also be enabled for that session.  Otherwise,
         this feature must not be enabled.&quot;;

      reference &quot;RFC 6241, Section 8.4&quot;;
    }

    feature rollback-on-error {
      description
        &quot;NETCONF :rollback-on-error capability;
         If the server advertises the :rollback-on-error
         capability for a session, then this feature must
         also be enabled for that session.  Otherwise,
         this feature must not be enabled.&quot;;
      reference &quot;RFC 6241, Section 8.5&quot;;
    }

    feature validate {
      description
        &quot;NETCONF :validate:1.1 capability;
         If the server advertises the :validate:1.1
         capability for a session, then this feature must
         also be enabled for that session.  Otherwise,
         this feature must not be enabled.&quot;;

      reference &quot;RFC 6241, Section 8.6&quot;;
    }

    feature startup {
      description
        &quot;NETCONF :startup capability;
         If the server advertises the :startup
         capability for a session, then this feature must
         also be enabled for that session.  Otherwise,
         this feature must not be enabled.&quot;;
      reference &quot;RFC 6241, Section 8.7&quot;;
    }

    feature url {
      description
        &quot;NETCONF :url capability;
         If the server advertises the :url
         capability for a session, then this feature must
         also be enabled for that session.  Otherwise,
         this feature must not be enabled.&quot;;
      reference &quot;RFC 6241, Section 8.8&quot;;
    }

    feature xpath {
      description
        &quot;NETCONF :xpath capability;
         If the server advertises the :xpath
         capability for a session, then this feature must
         also be enabled for that session.  Otherwise,
         this feature must not be enabled.&quot;;
      reference &quot;RFC 6241, Section 8.9&quot;;
    }

    // NETCONF Simple Types

    typedef session-id-type {
      type uint32 {
        range &quot;1..max&quot;;
      }
      description
        &quot;NETCONF Session Id&quot;;
    }

    typedef session-id-or-zero-type {
      type uint32;
      description
        &quot;NETCONF Session Id or Zero to indicate none&quot;;
    }

    typedef error-tag-type {
      type enumeration {
         enum in-use {
           description
             &quot;The request requires a resource that
              already is in use.&quot;;
         }
         enum invalid-value {
           description
             &quot;The request specifies an unacceptable value for one
              or more parameters.&quot;;
         }
         enum too-big {
           description
             &quot;The request or response (that would be generated) is
              too large for the implementation to handle.&quot;;
         }
         enum missing-attribute {
           description
             &quot;An expected attribute is missing.&quot;;
         }
         enum bad-attribute {
           description
             &quot;An attribute value is not correct; e.g., wrong type,
              out of range, pattern mismatch.&quot;;
         }
         enum unknown-attribute {
           description
             &quot;An unexpected attribute is present.&quot;;
         }
         enum missing-element {
           description
             &quot;An expected element is missing.&quot;;
         }
         enum bad-element {
           description
             &quot;An element value is not correct; e.g., wrong type,
              out of range, pattern mismatch.&quot;;
         }
         enum unknown-element {
           description
             &quot;An unexpected element is present.&quot;;
         }
         enum unknown-namespace {
           description
             &quot;An unexpected namespace is present.&quot;;
         }
         enum access-denied {

           description
             &quot;Access to the requested protocol operation or
              data model is denied because authorization failed.&quot;;
         }
         enum lock-denied {
           description
             &quot;Access to the requested lock is denied because the
              lock is currently held by another entity.&quot;;
         }
         enum resource-denied {
           description
             &quot;Request could not be completed because of
              insufficient resources.&quot;;
         }
         enum rollback-failed {
           description
             &quot;Request to roll back some configuration change (via
              rollback-on-error or &lt;discard-changes&gt; operations)
              was not completed for some reason.&quot;;

         }
         enum data-exists {
           description
             &quot;Request could not be completed because the relevant
              data model content already exists.  For example,
              a &#x27;create&#x27; operation was attempted on data that
              already exists.&quot;;
         }
         enum data-missing {
           description
             &quot;Request could not be completed because the relevant
              data model content does not exist.  For example,
              a &#x27;delete&#x27; operation was attempted on
              data that does not exist.&quot;;
         }
         enum operation-not-supported {
           description
             &quot;Request could not be completed because the requested
              operation is not supported by this implementation.&quot;;
         }
         enum operation-failed {
           description
             &quot;Request could not be completed because the requested
              operation failed for some reason not covered by
              any other error condition.&quot;;
         }
         enum partial-operation {
           description

             &quot;This error-tag is obsolete, and SHOULD NOT be sent
              by servers conforming to this document.&quot;;
         }
         enum malformed-message {
           description
             &quot;A message could not be handled because it failed to
              be parsed correctly.  For example, the message is not
              well-formed XML or it uses an invalid character set.&quot;;
         }
       }
       description &quot;NETCONF Error Tag&quot;;
       reference &quot;RFC 6241, Appendix A&quot;;
    }

    typedef error-severity-type {
      type enumeration {
        enum error {
          description &quot;Error severity&quot;;
        }
        enum warning {
          description &quot;Warning severity&quot;;
        }
      }
      description &quot;NETCONF Error Severity&quot;;
      reference &quot;RFC 6241, Section 4.3&quot;;
    }

    typedef edit-operation-type {
      type enumeration {
        enum merge {
          description
            &quot;The configuration data identified by the
             element containing this attribute is merged
             with the configuration at the corresponding
             level in the configuration datastore identified
             by the target parameter.&quot;;
        }
        enum replace {
          description
            &quot;The configuration data identified by the element
             containing this attribute replaces any related
             configuration in the configuration datastore
             identified by the target parameter.  If no such
             configuration data exists in the configuration
             datastore, it is created.  Unlike a
             &lt;copy-config&gt; operation, which replaces the
             entire target configuration, only the configuration
             actually present in the config parameter is affected.&quot;;

        }
        enum create {
          description
            &quot;The configuration data identified by the element
             containing this attribute is added to the
             configuration if and only if the configuration
             data does not already exist in the configuration
             datastore.  If the configuration data exists, an
             &lt;rpc-error&gt; element is returned with an
             &lt;error-tag&gt; value of &#x27;data-exists&#x27;.&quot;;
        }
        enum delete {
          description
            &quot;The configuration data identified by the element
             containing this attribute is deleted from the
             configuration if and only if the configuration
             data currently exists in the configuration
             datastore.  If the configuration data does not
             exist, an &lt;rpc-error&gt; element is returned with
             an &lt;error-tag&gt; value of &#x27;data-missing&#x27;.&quot;;
        }
        enum remove {
          description
            &quot;The configuration data identified by the element
             containing this attribute is deleted from the
             configuration if the configuration
             data currently exists in the configuration
             datastore.  If the configuration data does not
             exist, the &#x27;remove&#x27; operation is silently ignored
             by the server.&quot;;
        }
      }
      default &quot;merge&quot;;
      description &quot;NETCONF &#x27;operation&#x27; attribute values&quot;;
      reference &quot;RFC 6241, Section 7.2&quot;;
    }

    // NETCONF Standard Protocol Operations

    rpc get-config {
      description
        &quot;Retrieve all or part of a specified configuration.&quot;;

      reference &quot;RFC 6241, Section 7.1&quot;;

      input {
        container source {
          description

            &quot;Particular configuration to retrieve.&quot;;

          choice config-source {
            mandatory true;
            description
              &quot;The configuration to retrieve.&quot;;
            leaf candidate {
              if-feature candidate;
              type empty;
              description
                &quot;The candidate configuration is the config source.&quot;;
            }
            leaf running {
              type empty;
              description
                &quot;The running configuration is the config source.&quot;;
            }
            leaf startup {
              if-feature startup;
              type empty;
              description
                &quot;The startup configuration is the config source.
                 This is optional-to-implement on the server because
                 not all servers will support filtering for this
                 datastore.&quot;;
            }
          }
        }

        anyxml filter {
          description
            &quot;Subtree or XPath filter to use.&quot;;
          nc:get-filter-element-attributes;
        }
      }

      output {
        anyxml data {
          description
            &quot;Copy of the source datastore subset that matched
             the filter criteria (if any).  An empty data container
             indicates that the request did not produce any results.&quot;;
        }
      }
    }

    rpc edit-config {
      description

        &quot;The &lt;edit-config&gt; operation loads all or part of a specified
         configuration to the specified target configuration.&quot;;

      reference &quot;RFC 6241, Section 7.2&quot;;

      input {
        container target {
          description
            &quot;Particular configuration to edit.&quot;;

          choice config-target {
            mandatory true;
            description
              &quot;The configuration target.&quot;;

            leaf candidate {
              if-feature candidate;
              type empty;
              description
                &quot;The candidate configuration is the config target.&quot;;
            }
            leaf running {
              if-feature writable-running;
              type empty;
              description
                &quot;The running configuration is the config source.&quot;;
            }
          }
        }

        leaf default-operation {
          type enumeration {
            enum merge {
              description
                &quot;The default operation is merge.&quot;;
            }
            enum replace {
              description
                &quot;The default operation is replace.&quot;;
            }
            enum none {
              description
                &quot;There is no default operation.&quot;;
            }
          }
          default &quot;merge&quot;;
          description
            &quot;The default operation to use.&quot;;

        }

        leaf test-option {
          if-feature validate;
          type enumeration {
            enum test-then-set {
              description
                &quot;The server will test and then set if no errors.&quot;;
            }
            enum set {
              description
                &quot;The server will set without a test first.&quot;;
            }

            enum test-only {
              description
                &quot;The server will only test and not set, even
                 if there are no errors.&quot;;
            }
          }
          default &quot;test-then-set&quot;;
          description
            &quot;The test option to use.&quot;;
        }

        leaf error-option {
          type enumeration {
            enum stop-on-error {
              description
                &quot;The server will stop on errors.&quot;;
            }
            enum continue-on-error {
              description
                &quot;The server may continue on errors.&quot;;
            }
            enum rollback-on-error {
              description
                &quot;The server will roll back on errors.
                 This value can only be used if the &#x27;rollback-on-error&#x27;
                 feature is supported.&quot;;
            }
          }
          default &quot;stop-on-error&quot;;
          description
            &quot;The error option to use.&quot;;
        }

        choice edit-content {

          mandatory true;
          description
            &quot;The content for the edit operation.&quot;;

          anyxml config {
            description
              &quot;Inline Config content.&quot;;
          }
          leaf url {
            if-feature url;
            type inet:uri;
            description
              &quot;URL-based config content.&quot;;
          }
        }
      }
    }

    rpc copy-config {
      description
        &quot;Create or replace an entire configuration datastore with the
         contents of another complete configuration datastore.&quot;;

      reference &quot;RFC 6241, Section 7.3&quot;;

      input {
        container target {
          description
            &quot;Particular configuration to copy to.&quot;;

          choice config-target {
            mandatory true;
            description
              &quot;The configuration target of the copy operation.&quot;;

            leaf candidate {
              if-feature candidate;
              type empty;
              description
                &quot;The candidate configuration is the config target.&quot;;
            }
            leaf running {
              if-feature writable-running;
              type empty;
              description
                &quot;The running configuration is the config target.
                 This is optional-to-implement on the server.&quot;;
            }

            leaf startup {
              if-feature startup;
              type empty;
              description
                &quot;The startup configuration is the config target.&quot;;
            }
            leaf url {
              if-feature url;
              type inet:uri;
              description
                &quot;The URL-based configuration is the config target.&quot;;
            }
          }
        }

        container source {
          description
            &quot;Particular configuration to copy from.&quot;;

          choice config-source {
            mandatory true;
            description
              &quot;The configuration source for the copy operation.&quot;;

            leaf candidate {
              if-feature candidate;
              type empty;
              description
                &quot;The candidate configuration is the config source.&quot;;
            }
            leaf running {
              type empty;
              description
                &quot;The running configuration is the config source.&quot;;
            }
            leaf startup {
              if-feature startup;
              type empty;
              description
                &quot;The startup configuration is the config source.&quot;;
            }
            leaf url {
              if-feature url;
              type inet:uri;
              description
                &quot;The URL-based configuration is the config source.&quot;;
            }
            anyxml config {

              description
                &quot;Inline Config content: &lt;config&gt; element.  Represents
                 an entire configuration datastore, not
                 a subset of the running datastore.&quot;;
            }
          }
        }
      }
    }

    rpc delete-config {
      description
        &quot;Delete a configuration datastore.&quot;;

      reference &quot;RFC 6241, Section 7.4&quot;;

      input {
        container target {
          description
            &quot;Particular configuration to delete.&quot;;

          choice config-target {
            mandatory true;
            description
              &quot;The configuration target to delete.&quot;;

            leaf startup {
              if-feature startup;
              type empty;
              description
                &quot;The startup configuration is the config target.&quot;;
            }
            leaf url {
              if-feature url;
              type inet:uri;
              description
                &quot;The URL-based configuration is the config target.&quot;;
            }
          }
        }
      }
    }

    rpc lock {
      description
        &quot;The lock operation allows the client to lock the configuration
         system of a device.&quot;;

      reference &quot;RFC 6241, Section 7.5&quot;;

      input {
        container target {
          description
            &quot;Particular configuration to lock.&quot;;

          choice config-target {
            mandatory true;
            description
              &quot;The configuration target to lock.&quot;;

            leaf candidate {
              if-feature candidate;
              type empty;
              description
                &quot;The candidate configuration is the config target.&quot;;
            }
            leaf running {
              type empty;
              description
                &quot;The running configuration is the config target.&quot;;
            }
            leaf startup {
              if-feature startup;
              type empty;
              description
                &quot;The startup configuration is the config target.&quot;;
            }
          }
        }
      }
    }

    rpc unlock {
      description
        &quot;The unlock operation is used to release a configuration lock,
         previously obtained with the &#x27;lock&#x27; operation.&quot;;

      reference &quot;RFC 6241, Section 7.6&quot;;

      input {
        container target {
          description
            &quot;Particular configuration to unlock.&quot;;

          choice config-target {
            mandatory true;

            description
              &quot;The configuration target to unlock.&quot;;

            leaf candidate {
              if-feature candidate;
              type empty;
              description
                &quot;The candidate configuration is the config target.&quot;;
            }
            leaf running {
              type empty;
              description
                &quot;The running configuration is the config target.&quot;;
            }
            leaf startup {
              if-feature startup;
              type empty;
              description
                &quot;The startup configuration is the config target.&quot;;
            }
          }
        }
      }
    }

    rpc get {
      description
        &quot;Retrieve running configuration and device state information.&quot;;

      reference &quot;RFC 6241, Section 7.7&quot;;

      input {
        anyxml filter {
          description
            &quot;This parameter specifies the portion of the system
             configuration and state data to retrieve.&quot;;
          nc:get-filter-element-attributes;
        }
      }

      output {
        anyxml data {
          description
            &quot;Copy of the running datastore subset and/or state
             data that matched the filter criteria (if any).
             An empty data container indicates that the request did not
             produce any results.&quot;;
        }

      }
    }

    rpc close-session {
      description
        &quot;Request graceful termination of a NETCONF session.&quot;;

      reference &quot;RFC 6241, Section 7.8&quot;;
    }

    rpc kill-session {
      description
        &quot;Force the termination of a NETCONF session.&quot;;

      reference &quot;RFC 6241, Section 7.9&quot;;

      input {
        leaf session-id {
          type session-id-type;
          mandatory true;
          description
            &quot;Particular session to kill.&quot;;
        }
      }
    }

    rpc commit {
      if-feature candidate;

      description
        &quot;Commit the candidate configuration as the device&#x27;s new
         current configuration.&quot;;

      reference &quot;RFC 6241, Section 8.3.4.1&quot;;

      input {
        leaf confirmed {
          if-feature confirmed-commit;
          type empty;
          description
            &quot;Requests a confirmed commit.&quot;;
          reference &quot;RFC 6241, Section 8.3.4.1&quot;;
        }

        leaf confirm-timeout {
          if-feature confirmed-commit;
          type uint32 {
            range &quot;1..max&quot;;

          }
          units &quot;seconds&quot;;
          default &quot;600&quot;;   // 10 minutes
          description
            &quot;The timeout interval for a confirmed commit.&quot;;
          reference &quot;RFC 6241, Section 8.3.4.1&quot;;
        }

        leaf persist {
          if-feature confirmed-commit;
          type string;
          description
            &quot;This parameter is used to make a confirmed commit
             persistent.  A persistent confirmed commit is not aborted
             if the NETCONF session terminates.  The only way to abort
             a persistent confirmed commit is to let the timer expire,
             or to use the &lt;cancel-commit&gt; operation.

             The value of this parameter is a token that must be given
             in the &#x27;persist-id&#x27; parameter of &lt;commit&gt; or
             &lt;cancel-commit&gt; operations in order to confirm or cancel
             the persistent confirmed commit.

             The token should be a random string.&quot;;
          reference &quot;RFC 6241, Section 8.3.4.1&quot;;
        }

        leaf persist-id {
          if-feature confirmed-commit;
          type string;
          description
            &quot;This parameter is given in order to commit a persistent
             confirmed commit.  The value must be equal to the value
             given in the &#x27;persist&#x27; parameter to the &lt;commit&gt; operation.
             If it does not match, the operation fails with an
            &#x27;invalid-value&#x27; error.&quot;;
          reference &quot;RFC 6241, Section 8.3.4.1&quot;;
        }

      }
    }

    rpc discard-changes {
      if-feature candidate;

      description
        &quot;Revert the candidate configuration to the current
         running configuration.&quot;;

      reference &quot;RFC 6241, Section 8.3.4.2&quot;;
    }

    rpc cancel-commit {
      if-feature confirmed-commit;
      description
        &quot;This operation is used to cancel an ongoing confirmed commit.
         If the confirmed commit is persistent, the parameter
         &#x27;persist-id&#x27; must be given, and it must match the value of the
         &#x27;persist&#x27; parameter.&quot;;
      reference &quot;RFC 6241, Section 8.4.4.1&quot;;

      input {
        leaf persist-id {
          type string;
          description
            &quot;This parameter is given in order to cancel a persistent
             confirmed commit.  The value must be equal to the value
             given in the &#x27;persist&#x27; parameter to the &lt;commit&gt; operation.
             If it does not match, the operation fails with an
            &#x27;invalid-value&#x27; error.&quot;;
        }
      }
    }

    rpc validate {
      if-feature validate;

      description
        &quot;Validates the contents of the specified configuration.&quot;;

      reference &quot;RFC 6241, Section 8.6.4.1&quot;;

      input {
        container source {
          description
            &quot;Particular configuration to validate.&quot;;

          choice config-source {
            mandatory true;
            description
              &quot;The configuration source to validate.&quot;;

            leaf candidate {
              if-feature candidate;
              type empty;
              description
                &quot;The candidate configuration is the config source.&quot;;

            }
            leaf running {
              type empty;
              description
                &quot;The running configuration is the config source.&quot;;
            }
            leaf startup {
              if-feature startup;
              type empty;
              description
                &quot;The startup configuration is the config source.&quot;;
            }
            leaf url {
              if-feature url;
              type inet:uri;
              description
                &quot;The URL-based configuration is the config source.&quot;;
            }
            anyxml config {
              description
                &quot;Inline Config content: &lt;config&gt; element.  Represents
                 an entire configuration datastore, not
                 a subset of the running datastore.&quot;;
            }
          }
        }
      }
    }

  }

  &lt;CODE ENDS&gt;

Appendix D.  Capability Template

   This non-normative section defines a template that can be used to
   define protocol capabilities.  Data models written in YANG usually do
   not need to define protocol capabilities since the usage of YANG
   automatically leads to a capability announcing the data model and any
   optional portions of the data model, so called features in YANG
   terminology.  The capabilities template is intended to be used in
   cases where the YANG mechanisms are not powerful enough (e.g., for
   handling parameterized features) or a different data modeling
   language is used.

D.1.  capability-name (template)

D.1.1.  Overview

D.1.2.  Dependencies

D.1.3.  Capability Identifier

   The {name} capability is identified by the following capability
   string:

      {capability uri}

D.1.4.  New Operations

D.1.4.1.  &lt;op-name&gt;

D.1.5.  Modifications to Existing Operations

D.1.5.1.  &lt;op-name&gt;

   If existing operations are not modified by this capability, this
   section may be omitted.

D.1.6.  Interactions with Other Capabilities

   If this capability does not interact with other capabilities, this
   section may be omitted.

Appendix E.  Configuring Multiple Devices with NETCONF

   This section is non-normative.

E.1.  Operations on Individual Devices

   Consider the work involved in performing a configuration update
   against a single individual device.  In making a change to the
   configuration, the application needs to build trust that its change
   has been made correctly and that it has not impacted the operation of
   the device.  The application (and the application user) should feel
   confident that their change has not damaged the network.

   Protecting each individual device consists of a number of steps:

   o  Acquiring the configuration lock.

   o  Checkpointing the running configuration.

   o  Loading and validating the incoming configuration.

   o  Changing the running configuration.

   o  Testing the new configuration.

   o  Making the change permanent (if desired).

   o  Releasing the configuration lock.

   Let&#x27;s look at the details of each step.

E.1.1.  Acquiring the Configuration Lock

   A lock should be acquired to prevent simultaneous updates from
   multiple sources.  If multiple sources are affecting the device, the
   application is hampered in both testing of its change to the
   configuration and in recovery if the update fails.  Acquiring a
   short-lived lock is a simple defense to prevent other parties from
   introducing unrelated changes.

   The lock can be acquired using the &lt;lock&gt; operation.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;lock&gt;
         &lt;target&gt;
           &lt;running/&gt;
         &lt;/target&gt;
       &lt;/lock&gt;
     &lt;/rpc&gt;

   If the :candidate capability is supported, the candidate
   configuration should be locked.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;lock&gt;
         &lt;target&gt;
           &lt;candidate/&gt;
         &lt;/target&gt;
       &lt;/lock&gt;
     &lt;/rpc&gt;

E.1.2.  Checkpointing the Running Configuration

   The running configuration can be saved into a local file as a
   checkpoint before loading the new configuration.  If the update
   fails, the configuration can be restored by reloading the checkpoint
   file.

   The checkpoint file can be created using the &lt;copy-config&gt; operation.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;copy-config&gt;
         &lt;target&gt;
           &lt;url&gt;file://checkpoint.conf&lt;/url&gt;
         &lt;/target&gt;
         &lt;source&gt;
           &lt;running/&gt;
         &lt;/source&gt;
       &lt;/copy-config&gt;
     &lt;/rpc&gt;

   To restore the checkpoint file, reverse the &lt;source&gt; and &lt;target&gt;
   parameters.

E.1.3.  Loading and Validating the Incoming Configuration

   If the :candidate capability is supported, the configuration can be
   loaded onto the device without impacting the running system.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;edit-config&gt;
         &lt;target&gt;
           &lt;candidate/&gt;
         &lt;/target&gt;
         &lt;config&gt;
           &lt;!-- place incoming configuration changes here --&gt;
         &lt;/config&gt;
       &lt;/edit-config&gt;
     &lt;/rpc&gt;

   If the device supports the :validate:1.1 capability, it will by
   default validate the incoming configuration when it is loaded into
   the candidate.  To avoid this validation, pass the &lt;test-option&gt;
   parameter with the value &quot;set&quot;.  Full validation can be requested
   with the &lt;validate&gt; operation.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;validate&gt;
         &lt;source&gt;
           &lt;candidate/&gt;
         &lt;/source&gt;
       &lt;/validate&gt;
     &lt;/rpc&gt;

E.1.4.  Changing the Running Configuration

   When the incoming configuration has been safely loaded onto the
   device and validated, it is ready to impact the running system.

   If the device supports the :candidate capability, use the &lt;commit&gt;
   operation to set the running configuration to the candidate
   configuration.  Use the &lt;confirmed&gt; parameter to allow automatic
   reversion to the original configuration if connectivity to the device
   fails.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;commit&gt;
         &lt;confirmed/&gt;
         &lt;confirm-timeout&gt;120&lt;/confirm-timeout&gt;
       &lt;/commit&gt;
     &lt;/rpc&gt;

   If the candidate is not supported by the device, the incoming
   configuration change is loaded directly into running.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;edit-config&gt;
         &lt;target&gt;
           &lt;running/&gt;
         &lt;/target&gt;
         &lt;config&gt;
           &lt;!-- place incoming configuration changes here --&gt;
         &lt;/config&gt;
       &lt;/edit-config&gt;
     &lt;/rpc&gt;

E.1.5.  Testing the New Configuration

   Now that the incoming configuration has been integrated into the
   running configuration, the application needs to gain trust that the
   change has affected the device in the way intended without affecting
   it negatively.

   To gain this confidence, the application can run tests of the
   operational state of the device.  The nature of the test is dependent
   on the nature of the change and is outside the scope of this
   document.  Such tests may include reachability from the system
   running the application (using ping), changes in reachability to the
   rest of the network (by comparing the device&#x27;s routing table), or
   inspection of the particular change (looking for operational evidence
   of the BGP peer that was just added).

E.1.6.  Making the Change Permanent

   When the configuration change is in place and the application has
   sufficient faith in the proper function of this change, the
   application is expected to make the change permanent.

   If the device supports the :startup capability, the current
   configuration can be saved to the startup configuration by using the
   startup configuration as the target of the &lt;copy-config&gt; operation.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;copy-config&gt;
         &lt;target&gt;
           &lt;startup/&gt;
         &lt;/target&gt;
         &lt;source&gt;
           &lt;running/&gt;
         &lt;/source&gt;
       &lt;/copy-config&gt;
     &lt;/rpc&gt;

   If the device supports the :candidate capability and a confirmed
   commit was requested, the confirming commit must be sent before the
   timeout expires.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;commit/&gt;
     &lt;/rpc&gt;

E.1.7.  Releasing the Configuration Lock

   When the configuration update is complete, the lock must be released,
   allowing other applications access to the configuration.

   Use the &lt;unlock&gt; operation to release the configuration lock.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;unlock&gt;
         &lt;target&gt;
           &lt;running/&gt;
         &lt;/target&gt;
       &lt;/unlock&gt;
     &lt;/rpc&gt;

   If the :candidate capability is supported, the candidate
   configuration should be unlocked.

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;unlock&gt;
         &lt;target&gt;
           &lt;candidate/&gt;
         &lt;/target&gt;
       &lt;/unlock&gt;
     &lt;/rpc&gt;

E.2.  Operations on Multiple Devices

   When a configuration change requires updates across a number of
   devices, care needs to be taken to provide the required transaction
   semantics.  The NETCONF protocol contains sufficient primitives upon
   which transaction-oriented operations can be built.  Providing
   complete transactional semantics across multiple devices is
   prohibitively expensive, but the size and number of windows for
   failure scenarios can be reduced.

   There are two classes of multi-device operations.  The first class
   allows the operation to fail on individual devices without requiring
   all devices to revert to their original state.  The operation can be
   retried at a later time, or its failure simply reported to the user.
   An example of this class might be adding an NTP server.  For this
   class of operations, failure avoidance and recovery are focused on
   the individual device.  This means recovery of the device, reporting
   the failure, and perhaps scheduling another attempt.

   The second class is more interesting, requiring that the operation
   should complete on all devices or be fully reversed.  The network
   should either be transformed into a new state or be reset to its
   original state.  For example, a change to a VPN may require updates
   to a number of devices.  Another example of this might be adding a
   class-of-service definition.  Leaving the network in a state where
   only a portion of the devices have been updated with the new
   definition will lead to future failures when the definition is
   referenced.

   To give transactional semantics, the same steps used in single-device
   operations listed above are used, but are performed in parallel
   across all devices.  Configuration locks should be acquired on all
   target devices and kept until all devices are updated and the changes
   made permanent.  Configuration changes should be uploaded and
   validation performed across all devices.  Checkpoints should be made
   on each device.  Then the running configuration can be changed,
   tested, and made permanent.  If any of these steps fail, the previous
   configurations can be restored on any devices upon which they were
   changed.  After the changes have been completely implemented or
   completely discarded, the locks on each device can be released.

Appendix F.  Changes from RFC 4741

   This section lists major changes between this document and RFC 4741.

   o  Added the &quot;malformed-message&quot; error-tag.

   o  Added &quot;remove&quot; enumeration value to the &quot;operation&quot; attribute.

   o  Obsoleted the &quot;partial-operation&quot; error-tag enumeration value.

   o  Added &lt;persist&gt; and &lt;persist-id&gt; parameters to the &lt;commit&gt;
      operation.

   o  Updated the base protocol URI and clarified the &lt;hello&gt; message
      exchange to select and identify the base protocol version in use
      for a particular session.

   o  Added a YANG module to model the operations and removed the
      operation layer from the XSD.

   o  Clarified lock behavior for the candidate datastore.

   o  Clarified the error response server requirements for the &quot;delete&quot;
      enumeration value of the &quot;operation&quot; attribute.

   o  Added a namespace wildcarding mechanism for subtree filtering.

   o  Added a &quot;test-only&quot; value for the &lt;test-option&gt; parameter to the
      &lt;edit-config&gt; operation.

   o  Added a &lt;cancel-commit&gt; operation.

   o  Introduced a NETCONF username and a requirement for transport
      protocols to explain how a username is derived.

Authors&#x27; Addresses

   Rob Enns (editor)
   Juniper Networks

   EMail: rob.enns@gmail.com


   Martin Bjorklund (editor)
   Tail-f Systems

   EMail: mbj@tail-f.com


   Juergen Schoenwaelder (editor)
   Jacobs University

   EMail: j.schoenwaelder@jacobs-university.de


   Andy Bierman (editor)
   Brocade

   EMail: andy.bierman@brocade.com


        </re>
        <div class='Verified-endnote-styling' id='eid3980'>
<pre>
<b><i><a href='https://www.rfc-editor.org/errata/eid3980'>EID 3980</a> (Verified) is as follows:</i></b>

<b>Section:</b> 99Sections 6.2.5 and 6.3

<b>Original Text:</b>

In section 6.3:

OLD:
   The
   algorithm continues until all sibling sets in all subtrees specified
   in the filter have been processed.

In section 6.2.5

OLD:
  o  If any sibling nodes of the selection node are instance identifier
      components for a conceptual data structure (e.g., list key leaf),
      then they MAY also be included in the filter output.

<b>Corrected Text:</b>

In section 6.3:

NEW:

   The 
   algorithm continues until all sibling sets in all subtrees specified
   in the filter have been processed. If any sibling nodes of a node
   are instance identifier components for a conceptual data structure
   (e.g., list key leaf), then they MAY also be included in the filter 
   output.

In section 6.2.5

NEW:
</pre>
<b>Notes:</b><br/>
The intent is to allow the server to always include the key node values and the wording accidentally does not cover this case.<br/><br/>Here is the OLD/NEW in a more intuitive way:<br/>In section 6.3:<br/><br/>OLD:<br/><br/>  The algorithm continues until all sibling sets in all subtrees specified<br/>   in the filter have been processed.<br/>NEW:<br/><br/>   The algorithm continues until all sibling sets in all subtrees specified<br/>   in the filter have been processed. If any sibling nodes of a node<br/>   are instance identifier components for a conceptual data structure<br/>   (e.g., list key leaf), then they MAY also be included in the filter output.<br/><br/>Implicitly in section 6.2.5 to delete the moved text:<br/><br/>OLD:<br/><br/>   If any sibling nodes of the selection node are instance identifier<br/>   components for a conceptual data structure (e.g., list key leaf),<br/>   then they MAY also be included in the filter output.<br/><br/>NEW:<br/>   &lt;void&gt;<br/>
<br/>
</div>
<div class='Verified-endnote-styling' id='eid5790'>
<pre>
<b><i><a href='https://www.rfc-editor.org/errata/eid5790'>EID 5790</a> (Verified) is as follows:</i></b>

<b>Section:</b> 99In Sections 7.8, 7.9, and 8.4.1

<b>Original Text:</b>

OLD:

7.8.  &lt;close-session&gt;

   Description:  Request graceful termination of a NETCONF session.

      When a NETCONF server receives a &lt;close-session&gt; request, it will
      gracefully close the session.  The server will release any locks
      and resources associated with the session and gracefully close
      any associated connections.  Any NETCONF requests received after
      a &lt;close-session&gt; request will be ignored.

   Positive Response:  If the device was able to satisfy the request, an
      &lt;rpc-reply&gt; is sent that includes an &lt;ok&gt; element.

   Negative Response:  An &lt;rpc-error&gt; element is included in the
      &lt;rpc-reply&gt; if the request cannot be completed for any reason.

   Example:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;close-session/&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

NEW

7.8.  &lt;close-session&gt;

   Description:  Request graceful termination of a NETCONF session.

      When a NETCONF server receives a &lt;close-session&gt; request, it will
      gracefully close the session.  The server will release any locks
      and resources associated with the session and gracefully close any
      associated connections.  Any NETCONF requests received after a
      &lt;close-session&gt; request will be ignored.

      For details on what happens if a NETCONF server receives a 
      &lt;close-session&gt; request while processing a confirmed commit,
      please refer to Section 8.4.

   Positive Response:  If the device was able to satisfy the request, an
      &lt;rpc-reply&gt; is sent that includes an &lt;ok&gt; element.

   Negative Response:  An &lt;rpc-error&gt; element is included in the
      &lt;rpc-reply&gt; if the request cannot be completed for any reason.

   Example:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;close-session/&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

OLD

7.9.  &lt;kill-session&gt;

   Description:  Force the termination of a NETCONF session.

      When a NETCONF entity receives a &lt;kill-session&gt; request for an
      open session, it will abort any operations currently in process,
      release any locks and resources associated with the session, and
      close any associated connections.

      If a NETCONF server receives a &lt;kill-session&gt; request while
      processing a confirmed commit (Section 8.4), it MUST restore the
      configuration to its state before the confirmed commit was issued.

      Otherwise, the &lt;kill-session&gt; operation does not roll back
      configuration or other device state modifications made by the
      entity holding the lock.

   Parameters:

      session-id:  Session identifier of the NETCONF session to be
         terminated.  If this value is equal to the current session ID,
         an &quot;invalid-value&quot; error is returned.

   Positive Response:  If the device was able to satisfy the request, an
      &lt;rpc-reply&gt; is sent that includes an &lt;ok&gt; element.

   Negative Response:  An &lt;rpc-error&gt; element is included in the
      &lt;rpc-reply&gt; if the request cannot be completed for any reason.


   Example:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;kill-session&gt;
         &lt;session-id&gt;4&lt;/session-id&gt;
       &lt;/kill-session&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;

NEW

7.9.  &lt;kill-session&gt;

   Description:  Force the termination of a NETCONF session.

      When a NETCONF entity receives a &lt;kill-session&gt; request for an
      open session, it will abort any operations currently in process,
      release any locks and resources associated with the session, and
      close any associated connections.

      For details on what happens if a NETCONF server receives a 
      &lt;kill-session&gt; request while processing a confirmed commit,
      please refer to Section 8.4.

      Otherwise, the &lt;kill-session&gt; operation does not roll back
      configuration or other device state modifications made by the
      entity holding the lock.

   Parameters:

      session-id:  Session identifier of the NETCONF session to be
         terminated.  If this value is equal to the current session ID,
         an &quot;invalid-value&quot; error is returned.

   Positive Response:  If the device was able to satisfy the request, an
      &lt;rpc-reply&gt; is sent that includes an &lt;ok&gt; element.

   Negative Response:  An &lt;rpc-error&gt; element is included in the
      &lt;rpc-reply&gt; if the request cannot be completed for any reason.


   Example:

     &lt;rpc message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;kill-session&gt;
         &lt;session-id&gt;4&lt;/session-id&gt;
       &lt;/kill-session&gt;
     &lt;/rpc&gt;

     &lt;rpc-reply message-id=&quot;101&quot;
          xmlns=&quot;urn:ietf:params:xml:ns:netconf:base:1.0&quot;&gt;
       &lt;ok/&gt;
     &lt;/rpc-reply&gt;


Section 8.4.1

OLD:

   If the device reboots for any reason before the confirm timeout
   expires, the server MUST restore the configuration to its state
   before the confirmed commit was issued.

NEW:

   If the device reboots for any reason before the confirm timeout
   expires, the server MUST restore the configuration to its state
   before the confirmed commit was issued, unless the confirmed commit 
   also included a &lt;persist&gt; element, in which case the server MAY
   continue the confirmed commit procedure.

<b>Corrected Text:</b>

None
</pre>
<b>Notes:</b><br/>
This Errata modifies three different sections, Sections 7.8, 7.9 and 8.4.1. The changes in Section 7.8 and 7.9 defer the description of the behavior of confirmed commit to Section 8.4.1.
<br/>
</div>

    </body>
</html>
