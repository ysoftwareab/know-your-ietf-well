K = MD4(UNICODE(password))

T=7)
T = 0 in the generation of sequence number for the MIC token
T = 0 in the generation of sequence number for the WRAP token
T = 0 in the generation of encrypted data for the WRAPPED token

Ksign = HMAC(K, "signaturekey")  //includes zero octet at end
tmp = MD5(concat(T, data))
CHKSUM = HMAC(Ksign, tmp)


T = the message type, encoded as a little-endian four byte integer.

           OCTET L40[14] = "fortybits";

      The header field on the encrypted data in KDC messages is:

           typedef struct _RC4_MDx_HEADER {
               OCTET Checksum[16];
               OCTET Confounder[8];
           } RC4_MDx_HEADER, *PRC4_MDx_HEADER;


           ENCRYPT (K, export, T, data)
           {
               struct EDATA {
                   struct HEADER {
                           OCTET Checksum[16];
                           OCTET Confounder[8];
                   } Header;
                   OCTET Data[0];
               } edata;

               if (export){
                   *((DWORD *)(L40+10)) = T;
                   HMAC (K, L40, 10 + 4, K1);
               }
               else
               {
                   HMAC (K, &T, 4, K1);
               }
               memcpy (K2, K1, 16);
               if (export) memset (K1+7, 0xAB, 9);

               nonce (edata.Confounder, 8);
               memcpy (edata.Data, data);

               edata.Checksum = HMAC (K2, edata);
K3 = HMAC (K1, edata.Checksum);

K3 = HMAC (K1, edata.Checksum);
checksum = HMAC (K2, concat(edata.Confounder, edata.Data));
               if (checksum != edata.Checksum)
                   printf("CHECKSUM ERROR  !!!!!!\n");
Ksign = HMAC(Kss, "signaturekey");
                                     // length includes terminating null

Sgn_Cksum = MD5((int32)15, Token.Header, data);

Sgn_Cksum = HMAC(Ksign, Sgn_Cksum);
Kseq = HMAC(Kss, "fortybits", (int32)0);
                                        // len includes terminating null
Kseq = HMAC(Kss, (int32)0);
Kseq = HMAC(Kseq, Token.SGN_CKSUM);

Ksign = HMAC(Kss, "signaturekey");

Sgn_Cksum = MD5((int32)15, Token.Header,
                                   Token.Confounder);

Kcrypt = HMAC(Klocal, "fortybits", (int32)0);
                                       // len includes terminating null
Kcrypt = HMAC(Klocal, (int32)0);
Kcrypt = HMAC(Kcrypt, (int32)seq);

Sgn_Cksum = HMAC(Ksign, Sgn_Cksum);
Kseq = HMAC(Kss, "fortybits", (int32)0);
                                       // len includes terminating null
Kseq = HMAC(Kss, (int32)0);
Kseq = HMAC(Kseq, Token.SGN_CKSUM);

