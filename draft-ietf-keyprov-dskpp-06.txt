


KEYPROV Working Group                                         A. Doherty
Internet-Draft                         RSA, The Security Division of EMC
Intended status: Standards Track                                  M. Pei
Expires: May 7, 2009                                      Verisign, Inc.
                                                              S. Machani
                                                        Diversinet Corp.
                                                              M. Nystrom
                                       RSA, The Security Division of EMC
                                                        November 3, 2008


          Dynamic Symmetric Key Provisioning Protocol (DSKPP)
                    draft-ietf-keyprov-dskpp-06.txt

Status of this Memo

   By submitting this Internet-Draft, each author represents that any
   applicable patent or other IPR claims of which he or she is aware
   have been or will be disclosed, and any of which he or she becomes
   aware will be disclosed, in accordance with Section 6 of BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF), its areas, and its working groups.  Note that
   other groups may also distribute working documents as Internet-
   Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt.

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html.

   This Internet-Draft will expire on May 7, 2009.

Abstract

   DSKPP is a client-server protocol for initialization (and
   configuration) of symmetric keys to locally and remotely accessible
   cryptographic modules.  The protocol can be run with or without
   private-key capabilities in the cryptographic modules, and with or
   without an established public-key infrastructure.

   Two variations of the protocol support multiple usage scenarios.



Doherty, et al.            Expires May 7, 2009                  [Page 1]


Internet-Draft                    DSKPP                    November 2008


   With the four-pass variant, keys are mutually generated by the
   provisioning server and cryptographic module; provisioned keys are
   not transferred over-the-wire or over-the-air.  The two-pass variant
   enables secure and efficient download and installation of pre-
   generated symmetric keys to a cryptographic module.

   This document builds on information contained in [RFC4758], adding
   specific enhancements in response to implementation experience and
   liaison requests.


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   6
     1.1.  Usage Scenarios . . . . . . . . . . . . . . . . . . . . .   6
       1.1.1.  Single Key Request  . . . . . . . . . . . . . . . . .   7
       1.1.2.  Multiple Key Requests . . . . . . . . . . . . . . . .   7
       1.1.3.  User Authentication . . . . . . . . . . . . . . . . .   7
       1.1.4.  Provisioning Time-Out Policy  . . . . . . . . . . . .   7
       1.1.5.  Key Renewal . . . . . . . . . . . . . . . . . . . . .   7
       1.1.6.  Pre-Loaded Key Replacement  . . . . . . . . . . . . .   8
       1.1.7.  Pre-Shared Manufacturing Key  . . . . . . . . . . . .   8
       1.1.8.  End-to-End Protection of Key Material . . . . . . . .   8
     1.2.  Protocol Entities . . . . . . . . . . . . . . . . . . . .   9
     1.3.  Initiating DSKPP  . . . . . . . . . . . . . . . . . . . .  10
     1.4.  Determining Which Protocol Variant to Use . . . . . . . .  11
       1.4.1.  Criteria for Using the Four-Pass Protocol . . . . . .  11
       1.4.2.  Criteria for Using the Two-Pass Protocol  . . . . . .  12
     1.5.  Presentation Syntax . . . . . . . . . . . . . . . . . . .  12
       1.5.1.  Versions  . . . . . . . . . . . . . . . . . . . . . .  12
       1.5.2.  Namespaces  . . . . . . . . . . . . . . . . . . . . .  12
       1.5.3.  Identifiers . . . . . . . . . . . . . . . . . . . . .  13
   2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .  13
     2.1.  Key Words . . . . . . . . . . . . . . . . . . . . . . . .  13
     2.2.  Definitions . . . . . . . . . . . . . . . . . . . . . . .  13
     2.3.  Notation  . . . . . . . . . . . . . . . . . . . . . . . .  15
     2.4.  Abbreviations . . . . . . . . . . . . . . . . . . . . . .  16
   3.  DSKPP Protocol Details  . . . . . . . . . . . . . . . . . . .  17
     3.1.  Protocol Initiation . . . . . . . . . . . . . . . . . . .  17
       3.1.1.  Server Initiation . . . . . . . . . . . . . . . . . .  17
       3.1.2.  Client Initiation . . . . . . . . . . . . . . . . . .  18
     3.2.  Protocol Variations . . . . . . . . . . . . . . . . . . .  18
       3.2.1.  Four-Pass Protocol Interaction  . . . . . . . . . . .  18
       3.2.2.  Two-Pass Protocol Interaction . . . . . . . . . . . .  20
     3.3.  Cryptographic Construction  . . . . . . . . . . . . . . .  21
       3.3.1.  The DSKPP One-Way Pseudorandom Function, DSKPP-PRF  .  21
     3.4.  Four-Pass Protocol Usage  . . . . . . . . . . . . . . . .  22
       3.4.1.  Message Flow  . . . . . . . . . . . . . . . . . . . .  22



Doherty, et al.            Expires May 7, 2009                  [Page 2]


Internet-Draft                    DSKPP                    November 2008


       3.4.2.  Generation of Symmetric Keys for Cryptographic
               Modules . . . . . . . . . . . . . . . . . . . . . . .  25
       3.4.3.  Encryption of Pseudorandom Nonces Sent from the
               DSKPP Client  . . . . . . . . . . . . . . . . . . . .  28
       3.4.4.  MAC Calculations  . . . . . . . . . . . . . . . . . .  28
     3.5.  Two-Pass Protocol Usage . . . . . . . . . . . . . . . . .  30
       3.5.1.  Message Flow  . . . . . . . . . . . . . . . . . . . .  30
       3.5.2.  Key Protection Profiles . . . . . . . . . . . . . . .  33
       3.5.3.  MAC Calculations  . . . . . . . . . . . . . . . . . .  37
     3.6.  Device Identification . . . . . . . . . . . . . . . . . .  38
     3.7.  User Authentication . . . . . . . . . . . . . . . . . . .  39
       3.7.1.  Authentication Data . . . . . . . . . . . . . . . . .  39
       3.7.2.  Authentication Code Format  . . . . . . . . . . . . .  40
       3.7.3.  Authentication Data Calculation . . . . . . . . . . .  42
   4.  DSKPP Message Formats . . . . . . . . . . . . . . . . . . . .  43
     4.1.  General XML Schema Requirements . . . . . . . . . . . . .  43
     4.2.  Components of the <KeyProvTrigger> Message  . . . . . . .  44
     4.3.  Components of the <KeyProvClientHello> Request  . . . . .  45
       4.3.1.  The DeviceIdentifierDataType Type . . . . . . . . . .  48
       4.3.2.  The ProtocolVariantsType Type . . . . . . . . . . . .  48
       4.3.3.  The KeyPackagesFormatType Type  . . . . . . . . . . .  49
       4.3.4.  The AuthenticationDataType Type . . . . . . . . . . .  50
     4.4.  Components of the <KeyProvServerHello> Response (Used
           Only in Four-Pass DSKPP)  . . . . . . . . . . . . . . . .  50
     4.5.  Components of a <KeyProvClientNonce> Request (Used
           Only in Four-Pass DSKPP)  . . . . . . . . . . . . . . . .  52
     4.6.  Components of a <KeyProvServerFinished> Response  . . . .  53
     4.7.  The StatusCode Type . . . . . . . . . . . . . . . . . . .  55
   5.  Protocol Extensions . . . . . . . . . . . . . . . . . . . . .  57
     5.1.  The ClientInfoType Type . . . . . . . . . . . . . . . . .  57
     5.2.  The ServerInfoType Type . . . . . . . . . . . . . . . . .  57
   6.  Protocol Bindings . . . . . . . . . . . . . . . . . . . . . .  57
     6.1.  General Requirements  . . . . . . . . . . . . . . . . . .  57
     6.2.  HTTP/1.1 Binding for DSKPP  . . . . . . . . . . . . . . .  57
       6.2.1.  Introduction  . . . . . . . . . . . . . . . . . . . .  57
       6.2.2.  Identification of DSKPP Messages  . . . . . . . . . .  58
       6.2.3.  HTTP Headers  . . . . . . . . . . . . . . . . . . . .  58
       6.2.4.  HTTP Operations . . . . . . . . . . . . . . . . . . .  58
       6.2.5.  HTTP Status Codes . . . . . . . . . . . . . . . . . .  59
       6.2.6.  HTTP Authentication . . . . . . . . . . . . . . . . .  59
       6.2.7.  Initialization of DSKPP . . . . . . . . . . . . . . .  59
       6.2.8.  Example Messages  . . . . . . . . . . . . . . . . . .  60
   7.  DSKPP Schema  . . . . . . . . . . . . . . . . . . . . . . . .  60
   8.  Conformance Requirements  . . . . . . . . . . . . . . . . . .  69
   9.  Security Considerations . . . . . . . . . . . . . . . . . . .  70
     9.1.  General . . . . . . . . . . . . . . . . . . . . . . . . .  70
     9.2.  Active Attacks  . . . . . . . . . . . . . . . . . . . . .  70
       9.2.1.  Introduction  . . . . . . . . . . . . . . . . . . . .  70



Doherty, et al.            Expires May 7, 2009                  [Page 3]


Internet-Draft                    DSKPP                    November 2008


       9.2.2.  Message Modifications . . . . . . . . . . . . . . . .  70
       9.2.3.  Message Deletion  . . . . . . . . . . . . . . . . . .  72
       9.2.4.  Message Insertion . . . . . . . . . . . . . . . . . .  72
       9.2.5.  Message Replay  . . . . . . . . . . . . . . . . . . .  72
       9.2.6.  Message Reordering  . . . . . . . . . . . . . . . . .  73
       9.2.7.  Man-in-the-Middle . . . . . . . . . . . . . . . . . .  73
     9.3.  Passive Attacks . . . . . . . . . . . . . . . . . . . . .  73
     9.4.  Cryptographic Attacks . . . . . . . . . . . . . . . . . .  73
     9.5.  Attacks on the Interaction between DSKPP and User
           Authentication  . . . . . . . . . . . . . . . . . . . . .  74
     9.6.  Miscellaneous Considerations  . . . . . . . . . . . . . .  75
       9.6.1.  Client Contributions to K_TOKEN Entropy . . . . . . .  75
       9.6.2.  Key Confirmation  . . . . . . . . . . . . . . . . . .  75
       9.6.3.  Server Authentication . . . . . . . . . . . . . . . .  75
       9.6.4.  User Authentication . . . . . . . . . . . . . . . . .  75
       9.6.5.  Key Protection in Two-Pass DSKPP  . . . . . . . . . .  76
   10. Internationalization Considerations . . . . . . . . . . . . .  77
   11. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  77
     11.1. URN Sub-Namespace Registration  . . . . . . . . . . . . .  77
     11.2. XML Schema Registration . . . . . . . . . . . . . . . . .  78
     11.3. MIME Media Type Registration  . . . . . . . . . . . . . .  78
     11.4. Status Code Registry  . . . . . . . . . . . . . . . . . .  79
   12. Intellectual Property Considerations  . . . . . . . . . . . .  80
   13. Contributors  . . . . . . . . . . . . . . . . . . . . . . . .  80
   14. Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  80
   15. References  . . . . . . . . . . . . . . . . . . . . . . . . .  81
     15.1. Normative references  . . . . . . . . . . . . . . . . . .  81
     15.2. Informative references  . . . . . . . . . . . . . . . . .  82
   Appendix A.  Examples . . . . . . . . . . . . . . . . . . . . . .  84
     A.1.  Trigger Message . . . . . . . . . . . . . . . . . . . . .  85
     A.2.  Four-Pass Protocol  . . . . . . . . . . . . . . . . . . .  85
       A.2.1.  <KeyProvClientHello> Without a Preceding Trigger  . .  86
       A.2.2.  <KeyProvClientHello> Assuming a Preceding Trigger . .  87
       A.2.3.  <KeyProvServerHello> Without a Preceding Trigger  . .  88
       A.2.4.  <KeyProvServerHello> Assuming a Preceding Trigger . .  89
       A.2.5.  <KeyProvClientNonce> Using Default Encryption . . . .  89
       A.2.6.  <KeyProvServerFinished> Using Default Encryption  . .  91
     A.3.  Two-Pass Protocol . . . . . . . . . . . . . . . . . . . .  91
       A.3.1.  Example Using the Key Transport Profile . . . . . . .  91
       A.3.2.  Example Using the Key Wrap Profile  . . . . . . . . .  94
       A.3.3.  Example Using the Passphrase-Based Key Wrap Profile .  97
   Appendix B.  Integration with PKCS #11  . . . . . . . . . . . . . 100
     B.1.  The 4-pass Variant  . . . . . . . . . . . . . . . . . . . 100
     B.2.  The 2-pass Variant  . . . . . . . . . . . . . . . . . . . 100
   Appendix C.  Example of DSKPP-PRF Realizations  . . . . . . . . . 103
     C.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . 103
     C.2.  DSKPP-PRF-AES . . . . . . . . . . . . . . . . . . . . . . 103
       C.2.1.  Identification  . . . . . . . . . . . . . . . . . . . 103



Doherty, et al.            Expires May 7, 2009                  [Page 4]


Internet-Draft                    DSKPP                    November 2008


       C.2.2.  Definition  . . . . . . . . . . . . . . . . . . . . . 103
       C.2.3.  Example . . . . . . . . . . . . . . . . . . . . . . . 104
     C.3.  DSKPP-PRF-SHA256  . . . . . . . . . . . . . . . . . . . . 104
       C.3.1.  Identification  . . . . . . . . . . . . . . . . . . . 105
       C.3.2.  Definition  . . . . . . . . . . . . . . . . . . . . . 105
       C.3.3.  Example . . . . . . . . . . . . . . . . . . . . . . . 106
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . . 106
   Intellectual Property and Copyright Statements  . . . . . . . . . 108











































Doherty, et al.            Expires May 7, 2009                  [Page 5]


Internet-Draft                    DSKPP                    November 2008


1.  Introduction

   While the range of problems for which symmetric key cryptography is
   the solution of choice is somewhat smaller than for public key
   cryptography, the problems it does solve, it solves exceedingly well.
   In particular, symmetric key algorithms are considerably faster than
   public key equivalents and allow for smaller key and signature sizes.

   Despite the clear advantages of employing symmetric keys as long term
   credentials or access keys in certain circumstances, it has generally
   been assumed that any protocol in which ease of key management is
   required will employ public key cryptography.  In particular it is
   assumed that only private components of public keypairs will be
   employed as long term secrets and that symmetric cryptography will
   only play a supporting role.

   This document describes the Dynamic Symmetric Key Provisioning
   Protocol (DSKPP), which provides a mechanism for provisioning
   symmetric keys that provides the same degree of flexibility and
   convenience in use as equivalent infrastructures for public keys.

   DSKPP enables provisioning of symmetric keys to a symmetric key
   cryptographic module that provides data authentication and encryption
   services to software (or firmware) applications hosted on a wide
   range of hardware devices, such as personal computers, handheld
   mobile phones, one-time password tokens, USB flash drives, tape
   drives, etc.

   DSKPP provides an open and interoperable mechanism for initializing
   and configuring symmetric keys to cryptographic modules that are
   accessible over the Internet.  The description is based on the
   information contained in [RFC4758], and contains specific
   enhancements, such as User Authentication and support for the [PSKC]
   format for transmission of keying material.

   DSKPP has two principal protocol variations.  The four pass protocol
   variation permits a symmetric key to be established that includes
   randomness contributed by both the client and the server.  The two
   pass protocol requires only one round trip instead of two and permits
   a server specified key to be established.

1.1.  Usage Scenarios

   DSKPP is expected to be used to provision symmetric keys to
   cryptographic modules in a number of different scenarios, each with
   its own special requirements.





Doherty, et al.            Expires May 7, 2009                  [Page 6]


Internet-Draft                    DSKPP                    November 2008


1.1.1.  Single Key Request

   The usual scenario is that a cryptographic module makes a request for
   a symmetric key from a provisioning server that is located on the
   local network or somewhere on the Internet.  Depending upon the
   deployment scenario, the provisioning server may generate a new key
   on-the-fly or use a pre-generated key, e.g., one provided by a legacy
   back-end issuance server.  The provisioning server assigns a unique
   key ID to the symmetric key and provisions it to the cryptographic
   module.

1.1.2.  Multiple Key Requests

   A cryptographic module makes multiple requests for symmetric keys
   from the same provisioning server.  The symmetric keys need not be of
   the same type, i.e., the keys may be used with different symmetric
   key cryptographic algorithms, including one-time password
   authentication algorithms, and the AES encryption algorithm.

1.1.3.  User Authentication

   In some deployment scenarios, a key issuer may rely on a third party
   provisioning service.  In this case, the issuer directs provisioning
   requests from the cryptographic module to the provisioning service.
   As such, it is the responsibility of the issuer to authenticate the
   user through some out-of-band means before granting him rights to
   acquire keys.  Once the issuer has granted those rights, the issuer
   provides an authentication code to the user and makes it available to
   the provisioning service, so that the user can prove that he is
   authorized to acquire keys.

1.1.4.  Provisioning Time-Out Policy

   An issuer may provide a time-limited authentication code to a user
   during registration, which the user will input into the cryptographic
   module to authenticate themselves with the provisioning server.  The
   server will allow a key to be provisioned to the cryptographic module
   hosted by the user's device when user authentication is required only
   if the user inputs a valid authentication code within the fixed time
   period established by the issuer.

1.1.5.  Key Renewal

   A cryptographic module requests renewal of the symmetric key material
   attached to a key ID, as opposed to keeping the key value constant
   and refreshing the metadata.  Such a need may occur in the case when
   a user wants to upgrade her device that houses the cryptographic
   module or when a key has expired.  When a user uses the same



Doherty, et al.            Expires May 7, 2009                  [Page 7]


Internet-Draft                    DSKPP                    November 2008


   cryptographic module to, for example, perform strong authentication
   at multiple Web login sites, keeping the same key ID removes the need
   for the user to register a new key ID at each site.

1.1.6.  Pre-Loaded Key Replacement

   This scenario represents a special case of symmetric key renewal in
   which a local administrator can authenticate the user procedurally
   before initiating the provisioning process.  It also allows for a
   device issuer to pre-load a key onto a cryptographic module with a
   restriction that the key is replaced with a new key prior to use of
   the cryptographic module.  Another variation of this scenario is the
   organization who recycles devices.  In this case, a key issuer would
   provision a new symmetric key to a cryptographic module hosted on a
   device that was previously owned by another user.

   Note that this usage scenario is essentially the same as the previous
   scenario wherein the same key ID is used for renewal.

1.1.7.  Pre-Shared Manufacturing Key

   A cryptographic module is loaded onto a smart card after the card is
   issued to a user.  The symmetric key for the cryptographic module
   will then be provisioned using a secure channel mechanism present in
   many smart card platforms.  This allows a direct secure channel to be
   established between the smart card chip and the provisioning server.
   For example, the card commands (i.e., Application Protocol Data
   Units, or APDUs) are encrypted with a pre-issued card manufacturer's
   key and sent directly to the smart card chip, allowing secure post-
   issuance in-the-field provisioning.  This secure flow can pass
   Transport Layer Security (TLS) and other transport security
   boundaries.

   Note that two pre-conditions for this usage scenario are for the
   protocol to be tunneled and the provisioning server to know the
   correct pre-established manufacturer's key.

1.1.8.  End-to-End Protection of Key Material

   In this scenario, transport layer security does not provide end-to-
   end protection of keying material transported from the provisioning
   server to the cryptographic module.  For example, TLS may terminate
   at an application hosted on a PC rather than at the cryptographic
   module (i.e., the endpoint) located on a data storage device.
   Mutually authenticated key agreement provides end-to-end protection,
   which TLS cannot provide.





Doherty, et al.            Expires May 7, 2009                  [Page 8]


Internet-Draft                    DSKPP                    November 2008


1.2.  Protocol Entities

   A DSKPP provisioning transaction has three entities:

   Server:   The DSKPP provisioning server.

   Cryptographic Module:  The cryptographic module to which the
       symmetric keys are to be provisioned.

   Client:  The DSKPP client which manages communication between the
       cryptographic module and the provisioning server.

   While it is highly desirable for the entire communication between the
   DSKPP client and server to be protected by means of a transport
   providing confidentiality and integrity protection such as HTTP over
   Transport Layer Security (TLS), such protection is not sufficient to
   protect the exchange of the symmetric key data between the server and
   the cryptographic module and the DSKPP protocol is designed to permit
   implementations that satisfy this requirement.

   The server only communicates to the client.  As far as the server is
   concerned, the client and cryptographic module may be considered to
   be a single entity.

   From a client-side security perspective, however, the client and the
   cryptographic module are separate logical entities and may in some
   implementations be separate physical entities as well.

   A high-level object model that describes the client-side entities and
   how they relate to each other is shown in Figure 1.  Conceptually,
   each entity is represented by the definitions found in Section 2.2.




















Doherty, et al.            Expires May 7, 2009                  [Page 9]


Internet-Draft                    DSKPP                    November 2008


   -----------          -------------
   | User    |          | Device    |
   |---------|*  owns  *|-----------|
   | UserID  |--------->| DeviceID  |
   | ...     |          | ...       |
   -----------          -------------
                             | 1
                             |
                             | contains
                             |
                             | *
                             V
                 --------------------------
                 |Cryptographic Module    |
                 |------------------------|
                 |Crypto Module ID        |
                 |Security Attribute List |
                 |...                     |
                 --------------------------
                            | 1
                            |
                            | contains
                            |
                            | *
                            V
                   -----------------------
                   |Key Package          |
                   |---------------------|
                   |Key ID               |
                   |Key Type             |
                   |...                  |
                   -----------------------

                          Figure 1: Object Model

   It is assumed that a device will host an application layered above
   the cryptographic module, and this application will manage
   communication between the DSKPP client and cryptographic module.  The
   manner in which the communicating application will transfer DSKPP
   protocol elements to and from the cryptographic module is transparent
   to the DSKPP server.  One method for this transfer is described in
   [CT-KIP-P11].

1.3.  Initiating DSKPP

   To initiate DSKPP:





Doherty, et al.            Expires May 7, 2009                 [Page 10]


Internet-Draft                    DSKPP                    November 2008


   1.  A server may first send a DSKPP trigger message to a client
       application (e.g., in response to a user browsing to a Web site
       that requires a symmetric key for authentication), although this
       step is optional.
   2.  A client application calls on the DSKPP client to send a
       symmetric key request to a DSKPP server, thus beginning a DSKPP
       protocol run.

   One of the following actions may be used to contact a DSKPP server:

   1.  A user may indicate how the DSKPP client is to contact a certain
       DSKPP server during a browsing session.
   2.  A DSKPP client may be pre-configured to contact a certain DSKPP
       server.
   3.  A user may be informed out-of-band about the location of the
       DSKPP server.

   Once the location of the DSKPP server is known, the DSKPP client and
   the DSKPP server engage in a 4-pass or 2-pass protocol.

1.4.  Determining Which Protocol Variant to Use

   The four-pass and two-pass protocols are appropriate in different
   deployment scenarios, as described in the sub-sections below.  The
   biggest differentiator between the two is that the two-pass protocol
   supports transport of an existing key to a cryptographic module,
   while the four-pass involves key generation on-the-fly via key
   agreement.  In either case, both protocol variants support algorithm
   agility through negotiation of encryption mechanisms and key types at
   the beginning of each protocol run.

1.4.1.  Criteria for Using the Four-Pass Protocol

   The four-pass protocol is needed under one or more of the following
   conditions:

   o  Policy requires that both parties engaged in the protocol jointly
      contribute entropy to the key.  Enforcing this policy mitigates
      the risk of exposing a key during the provisioning process as the
      key is generated through mutual agreement without being
      transferred over-the-air or over-the-wire.  It also mitigates risk
      of exposure after the key is provisioned, as the key will be not
      be vulnerable to a single point of attack in the system.
   o  A cryptographic module does not have private-key capabilities.
   o  The cryptographic module is hosted by a device that was neither
      pre-issued with a manufacturer's key or other form of pre-shared
      key (as might be the case with a smart card or SIM card) nor has a
      keypad that can be used for entering a passphrase (such as present



Doherty, et al.            Expires May 7, 2009                 [Page 11]


Internet-Draft                    DSKPP                    November 2008


      on a mobile phone).

1.4.2.  Criteria for Using the Two-Pass Protocol

   The two-pass protocol is needed under one or more of the following
   conditions:

   o  Pre-existing (i.e., legacy) keys must be provisioned via transport
      to the cryptographic module.
   o  The cryptographic module is hosted on a device that was pre-issued
      with a manufacturer's key (such as may exist on a smart card), or
      other form of pre-shared key (such as may exist on a SIM-card),
      and is capable of performing private-key operations.
   o  The cryptographic module is hosted by a device that has a built-in
      keypad with which a user may enter a passphrase, useful for
      deriving a key wrapping key for distribution of keying material.

1.5.  Presentation Syntax

   This documents presents DSKPP message formats and data elements using
   XML syntax.  The main goal in using this syntax is to document DSKPP.
   Application of the syntax beyond this goal is OPTIONAL (i.e., an
   implementation that does not use XML and instead uses ASN.1 could
   claim compliance with this specification).

1.5.1.  Versions

   There is a provision made in the syntax for an explicit version
   number.  Only version "1.0" is currently specified.

1.5.2.  Namespaces

   The XML namespace [XMLNS] URN that MUST be used by implementations of
   this syntax is:

   xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"

   References to qualified elements in the DSKPP schema defined herein
   use the prefix "dskpp".

   This document relies on qualified elements already defined in the
   Portable Symmetric Key Container [PSKC] namespace, which is
   represented by the prefix "pskc" and declared as:

   xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"

   Finally, the DSKPP syntax presented in this document relies on
   algorithm identifiers defined in the XML Signature [XMLDSIG]



Doherty, et al.            Expires May 7, 2009                 [Page 12]


Internet-Draft                    DSKPP                    November 2008


   namespace:

   xmlns:ds="http://www.w3.org/2000/09/xmldsig#"

   References to algorithm identifiers in the XML Signature namespace
   are represented by the prefix "ds".

1.5.3.  Identifiers

   This document uses Uniform Resource Identifiers [RFC2396] to identify
   resources, algorithms, and semantics.


2.  Terminology

2.1.  Key Words

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

2.2.  Definitions

   The definitions provided below are defined as used in this document.
   The same terms may be defined differently in other documents.

   Authentication Code (AC):  Client Authentication Code comprised of a
       string of numeric characters known to the device and the server
       and containing an identifier and a password

   Authentication Data (AD):  Client Authentication Data that may be
       derived from the Authentication Code (AC)

   Cryptographic Module:  A component of an application, which enables
       symmetric key cryptographic functionality

   CryptoModule ID:  A unique identifier for an instance of the
       cryptographic module

   Device:  A physical piece of hardware, or a software framework, that
       hosts symmetric key cryptographic modules

   Device ID (DeviceID):  A unique identifier for the device








Doherty, et al.            Expires May 7, 2009                 [Page 13]


Internet-Draft                    DSKPP                    November 2008


   DSKPP Client:  Manages communication between the symmetric key
       cryptographic module and the DSKPP server

   DSKPP Server:  The symmetric key provisioning server that
       participates in the DSKPP protocol run

   DSKPP Server ID (ServerID):  The unique identifier of a DSKPP server

   Issuer:  See "Key Issuer"

   Key Issuer:  An organization that issues symmetric keys to end-users

   Key Package (KP):  An object that encapsulates a symmetric key and
       its configuration data

   Key Package Header (KPH):  Information about the Key Package, useful
       for two-pass DSKPP, e.g., the passing the ServerID and the Key
       Protection Method

   Key ID (KeyID):  A unique identifier for the symmetric key

   Key Protection Method (KPM):  The key transport method used during
       two-pass DSKPP

   Key Protection Method List (KPML):  The list of key protection
       methods supported by a cryptographic module

   Key Provisioning Server:  A lifecycle management system that provides
       a key issuer with the ability to provision keys to cryptographic
       modules hosted on end-users' devices

   Key Transport:  A key establishment procedure whereby the DSKPP
       server selects and encrypts the keying material and then sends
       the material to the DSKPP client [NIST-SP800-57]

   Key Transport Key:  The private key that resides on the cryptographic
       module.  This key is paired with the DSKPP client's public key,
       which the DSKPP server uses to encrypt keying material during key
       transport [NIST-SP800-57]

   Key Type:  The type of symmetric key cryptographic methods for which
       the key will be used (e.g., OATH HOTP or RSA SecurID
       authentication, AES encryption, etc.)








Doherty, et al.            Expires May 7, 2009                 [Page 14]


Internet-Draft                    DSKPP                    November 2008


   Key Wrapping:  A method of encrypting keys for key transport
       [NIST-SP800-57]

   Key Wrapping Key:  A symmetric key encrypting key used for key
       wrapping [NIST-SP800-57]

   Keying Material:  The data necessary (e.g., keys and key
       configuration data) necessary to establish and maintain
       cryptographic keying relationships [NIST-SP800-57]

   Manufacturer's Key  A unique master key pre-issued to a hardware
       device, e.g., a smart card, during the manufacturing process.  If
       present, this key may be used by a cryptographic module to derive
       secret keys

   Provisioning Service:  See "Key Provisioning Server"

   Security Attribute List (SAL):  A payload that contains the DSKPP
       version, DSKPP variation (four- or two-pass), key package
       formats, key types, and cryptographic algorithms that the
       cryptographic module is capable of supporting

   Security Context (SC):  A payload that contains the DSKPP version,
       DSKPP variation (four- or two-pass), key package format, key
       type, and cryptographic algorithms relevant to the current
       protocol run

   User:  The person or client to whom devices are issued

   User ID:  A unique identifier for the user or client


2.3.  Notation

   ||                String concatenation

   [x]               Optional element x

   A ^ B             Exclusive-OR operation on strings A and B (where A
                     and B are of equal length)

   <XMLElement>      A typographical convention used in the body of the
                     text








Doherty, et al.            Expires May 7, 2009                 [Page 15]


Internet-Draft                    DSKPP                    November 2008


   DSKPP-PRF(k,s,dsLen)  A keyed pseudo-random function (see
                     Section 3.3.1)

   E(k,m)            Encryption of m with the key k

   K                 Key used to encrypt R_C (either K_SERVER or
                     K_SHARED), or in MAC or DSKPP_PRF computations

   K_AC              Secret key that is derived from the Authentication
                     Code and used for user authentication purposes

   K_MAC             Secret key derived during a DSKPP exchange for use
                     with key confirmation

   K_MAC'            A second secret key used for server authentication

   K_PROV            A provisioning master key from which two keys are
                     derived: K_TOKEN and K_MAC

   K_SERVER          Public key of the DSKPP server; used for encrypting
                     R_C in the four-pass protocol variant

   K_SHARED          Secret key that is pre-shared between the DSKPP
                     client and the DSKPP server; used for encrypting
                     R_C in the four-pass protocol variant

   K_TOKEN           Secret key that is established in a cryptographic
                     module using DSKPP

   R                 Pseudorandom value chosen by the DSKPP client and
                     used for MAC computations

   R_C               Pseudorandom value chosen by the DSKPP client and
                     used as input to the generation of K_TOKEN

   R_S               Pseudorandom value chosen by the DSKPP server and
                     used as input to the generation of K_TOKEN

   R_TRIGGER         Pseudorandom value chosen by the DSKPP server and
                     used as input in a trigger message.

   URL_S             DSKPP server address, as a URL


2.4.  Abbreviations






Doherty, et al.            Expires May 7, 2009                 [Page 16]


Internet-Draft                    DSKPP                    November 2008


   AC      Authentication Code
   AD      Authentication Data
   DSKPP   Dynamic Symmetric Key Provisioning Protocol
   HTTP    Hypertext Transfer Protocol
   KP      Key Package
   KPH     Key Package Header
   KPM     Key Protection Method
   KPML    Key Protection Method List
   MAC     Message Authentication Code
   PC      Personal Computer
   PDU     Protocol Data Unit
   PKCS    Public-Key Cryptography Standards
   PRF     Pseudo-Random Function
   PSKC    Portable Symmetric Key Container
   SAL     Security Attribute List (see Section 2.2)
   SC      Security Context (see Section 2.2)
   TLS     Transport Layer Security
   URL     Uniform Resource Locator
   USB     Universal Serial Bus
   XML     eXtensible Markup Language


3.  DSKPP Protocol Details

   DSKPP enables symmetric key provisioning between a DSKPP server and
   DSKPP client.

3.1.  Protocol Initiation

   The DSKPP protocol has two- and four-pass variations, either of which
   may be initiated by either the client or the server making four
   possible successful protocol interactions.  In every case the first
   message sent from the client to the server is <KeyProvClientHello>
   and the last message is <KeyProvServerFinished> and is sent from the
   server to the client.

3.1.1.  Server Initiation

   The DSKPP protocol may be initiated by the server by means of a
   <KeyProvTrigger> message to which the client responds with a
   <KeyProvClientHello> message as shown in Figure 2.  The trigger
   message always contains a nonce to allow the server to couple the
   trigger with a later <KeyProvClientHello> request.








Doherty, et al.            Expires May 7, 2009                 [Page 17]


Internet-Draft                    DSKPP                    November 2008


   +---------------+                            +---------------+
   |               |                            |               |
   |  DSKPP Client |                            |  DSKPP Server |
   |               |                            |               |
   +---------------+                            +---------------+
           |                                            |
           |   <--------- <KeyProvTrigger> ---------    |
           |                                            |
           |   ------- <KeyProvClientHello> ------->    |
          ...                                          ...

                 Figure 2: Server Initiated DSKPP (start)

3.1.2.  Client Initiation

   The DSKPP protocol may be initiated by the client by means of the
   <KeyProvClientHello> message Figure 3 message.
   +---------------+                            +---------------+
   |               |                            |               |
   |  DSKPP Client |                            |  DSKPP Server |
   |               |                            |               |
   +---------------+                            +---------------+
           |                                            |
           |   ------- <KeyProvClientHello> ------->    |
          ...                                          ...

                 Figure 3: Client Initiated DSKPP (start)

3.2.  Protocol Variations

   Once contact has been initiated, the client and server MAY engage in
   either a two-pass or four-pass protocol depending on the protocol
   options specified in the <KeyProvClientHello> message and the server
   configuration.

3.2.1.  Four-Pass Protocol Interaction

   In the four-pass version of the protocol the server responds to the
   <KeyProvClientHello> message with <KeyProvServerHello>.  The client
   then responds with <KeyProvClientNonce> and the server with
   <KeyProvServerFinished> as shown in Figure 4.










Doherty, et al.            Expires May 7, 2009                 [Page 18]


Internet-Draft                    DSKPP                    November 2008


   +---------------+                            +---------------+
   |               |                            |               |
   |  DSKPP Client |                            |  DSKPP Server |
   |               |                            |               |
   +---------------+                            +---------------+
           |                                            |
           | [ <--------- <KeyProvTrigger> --------- ]  |
           |                                            |
           |   ------- <KeyProvClientHello> ------->    |
           |                                            |
           |   <------ <KeyProvServerHello> --------    |
           |                                            |
           |   ------- <KeyProvClientNonce> ------->    |
           |                                            |
           |   <---- <KeyProvServerFinished> -------    |
           |                                            |

   Figure 4: Four Pass DSKPP protocol (with OPTIONAL preceding trigger)

   [<KeyProvTrigger> Message]:  The <KeyProvTrigger> message is used to
       initiate a request from the server.  The trigger message always
       contains a nonce to allow the server to couple the trigger with a
       later <KeyProvClientHello> request.

   <KeyProvClientHello>:  The <KeyProvClientHello> request is sent by a
       DSKPP client to initiate contact with the DSKPP server,
       indicating which protocol versions and variations (four-pass or
       two-pass), key types, encryption and MAC algorithms that it
       supports.  In addition, the request may include client
       authentication data that the DSKPP server uses to verify proof-
       of-possession of the device.

   Server Processing of <KeyProvClientHello>:  Upon receiving a
       <KeyProvClientHello> request, the DSKPP server uses the
       <KeyProvServerHello> response to specify which protocol version
       and variation, key type, encryption algorithm, and MAC algorithm
       that will be used by the DSKPP server and DSKPP client during the
       protocol run.  The decision of which variation, key type, and
       cryptographic algorithms to pick is policy- and implementation-
       dependent and therefore outside the scope of this document.

   <KeyProvServerHello>:  The <KeyProvServerHello> response is only used
       in the four pass protocol, it includes the DSKPP server's random
       nonce, R_S. The response also consists of information about
       either a shared secret key, or its own public key, that the DSKPP
       client uses when sending its protected random nonce, R_C, in the
       <KeyProvClientNonce> request (see below).




Doherty, et al.            Expires May 7, 2009                 [Page 19]


Internet-Draft                    DSKPP                    November 2008


       Optionally, the DSKPP server may provide a MAC that the DSKPP
       client may use for server authentication.

   Client Processing of <KeyProvServerHello>:  On receipt of
       <KeyProvServerHello>, the client encrypts the random client nonce
       R_c under the (provided) server key K.

   <KeyProvClientNonce>:  The <KeyProvClientNonce> request is only used
       in the four pass protocol, it is used to exchange protected data,
       i.e., the protected random nonce R_C. In addition, the request
       may include user authentication data that the DSKPP server uses
       to verify proof-of-possession of the device.

   <KeyProvServerFinished>:  The <KeyProvServerFinished> response is a
       confirmation message that includes a key package that holds
       configuration data, but no keying material.

       Optionally, the DSKPP server may provide a MAC that the DSKPP
       client may use for server authentication.

3.2.2.  Two-Pass Protocol Interaction

   In the two-pass version of the protocol the server responds to the
   <KeyProvClientHello> message with a <KeyProvServerFinished> message
   Figure 5
   +---------------+                            +---------------+
   |               |                            |               |
   |  DSKPP Client |                            |  DSKPP Server |
   |               |                            |               |
   +---------------+                            +---------------+
           |                                            |
           | [ <--------- <KeyProvTrigger> --------- ]  |
           |                                            |
           |   ------- <KeyProvClientHello> ------->    |
           |                                            |
           |   <---- <KeyProvServerFinished> -------    |
           |                                            |

    Figure 5: Two Pass DSKPP protocol (with OPTIONAL preceding trigger)

   [<KeyProvTrigger> Message]:  The <KeyProvTrigger> message is used to
       initiate a request from the server.  The trigger message always
       contains a nonce to allow the server to couple the trigger with a
       later <KeyProvClientHello> request.







Doherty, et al.            Expires May 7, 2009                 [Page 20]


Internet-Draft                    DSKPP                    November 2008


   <KeyProvClientHello>:  The <KeyProvClientHello> request is sent by a
       DSKPP client to initiate contact with the DSKPP server,
       indicating which protocol versions and variations (four-pass or
       two-pass), key types, encryption and MAC algorithms that it
       supports.  In addition, the request may include client
       authentication data that the DSKPP server uses to verify proof-
       of-possession of the device.

   <KeyProvServerFinished>:  The <KeyProvServerFinished> response is a
       confirmation message that includes a key package that holds
       configuration data and contain protected keying material.

       Optionally, the DSKPP server may provide a MAC that the DSKPP
       client may use for server authentication.

3.3.  Cryptographic Construction

3.3.1.  The DSKPP One-Way Pseudorandom Function, DSKPP-PRF

3.3.1.1.  Introduction

   Regardless of the protocol variation employed, there is a requirement
   for a cryptographic primitive that provides a deterministic
   transformation of a secret key k and a varying length octet string s
   to a bitstring of specified length dsLen.

   This primitive must meet the same requirements as for a keyed hash
   function: It MUST take an arbitrary length input, and generate an
   output that is one-way and collision-free (for a definition of these
   terms, see, e.g., [FAQ]).  Further, its output MUST be unpredictable
   even if other outputs for the same key are known.

   From the point of view of this specification, DSKPP-PRF is a "black-
   box" function that, given the inputs, generates a pseudorandom value
   and MAY be realized by any appropriate and competent cryptographic
   technique.  Appendix C contains two example realizations of DSKPP-
   PRF.

3.3.1.2.  Declaration

   DSKPP-PRF (k, s, dsLen)

   Input:








Doherty, et al.            Expires May 7, 2009                 [Page 21]


Internet-Draft                    DSKPP                    November 2008


   k     secret key in octet string format
   s     octet string of varying length consisting of variable data
         distinguishing the particular string being derived
   dsLen desired length of the output

   Output:

   DS    pseudorandom string, dsLen-octets long

   For the purposes of this document, the secret key k MUST be at least
   16 octets long.

3.4.  Four-Pass Protocol Usage

   This section describes the message flow and methods that comprise the
   four-pass protocol variant.

3.4.1.  Message Flow

   The four-pass protocol flow consists of two message exchanges:

   1:  Pass 1 = <KeyProvClientHello>, Pass 2 = <KeyProvServerHello>
   2:  Pass 3 = <KeyProvClientNonce>, Pass 4 = <KeyProvServerFinished>

   The first pair of messages negotiate cryptographic algorithms and
   exchange nonces.  The second pair of messages establishes a symmetric
   key using mutually authenticated key agreement.

   The DSKPP server MUST ensure that a generated key is associated with
   the correct cryptographic module, and if applicable, the correct
   user.  To do this, the DSKPP server MAY couple an initial user
   authentication to the DSKPP execution using one of the mechanisms
   described in Section 3.7.

   The purpose and content of each message are described below,
   including the optional <KeyProvTrigger>.

           DSKPP Client                         DSKPP Server
           ------------                         ------------
                                [<---] R_TRIGGER, [DeviceID],
                                            [KeyID], [URL_S]

   The DSKPP server optionally sends a <KeyProvTrigger> message to the
   DSKPP client.  The trigger message MUST contain a nonce, R_TRIGGER,
   to allow the server to couple the trigger with a later
   <KeyProvClientHello> request. <KeyProvTrigger> MAY include a DeviceID
   to allow the client to select the device with which it will
   communicate (for more information about device identification, refer



Doherty, et al.            Expires May 7, 2009                 [Page 22]


Internet-Draft                    DSKPP                    November 2008


   to Section 3.6).  In the case of key renewal, <KeyProvTrigger> MAY
   include the identifier for the key, KeyID, that is being replaced.
   Finally, the trigger MAY contain a URL for the DSKPP client to use
   when contacting the DSKPP server.

           DSKPP Client                         DSKPP Server
           ------------                         ------------
           SAL, [R_TRIGGER],
           [DeviceID], [KeyID]     --->

   The DSKPP client sends a <KeyProvClientHello> message to the DSKPP
   server.  This message MUST contain a Security Attribute List (SAL),
   identifying which DSKPP versions, protocol variations (in this case
   "four-pass"), key package formats, key types, encryption and MAC
   algorithms that the client supports.  In addition, if a trigger
   message preceded <KeyProvClientHello>, then it passes the parameters
   received in <KeyProvTrigger> back to the DSKPP Server.  In
   particular, it MUST include R_TRIGGER so that the DSKPP server can
   associate the client with the trigger message, and SHOULD include
   DeviceID and KeyID.

           DSKPP Client                         DSKPP Server
           ------------                         ------------
                                   <---  SC, R_S, [K], [MAC]

   The DSKPP server responds to the DSKPP client with a
   <KeyProvServerHello> message, whose Status attribute is set to a
   return code for <KeyProvClientHello>.  If Status is not "Continue",
   only the Status and Version attributes will be present, and the DSKPP
   client MUST abort the protocol.  If Status is set to "Continue", then
   the message MUST include a Security Context (SC).  The DSKPP client
   will use the SC to select the DSKPP version and variation (e.g.,
   four-pass), type of key to generate, and cryptographic algorithms
   that it will use for the remainder of the protocol run.
   <KeyProvServerHello> MUST also include the server's random nonce,
   R_S, whose length may depend on the selected key type.  In addition,
   the <KeyProvServerHello> message MAY provide K, which represents its
   own public key (K_SERVER) or information about a shared secret key
   (K_SHARED) to use for encrypting the cryptographic module's random
   nonce (see description of <KeyProvClientNonce> below).  Optionally,
   <KeyProvServerHello> MAY include a MAC that the DSKPP client can use
   for server authentication in the case of key renewal (Section 3.4.4.1
   describes how to calculate the MAC).








Doherty, et al.            Expires May 7, 2009                 [Page 23]


Internet-Draft                    DSKPP                    November 2008


           DSKPP Client                         DSKPP Server
           ------------                         ------------
           E(K,R_C), [AD]          --->

   Based on the Security Context (SC) provided in the
   <KeyProvServerHello> message, the cryptographic module generates a
   random nonce, R_C. The length of the nonce R_C will depend on the
   selected key type.  The cryptographic module encrypts R_C using the
   selected encryption algorithm and with a key, K, that is either the
   DSKPP server's public key, K_SERVER, or a shared secret key,
   K_SHARED, as indicated by the DSKPP server.

   Note: If K is equivalent to K_SERVER, then the cryptographic module
   SHOULD verify the server's certificate before using it to encrypt R_C
   in accordance with [RFC5280].

   Note: If successful execution of the protocol will result in the
   replacement of an existing key with a newly generated one, the DSKPP
   client MUST verify the MAC provided in the <KeyProvServerHello>
   message.  The DSKPP client MUST terminate the DSKPP session if the
   MAC does not verify, and MUST delete any nonces, keys, and/or secrets
   associated with the failed run.

   The DSKPP client MUST send the encrypted random nonce to the DSKPP
   server in a <KeyProvClientNonce> message, and MAY include client
   Authentication Data (AD), such as a MAC derived from an
   authentication code and R_C (refer to Section 3.7.1).  Finally, the
   cryptographic module calculates and stores a symmetric key, K_TOKEN,
   of the key type specified in the SC received in <KeyProvServerHello>
   (refer to Section 3.4.2.2.<KeyProvServerFinished> for a description
   of how K_TOKEN is generated).

           DSKPP Client                         DSKPP Server
           ------------                         ------------
                                    <---             KP, MAC

   If Authentication Data (AD) was received in the <KeyProvClientNonce>
   message, then the DSKPP server MUST authenticate the user in
   accordance with Section 3.7.1.  If authentication fails, then DSKPP
   server MUST abort.  Otherwise, the DSKPP server decrypts R_C,
   calculates K_TOKEN from the combination of the two random nonces R_S
   and R_C, the encryption key K, and possibly some other data (refer to
   Section 3.4.2.2 for a description of how K_TOKEN is generated).  The
   server then associates K_TOKEN with the cryptographic module in a
   server-side data store.  The intent is that the data store later on
   will be used by some service that needs to verify or decrypt data
   produced by the cryptographic module and the key.




Doherty, et al.            Expires May 7, 2009                 [Page 24]


Internet-Draft                    DSKPP                    November 2008


   Once the association has been made, the DSKPP server sends a
   confirmation message to the DSKPP client called
   <KeyProvServerFinished>.  The confirmation message MUST include a Key
   Package (KP) that holds an identifier for the generated key (but not
   the key itself) and additional configuration information, e.g., the
   identity of the DSKPP server.  The default symmetric key package
   format is based on the Portable Symmetric Key Container (PSKC)
   defined in [PSKC].  Alternative formats MAY include [SKPC-ASN.1],
   PKCS#12 [PKCS-12], or PKCS#5 XML [PKCS-5-XML] format.  In addition to
   a Key Package, <KeyProvServerFinished> MUST also include a MAC that
   the DSKPP client will use to authenticate the message before
   committing K_TOKEN

   After receiving a <KeyProvServerFinished> message with Status =
   "Success", the DSKPP client MUST verify the MAC.  The DSKPP client
   MUST terminate the DSKPP session if the MAC does not verify, and
   MUST, in this case, also delete any nonces, keys, and/or secrets
   associated with the failed run of the protocol.  If
   <KeyProvServerFinished> has Status = "Success" and the MAC was
   verified, then the DSKPP client MUST associate the provided key
   package with the generated key K_TOKEN, and store this data
   permanently.  After this operation, it MUST NOT be possible to
   overwrite the key unless knowledge of an authorizing key is proven
   through a MAC on a later <KeyProvServerHello> (and
   <KeyProvServerFinished>) message.

3.4.2.  Generation of Symmetric Keys for Cryptographic Modules

   With 4-pass DSKPP, the symmetric key that is the target of
   provisioning, is generated on-the-fly without being transferred
   between the DSKPP client and DSKPP server.  A sample data flow
   depicting how this works followed by computational information are
   provided in the subsections below.

3.4.2.1.  Data Flow

   A sample data flow showing key generation during the 4-pass protocol
   is shown in Figure 6.













Doherty, et al.            Expires May 7, 2009                 [Page 25]


Internet-Draft                    DSKPP                    November 2008


   +----------------------+    +-------+     +----------------------+
   |    +------------+    |    |       |     |                      |
   |    | Server key |    |    |       |     |                      |
   | +<-|  Public    |------>------------->-------------+---------+ |
   | |  |  Private   |    |    |       |     |          |         | |
   | |  +------------+    |    |       |     |          |         | |
   | |        |           |    |       |     |          |         | |
   | V        V           |    |       |     |          V         V |
   | |   +---------+      |    |       |     |        +---------+ | |
   | |   | Decrypt |<-------<-------------<-----------| Encrypt | | |
   | |   +---------+      |    |       |     |        +---------+ | |
   | |      |  +--------+ |    |       |     |            ^       | |
   | |      |  | Server | |    |       |     |            |       | |
   | |      |  | Random |--->------------->------+  +----------+  | |
   | |      |  +--------+ |    |       |     |   |  | Client   |  | |
   | |      |      |      |    |       |     |   |  | Random   |  | |
   | |      |      |      |    |       |     |   |  +----------+  | |
   | |      |      |      |    |       |     |   |        |       | |
   | |      V      V      |    |       |     |   V        V       | |
   | |   +------------+   |    |       |     | +------------+     | |
   | +-->|  DSKPP PRF |   |    |       |     | |  DSKPP PRF |<----+ |
   |     +------------+   |    |       |     | +------------+       |
   |           |          |    |       |     |       |              |
   |           V          |    |       |     |       V              |
   |       +-------+      |    |       |     |   +-------+          |
   |       |  Key  |      |    |       |     |   |  Key  |          |
   |       +-------+      |    |       |     |   +-------+          |
   |       +-------+      |    |       |     |   +-------+          |
   |       |Key Id |-------->------------->------|Key Id |          |
   |       +-------+      |    |       |     |   +-------+          |
   +----------------------+    +-------+     +----------------------+
         DSKPP Server         DSKPP Client         DSKPP Client
                               (PC Host)      (cryptographic module)

   Figure 6: Principal data flow for DSKPP key generation             -
                          using public server key

   Note: Conceptually, although R_C is one pseudorandom string, it may
   be viewed as consisting of two components, R_C1 and R_C2, where R_C1
   is generated during the protocol run, and R_C2 can be pre-generated
   and loaded on the cryptographic module before the device is issued to
   the user.  In that case, the latter string, R_C2, SHOULD be unique
   for each cryptographic module.

   The inclusion of the two random nonces R_S and R_C in the key
   generation provides assurance to both sides (the cryptographic module
   and the DSKPP server) that they have contributed to the key's
   randomness and that the key is unique.  The inclusion of the



Doherty, et al.            Expires May 7, 2009                 [Page 26]


Internet-Draft                    DSKPP                    November 2008


   encryption key K ensures that no man-in-the-middle may be present, or
   else the cryptographic module will end up with a key different from
   the one stored by the legitimate DSKPP server.

   Note: A man-in-the-middle (in the form of corrupt client software or
   a mistakenly contacted server) may present his own public key to the
   cryptographic module.  This will enable the attacker to learn the
   client's version of K_TOKEN.  However, the attacker is not able to
   persuade the legitimate server to derive the same value for K_TOKEN,
   since K_TOKEN is a function of the public key involved, and the
   attacker's public key must be different than the correct server's (or
   else the attacker would not be able to decrypt the information
   received from the client).  Therefore, once the attacker is no longer
   "in the middle," the client and server will detect that they are "out
   of sync" when they try to use their keys.  In the case of encrypting
   R_C with K_SERVER, it is therefore important to verify that K_SERVER
   really is the legitimate server's key.  One way to do this is to
   independently validate a newly generated K_TOKEN against some
   validation service at the server (e.g. using a connection independent
   from the one used for the key generation).

3.4.2.2.  Computing the Symmetric Key

   In DSKPP, K_TOKEN and K_MAC are derived from provisioning key,
   K_PROV, which is generated using the DSKPP-PRF function as follows
   (refer to Section 3.3.1):

   K_PROV = DSKPP-PRF(k,s,dsLen), where

       k = R_C (i.e., the secret random value chosen by the DSKPP
       client)

       s = "Key generation" || K || R_S (where K is the key used to
       encrypt R_C and R_S is the random value chosen by the DSKPP
       server)

       dsLen = (desired length of K_PROV whose first half constitutes
       K_MAC and second half constitutes K_TOKEN)

   Then K_TOKEN and K_MAC derived from K_PROV, where

       K_PROV = K_MAC || K_TOKEN

   When computing K_PROV, the derived keys, K_MAC and K_TOKEN, MAY be
   subject to an algorithm-dependent transform before being adopted as a
   key of the selected type.  One example of this is the need for parity
   in DES keys.




Doherty, et al.            Expires May 7, 2009                 [Page 27]


Internet-Draft                    DSKPP                    November 2008


3.4.3.  Encryption of Pseudorandom Nonces Sent from the DSKPP Client

   DSKPP client random nonce(s) are either encrypted with the public key
   provided by the DSKPP server or by a shared secret key.  For example,
   in the case of a public RSA key, an RSA encryption scheme from PKCS
   #1 [PKCS-1] MAY be used.

   In the case of a shared secret key, to avoid dependence on other
   algorithms, the DSKPP client MAY use the DSKPP-PRF function described
   herein with the shared secret key K_SHARED as input parameter k (in
   this case, K_SHARED SHOULD be used solely for this purpose), the
   concatenation of the (ASCII) string "Encryption" and the server's
   nonce R_S as input parameter s, and dsLen set to the length of R_C:

   dsLen = len(R_C)

   DS = DSKPP-PRF(K_SHARED, "Encryption" || R_S, dsLen)

   This will produce a pseudorandom string DS of length equal to R_C.
   Encryption of R_C MAY then be achieved by XOR-ing DS with R_C:

   E(DS, R_C) = DS ^ R_C

   The DSKPP server will then perform the reverse operation to extract
   R_C from E(DS, R_C).

3.4.4.  MAC Calculations

3.4.4.1.  Server Authentication in the Case of Key Renewal

   A MAC MUST be present in the <KeyProvServerHello> message if the
   DSKPP run will result in the replacement of an existing key with a
   new one, as proof that the DSKPP server is authenticated to perform
   the action.  When the MAC value is used for server authentication,
   the value MAY be computed by using the DSKPP-PRF function of
   Section 3.3.1, in which case the input parameter k MUST be set to the
   existing MAC key K_MAC' (i.e., the value of the MAC key that existed
   before this protocol run); and input parameter s MUST be set to the
   concatenation of the (ASCII) string "MAC 1 computation", R (if sent
   by the client), and R_S. Note that the implementation MAY specify
   K_MAC' to be the value of the K_TOKEN that is being replaced, or a
   version of K_MAC from the previous protocol run.

   The input parameter dsLen MUST be set to the length of R_S:

   dsLen = len(R_S)

   MAC = DSKPP-PRF (K_MAC', "MAC 1 computation" || [R ||] R_S, dsLen)



Doherty, et al.            Expires May 7, 2009                 [Page 28]


Internet-Draft                    DSKPP                    November 2008


   The MAC algorithm MUST be the same as the algorithm used for key
   confirmation purposes.

3.4.4.2.  Key Confirmation

   To avoid a false "Commit" message causing the cryptographic module to
   end up in an initialized state in which the server does not recognize
   the stored key, <KeyProvServerFinished> messages MUST be
   authenticated with a MAC, calculated as follows:

   msg_hash = SHA-256(msg_1, ..., msg_n)

   dsLen = len(msg_hash)

   MAC = DSKPP-PRF (K_MAC, "MAC 2 computation" || msg_hash, dsLen)

   where

   MAC         The MAC MUST be calculated using the already established
               MAC algorithm and MUST be computed on the (ASCII) string
               "MAC 2 computation" and msg_hash using the existing the
               MAC key K_MAC.

   K_MAC       The key derived from K_PROV, as described in
               Section 3.4.2.2.

   msg_hash    The message hash, defined below, of messages msg_1, ...,
               msg_n.

   If DSKPP-PRF (defined in Section 3.3.1) is used as the MAC algorithm,
   then the input parameter s MUST consist of the concatenation of the
   (ASCII) string "MAC 2 computation" and msg_hash, and the parameter
   dsLen MUST be set to the length of msg_hash.

3.4.4.3.  Message Hash Algorithm

   To compute a message hash for a MAC, given a sequence of DSKPP
   messages msg_1, ..., msg_n, the following operations MUST be carried
   out:

   a.  The sequence of messages contains all DSKPP Request and Response
       messages up to but not including this message.
   b.  Re-transmitted messages are removed from the sequence of
       messages.
       Note: The resulting sequence of messages MUST be an alternating
       sequence of DSKPP Request and DSKPP Response messages





Doherty, et al.            Expires May 7, 2009                 [Page 29]


Internet-Draft                    DSKPP                    November 2008


   c.  The contents of each message is concatenated together.
   d.  The resulting string is hashed using SHA-256 in accordance with
       [FIPS180-SHA].

3.5.  Two-Pass Protocol Usage

   This section describes the message flow and methods that comprise the
   two-pass protocol variant.  Two-pass DSKPP is essentially a transport
   of keying material from the DSKPP server to the DSKPP client.  The
   keying material is contained in a package that is formatted in such a
   way that ensures that the symmetric key that is being established,
   K_TOKEN, is not exposed to any other entity than the DSKPP server and
   the cryptographic module itself.  To ensure the keying material is
   adequately protected for all two-pass usage scenarios, the key
   package format MUST support the following key protection methods, as
   defined in Section 3.5.2:

   Key Transport               This profile is intended for PKI-capable
                               devices.  Key transport is carried out
                               using the public key of the DSKPP client,
                               whose private key part resides in the
                               cryptographic module as the key transport
                               key.
   Key Wrap                    This profile is ideal for pre-keyed
                               devices, e.g., SIM cards.  Key wrap is
                               carried out using a key wrapping key,
                               which is known in advance by both the
                               cryptographic module and the DSKPP
                               server.
   Passphrase-Based Key Wrap   This profile is a variation of the Key
                               Wrap Profile.  It is applicable to
                               constrained devices with keypads, e.g.,
                               mobile phones.  Key wrap is carried out
                               using a passphrase-derived key wrapping
                               key, known in advance by both the
                               cryptographic module and DSKPP server.

   Key package formats that satisfy this criteria are [PSKC],
   [SKPC-ASN.1], PKCS#12 [PKCS-12], and PKCS#5 XML [PKCS-5-XML].

3.5.1.  Message Flow

   The two-pass protocol flow consists of one exchange:








Doherty, et al.            Expires May 7, 2009                 [Page 30]


Internet-Draft                    DSKPP                    November 2008


   1:  Pass 1 = <KeyProvClientHello>, Pass 2 = <KeyProvServerFinished>

   The client's initial <KeyProvClientHello> message is directly
   followed by a <KeyProvServerFinished> message (unlike the four-pass
   variant, there is no exchange of the <KeyProvServerHello> and
   <KeyProvClientNonce> messages).  However, as the two-pass variation
   of DSKPP consists of one round trip to the server, the client is
   still able to include its random nonce, R_C, algorithm preferences
   and supported key types in the <KeyProvClientHello> message.  Note
   that by including R_C in <KeyProvClientHello>, the DSKPP client is
   able to ensure the server is alive before "committing" the key.

   The DSKPP server MUST ensure that a generated key is associated with
   the correct cryptographic module, and if applicable, the correct
   user.  To ensure that the key K_TOKEN ends up associated with the
   correct cryptographic module and user, the DSKPP server MAY couple an
   initial user authentication to the DSKPP execution as described in
   Section 3.7.

   The purpose and content of each message are described below,
   including the optional <KeyProvTrigger>.

           DSKPP Client                         DSKPP Server
           ------------                         ------------
                                [<---] R_TRIGGER, [DeviceID],
                                            [KeyID], [URL_S]

   The DSKPP server optionally sends a <KeyProvTrigger> message to the
   DSKPP client.  The trigger message MUST contain a nonce, R_TRIGGER,
   to allow the server to couple the trigger with a later
   <KeyProvClientHello> request. <KeyProvTrigger> MAY include a DeviceID
   to allow the client to select the device with which it will
   communicate (for more information about device identification, refer
   to Section 3.6).  In the case of key renewal, <KeyProvTrigger> SHOULD
   include the identifier for the key, KeyID, that is being replaced.
   Finally, the trigger MAY contain a URL for the DSKPP client to use
   when contacting the DSKPP server.

           DSKPP Client                         DSKPP Server
           ------------                         ------------
           R_C, SAL, KPML, [AD],
           [R_TRIGGER],
           [DeviceID], [KeyID]     --->

   The DSKPP client sends a <KeyProvClientHello> message to the DSKPP
   server. <KeyProvClientHello> MUST include client nonce, R_C, and a
   Security Attribute List (SAL), identifying which DSKPP versions,
   protocol variations (in this case "two-pass"), key package formats,



Doherty, et al.            Expires May 7, 2009                 [Page 31]


Internet-Draft                    DSKPP                    November 2008


   key types, encryption and MAC algorithms that the client supports.
   Unlike 4-pass DSKPP, the 2-pass DSKPP client uses the
   <KeyProvClientHello> message to declare the list of Key Protection
   Method List (KPML) it supports, providing required payload
   information in accordance with Section 3.5.2.  Optionally, the
   message MAY include client Authentication Data (AD), such as a MAC
   derived from an authentication code and R_C (refer to Section 3.7.1).
   In addition, if a trigger message preceded <KeyProvClientHello>, then
   it passes the parameters received in <KeyProvTrigger> back to the
   DSKPP Server.  In particular, it MUST include R_TRIGGER so that the
   DSKPP server can associate the client with the trigger message, and
   SHOULD include DeviceID and KeyID.

           DSKPP Client                         DSKPP Server
           ------------                         ------------
                                  <---  KPH, KP, E(K,K_PROV),
                                                     MAC, AD

   If Authentication Data (AD) was received, then the DSKPP server MUST
   authenticate the user in accordance with Section 3.7.1.  If
   authentication fails, then DSKPP server MUST abort.  Otherwise, the
   DSKPP server generates a key K_PROV from which two keys, K_TOKEN and
   K_MAC, are derived.  (Alternatively, the key K_PROV may have been
   pre-generated as described in Section 1.1.1.)  The DSKPP server
   selects a Key Protection Method (KPM) and applies it to K_PROV in
   accordance with Section 3.5.2.  The server then associates K_TOKEN
   with the cryptographic module in a server-side data store.  The
   intent is that the data store later will be used by some service that
   needs to verify or decrypt data produced by the cryptographic module
   and the key.

   Once the association has been made, the DSKPP server sends a
   confirmation message to the DSKPP client called
   <KeyProvServerFinished>.  For two-pass DSKPP, the confirmation
   message MUST include a Key Package Header (KPH) that contains the
   DSKPP Server's ID and KPM.  The ServerID is used for authentication
   purposes, and the KPM informs the DSKPP client of the security
   context in which it will operate.  In addition to the KPH, the
   confirmation message MUST include the Key Package (KP) that holds the
   KeyID, K_PROV from which K_TOKEN and K_MAC are derived, and
   additional configuration information.  The default symmetric key
   package format is based on the Portable Symmetric Key Container
   (PSKC) defined in [PSKC].  Alternative formats MAY include
   [SKPC-ASN.1], PKCS#12 [PKCS-12], or PKCS#5 XML [PKCS-5-XML].
   Finally, <KeyProvServerFinished> MUST include two MACs (MAC and AD)
   whose values are calculated with contribution from the client nonce,
   R_C, provided in the <ClientHello> message.  The MAC values will
   allow the cryptographic module to perform key confirmation and server



Doherty, et al.            Expires May 7, 2009                 [Page 32]


Internet-Draft                    DSKPP                    November 2008


   authentication before "committing" the key (see Section 3.5.3 for
   more information).

   After receiving a <KeyProvServerFinished> message with Status =
   "Success", the DSKPP client MUST verify both MAC values (MAC and AD).
   The DSKPP client MUST terminate the DSKPP protocol run if either MAC
   does not verify, and MUST, in this case, also delete any nonces,
   keys, and/or secrets associated with the failed run of the protocol.
   If <KeyProvServerFinished> has Status = "Success" and the MACs were
   verified, then the DSKPP client MUST extract the key data from the
   provided key package, and store data locally.  After this operation,
   it MUST NOT be possible to overwrite the key unless knowledge of an
   authorizing key is proven through a MAC on a later
   <KeyProvServerFinished> message.

3.5.2.  Key Protection Profiles

   This section introduces three profiles of two-pass DSKPP for key
   protection.  Further profiles MAY be defined by external entities or
   through the IETF process.

3.5.2.1.  Key Transport Profile

   This profile establishes a symmetric key, K_TOKEN, in the
   cryptographic module using key transport and key derivation.  Key
   transport is carried out using a public key whose private key part
   resides in the cryptographic module as the key transport key.  A
   provisioning master key, K_PROV, MUST be transported from the DSKPP
   server to the client.  From K_PROV, two keys are derived: the
   symmetric key to be established, K_TOKEN, and a key used to compute
   MACs, K_MAC.

   This profile MUST be identified with the following URN:
   urn:ietf:params:xml:schema:keyprov:dskpp#transport

   In the two-pass version of DSKPP, the client MUST send a payload with
   the Key Transport Profile.  This payload MUST be of type <ds:
   KeyInfoType> ([XMLDSIG]), and only those choices of <ds:KeyInfoType>
   that identify a public key are allowed (i.e., <ds:KeyName>, <ds:
   KeyValue>, <ds:X509Data>, or <ds:PGPData>).  The <ds:X509Certificate>
   option of the <ds:X509Data> alternative is RECOMMENDED when the
   public key corresponding to the private key on the cryptographic
   module has been certified.

   The server payload associated with this key protection method MUST be
   of type <xenc:EncryptedKeyType> ([XMLENC]), and only those encryption
   methods utilizing a public key that are supported by the DSKPP client
   (as indicated in the <SupportedEncryptionAlgorithms> element of the



Doherty, et al.            Expires May 7, 2009                 [Page 33]


Internet-Draft                    DSKPP                    November 2008


   <KeyProvClientHello> message in the case of 2-pass DSKPP) are allowed
   as values for the <xenc:EncryptionMethod>.  Further, in the case of
   2-pass DSKPP, <ds:KeyInfo> MUST contain the same value (i.e. identify
   the same public key) as the <Payload> of the corresponding supported
   key protection method in the <KeyProvClientHello> message that
   triggered the response. <xenc:CarriedKeyName> MAY be present, but
   MUST, when present, contain the same value as the <KeyID> element of
   the <KeyProvServerFinished> message.  The Type attribute of the
   <xenc:EncryptedKeyType> MUST be present and MUST identify the type of
   the wrapped key.  The type MUST be one of the types supported by the
   DSKPP client (as reported in the <SupportedKeyTypes> of the preceding
   <KeyProvClientHello> message in the case of 2-pass DSKPP).  The
   transported key, K_PROV, MUST consist of two parts of equal length.
   The first half constitutes K_MAC and the second half constitutes
   K_TOKEN.  The length of K_TOKEN (and hence also the length of K_MAC)
   is determined by the type of K_TOKEN.

   DSKPP servers and cryptographic modules supporting this profile MUST
   support the http://www.w3.org/2001/04/xmlenc#rsa-1_5 key wrapping
   mechanism defined in [XMLENC].

   When this profile is used, the MacAlgorithm attribute of the <Mac>
   element of the <KeyProvServerFinished> message MUST be present and
   MUST identify the selected MAC algorithm.  The selected MAC algorithm
   MUST be one of the MAC algorithms supported by the DSKPP client (as
   indicated in the <SupportedMacAlgorithms> element of the
   <KeyProvClientHello> message in the case of 2-pass DSKPP).  The MAC
   MUST be calculated as described in Section 3.5.3 for two-pass DSKPP.

   In addition, DSKPP servers MUST include the AuthenticationDataType
   element in their <KeyProvServerFinished> messages whenever a
   successful protocol run will result in an existing K_TOKEN being
   replaced.

3.5.2.2.  Key Wrap Profile

   This profile establishes a symmetric key, K_TOKEN, in the
   cryptographic module through key wrap and key derivation.  Key wrap
   is carried out using a symmetric key wrapping key, known in advance
   by both the cryptographic module and the DSKPP server.  A
   provisioning master key, K_PROV, MUST be transported from the DSKPP
   server to the client.  From K_PROV, two keys are derived: the
   symmetric key to be established, K_TOKEN, and a key used to compute
   MACs, K_MAC.

   This profile MUST be identified with the following URI:
   urn:ietf:params:xml:schema:keyprov:dskpp#wrap




Doherty, et al.            Expires May 7, 2009                 [Page 34]


Internet-Draft                    DSKPP                    November 2008


   In the 2-pass version of DSKPP, the client MUST send a payload with
   the Key Wrap Profile.  This payload MUST be of type <ds:KeyInfoType>
   ([XMLDSIG]), and only those choices of <ds:KeyInfoType> that identify
   a symmetric key are allowed (i.e., <ds:KeyName> and <ds:KeyValue>).
   The <ds:KeyName> alternative is RECOMMENDED.

   The server payload associated with this key protection method MUST be
   of type <xenc:EncryptedKeyType> ([XMLENC]), and only those encryption
   methods utilizing a symmetric key that are supported by the DSKPP
   client (as indicated in the <SupportedEncryptionAlgorithms> element
   of the <KeyProvClientHello> message in the case of 2-pass DSKPP) are
   allowed as values for the <xenc:EncryptionMethod>.  Further, in the
   case of 2-pass DSKPP, <ds:KeyInfo> MUST contain the same value (i.e.
   identify the same symmetric key) as the <Payload> of the
   corresponding supported key protection method in the
   <KeyProvClientHello> message that triggered the response. <xenc:
   CarriedKeyName> MAY be present, and MUST, when present, contain the
   same value as the <KeyID> element of the <KeyProvServerFinished>
   message.  The Type attribute of the <xenc:EncryptedKeyType> MUST be
   present and MUST identify the type of the wrapped key.  The type MUST
   be one of the types supported by the DSKPP client (as reported in the
   <SupportedKeyTypes> of the preceding <KeyProvClientHello> message in
   the case of 2-pass DSKPP).  The wrapped key, K_PROV, MUST consist of
   two parts of equal length.  The first half constitutes K_MAC and the
   second half constitutes K_TOKEN.  The length of K_TOKEN (and hence
   also the length of K_MAC) is determined by the type of K_TOKEN.

   DSKPP servers and cryptographic modules supporting this profile MUST
   support the http://www.w3.org/2001/04/xmlenc#kw-aes128 key wrapping
   mechanism defined in [XMLENC].

   When this profile is used, the MacAlgorithm attribute of the <Mac>
   element of the <KeyProvServerFinished> message MUST be present and
   MUST identify the selected MAC algorithm.  The selected MAC algorithm
   MUST be one of the MAC algorithms supported by the DSKPP client (as
   indicated in the <SupportedMacAlgorithms> element of the
   <KeyProvClientHello> message in the case of 2-pass DSKPP).  The MAC
   MUST be calculated as described in Section 3.5.3.

   In addition, DSKPP servers MUST include the AuthenticationDataType
   element in their <KeyProvServerFinished> messages whenever a
   successful protocol run will result in an existing K_TOKEN being
   replaced.

3.5.2.3.  Passphrase-Based Key Wrap Profile

   This profile is a variation of the key wrap profile.  It establishes
   a symmetric key, K_TOKEN, in the cryptographic module through key



Doherty, et al.            Expires May 7, 2009                 [Page 35]


Internet-Draft                    DSKPP                    November 2008


   wrap and key derivation.  Key wrap is carried out using a passphrase-
   derived key wrapping key.  The passphrase is known in advance by both
   the user of the device and the DSKPP server.  To preserve the
   property of not exposing K_TOKEN to any other entity than the DSKPP
   server and the cryptographic module itself, the method SHOULD be
   employed only when the device contains facilities (e.g. a keypad) for
   direct entry of the passphrase.  A provisioning master key, K_PROV,
   MUST be transported from the DSKPP server to the client.  From
   K_PROV, two keys are derived: the symmetric key to be established,
   K_TOKEN, and a key used to compute MACs, K_MAC.

   This profile MUST be identified with the following URI:
   urn:ietf:params:xml:schema:keyprov:dskpp#passphrase-wrap

   In the 2-pass version of DSKPP, the client MUST send a payload with
   the Passphrase-Based Key Wrap Profile.  This payload MUST be of type
   <ds:KeyInfoType> ([XMLDSIG]).  The <ds:KeyName> option MUST be used
   and the key name MUST identify the passphrase that will be used by
   the server to generate the key wrapping key.  As an example, the
   identifier could be a user identifier or a registration identifier
   issued by the server to the user during a session preceding the DSKPP
   protocol run.

   The server payload associated with this key protection method MUST be
   of type <xenc:EncryptedKeyType> ([XMLENC]), and only those encryption
   methods utilizing a passphrase to derive the key wrapping key that
   are supported by the DSKPP client (as indicated in the
   <SupportedEncryptionAlgorithms> element of the <KeyProvClientHello>
   message in the case of 2-pass DSKPP) are allowed as values for the
   <xenc:EncryptionMethod>.  Further, in the case of 2-pass DSKPP, <ds:
   KeyInfo> MUST contain the same value (i.e. identify the same
   passphrase) as the <Payload> of the corresponding supported key
   protection method in the <KeyProvClientHello> message that triggered
   the response. <xenc:CarriedKeyName> MAY be present, and MUST, when
   present, contain the same value as the <KeyID> element of the
   <KeyProvServerFinished> message.  The Type attribute of the <xenc:
   EncryptedKeyType> MUST be present and MUST identify the type of the
   wrapped key.  The type MUST be one of the types supported by the
   DSKPP client (as reported in the <SupportedKeyTypes> of the preceding
   <KeyProvClientHello> message in the case of 2-pass DSKPP).  The
   wrapped key, K_PROV, MUST consist of two parts of equal length.  The
   first half constitutes K_MAC and the second half constitutes K_TOKEN.
   The length of K_TOKEN (and hence also the length of K_MAC) is
   determined by the type of K_TOKEN.

   DSKPP servers and cryptographic modules supporting this profile MUST
   support the PBES2 password based encryption scheme defined in
   [PKCS-5] (and identified as



Doherty, et al.            Expires May 7, 2009                 [Page 36]


Internet-Draft                    DSKPP                    November 2008


   http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2 in
   [PKCS-5-XML]), the PBKDF2 passphrase-based key derivation function
   also defined in [PKCS-5] (and identified as
   http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbkdf2 in
   [PKCS-5-XML]), and the http://www.w3.org/2001/04/xmlenc#kw-aes128 key
   wrapping mechanism defined in [XMLENC].

   When this profile is used, the MacAlgorithm attribute of the <Mac>
   element of the <KeyProvServerFinished> message MUST be present and
   MUST identify the selected MAC algorithm.  The selected MAC algorithm
   MUST be one of the MAC algorithms supported by the DSKPP client (as
   indicated in the <SupportedMacAlgorithms> element of the
   <KeyProvClientHello> message in the case of 2-pass DSKPP).  The MAC
   MUST be calculated as described in Section 3.5.3.

   In addition, DSKPP servers MUST include the AuthenticationDataType
   element in their <KeyProvServerFinished> messages whenever a
   successful protocol run will result in an existing K_TOKEN being
   replaced.

3.5.3.  MAC Calculations

3.5.3.1.  Key Confirmation

   The MAC value in the <KeyProvServerFinished> message MUST be
   calculated as follows:

   msg_hash = SHA-256(msg_1, ..., msg_n)

   dsLen = len(msg_hash)

   MAC = DSKPP-PRF (K_MAC, "MAC 1 computation" || msg_hash || ServerID,
   dsLen)

   where

   MAC         The MAC MUST be calculated using the already established
               MAC algorithm and MUST be computed on the (ASCII) string
               "MAC 1 computation", msg_hash, and ServerID using the
               existing the MAC key K_MAC.

   K_MAC       The key, along with K_TOKEN, that is derived from K_PROV
               which the DSKPP server MUST provide to the cryptographic
               module.







Doherty, et al.            Expires May 7, 2009                 [Page 37]


Internet-Draft                    DSKPP                    November 2008


   msg_hash    The message hash, defined in Section 3.4.4.3, of messages
               msg_1, ..., msg_n.

   ServerID    The identifier that the DSKPP server MUST include in the
               <KeyPackage> element of <KeyProvServerFinished>.

   If DSKPP-PRF (defined in Section 3.3.1) is used as the MAC algorithm,
   then the input parameter s MUST consist of the concatenation of the
   (ASCII) string "MAC 1 computation", msg_hash, and ServerID, and the
   parameter dsLen MUST be set to the length of msg_hash.

3.5.3.2.  Server Authentication in the Case of Key Renewal

   A second MAC MUST be present in the <KeyProvServerFinished> message
   as proof that the DSKPP server is authorized to replace a key on the
   cryptographic module.  In 2-pass DSKPP, servers provide the second
   MAC in the AuthenticationDataType element of <KeyProvServerFinished>.
   The MAC value in the AuthenticationDataType element MUST be computed
   on the (ASCII) string "MAC 2 computation", the server identifier
   ServerID, and R, using a pre-existing MAC key K_MAC' (the MAC key
   that existed before this protocol run).  Note that the implementation
   may specify K_MAC' to be the value of the K_TOKEN that is being
   replaced, or a version of K_MAC from the previous protocol run.

   If DSKPP-PRF is used as the MAC algorithm, then the input parameter s
   MUST consist of the concatenation of the (ASCII) string "MAC 2
   computation" ServerID, and R. The parameter dsLen MUST be set to at
   least 16 (i.e. the length of the MAC MUST be at least 16 octets):

   dsLen >= 16

   MAC = DSKPP-PRF (K_MAC', "MAC 2 computation" || ServerID || R, dsLen)

   The MAC algorithm MUST be the same as the algorithm used for key
   confirmation purposes.

3.6.  Device Identification

   The DSKPP server MAY be pre-configured with a unique device
   identifier corresponding to a particular cryptographic module.  The
   DSKPP server MAY then include this identifier in the DSKPP
   initialization trigger, in which case the DSKPP client MUST include
   it in its message(s) to the DSKPP server for authentication.  Note
   that it is also legitimate for a DSKPP client to initiate the DSKPP
   protocol run without having received an initialization message from a
   server, but in this case any provided device identifier MUST NOT be
   accepted by the DSKPP server unless the server has access to a unique
   key for the identified device and that key will be used in the



Doherty, et al.            Expires May 7, 2009                 [Page 38]


Internet-Draft                    DSKPP                    November 2008


   protocol.

3.7.  User Authentication

   The DSKPP server MUST ensure that a generated key is associated with
   the correct cryptographic module, and if applicable, the correct
   user.  If the user has not been authenticated by some out-of-band
   means, then the user SHOULD be authenticated within the DSKPP.  When
   relying on DSKPP for user authentication, the DSKPP server SHOULD
   explicitly rely on client-provided Authentication Data (AD) to verify
   that a legitimate user is behind the wheel.  For a further discussion
   of this, and threats related to man-in-the-middle attacks in this
   context, see Section 9.6.4.

3.7.1.  Authentication Data

   As described in the message flows above (see Section 3.4.1 and
   Section 3.5.1), the DSKPP client MAY include Authentication Data (AD)
   in its request(s).  Note that AD MAY be omitted if client certificate
   authentication has been provided by the transport channel such as
   TLS.  Nonetheless, when AD is provided, the DSKPP server MUST verify
   the data before continuing with the protocol run.

   The data element that holds AD MUST include a Client ID and a value
   derived from an Authentication Code (AC).  The Client ID represents a
   key request made by the user to the Provisioning Server.  AC is a
   one-time use value that is a (potentially low entropy) shared secret
   between a user and the Provisioning Server.  This secret is made
   available to the client before the DSKPP message exchange.  Below are
   examples of how the DSKPP client may obtain the AC:

   a.  A key issuer may deliver an AC to the user or device in response
       to a key request, which the user enters into an application
       hosted on their device.  For example, a user runs an application
       that is resident on their device, e.g., a mobile phone.  The
       application cannot proceed without a new symmetric key.  The user
       is redirected to an issuer's Web site from where the user
       requests a key.  The issuer's Web application processes the
       request, and returns an AC, which then appears on the user's
       display.  The user then invokes a symmetric key-based application
       hosted on the device, which asks the user to input the AC using a
       keypad.  The application invokes the DSKPP client, providing it
       with the AC.
   b.  The provisioning server may send a trigger message,
       <KeyProvTrigger>, to the DSKPP client, which sets the value of
       the trigger nonce, R_TRIGGER, to AC.  When this method is used, a
       transport providing confidentiality and integrity MUST be used to
       deliver the DSKPP initialization trigger from the DSKPP server to



Doherty, et al.            Expires May 7, 2009                 [Page 39]


Internet-Draft                    DSKPP                    November 2008


       the DSKPP client, e.g., HTTPS.

   A description of the AC and how it is used to derive AD is contained
   in the sub-sections below.

3.7.2.  Authentication Code Format

   AC is encoded in Type-Length-Value (TLV) format.  The format consists
   of a minimum of two TLVs and a variable number of additional TLVs,
   depending on implementation.  See Figure 7 for TLV field layout.

   A 1 byte type field identifies the specific TLV, and a 1 byte length,
   in hexadecimal, indicates the length of the value field contained in
   the TLV.  A TLV MUST start on a 4 byte boundary.  Pad bytes MUST be
   placed at the end of the previous TLV in order to align the next TLV.
   These pad bytes are not counted in the length field of the TLV.

    0                   1                   2
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      Type     |     Length    |    Value[0]   |  ...Value[Length-1]
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                           Figure 7: TLV Format

   The TLV fields are defined as follows:

   Type (1 byte)             The integer value identifying the type of
                             information contained in the value field.

   Length (1 byte)           The length, in hexadecimal, of the value
                             field to follow.

   Value (variable length)   A variable-length hexadecimal value
                             containing the instance-specific
                             information for this TLV.

   Figure 8 summarizes the TLVs defined in this document.  Optional TLVs
   are allowed for vendor-specific extensions with the constraint that
   the high bit MUST be set to indicate a vendor-specific type.  Other
   TLVs are left for later revisions of this protocol.










Doherty, et al.            Expires May 7, 2009                 [Page 40]


Internet-Draft                    DSKPP                    November 2008


   +------+------------+-------------------------------------------+
   | Type | TLV Name   | Conformance | Example Usage               |
   +------+------------+-------------------------------------------+
   |  1   | Client ID  | Mandatory   | { "AC00000A" }              |
   +------+------------+-------------+-----------------------------+
   |  2   | Password   | Mandatory   | { "3582" }                  |
   +------+------------+-------------+-----------------------------+
   |  3   | Checksum   | Optional    | { 0x5F8D }                  |
   +------+------------+-------------+-----------------------------+

                           Figure 8: TLV Summary

3.7.2.1.  Client ID (MANDATORY)

   The Client ID is a mandatory TLV that represents the user's key
   request.  A summary of the Client ID TLV format is given in Figure 9.
   The fields are transmitted from left to right.

    0                   1                   2
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Type = 0x1    |     Length    | clientID ...                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                       Figure 9: ClientID TLV Format

   clientID is an ASCII string that identifies the key request.  The
   clientID MUST be HEX encoded.

   For example, suppose clientID is set to "AC00000A", the hexadecimal
   equivalent is 0x4143303030303041, resulting in a TLV of {0x1, 0x8,
   0x4143303030303041}.

3.7.2.2.  Password (MANDATORY)

   The Password is a mandatory TLV the contains a one-time use shared
   secret known by the user and the Provisioning Server.  A summary of
   the Password TLV format is given in Figure 10.  The fields are
   transmitted from left to right.












Doherty, et al.            Expires May 7, 2009                 [Page 41]


Internet-Draft                    DSKPP                    November 2008


    0                   1                   2
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Type = 0x2    |     Length    | password ...                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Figure 10: Password TLV Format

   Password is a unique value that SHOULD be a random string to make AC
   more difficult to guess.  The string MUST be UTF-8 encoded in
   accordance with [RFC3629].

   For example, suppose password is set to "3582", then the TLV would be
   {0x2, 0x4, UTF-8("3582")}.

3.7.2.3.  Checksum (OPTIONAL)

   The Checksum is an OPTIONAL TLV, which is generated by the issuing
   server and sent to the user as part of the AC.  A summary of the
   Checksum TLV format is given in Figure 11.  The fields are
   transmitted from left to right.

    0                   1                   2
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | Type = 0x3    |     Length    | checksum                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Figure 11: Checksum TLV Format

   If included, the checksum MUST be computed using the CRC16 algorithm
   [ISO3309].  When the user enters the AC, the typed password is
   verified with the checksum to ensure it is correctly entered by the
   user.

   For example, suppose the Password is set to "3582", then the CRC16
   calculation would generate a checksum of 0x5F8D, resulting in TLV
   {0x3, 0x2, 0x5F8D}.

3.7.3.  Authentication Data Calculation

   The Authentication Data consists of a Client ID (extracted from the
   AC) and a value, which is derived from AC as follows (refer to
   Section 3.3.1 for a description of DSKPP-PRF in general and
   Appendix C for a description of DSKPP-PRF-AES):

   MAC = DSKPP-PRF(K_AC, AC->clientID||URL_S||R_C||[R_S], 16)




Doherty, et al.            Expires May 7, 2009                 [Page 42]


Internet-Draft                    DSKPP                    November 2008


   In four-pass DSKPP, the cryptographic module uses R_C, R_S, and URL_S
   to calculate the MAC, where URL_S is the URL the DSKPP client uses
   when contacting the DSKPP server.  In two-pass DSKPP, the
   cryptographic module does not have access to R_S, therefore only R_C
   is used in combination with URL_S to produce the MAC.  In either
   case, K_AC MUST be derived from AC>password as follows [PKCS-5]:

   K_AC = PBKDF2(AC->password, R_C || K, iter_count, 16)

   One of the following values for K MUST be used:

   a.  In four-pass:
       *  The public key of the DSKPP server (K_SERVER), or (in the pre-
          shared key variant) the pre-shared key between the client and
          the server (K_SHARED)
   b.  In two-pass:
       *  The public key of the DSKPP client, or the public key of the
          device when a device certificate is available
       *  The pre-shared key between the client and the server
          (K_SHARED)
       *  A passphrase-derived key

   The iteration count, iter_count, MUST be set to at least 100,000
   except for case (b) and (c), above, in which case it MUST be set to
   1.


4.  DSKPP Message Formats

   The message formats from the DSKPP XML schema, found in Section 7,
   are explained in this section.  Examples can be found in Appendix A.
   The XML format for DSKPP messages has been designed to be extensible.
   However, it is possible that the use of extensions will harm
   interoperability; therefore, any use of extensions SHOULD be
   carefully considered.  For example, if a particular implementation
   relies on the presence of a proprietary extension, then it may not be
   able to interoperate with independent implementations that have no
   knowledge of this extension.

4.1.  General XML Schema Requirements

   Some DSKPP elements rely on the parties being able to compare
   received values with stored values.  Unless otherwise noted, all
   elements in this document that have the XML Schema "xs:string" type,
   or a type derived from it, MUST be compared using an exact binary
   comparison.  In particular, DSKPP implementations MUST NOT depend on
   case-insensitive string comparisons, normalization or trimming of
   white space, or conversion of locale-specific formats such as



Doherty, et al.            Expires May 7, 2009                 [Page 43]


Internet-Draft                    DSKPP                    November 2008


   numbers.

   Implementations that compare values that are represented using
   different character encodings MUST use a comparison method that
   returns the same result as converting both values to the Unicode
   character encoding, Normalization Form C [UNICODE], and then
   performing an exact binary comparison.

   No collation or sorting order for attributes or element values is
   defined.  Therefore, DSKPP implementations MUST NOT depend on
   specific sorting orders for values.

4.2.  Components of the <KeyProvTrigger> Message

   The DSKPP server MAY initialize the DSKPP protocol by sending a
   <KeyProvTrigger> message.  This message MAY, e.g., be sent in
   response to a user requesting key initialization in a browsing
   session.

































Doherty, et al.            Expires May 7, 2009                 [Page 44]


Internet-Draft                    DSKPP                    November 2008


   <xs:element name="KeyProvTrigger" type="dskpp:KeyProvTriggerType">
   </xs:element>
   <xs:complexType name="KeyProvTriggerType">
     <xs:sequence>
       <xs:choice>
         <xs:element name="InitializationTrigger"
           type="dskpp:InitializationTriggerType" />
         <xs:any namespace="##other" processContents="strict" />
       </xs:choice>
     </xs:sequence>
     <xs:attribute name="Version" type="dskpp:VersionType" />
   </xs:complexType>

   <xs:complexType name="InitializationTriggerType">
     <xs:sequence>
       <xs:element minOccurs="0" name="DeviceIdentifierData"
         type="dskpp:DeviceIdentifierDataType" />
       <xs:element minOccurs="0" name="KeyID" type="xs:base64Binary" />
       <xs:element minOccurs="0" name="TokenPlatformInfo"
         type="dskpp:TokenPlatformInfoType" />
       <xs:element name="TriggerNonce" type="dskpp:NonceType" />
       <xs:element minOccurs="0" name="ServerUrl" type="xs:anyURI" />
       <xs:any minOccurs="0" namespace="##other"
         processContents="strict" />
     </xs:sequence>
   </xs:complexType>

   The <KeyProvTrigger> element is intended for the DSKPP client and MAY
   inform the DSKPP client about the identifier for the device that
   houses the cryptographic module to be initialized, and optionally of
   the identifier for the key on that module.  The latter would apply to
   key renewal.  The trigger always contains a nonce to allow the DSKPP
   server to couple the trigger with a later DSKPP <KeyProvClientHello>
   request.  Finally, the trigger MAY contain a URL to use when
   contacting the DSKPP server.  The <xs:any> elements are for future
   extensibility.  Any provided <DeviceIdentifierData> or <KeyID> values
   MUST be used by the DSKPP client in the subsequent
   <KeyProvClientHello> request.  The OPTIONAL <TokenPlatformInfo>
   element informs the DSKPP client about the characteristics of the
   intended cryptographic module platform, and applies in the public-key
   variant of DSKPP in situations when the client potentially needs to
   decide which one of several modules to initialize.

4.3.  Components of the <KeyProvClientHello> Request

   This message is the initial message sent from the DSKPP client to the
   DSKPP server in both variations of the DSKPP.




Doherty, et al.            Expires May 7, 2009                 [Page 45]


Internet-Draft                    DSKPP                    November 2008


   <xs:element name="KeyProvClientHello"
     type="dskpp:KeyProvClientHelloPDU">
   </xs:element>

   <xs:complexType name="KeyProvClientHelloPDU">
     <xs:complexContent mixed="false">
       <xs:extension base="dskpp:AbstractRequestType">
         <xs:sequence>
           <xs:element minOccurs="0" name="DeviceIdentifierData"
             type="dskpp:DeviceIdentifierDataType" />
           <xs:element minOccurs="0" name="KeyID"
             type="xs:base64Binary" />
           <xs:element minOccurs="0" name="ClientNonce"
             type="dskpp:NonceType" />
           <xs:element minOccurs="0" name="TriggerNonce"
             type="dskpp:NonceType" />
           <xs:element name="SupportedKeyTypes"
             type="dskpp:AlgorithmsType" />
           <xs:element name="SupportedEncryptionAlgorithms"
             type="dskpp:AlgorithmsType" />
           <xs:element name="SupportedMacAlgorithms"
             type="dskpp:AlgorithmsType" />
           <xs:element minOccurs="0" name="SupportedProtocolVariants"
             type="dskpp:ProtocolVariantsType" />
           <xs:element minOccurs="0" name="SupportedKeyPackages"
             type="dskpp:KeyPackagesFormatType" />
           <xs:element minOccurs="0" name="AuthenticationData"
             type="dskpp:AuthenticationDataType" />
           <xs:element minOccurs="0" name="Extensions"
             type="dskpp:ExtensionsType" />
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   The components of this message have the following meaning:

   o  Version: (attribute inherited from the AbstractRequestType type)
      The highest version of this protocol the client supports.  Only
      version one ("1.0") is currently specified.
   o  <DeviceIdentifierData>: An identifier for the cryptographic module
      as defined in Section 3.7 above.  The identifier MUST only be
      present if such shared secrets exist or if the identifier was
      provided by the server in a <KeyProvTrigger> element (see
      Section 6.2.7).  In the latter case, it MUST have the same value
      as the identifier provided in that element.





Doherty, et al.            Expires May 7, 2009                 [Page 46]


Internet-Draft                    DSKPP                    November 2008


   o  <KeyID>: An identifier for the key that will be overwritten if the
      protocol run is successful.  The identifier MUST only be present
      if the key exists or if the identifier was provided by the server
      in a <KeyProvTrigger> element, in which case, it MUST have the
      same value as the identifier provided in that element (see a
      (Section 4.2) and Section 6.2.7).
   o  <ClientNonce>: This is the nonce R, which, when present, MUST be
      used by the server when calculating MAC values (see below).  It is
      RECOMMENDED that clients include this element whenever the <KeyID>
      element is present.
   o  <TriggerNonce>: This OPTIONAL element MUST be present if and only
      if the DSKPP run was initialized with a <KeyProvTrigger> message
      (see Section 6.2.7), and MUST, in that case, have the same value
      as the <TriggerNonce> child of that message.  A server using
      nonces in this way MUST verify that the nonce is valid and that
      any device or key identifier values provided in the
      <KeyProvTrigger> message match the corresponding identifier values
      in the <KeyProvClientHello> message.
   o  <SupportedKeyTypes>: A sequence of container elements that in turn
      contain URLs indicating the key types for which the cryptographic
      module is willing to generate keys through DSKPP.
   o  <SupportedEncryptionAlgorithms>: A sequence of container elements
      that in turn contain URLs indicating the encryption algorithms
      supported by the cryptographic module for the purposes of DSKPP.
      The DSKPP client MAY indicate the same algorithm both as a
      supported key type and as an encryption algorithm.
   o  <SupportedMacAlgorithms>: A sequence of container elements that in
      turn contain URLs indicating the MAC algorithms supported by the
      cryptographic module for the purposes of DSKPP.  The DSKPP client
      MAY indicate the same algorithm both as an encryption algorithm
      and as a MAC algorithm (e.g.,
      http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128, which is
      defined in Appendix C).
   o  <SupportedProtocolVariants>: This OPTIONAL element is used by the
      DSKPP client to indicate support for four-pass or two-pass DSKPP.
      If two-pass support is specified, then <KeyProvClientNonce> MUST
      be set to nonce R in the <KeyProvClientHello> message unless
      <TriggerNonce> is already present.
   o  <SupportedKeyPackages>: This OPTIONAL element is a sequence of
      container elements that in turn contain URLs indicating the key
      package formats supported by the DSKPP client.  If this element is
      not provided, then the DSKPP server MUST proceed with
      "http://www.ietf.org/keyprov/pskc#KeyContainer" (see [PSKC]).
   o  <AuthenticationData>: This OPTIONAL element contains data that the
      DSKPP client uses to authenticate the user or device to the DSKPP
      server.  The element is set as specified in Section 3.7.





Doherty, et al.            Expires May 7, 2009                 [Page 47]


Internet-Draft                    DSKPP                    November 2008


   o  <Extensions>: A sequence of OPTIONAL extensions.  One extension is
      defined for this message in this version of DSKPP: the
      ClientInfoType (see Section 5).

   Some of the core elements of the message are described below.

4.3.1.  The DeviceIdentifierDataType Type

   The DeviceIdentifierDataType type is used to uniquely identify the
   device that houses the cryptographic module, e.g., a mobile phone.
   The device identifier allows the DSKPP server to find, e.g., a pre-
   shared key transport key for 2-pass DSKPP and/or the correct shared
   secret for MAC'ing purposes.  The default DeviceIdentifierDataType is
   defined in [PSKC].

   <xs:complexType name="DeviceIdentifierDataType">
     <xs:choice>
       <xs:element name="DeviceId" type="pskc:DeviceIdType" />
       <xs:any namespace="##other" processContents="strict" />
     </xs:choice>
   </xs:complexType>

4.3.2.  The ProtocolVariantsType Type

   The ProtocolVariantsType is a complex type that is a sequence of
   elements, each describing a DSKPP protocol variant.  The DSKPP client
   MAY use the ProtocolVariantsType to identify which protocol variants
   it supports, i.e., by providing <SupportProtocolVariants> within a
   <KeyProvClientHello> message.

   Selecting the <FourPass> element signals client support for 4-pass
   DSKPP as described in Section 3.4.1.

   Selecting the <TwoPass> element signals client support for the 2-pass
   version of DSKPP as described in Section 3.5.1.  The <TwoPass>
   element is of type KeyProtectionDataType, which carries information
   that informs the server of supported two-pass key protection methods
   as described in Section 3.5.2, and provides OPTIONAL payload data to
   the DSKPP server.  The payload is sent in an opportunistic fashion,
   and MAY be discarded by the DSKPP server if the server does not
   support the key protection method with which the payload is
   associated.

   If the DSKPP client does not include <SupportedProtocolVariants> in
   the <KeyProvClientHello> message, then the DSKPP server MUST proceed
   by using the 4-pass DSKPP variant.  If the DSKPP server does not
   support 4-pass DSKPP, then the server MUST use the two-pass protocol
   variant.  If it cannot support the two-pass protocol variant, then



Doherty, et al.            Expires May 7, 2009                 [Page 48]


Internet-Draft                    DSKPP                    November 2008


   the protocol run MUST fail.

   <xs:complexType name="ProtocolVariantsType">
     <xs:sequence>
       <xs:element name="FourPass" minOccurs="0" />
       <xs:element name="TwoPass" type="dskpp:KeyProtectionDataType"
           minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="KeyProtectionDataType">
     <xs:sequence maxOccurs="unbounded">
         <xs:element name="SupportedKeyProtectionMethod" type="xs:anyURI"/>
         <xs:element name="Payload" type="dskpp:PayloadType" minOccurs="0"/>
     </xs:sequence>
   </xs:complexType>

   The elements of this type have the following meaning:

   o  <SupportedKeyProtectionMethod>: A two-pass key protection method
      supported by the DSKPP client.  Multiple supported methods MAY be
      present, in which case they MUST be listed in order of precedence.
   o  <Payload>: An OPTIONAL payload associated with each supported key
      protection method.

   A DSKPP client that indicates support for two-pass DSKPP MUST also
   include the nonce R in its <KeyProvClientHello> message (this will
   enable the client to verify that the DSKPP server it is communicating
   with is alive).

4.3.3.  The KeyPackagesFormatType Type

   The OPTIONAL KeyPackagesFormatType type is a list of type-value pairs
   that a DSKPP client or server MAY use to define key package formats
   it supports.  Key package formats are identified through URLs, e.g.,
   the PSKC KeyContainer URL
   "http://www.ietf.org/keyprov/pskc#KeyContainer" (see [PSKC]).














Doherty, et al.            Expires May 7, 2009                 [Page 49]


Internet-Draft                    DSKPP                    November 2008


   <xs:complexType name="KeyPackagesFormatType">
     <xs:sequence maxOccurs="unbounded">
       <xs:element name="KeyPackageFormat"
       type="dskpp:KeyPackageFormatType"/>
     </xs:sequence>

   </xs:complexType>
   <xs:simpleType name="KeyPackageFormatType">
     <xs:restriction base="xs:anyURI" />
   </xs:simpleType>

4.3.4.  The AuthenticationDataType Type

   The OPTIONAL AuthenticationDataType type is used by DSKPP clients to
   carry authentication values in DSKPP messages as described in
   Section 3.7.

   <xs:complexType name="AuthenticationDataType">
     <xs:sequence>
       <xs:element name="ClientID"
         type="dskpp:IdentifierType" />
       <xs:element name="AuthenticationCodeMac"
         type="dskpp:AuthenticationMacType" />
     </xs:sequence>
   </xs:complexType>

   <xs:complexType name="AuthenticationMacType">
     <xs:sequence>
       <xs:element minOccurs="0" name="Nonce" type="dskpp:NonceType" />
       <xs:element minOccurs="0" name="IterationCount" type="xs:int" />
       <xs:element name="Mac" type="dskpp:MacType" />
     </xs:sequence>
   </xs:complexType>

   The elements of the AuthenticationDataType type have the following
   meaning:

   o  <ClientID>: A requester's identifier of maximum length 128.  The
      value MAY be a user ID, a device ID, or a keyID associated with
      the requester's authentication value.
   o  <AuthenticationCodeMac>: An authentication MAC and additional
      information (e.g., MAC algorithm), derived as described in
      Section 3.7.3.

4.4.  Components of the <KeyProvServerHello> Response (Used Only in
      Four-Pass DSKPP)

   In a four-pass exchange, this message is the first message sent from



Doherty, et al.            Expires May 7, 2009                 [Page 50]


Internet-Draft                    DSKPP                    November 2008


   the DSKPP server to the DSKPP client (assuming a trigger message has
   not been sent to initiate the protocol, in which case, this message
   is the second message sent from the DSKPP server to the DSKPP
   client).  It is sent upon reception of a <KeyProvClientHello>
   message.

   <xs:element name="KeyProvServerHello"
     type="dskpp:KeyProvServerHelloPDU">
   </xs:element>
   <xs:complexType name="KeyProvServerHelloPDU">
     <xs:complexContent mixed="false">
       <xs:extension base="dskpp:AbstractResponseType">
         <xs:sequence minOccurs="0">
           <xs:element name="KeyType" type="dskpp:AlgorithmType" />
           <xs:element name="EncryptionAlgorithm"
             type="dskpp:AlgorithmType" />
           <xs:element name="MacAlgorithm" type="dskpp:AlgorithmType" />
           <xs:element name="EncryptionKey" type="ds:KeyInfoType" />
           <xs:element name="KeyPackageFormat"
             type="dskpp:KeyPackageFormatType" />
           <xs:element name="Payload" type="dskpp:PayloadType" />
           <xs:element minOccurs="0" name="Extensions"
             type="dskpp:ExtensionsType" />
           <xs:element minOccurs="0" name="Mac" type="dskpp:MacType" />
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   The components of this message have the following meaning:

   o  Version: (attribute inherited from the AbstractResponseType type)
      The version selected by the DSKPP server.  MAY be lower than the
      version indicated by the DSKPP client, in which case, local policy
      at the client MUST determine whether or not to continue the
      session.
   o  SessionID: (attribute inherited from the AbstractResponseType
      type) An identifier for this session.  The SessionID has a maximum
      length of 128.
   o  Status: (attribute inherited from the AbstractResponseType type)
      Return code for the <KeyProvClientHello>.  If Status is not
      "Continue", only the Status and Version attributes will be
      present; otherwise, all the other element MUST be present as well.
   o  <KeyType>: The type of the key to be generated.
   o  <EncryptionAlgorithm>: The encryption algorithm to use when
      protecting R_C.





Doherty, et al.            Expires May 7, 2009                 [Page 51]


Internet-Draft                    DSKPP                    November 2008


   o  <MacAlgorithm>: The MAC algorithm to be used by the DSKPP server.
   o  <EncryptionKey>: Information about the key to use when encrypting
      R_C. It will either be the server's public key (the <ds:KeyValue>
      alternative of ds:KeyInfoType) or an identifier for a shared
      secret key (the <ds:KeyName> alternative of ds:KeyInfoType).
   o  <KeyPackageFormat>: The key package format type to be used by the
      DSKPP server.  The default setting relies on the KeyPackageType
      element defined in "urn:ietf:params:xml:schema:keyprov:pskc"
      [PSKC].
   o  <Payload>: The actual payload.  For this version of the protocol,
      only one payload is defined: the pseudorandom string R_S.
   o  <Extensions>: A list of server extensions.  Two extensions are
      defined for this message in this version of DSKPP: the
      ClientInfoType and the ServerInfoType (see Section 5).
   o  <Mac>: The MAC MUST be present if the DSKPP run will result in the
      replacement of an existing symmetric key with a new one (i.e., if
      the <KeyID> element was present in the <ClientHello message).  In
      this case, the DSKPP server MUST prove to the cryptographic module
      that it is authorized to replace it.

4.5.  Components of a <KeyProvClientNonce> Request (Used Only in Four-
      Pass DSKPP)

   In a four-pass DSKPP exchange, this message contains the nonce R_C
   that was chosen by the cryptographic module, and encrypted by the
   negotiated encryption key and encryption algorithm.

























Doherty, et al.            Expires May 7, 2009                 [Page 52]


Internet-Draft                    DSKPP                    November 2008


   <xs:element name="KeyProvClientNonce"
     type="dskpp:KeyProvClientNoncePDU">
   </xs:element>
   <xs:complexType name="KeyProvClientNoncePDU">
     <xs:complexContent mixed="false">
       <xs:extension base="dskpp:AbstractRequestType">
         <xs:sequence>
           <xs:element name="EncryptedNonce" type="xs:base64Binary" />
           <xs:element minOccurs="0" name="AuthenticationData"
             type="dskpp:AuthenticationDataType" />
           <xs:element minOccurs="0" name="Extensions"
             type="dskpp:ExtensionsType" />
         </xs:sequence>
         <xs:attribute name="SessionID" type="dskpp:IdentifierType"
           use="required" />
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   The components of this message have the following meaning:

   o  Version: (inherited from the AbstractRequestType type) MUST be the
      same version as in the <KeyProvServerHello> message.
   o  <SessionID>: (attribute inherited from the AbstractResponseType
      type) MUST have the same value as the SessionID attribute in the
      received <KeyProvServerHello> message.  SessionID has maximum
      length of 128.
   o  <EncryptedNonce>: The nonce generated and encrypted by the
      cryptographic module.  The encryption MUST be made using the
      selected encryption algorithm and identified key, and as specified
      in Section 3.3.1.
   o  <AuthenticationData>: The authentication data value MUST be set as
      specified in Section 3.7 and Section 4.3.4.
   o  <Extensions>: A list of OPTIONAL extensions.  Two extensions are
      defined for this message in this version of DSKPP: the
      ClientInfoType and the ServerInfoType (see Section 5).

4.6.  Components of a <KeyProvServerFinished> Response

   This message is the last message of the DSKPP protocol run.  In a
   4-pass exchange, the DSKPP server sends this message in response to a
   <KeyProvClientNonce> message, whereas in a 2-pass exchange, the DSKPP
   server sends this message in response to a <KeyProvClientHello>
   message.







Doherty, et al.            Expires May 7, 2009                 [Page 53]


Internet-Draft                    DSKPP                    November 2008


   <xs:element name="KeyProvServerFinished"
     type="dskpp:KeyProvServerFinishedPDU">
   </xs:element>
   <xs:complexType name="KeyProvServerFinishedPDU">
     <xs:complexContent mixed="false">
       <xs:extension base="dskpp:AbstractResponseType">
         <xs:sequence minOccurs="0">
           <xs:element name="KeyPackage"
             type="dskpp:KeyPackageType" />
           <xs:element minOccurs="0" name="Extensions"
             type="dskpp:ExtensionsType" />
           <xs:element name="Mac" type="dskpp:MacType" />
           <xs:element minOccurs="0" name="AuthenticationData"
             type="dskpp:AuthenticationMacType" />
         </xs:sequence>
       </xs:extension>
     </xs:complexContent>
   </xs:complexType>

   The components of this message have the following meaning:

   o  Version: (inherited from the AbstractResponseType type) The DSKPP
      version used in this session.
   o  SessionID: (inherited from the AbstractResponseType type) The
      previously established identifier for this session.  The SessionID
      is of maximum length 128.
   o  Status: (inherited from the AbstractResponseType type) Return code
      for the <KeyProvServerFinished> message.  If Status is not
      "Success", only the Status, SessionID, and Version attributes will
      be present (the presence of the SessionID attribute is dependent
      on the type of reported error); otherwise, all the other elements
      MUST be present as well.  In this latter case, the
      <KeyProvServerFinished> message can be seen as a "Commit" message,
      instructing the cryptographic module to store the generated key
      and associate the given key identifier with this key.
   o  <KeyPackage>: The key package containing keying material in
      accordance with four- and two-pass DSKPP usage (see Section 3.4
      and Section 3.5).  The default package format is based on the
      KeyContainerType type from PSKC, as defined in [PSKC].
   o  <Extensions>: A list of extensions chosen by the DSKPP server.
      For this message, this version of DSKPP defines one extension, the
      ClientInfoType (see Section 5).
   o  <Mac>: To avoid a false "Commit" message causing the cryptographic
      module to end up in an initialized state for which the server does
      not know the stored key, <KeyProvServerFinished> messages MUST
      always be authenticated with a MAC.  The MAC MUST be made using
      the already established MAC algorithm.




Doherty, et al.            Expires May 7, 2009                 [Page 54]


Internet-Draft                    DSKPP                    November 2008


   o  <AuthenticationData>: This OPTIONAL element contains a MAC value
      that the DSKPP server provides in a two-pass message exchange as
      proof that the server is authorized to replace a key on the
      cryptographic module.  The MAC MUST be calculated as specified in
      Section 3.5.3.2.

4.7.  The StatusCode Type

   The StatusCode type enumerates all possible return codes:

   <xs:simpleType name="StatusCode">
     <xs:restriction base="xs:string">
       <xs:enumeration value="Continue" />
       <xs:enumeration value="Success" />
       <xs:enumeration value="Abort" />
       <xs:enumeration value="AccessDenied" />
       <xs:enumeration value="MalformedRequest" />
       <xs:enumeration value="UnknownRequest" />
       <xs:enumeration value="UnknownCriticalExtension" />
       <xs:enumeration value="UnsupportedVersion" />
       <xs:enumeration value="NoSupportedKeyTypes" />
       <xs:enumeration value="NoSupportedEncryptionAlgorithms" />
       <xs:enumeration value="NoSupportedMacAlgorithms" />
       <xs:enumeration value="NoProtocolVariants" />
       <xs:enumeration value="NoSupportedKeyPackages" />
       <xs:enumeration value="AuthenticationDataMissing" />
       <xs:enumeration value="AuthenticationDataInvalid" />
       <xs:enumeration value="InitializationFailed" />
     </xs:restriction>
   </xs:simpleType>

   Upon transmission or receipt of a message for which the Status
   attribute's value is not "Success" or "Continue", the default
   behavior, unless explicitly stated otherwise below, is that both the
   DSKPP server and the DSKPP client MUST immediately terminate the
   DSKPP protocol run.  DSKPP servers and DSKPP clients MUST delete any
   secret values generated as a result of failed runs of the DSKPP
   protocol.  Session identifiers MAY be retained from successful or
   failed protocol runs for replay detection purposes, but such retained
   identifiers MUST NOT be reused for subsequent runs of the protocol.

   When possible, the DSKPP client SHOULD present an appropriate error
   message to the user.

   These status codes are valid in all DSKPP Response messages unless
   explicitly stated otherwise:





Doherty, et al.            Expires May 7, 2009                 [Page 55]


Internet-Draft                    DSKPP                    November 2008


   o  "Continue" indicates that the DSKPP server is ready for a
      subsequent request from the DSKPP client.  It cannot be sent in
      the server's final message.
   o  "Success" indicates successful completion of the DSKPP session.
      It can only be sent in the server's final message.
   o  "Abort" indicates that the DSKPP server rejected the DSKPP
      client's request for unspecified reasons.
   o  "AccessDenied" indicates that the DSKPP client is not authorized
      to contact this DSKPP server.
   o  "MalformedRequest" indicates that the DSKPP server failed to parse
      the DSKPP client's request.
   o  "UnknownRequest" indicates that the DSKPP client made a request
      that is unknown to the DSKPP server.
   o  "UnknownCriticalExtension" indicates that a critical DSKPP
      extension (see below) used by the DSKPP client was not supported
      or recognized by the DSKPP server.
   o  "UnsupportedVersion" indicates that the DSKPP client used a DSKPP
      protocol version not supported by the DSKPP server.  This error is
      only valid in the DSKPP server's first response message.
   o  "NoSupportedKeyTypes" indicates that the DSKPP client only
      suggested key types that are not supported by the DSKPP server.
      This error is only valid in the DSKPP server's first response
      message.
   o  "NoSupportedEncryptionAlgorithms" indicates that the DSKPP client
      only suggested encryption algorithms that are not supported by the
      DSKPP server.  This error is only valid in the DSKPP server's
      first response message.
   o  "NoSupportedMacAlgorithms" indicates that the DSKPP client only
      suggested MAC algorithms that are not supported by the DSKPP
      server.  This error is only valid in the DSKPP server's first
      response message.
   o  "NoProtocolVariants" indicates that the DSKPP client only
      suggested a protocol variation (either 2-pass or 4-pass) that is
      not supported by the DSKPP server.  This error is only valid in
      the DSKPP server's first response message.
   o  "NoSupportedKeyPackages" indicates that the DSKPP client only
      suggested key package formats that are not supported by the DSKPP
      server.  This error is only valid in the DSKPP server's first
      response message.
   o  "AuthenticationDataMissing" indicates that the DSKPP client didn't
      provide authentication data that the DSKPP server required.
   o  "AuthenticationDataInvalid" indicates that the DSKPP client
      supplied user authentication data that the DSKPP server failed to
      validate.
   o  "InitializationFailed" indicates that the DSKPP server could not
      generate a valid key given the provided data.  When this status
      code is received, the DSKPP client SHOULD try to restart DSKPP, as
      it is possible that a new run will succeed.



Doherty, et al.            Expires May 7, 2009                 [Page 56]


Internet-Draft                    DSKPP                    November 2008


   o  "ProvisioningPeriodExpired" indicates that the provisioning period
      set by the DSKPP server has expired.  When the status code is
      received, the DSKPP client SHOULD report the reason for key
      initialization failure to the user and the user MUST register with
      the DSKPP server to initialize a new key.


5.  Protocol Extensions

5.1.  The ClientInfoType Type

   Present in a <KeyProvClientHello> or a <KeyProvClientNonce> message,
   the OPTIONAL ClientInfoType extension contains DSKPP client-specific
   information that is custom to an implementation.  DSKPP servers MUST
   support this extension.  DSKPP servers MUST NOT attempt to interpret
   the data it carries and, if received, MUST include it unmodified in
   the current protocol run's next server response.  Servers need not
   retain the ClientInfoType's data after that response has been
   generated.

5.2.  The ServerInfoType Type

   When present, the OPTIONAL ServerInfoType extension contains DSKPP
   server-specific information that is custom to an implementation.
   This extension is only valid in <KeyProvServerHello> messages for
   which Status = "Continue".  DSKPP clients MUST support this
   extension.  DSKPP clients MUST NOT attempt to interpret the data it
   carries and, if received, MUST include it unmodified in the current
   protocol run's next client request (i.e., the <KeyProvClientNonce>
   message).  DSKPP clients need not retain the ServerInfoType's data
   after that request has been generated.  This extension MAY be used,
   e.g., for state management in the DSKPP server.


6.  Protocol Bindings

6.1.  General Requirements

   DSKPP assumes a reliable transport.

6.2.  HTTP/1.1 Binding for DSKPP

6.2.1.  Introduction

   This section presents a binding of the previous messages to HTTP/1.1
   [RFC2616].  Note that the HTTP client normally will be different from
   the DSKPP client, i.e., the HTTP client will only exist to "proxy"
   DSKPP messages from the DSKPP client to the DSKPP server.  Likewise,



Doherty, et al.            Expires May 7, 2009                 [Page 57]


Internet-Draft                    DSKPP                    November 2008


   on the HTTP server side, the DSKPP server MAY receive DSKPP PDUs from
   a "front-end" HTTP server.  The DSKPP server will be identified by a
   specific URL, which may be pre-configured, or provided to the client
   during initialization.

6.2.2.  Identification of DSKPP Messages

   The MIME-type for all DSKPP messages MUST be

   application/vnd.ietf.keyprov.dskpp+xml

6.2.3.  HTTP Headers

   In order to avoid caching of responses carrying DSKPP messages by
   proxies, the following holds:

   o  When using HTTP/1.1, requesters SHOULD:
      *  Include a Cache-Control header field set to "no-cache, no-
         store".
      *  Include a Pragma header field set to "no-cache".

   o  When using HTTP/1.1, responders SHOULD:
      *  Include a Cache-Control header field set to "no-cache, no-must-
         revalidate, private".
      *  Include a Pragma header field set to "no-cache".
      *  NOT include a Validator, such as a Last-Modified or ETag
         header.

   To handle content negotiation, HTTP requests MAY include an HTTP
   Accept header field.  This header field SHOULD have the value
   application/vnd.ietf.keyprov.dskpp+xml as defined in Section 6.2.2.
   The Accept header MAY include additional content types defined by
   future versions of this protocol.

   There are no other restrictions on HTTP headers, besides the
   requirement to set the Content-Type header value according to
   Section 6.2.2.

6.2.4.  HTTP Operations

   Persistent connections as defined in HTTP/1.1 are OPTIONAL.  DSKPP
   requests are mapped to HTTP requests with the POST method.  DSKPP
   responses are mapped to HTTP responses.

   For the 4-pass DSKPP, messages within the protocol run are bound
   together.  In particular, <KeyProvServerHello> is bound to the
   preceding <KeyProvClientHello> by being transmitted in the
   corresponding HTTP response. <KeyProvServerHello> MUST have a



Doherty, et al.            Expires May 7, 2009                 [Page 58]


Internet-Draft                    DSKPP                    November 2008


   SessionID attribute, and the SessionID attribute of the subsequent
   <KeyProvClientNonce> message MUST be identical.
   <KeyProvServerFinished> is then once again bound to the rest through
   HTTP (and possibly through a SessionID).

6.2.5.  HTTP Status Codes

   A DSKPP HTTP responder that refuses to perform a message exchange
   with a DSKPP HTTP requester SHOULD return a 403 (Forbidden) response.
   In this case, the content of the HTTP body is not significant.  In
   the case of an HTTP error while processing a DSKPP request, the HTTP
   server MUST return a 500 (Internal Server Error) response.  This type
   of error SHOULD be returned for HTTP-related errors detected before
   control is passed to the DSKPP processor, or when the DSKPP processor
   reports an internal error (for example, the DSKPP XML namespace is
   incorrect, or the DSKPP schema cannot be located).  If a request is
   received that is not a DSKPP client message, the DSKPP responder MUST
   return a 400 (Bad request) response.

   In these cases (i.e., when the HTTP response code is 4xx or 5xx), the
   content of the HTTP body is not significant.

   Redirection status codes (3xx) apply as usual.

   Whenever the HTTP POST is successfully invoked, the DSKPP HTTP
   responder MUST use the 200 status code and provide a suitable DSKPP
   message (possibly with DSKPP error information included) in the HTTP
   body.

6.2.6.  HTTP Authentication

   No support for HTTP/1.1 authentication is assumed.

6.2.7.  Initialization of DSKPP

   If a user requests key initialization in a browsing session, and if
   that request has an appropriate Accept header (e.g., to a specific
   DSKPP server URL), the DSKPP server MAY respond by sending a DSKPP
   initialization message in an HTTP response with Content-Type set
   according to Section 6.2.2 and response code set to 200 (OK).  The
   initialization message MAY carry data in its body, such as the URL
   for the DSKPP client to use when contacting the DSKPP server.  If the
   message does carry data, the data MUST be a valid instance of a
   <KeyProvTrigger> element.

   Note that if the user's request was directed to some other resource,
   the DSKPP server MUST NOT respond by combining the DSKPP content type
   with response code 200.  In that case, the DSKPP server SHOULD



Doherty, et al.            Expires May 7, 2009                 [Page 59]


Internet-Draft                    DSKPP                    November 2008


   respond by sending a DSKPP initialization message in an HTTP response
   with Content-Type set according to Section 6.2.2 and response code
   set to 406 (Not Acceptable).

6.2.8.  Example Messages

   a.  Initialization from DSKPP server:
       HTTP/1.1 200 OK

       Cache-Control: no-store
       Content-Type: application/vnd.ietf.keyprov.dskpp+xml
       Content-Length: <some value>

       DSKPP initialization data in XML form...

   b.  Initial request from DSKPP client:
       POST http://example.com/cgi-bin/DSKPP-server HTTP/1.1

       Cache-Control: no-cache, no-store
       Pragma: no-cache
       Host: www.example.com
       Content-Type: application/vnd.ietf.keyprov.dskpp+xml
       Content-Length: <some value>

       DSKPP data in XML form (supported version, supported
       algorithms...)

   c.  Initial response from DSKPP server:
       HTTP/1.1 200 OK

       Cache-Control: no-cache, no-must-revalidate, private
       Pragma: no-cache
       Content-Type: application/vnd.ietf.keyprov.dskpp+xml
       Content-Length: <some value>

       DSKPP data in XML form (server random nonce, server public key,
       ...)


7.  DSKPP Schema

   <?xml version="1.0" encoding="utf-8"?>

   <xs:schema
      xmlns:xs="http://www.w3.org/2001/XMLSchema"
      xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
      xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
      xmlns:ds="http://www.w3.org/2000/09/xmldsig#"



Doherty, et al.            Expires May 7, 2009                 [Page 60]


Internet-Draft                    DSKPP                    November 2008


      targetNamespace="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
      elementFormDefault="qualified" attributeFormDefault="unqualified"
         version="1.0">
      <xs:import namespace="http://www.w3.org/2000/09/xmldsig#"
         schemaLocation=
         "http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/xmldsig-core-schema.xsd"/>
      <xs:import namespace="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
         schemaLocation="keyprov-pskc-1.0.xsd"/>
      <xs:complexType name="AbstractRequestType" abstract="true">
         <xs:annotation>
            <xs:documentation> Basic types </xs:documentation>
         </xs:annotation>
         <xs:attribute name="Version" type="dskpp:VersionType"
            use="required"/>
      </xs:complexType>

      <xs:complexType name="AbstractResponseType" abstract="true">
         <xs:annotation>
            <xs:documentation> Basic types </xs:documentation>
         </xs:annotation>
         <xs:attribute name="Version" type="dskpp:VersionType"
            use="required"/>
         <xs:attribute name="SessionID" type="dskpp:IdentifierType" />
         <xs:attribute name="Status" type="dskpp:StatusCode" use="required"/>
      </xs:complexType>

      <xs:simpleType name="VersionType">
         <xs:restriction base="xs:string">
            <xs:pattern value="\d{1,2}\.\d{1,3}" />
         </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="IdentifierType">
         <xs:restriction base="xs:string">
            <xs:maxLength value="128" />
         </xs:restriction>
      </xs:simpleType>

      <xs:simpleType name="StatusCode">
         <xs:restriction base="xs:string">
            <xs:enumeration value="Continue" />
            <xs:enumeration value="Success" />
            <xs:enumeration value="Abort" />
            <xs:enumeration value="AccessDenied" />
            <xs:enumeration value="MalformedRequest" />
            <xs:enumeration value="UnknownRequest" />
            <xs:enumeration value="UnknownCriticalExtension" />
            <xs:enumeration value="UnsupportedVersion" />



Doherty, et al.            Expires May 7, 2009                 [Page 61]


Internet-Draft                    DSKPP                    November 2008


            <xs:enumeration value="NoSupportedKeyTypes" />
            <xs:enumeration value="NoSupportedEncryptionAlgorithms" />
            <xs:enumeration value="NoSupportedMacAlgorithms" />
            <xs:enumeration value="NoProtocolVariants" />
            <xs:enumeration value="NoSupportedKeyPackages" />
            <xs:enumeration value="AuthenticationDataMissing" />
            <xs:enumeration value="AuthenticationDataInvalid" />
            <xs:enumeration value="InitializationFailed" />
         </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="DeviceIdentifierDataType">
         <xs:choice>
            <xs:element name="DeviceId" type="pskc:DeviceIdType" />
            <xs:any namespace="##other" processContents="strict" />
         </xs:choice>
      </xs:complexType>

      <xs:simpleType name="PlatformType">
         <xs:restriction base="xs:string">
            <xs:enumeration value="Hardware" />
            <xs:enumeration value="Software" />
            <xs:enumeration value="Unspecified" />
         </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="TokenPlatformInfoType">
         <xs:attribute name="KeyLocation" type="dskpp:PlatformType"/>
         <xs:attribute name="AlgorithmLocation" type="dskpp:PlatformType"/>
      </xs:complexType>

      <xs:simpleType name="NonceType">
         <xs:restriction base="xs:base64Binary">
            <xs:minLength value="16" />
         </xs:restriction>
      </xs:simpleType>

      <xs:complexType name="AlgorithmsType">
         <xs:sequence maxOccurs="unbounded">
            <xs:element name="Algorithm" type="dskpp:AlgorithmType" />
         </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="AlgorithmType">
         <xs:restriction base="xs:anyURI" />
      </xs:simpleType>

      <xs:complexType name="ProtocolVariantsType">



Doherty, et al.            Expires May 7, 2009                 [Page 62]


Internet-Draft                    DSKPP                    November 2008


         <xs:sequence>
            <xs:element name="FourPass" minOccurs="0" />
            <xs:element name="TwoPass" type="dskpp:KeyProtectionDataType"
               minOccurs="0"/>
         </xs:sequence>
      </xs:complexType>

      <xs:complexType name="KeyProtectionDataType">
         <xs:annotation>
            <xs:documentation xml:lang="en">
               This element is only valid for two-pass DSKPP.
            </xs:documentation>
         </xs:annotation>
         <xs:sequence maxOccurs="unbounded">
            <xs:element name="SupportedKeyProtectionMethod" type="xs:anyURI"/>
            <xs:element name="Payload" type="dskpp:PayloadType" minOccurs="0"/>
         </xs:sequence>
      </xs:complexType>

      <xs:complexType name="PayloadType">
         <xs:choice>
            <xs:element name="Nonce" type="dskpp:NonceType" />
            <xs:any namespace="##other" processContents="strict" />
         </xs:choice>
      </xs:complexType>

      <xs:complexType name="KeyPackagesFormatType">
         <xs:sequence maxOccurs="unbounded">
            <xs:element name="KeyPackageFormat"
               type="dskpp:KeyPackageFormatType"/>
         </xs:sequence>
      </xs:complexType>

      <xs:simpleType name="KeyPackageFormatType">
         <xs:restriction base="xs:anyURI" />
      </xs:simpleType>

      <xs:complexType name="AuthenticationDataType">
         <xs:annotation>
            <xs:documentation xml:lang="en">
               Authentication data contains a MAC.
            </xs:documentation>
         </xs:annotation>
         <xs:sequence>
            <xs:element name="ClientID"
               type="dskpp:IdentifierType" />
            <xs:choice>
               <xs:element name="AuthenticationCodeMac"



Doherty, et al.            Expires May 7, 2009                 [Page 63]


Internet-Draft                    DSKPP                    November 2008


                  type="dskpp:AuthenticationMacType"
               <xs:any namespace="##other" processContents="strict" />
            </xs:choice>
         </xs:sequence>
      </xs:complexType>

      <xs:complexType name="AuthenticationMacType">
         <xs:sequence>
            <xs:element minOccurs="0" name="Nonce" type="dskpp:NonceType" />
            <xs:element minOccurs="0" name="IterationCount" type="xs:int" />
            <xs:element name="Mac" type="dskpp:MacType" />
         </xs:sequence>
      </xs:complexType>

      <xs:complexType name="MacType">
         <xs:simpleContent>
            <xs:extension base="xs:base64Binary">
               <xs:attribute name="MacAlgorithm" type="xs:anyURI" />
            </xs:extension>
         </xs:simpleContent>
      </xs:complexType>

      <xs:complexType name="KeyPackageType">
         <xs:sequence>
            <xs:element minOccurs="0" name="ServerID" type="xs:anyURI" />
            <xs:element minOccurs="0" name="KeyProtectionMethod"
               type="xs:anyURI" />
            <xs:choice>
               <xs:element name="KeyPackage" type="pskc:KeyContainerType" />
               <xs:any namespace="##other" processContents="strict" />
            </xs:choice>
         </xs:sequence>
      </xs:complexType>

      <xs:complexType name="InitializationTriggerType">
         <xs:sequence>
            <xs:element minOccurs="0" name="DeviceIdentifierData"
               type="dskpp:DeviceIdentifierDataType" />
            <xs:element minOccurs="0" name="KeyID" type="xs:base64Binary" />
            <xs:element minOccurs="0" name="TokenPlatformInfo"
               type="dskpp:TokenPlatformInfoType" />
            <xs:element name="TriggerNonce" type="dskpp:NonceType" />
            <xs:element minOccurs="0" name="ServerUrl" type="xs:anyURI" />
            <xs:any minOccurs="0" namespace="##other"
               processContents="strict" />
         </xs:sequence>
      </xs:complexType>




Doherty, et al.            Expires May 7, 2009                 [Page 64]


Internet-Draft                    DSKPP                    November 2008


      <xs:complexType name="ExtensionsType">
         <xs:annotation>
            <xs:documentation> Extension types </xs:documentation>
         </xs:annotation>
         <xs:sequence maxOccurs="unbounded">
            <xs:element name="Extension" type="dskpp:AbstractExtensionType" />
         </xs:sequence>
      </xs:complexType>

      <xs:complexType name="AbstractExtensionType" abstract="true">
         <xs:attribute name="Critical" type="xs:boolean" />
      </xs:complexType>

      <xs:complexType name="ClientInfoType">
         <xs:complexContent mixed="false">
            <xs:extension base="dskpp:AbstractExtensionType">
               <xs:sequence>
                  <xs:element name="Data" type="xs:base64Binary" />
               </xs:sequence>
            </xs:extension>
         </xs:complexContent>
      </xs:complexType>

      <xs:complexType name="ServerInfoType">
         <xs:complexContent mixed="false">
            <xs:extension base="dskpp:AbstractExtensionType">
               <xs:sequence>
                  <xs:element name="Data" type="xs:base64Binary" />
               </xs:sequence>
            </xs:extension>
         </xs:complexContent>
      </xs:complexType>

      <xs:element name="KeyProvTrigger" type="dskpp:KeyProvTriggerType">
         <xs:annotation>
            <xs:documentation> DSKPP PDUs </xs:documentation>
         </xs:annotation>
      </xs:element>
      <xs:complexType name="KeyProvTriggerType">
         <xs:annotation>
         <xs:documentation xml:lang="en">
            Message used to trigger the device to initiate a
            DSKPP protocol run.
         </xs:documentation>
         </xs:annotation>
         <xs:sequence>
            <xs:choice>
               <xs:element name="InitializationTrigger"



Doherty, et al.            Expires May 7, 2009                 [Page 65]


Internet-Draft                    DSKPP                    November 2008


                  type="dskpp:InitializationTriggerType" />
               <xs:any namespace="##other" processContents="strict" />
            </xs:choice>
         </xs:sequence>
         <xs:attribute name="Version" type="dskpp:VersionType" />
      </xs:complexType>

      <xs:element name="KeyProvClientHello"
         type="dskpp:KeyProvClientHelloPDU">
         <xs:annotation>
            <xs:documentation> KeyProvClientHello PDU </xs:documentation>
         </xs:annotation>
      </xs:element>
      <xs:complexType name="KeyProvClientHelloPDU">
         <xs:annotation>
            <xs:documentation xml:lang="en">
               Message sent from DSKPP client to DSKPP server to initiate a
               DSKPP session.
            </xs:documentation>
         </xs:annotation>
         <xs:complexContent mixed="false">
            <xs:extension base="dskpp:AbstractRequestType">
               <xs:sequence>
                  <xs:element minOccurs="0" name="DeviceIdentifierData"
                     type="dskpp:DeviceIdentifierDataType" />
                  <xs:element minOccurs="0" name="KeyID"
                     type="xs:base64Binary" />
                  <xs:element minOccurs="0" name="ClientNonce"
                     type="dskpp:NonceType" />
                  <xs:element minOccurs="0" name="TriggerNonce"
                     type="dskpp:NonceType" />
                  <xs:element name="SupportedKeyTypes"
                     type="dskpp:AlgorithmsType" />
                  <xs:element name="SupportedEncryptionAlgorithms"
                     type="dskpp:AlgorithmsType" />
                  <xs:element name="SupportedMacAlgorithms"
                     type="dskpp:AlgorithmsType" />
                  <xs:element minOccurs="0" name="SupportedProtocolVariants"
                     type="dskpp:ProtocolVariantsType" />
                  <xs:element minOccurs="0" name="SupportedKeyPackages"
                     type="dskpp:KeyPackagesFormatType" />
                  <xs:element minOccurs="0" name="AuthenticationData"
                     type="dskpp:AuthenticationDataType" />
                  <xs:element minOccurs="0" name="Extensions"
                     type="dskpp:ExtensionsType" />
               </xs:sequence>
            </xs:extension>
         </xs:complexContent>



Doherty, et al.            Expires May 7, 2009                 [Page 66]


Internet-Draft                    DSKPP                    November 2008


      </xs:complexType>

      <xs:element name="KeyProvServerHello"
         type="dskpp:KeyProvServerHelloPDU">
         <xs:annotation>
            <xs:documentation> KeyProvServerHello PDU </xs:documentation>
         </xs:annotation>
      </xs:element>
      <xs:complexType name="KeyProvServerHelloPDU">
         <xs:annotation>
            <xs:documentation xml:lang="en">
               Response message sent from DSKPP server to DSKPP client
               in four-pass DSKPP.
            </xs:documentation>
         </xs:annotation>
         <xs:complexContent mixed="false">
            <xs:extension base="dskpp:AbstractResponseType">
               <xs:sequence minOccurs="0">
                  <xs:element name="KeyType" type="dskpp:AlgorithmType" />
                  <xs:element name="EncryptionAlgorithm"
                     type="dskpp:AlgorithmType" />
                  <xs:element name="MacAlgorithm" type="dskpp:AlgorithmType" />
                  <xs:element name="EncryptionKey" type="ds:KeyInfoType" />
                  <xs:element name="KeyPackageFormat"
                     type="dskpp:KeyPackageFormatType" />
                  <xs:element name="Payload" type="dskpp:PayloadType" />
                  <xs:element minOccurs="0" name="Extensions"
                     type="dskpp:ExtensionsType" />
                  <xs:element minOccurs="0" name="Mac" type="dskpp:MacType" />
               </xs:sequence>
            </xs:extension>
         </xs:complexContent>
      </xs:complexType>

      <xs:element name="KeyProvClientNonce"
         type="dskpp:KeyProvClientNoncePDU">
         <xs:annotation>
            <xs:documentation> KeyProvClientNonce PDU </xs:documentation>
         </xs:annotation>
      </xs:element>
      <xs:complexType name="KeyProvClientNoncePDU">
         <xs:annotation>
            <xs:documentation xml:lang="en">
               Response message sent from DSKPP client to
               DSKPP server in a four-pass DSKPP session.
            </xs:documentation>
         </xs:annotation>
         <xs:complexContent mixed="false">



Doherty, et al.            Expires May 7, 2009                 [Page 67]


Internet-Draft                    DSKPP                    November 2008


            <xs:extension base="dskpp:AbstractRequestType">
               <xs:sequence>
                  <xs:element name="EncryptedNonce" type="xs:base64Binary" />
                  <xs:element minOccurs="0" name="AuthenticationData"
                     type="dskpp:AuthenticationDataType" />
                  <xs:element minOccurs="0" name="Extensions"
                     type="dskpp:ExtensionsType" />
               </xs:sequence>
               <xs:attribute name="SessionID" type="dskpp:IdentifierType"
                  use="required" />
            </xs:extension>
         </xs:complexContent>
      </xs:complexType>

      <xs:element name="KeyProvServerFinished"
         type="dskpp:KeyProvServerFinishedPDU">
         <xs:annotation>
            <xs:documentation> KeyProvServerFinished PDU </xs:documentation>
         </xs:annotation>
      </xs:element>
      <xs:complexType name="KeyProvServerFinishedPDU">
         <xs:annotation>
            <xs:documentation xml:lang="en">
               Final message sent from DSKPP server to DSKPP client in a DSKPP
               session. A MAC value serves for key confirmation, and optional
               AuthenticationData serves for server authentication.
            </xs:documentation>
         </xs:annotation>
         <xs:complexContent mixed="false">
            <xs:extension base="dskpp:AbstractResponseType">
               <xs:sequence minOccurs="0">
                  <xs:element name="KeyPackage"
                     type="dskpp:KeyPackageType" />
                  <xs:element minOccurs="0" name="Extensions"
                     type="dskpp:ExtensionsType" />
                  <xs:element name="Mac" type="dskpp:MacType" />
                  <xs:element minOccurs="0" name="AuthenticationData"
                     type="dskpp:AuthenticationMacType" />
               </xs:sequence>
            </xs:extension>
         </xs:complexContent>
      </xs:complexType>
    </xs:schema>








Doherty, et al.            Expires May 7, 2009                 [Page 68]


Internet-Draft                    DSKPP                    November 2008


8.  Conformance Requirements

   In order to assure that all implementations of DSKPP can
   interoperate, the DSKPP server:

   a.  MUST implement the four-pass variation of the protocol
       (Section 3.4)

   b.  MUST implement the two-pass variation of the protocol
       (Section 3.5)

   c.  MUST support user authentication (Section 3.7)

   d.  MUST support the following Key Derivation Functions:
       *  DSKPP-PRF-AES DSKPP-PRF realization (Appendix C)
       *  DSKPP-PRF-SHA256 DSKPP-PRF realization (Appendix C)

   e.  MUST support the following Encryption mechanisms for protection
       of the client nonce in the four-pass protocol:
       *  Mechanism described in Section 3.4.3

   f.  MUST support the following Encryption algorithms for symmetric
       key operations, e.g., key wrap:
       *  AES-CBC-128 [FIPS197-AES]

   g.  MUST support the following Encryption algorithms for asymmetric
       key operations, e.g., key transport:
       *  RSA Encryption Scheme [PKCS-1]

   h.  MUST support the following Integrity/KDF MAC functions:
       *  HMAC-SHA256 [FIPS180-SHA]
       *  AES-CMAC-128 [FIPS197-AES]

   i.  MUST support the PSKC key package [PSKC]; all three PSKC key
       protection profiles (Key Transport, Key Wrap, and Passphrase-
       Based Key Wrap) MUST be implemented

   j.  MAY support the ASN.1 key package as defined in [SKPC-ASN.1]

   DSKPP clients MUST support either the two-pass or the four-pass
   variant of the protocol.  DSKPP clients MUST fulfill all requirements
   listed in item (c) - (j).

   Of course, DSKPP is a security protocol, and one of its major
   functions is to allow only authorized parties to successfully
   initialize a cryptographic module with a new symmetric key.
   Therefore, a particular implementation may be configured with any of
   a number of restrictions concerning algorithms and trusted



Doherty, et al.            Expires May 7, 2009                 [Page 69]


Internet-Draft                    DSKPP                    November 2008


   authorities that will prevent universal interoperability.


9.  Security Considerations

9.1.  General

   DSKPP is designed to protect generated keying material from exposure.
   No other entities than the DSKPP server and the cryptographic module
   will have access to a generated K_TOKEN if the cryptographic
   algorithms used are of sufficient strength and, on the DSKPP client
   side, generation and encryption of R_C and generation of K_TOKEN take
   place as specified in the cryptographic module.  This applies even if
   malicious software is present in the DSKPP client.  However, as
   discussed in the following sub-sections, DSKPP does not protect
   against certain other threats resulting from man-in-the-middle
   attacks and other forms of attacks.  DSKPP SHOULD, therefore, be run
   over a transport providing confidentiality and integrity, such as
   HTTP over Transport Layer Security (TLS) with a suitable ciphersuite,
   when such threats are a concern.  Note that TLS ciphersuites with
   anonymous key exchanges are not suitable in those situations.

9.2.  Active Attacks

9.2.1.  Introduction

   An active attacker MAY attempt to modify, delete, insert, replay, or
   reorder messages for a variety of purposes including service denial
   and compromise of generated keying material.  Section 9.2.2 through
   Section 9.2.7.

9.2.2.  Message Modifications

   Modifications to a <KeyProvTrigger> message will either cause denial-
   of-service (modifications of any of the identifiers or the nonce) or
   will cause the DSKPP client to contact the wrong DSKPP server.  The
   latter is in effect a man-in-the-middle attack and is discussed
   further in Section 9.2.7.

   An attacker may modify a <KeyProvClientHello> message.  This means
   that the attacker could indicate a different key or device than the
   one intended by the DSKPP client, and could also suggest other
   cryptographic algorithms than the ones preferred by the DSKPP client,
   e.g., cryptographically weaker ones.  The attacker could also suggest
   earlier versions of the DSKPP protocol, in case these versions have
   been shown to have vulnerabilities.  These modifications could lead
   to an attacker succeeding in initializing or modifying another
   cryptographic module than the one intended (i.e., the server



Doherty, et al.            Expires May 7, 2009                 [Page 70]


Internet-Draft                    DSKPP                    November 2008


   assigning the generated key to the wrong module), or gaining access
   to a generated key through the use of weak cryptographic algorithms
   or protocol versions.  DSKPP implementations MAY protect against the
   latter by having strict policies about what versions and algorithms
   they support and accept.  The former threat (assignment of a
   generated key to the wrong module) is not possible when the shared-
   key variant of DSKPP is employed (assuming existing shared keys are
   unique per cryptographic module), but is possible in the public-key
   variation.  Therefore, DSKPP servers MUST NOT accept unilaterally
   provided device identifiers in the public-key variation.  This is
   also indicated in the protocol description.  In the shared-key
   variation, however, an attacker may be able to provide the wrong
   identifier (possibly also leading to the incorrect user being
   associated with the generated key) if the attacker has real-time
   access to the cryptographic module with the identified key.  In other
   words, the generated key is associated with the correct cryptographic
   module but the module is associated with the incorrect user.  See
   further Section 9.5 for a discussion of this threat and possible
   countermeasures.

   An attacker may also modify a <KeyProvServerHello> message.  This
   means that the attacker could indicate different key types,
   algorithms, or protocol versions than the legitimate server would,
   e.g., cryptographically weaker ones.  The attacker may also provide a
   different nonce than the one sent by the legitimate server.  Clients
   MAY protect against the former through strict adherence to policies
   regarding permissible algorithms and protocol versions.  The latter
   (wrong nonce) will not constitute a security problem, as a generated
   key will not match the key generated on the legitimate server.  Also,
   whenever the DSKPP run would result in the replacement of an existing
   key, the <Mac> element protects against modifications of R_S.

   Modifications of <KeyProvClientNonce> messages are also possible.  If
   an attacker modifies the SessionID attribute, then, in effect, a
   switch to another session will occur at the server, assuming the new
   SessionID is valid at that time on the server.  It still will not
   allow the attacker to learn a generated K_TOKEN since R_C has been
   wrapped for the legitimate server.  Modifications of the
   <EncryptedNonce> element, e.g., replacing it with a value for which
   the attacker knows an underlying R'C, will not result in the client
   changing its pre-DSKPP state, since the server will be unable to
   provide a valid MAC in its final message to the client.  The server
   MAY, however, end up storing K'TOKEN rather than K_TOKEN.  If the
   cryptographic module has been associated with a particular user, then
   this could constitute a security problem.  For a further discussion
   about this threat, and a possible countermeasure, see Section 9.5
   below.  Note that use of TLS does not protect against this attack if
   the attacker has access to the DSKPP client (e.g., through malicious



Doherty, et al.            Expires May 7, 2009                 [Page 71]


Internet-Draft                    DSKPP                    November 2008


   software, "Trojans").

   Finally, attackers may also modify the <KeyProvServerFinished>
   message.  Replacing the <Mac> element will only result in denial-of-
   service.  Replacement of any other element may cause the DSKPP client
   to associate, e.g., the wrong service with the generated key.  DSKPP
   SHOULD be run over a transport providing confidentiality and
   integrity when this is a concern.

9.2.3.  Message Deletion

   Message deletion will not cause any other harm than denial-of-
   service, since a cryptographic module MUST NOT change its state
   (i.e., "commit" to a generated key) until it receives the final
   message from the DSKPP server and successfully has processed that
   message, including validation of its MAC.  A deleted
   <KeyProvServerFinished> message will not cause the server to end up
   in an inconsistent state vis-a-vis the cryptographic module if the
   server implements the suggestions in Section 9.5.

9.2.4.  Message Insertion

   An active attacker may initiate a DSKPP run at any time, and suggest
   any device identifier.  DSKPP server implementations MAY receive some
   protection against inadvertently initializing a key or inadvertently
   replacing an existing key or assigning a key to a cryptographic
   module by initializing the DSKPP run by use of the <KeyProvTrigger>.
   The <TriggerNonce> element allows the server to associate a DSKPP
   protocol run with, e.g., an earlier user-authenticated session.  The
   security of this method, therefore, depends on the ability to protect
   the <TriggerNonce> element in the DSKPP initialization message.  If
   an eavesdropper is able to capture this message, he may race the
   legitimate user for a key initialization.  DSKPP over a transport
   providing confidentiality and integrity, coupled with the
   recommendations in Section 9.5, is RECOMMENDED when this is a
   concern.

   Insertion of other messages into an existing protocol run is seen as
   equivalent to modification of legitimately sent messages.

9.2.5.  Message Replay

   During 4-pass DSKPP, attempts to replay a previously recorded DSKPP
   message will be detected, as the use of nonces ensures that both
   parties are live.  For example, a DSKPP client knows that a server it
   is communicating with is "live" since the server MUST create a MAC on
   information sent by the client.




Doherty, et al.            Expires May 7, 2009                 [Page 72]


Internet-Draft                    DSKPP                    November 2008


   The same is true for 2-pass DSKPP thanks to the requirement that the
   client sends R in the <KeyProvClientHello> message and that the
   server includes R in the MAC computation.

9.2.6.  Message Reordering

   An attacker may attempt to re-order 4-pass DSKPP messages but this
   will be detected, as each message is of a unique type.  Note: Message
   re-ordering attacks cannot occur in 2-pass DSKPP since each party
   sends at most one message each.

9.2.7.  Man-in-the-Middle

   In addition to other active attacks, an attacker posing as a man in
   the middle may be able to provide his own public key to the DSKPP
   client.  This threat and countermeasures to it are discussed in
   Section 3.4.2.1.  An attacker posing as a man-in-the-middle may also
   be acting as a proxy and, hence, may not interfere with DSKPP runs
   but still learn valuable information; see Section 9.3.

9.3.  Passive Attacks

   Passive attackers may eavesdrop on DSKPP runs to learn information
   that later on may be used to impersonate users, mount active attacks,
   etc.

   If DSKPP is not run over a transport providing confidentiality, a
   passive attacker may learn:
   o  What cryptographic modules a particular user is in possession of;
   o  The identifiers of keys on those cryptographic modules and other
      attributes pertaining to those keys, e.g., the lifetime of the
      keys;
   o  DSKPP versions and cryptographic algorithms supported by a
      particular DSKPP client or server; and
   o  Any value present in an <extension> that is part of
      <KeyProvClientHello>

   Whenever the above is a concern, DSKPP SHOULD be run over a transport
   providing confidentiality.  If man-in-the-middle attacks for the
   purposes described above are a concern, the transport SHOULD also
   offer server-side authentication.

9.4.  Cryptographic Attacks

   An attacker with unlimited access to an initialized cryptographic
   module may use the module as an "oracle" to pre-compute values that
   later on may be used to impersonate the DSKPP server.  Section 3.4.3
   and Section 3 contain discussions of this threat and steps



Doherty, et al.            Expires May 7, 2009                 [Page 73]


Internet-Draft                    DSKPP                    November 2008


   RECOMMENDED to protect against it.

   Implementers SHOULD also be aware that cryptographic algorithms
   become weaker with time.  As new cryptographic techniques are
   developed and computing performance improves, the work factor to
   break a particular cryptographic algorithm will reduce.  Therefore,
   cryptographic algorithm implementations SHOULD be modular allowing
   new algorithms to be readily inserted.  That is, implementers SHOULD
   be prepared to regularly update the algorithms in their
   implementations.

9.5.  Attacks on the Interaction between DSKPP and User Authentication

   If keys generated in DSKPP will be associated with a particular user
   at the DSKPP server (or a server trusted by, and communicating with
   the DSKPP server), then in order to protect against threats where an
   attacker replaces a client-provided encrypted R_C with his own R'C
   (regardless of whether the public-key variation or the shared-secret
   variation of DSKPP is employed to encrypt the client nonce), the
   server SHOULD not commit to associate a generated K_TOKEN with the
   given cryptographic module until the user simultaneously has proven
   both possession of the device that hosts the cryptographic module
   containing K_TOKEN and some out-of-band provided authenticating
   information (e.g., a temporary password).  For example, if the
   cryptographic module is a one-time password token, the user could be
   required to authenticate with both a one-time password generated by
   the cryptographic module and an out-of-band provided temporary PIN in
   order to have the server "commit" to the generated OTP value for the
   given user.  Preferably, the user SHOULD perform this operation from
   another host than the one used to initialize keys on the
   cryptographic module, in order to minimize the risk of malicious
   software on the client interfering with the process.

   Note: This scenario, wherein the attacker replaces a client-provided
   R_C with his own R'C, does not apply to 2-pass DSKPP as the client
   does not provide any entropy to K_TOKEN.  The attack as such (and its
   countermeasures) still applies to 2-pass DSKPP, however, as it
   essentially is a man-in-the-middle attack.

   Another threat arises when an attacker is able to trick a user to
   authenticate to the attacker rather than to the legitimate service
   before the DSKPP protocol run.  If successful, the attacker will then
   be able to impersonate the user towards the legitimate service, and
   subsequently receive a valid DSKPP trigger.  If the public-key
   variant of DSKPP is used, this may result in the attacker being able
   to (after a successful DSKPP protocol run) impersonate the user.
   Ordinary precautions MUST, therefore, be in place to ensure that
   users authenticate only to legitimate services.



Doherty, et al.            Expires May 7, 2009                 [Page 74]


Internet-Draft                    DSKPP                    November 2008


9.6.  Miscellaneous Considerations

9.6.1.  Client Contributions to K_TOKEN Entropy

   In 4-pass DSKPP, both the client and the server provide randomizing
   material to K_TOKEN, in a manner that allows both parties to verify
   that they did contribute to the resulting key.  In the 2-pass DSKPP
   version defined herein, only the server contributes to the entropy of
   K_TOKEN.  This means that a broken or compromised (pseudo-)random
   number generator in the server may cause more damage than it would in
   the 4-pass variation.  Server implementations SHOULD therefore take
   extreme care to ensure that this situation does not occur.

9.6.2.  Key Confirmation

   4-pass DSKPP servers provide key confirmation through the MAC on R_C
   in the <KeyProvServerFinished> message.  In the 2-pass DSKPP
   variation described herein, key confirmation is provided by the MAC
   including R, using K_MAC.

9.6.3.  Server Authentication

   DSKPP servers MUST authenticate themselves whenever a successful
   DSKPP 2-pass protocol run would result in an existing K_TOKEN being
   replaced by a K_TOKEN', or else a denial-of-service attack where an
   unauthorized DSKPP server replaces a K_TOKEN with another key would
   be possible.  In 2-pass DSKPP, servers authenticate by including the
   AuthenticationDataType extension containing a MAC as described in
   Section 3.5 for two-pass DSKPP.

9.6.4.  User Authentication

   A DSKPP server MUST authenticate a client to ensure that K_TOKEN is
   delivered to the intended device.  The following measures SHOULD be
   considered:

   o  When an Authentication Code is used for client authentication, a
      password dictionary attack on the authentication data is possible.
   o  The length of the Authentication Code when used over a non-secure
      channel SHOULD be longer than what is used over a secure channel.
      When a device, e.g., some mobile phones with small screens, cannot
      handle a long Authentication Code in a user-friendly manner, DSKPP
      SHOULD rely on a secure channel for communication.
   o  In the case that a non-secure channel has to be used, the
      Authentication Code SHOULD be sent to the server MAC'd as
      specified in Section 3.7.  The Authentication Code and nonce value
      MUST be strong enough to prevent offline brute-force recovery of
      the Authentication Code from the HMAC data.  Given that the nonce



Doherty, et al.            Expires May 7, 2009                 [Page 75]


Internet-Draft                    DSKPP                    November 2008


      value is sent in plaintext format over a non-secure transport, the
      cryptographic strength of the Authentication Data depends more on
      the quality of the Authentication Code.
   o  When the Authentication Code is sent from the DSKPP server to the
      device in a DSKPP initialization trigger message, an eavesdropper
      may be able to capture this message and race the legitimate user
      for a key initialization.  To prevent this, the transport layer
      used to send the DSKPP trigger MUST provide confidentiality and
      integrity e.g. secure browser session.

9.6.5.  Key Protection in Two-Pass DSKPP

   Three key protection profiles are defined for the different usages of
   2-pass DSKPP, which MUST be supported by a key package format, such
   as [PSKC] and [SKPC-ASN.1].  Therefore, key protection in the two-
   pass DSKPP is dependent upon the security of the key package format
   selected for a protocol run.  Some considerations for the Passphrase
   profile follow.

   The passphrase-based key wrap profile SHOULD depend upon the PBKDF2
   function from [PKCS-5] to generate an encryption key from a
   passphrase and salt string.  It is important to note that passphrase-
   based encryption is generally limited in the security that it
   provides despite the use of salt and iteration count in PBKDF2 to
   increase the complexity of attack.  Implementations SHOULD therefore
   take additional measures to strengthen the security of the
   passphrase-based key wrap profile.  The following measures SHOULD be
   considered where applicable:

   o  The passphrase SHOULD be selected well, and usage guidelines such
      as the ones in [NIST-PWD] SHOULD be taken into account.
   o  A different passphrase SHOULD be used for every key initialization
      wherever possible (the use of a global passphrase for a batch of
      cryptographic modules SHOULD be avoided, for example).  One way to
      achieve this is to use randomly-generated passphrases.
   o  The passphrase SHOULD be protected well if stored on the server
      and/or on the cryptographic module and SHOULD be delivered to the
      device's user using secure methods.
   o  User per-authentication SHOULD be implemented to ensure that
      K_TOKEN is not delivered to a rogue recipient.
   o  The iteration count in PBKDF2 SHOULD be high to impose more work
      for an attacker using brute-force methods (see [PKCS-5] for
      recommendations).  However, it MUST be noted that the higher the
      count, the more work is required on the legitimate cryptographic
      module to decrypt the newly delivered K_TOKEN.  Servers MAY use
      relatively low iteration counts to accommodate devices with
      limited processing power such as some PDA and cell phones when
      other security measures are implemented and the security of the



Doherty, et al.            Expires May 7, 2009                 [Page 76]


Internet-Draft                    DSKPP                    November 2008


      passphrase-based key wrap method is not weakened.
   o  Transport level security (e.g.  TLS) SHOULD be used where possible
      to protect a two-pass protocol run.  Transport level security
      provides a second layer of protection for the newly generated
      K_TOKEN.


10.  Internationalization Considerations

   The DSKPP protocol is mostly meant for machine-to-machine
   communications; as such, most of its elements are tokens not meant
   for direct human consumption.  If these tokens are presented to the
   end user, some localization may need to occur.  DSKPP exchanges
   information using XML.  All XML processors are required to understand
   UTF-8 and UTF-16 encoding, and therefore all DSKPP clients and
   servers MUST understand UTF-8 and UTF-16 encoded XML.  Additionally,
   DSKPP servers and clients MUST NOT encode XML with encodings other
   than UTF-8 or UTF-16.


11.  IANA Considerations

   This document requires several IANA registrations, detailed below.

11.1.  URN Sub-Namespace Registration

   This section registers a new XML namespace,
   "urn:ietf:params:xml:ns:keyprov:dskpp:1.0" per the guidelines in
   [RFC3688]:

   URI:  urn:ietf:params:xml:ns:keyprov:dskpp:1.0
   Registrant Contact:  IETF, KEYPROV Working Group (keyprov@ietf.org),
      Andrea Doherty (andrea.doherty@rsa.com)
   XML:

















Doherty, et al.            Expires May 7, 2009                 [Page 77]


Internet-Draft                    DSKPP                    November 2008


      BEGIN
         <?xml version="1.0"?>
         <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
            "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
         <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
         <head>
            <title>DSKPP Messsages</title>
         </head>
         <body>
            <h1>Namespace for DSKPP Messages</h1>
            <h2>urn:ietf:params:xml:ns:keyprov:dskpp:1.0</h2>
            [NOTE TO IANA/RFC-EDITOR: Please replace XXXX below
            with the RFC number for this specification.]
            <p>See RFCXXXX</p>
         </body>
         </html>
      END

11.2.  XML Schema Registration

   This section registers an XML schema as per the guidelines in
   [RFC3688].

   URI:  urn:ietf:params:xml:ns:keyprov:dskpp:1.0
   Registrant Contact:  IETF, KEYPROV Working Group (keyprov@ietf.org),
      Andrea Doherty (andrea.doherty@rsa.com)
   Schema  The XML for this schema can be found as the entirety of
      Section 7 of this document.

11.3.  MIME Media Type Registration

   This section registers the "application/dskpp+xml" MIME type:

   To:  ietf-types@iana.org
   Subject:  Registration of MIME media type application/dskpp+xml
   MIME media type name:  application
   MIME subtype name:  dskpp+xml
   Required parameters:  (none)
   Optional parameters:  charset
      Indicates the character encoding of enclosed XML.  Default is
      UTF-8.
   Encoding considerations:  Uses XML, which can employ 8-bit
      characters, depending on the character encoding used.  See
      [RFC3203], Section 3.2.







Doherty, et al.            Expires May 7, 2009                 [Page 78]


Internet-Draft                    DSKPP                    November 2008


   Security considerations:  This content type is designed to carry
      protocol data related to key management.  Security mechanisms are
      built into the protocol to ensure that various threats are dealt
      with.
   Interoperability considerations:  This content type provides a basis
      for a protocol.
   Published specification:  RFC XXXX [NOTE TO IANA/RFC-EDITOR: Please
      replace XXXX with the RFC number for this specification.]
   Applications which use this media type:  Protocol for key exchange.
   Additional information:
      Magic Number(s): (none)
      File extension(s): .xmls
      Macintosh File Type Code(s): (none)
   Person & email address to contact for further information:
      Andrea Doherty (andrea.doherty@rsa.com)
   Intended usage:  LIMITED USE
   Author/Change controller:  The IETF
   Other information:  This media type is a specialization of
      application/xml [RFC3203], and many of the considerations
      described there also apply to application/dskpp+xml.

11.4.  Status Code Registry

   This section registers status codes included in each DSKPP response
   message.  The status codes are defined in the schema in the
   <StatusCode> type definition as described in the XML schema in
   Section 7.  The following summarizes the registry:

   Related Registry:
      KEYPROV DSKPP Registries, Status codes for DSKPP

   Defining RFC:
      RFC XXXX [NOTE TO IANA/RFC-EDITOR: Please replace XXXX with the
      RFC number for this specification.]

   Registration/Assignment Procedures:
      Following the policies outlined in [RFC3575], the IANA policy for
      assigning new values for the status codes for DSKPP MUST be
      "Specification Required" and their meanings MUST be documented in
      an RFC or in some other permanent and readily available reference,
      in sufficient detail that interoperability between independent
      implementations is possible.  No mechanism to mark entries as
      "deprecated" is envisioned.  It is possible to delete or update
      entries from the registry.







Doherty, et al.            Expires May 7, 2009                 [Page 79]


Internet-Draft                    DSKPP                    November 2008


   Registrant Contact:
      IETF, KEYPROV working group (keyprov@ietf.org),
      Andrea Doherty (andrea.doherty@rsa.com)

   This section pre-registers the initial status codes, as described
   above in Section 4.7, including their textual description.  The list
   in Section 4.7, starts with the StatusCode "Continue" and ends with
   the StatusCode "InitializationFailed".


12.  Intellectual Property Considerations

   RSA and RSA Security are registered trademarks or trademarks of RSA
   Security Inc. in the United States and/or other countries.  The names
   of other products and services mentioned may be the trademarks of
   their respective owners.


13.  Contributors

   This work is based on information contained in [RFC4758], authored by
   Magnus Nystrom, with enhancements (esp.  Client Authentication, and
   support for multiple key package formats) from an individual
   Internet-Draft co-authored by Mingliang Pei and Salah Machani.

   We would like to thank Shuh Chang for contributing the DSKPP object
   model, and Philip Hoyer for his work in aligning DSKPP and PSKC
   schemas.

   We would also like to thank Hannes Tschofenig for his draft reviews,
   feedback, and text contributions.


14.  Acknowledgements

   We would like to thank the following for review of previous DSKPP
   document versions:

   o  Dr. Ulrike Meyer (Review June 2007)
   o  Niklas Neumann (Review June 2007)
   o  Shuh Chang (Review June 2007)
   o  Hannes Tschofenig (Review June 2007 and again in August 2007)
   o  Sean Turner (Reviews August 2007 and again in July 2008)
   o  John Linn (Review August 2007)
   o  Philip Hoyer (Review September 2007)
   o  Thomas Roessler (Review November 2007)





Doherty, et al.            Expires May 7, 2009                 [Page 80]


Internet-Draft                    DSKPP                    November 2008


   o  Lakshminath Dondeti (Comments December 2007)
   o  Pasi Eronen (Comments December 2007)
   o  Phillip Hallam-Baker (Review November 2008)

   We would also like to thank the following for their input to selected
   design aspects of the DSKPP protocol:

   o  Anders Rundgren (Key Package Format and Client Authentication
      Data)
   o  Thomas Roessler (HTTP Binding)
   o  Hannes Tschofenig (HTTP Binding)
   o  Phillip Hallam-Baker (Registry for Algorithms)

   Finally, we would like to thank Robert Griffin for opening
   communication channels for us with the IEEE P1619.3 Key Management
   Group, and facilitating our groups in staying informed of potential
   areas (esp. key provisioning and global key identifiers of
   collaboration) of collaboration.


15.  References

15.1.  Normative references

   [FIPS180-SHA]
              National Institute of Standards and Technology, "Secure
              Hash Standard", FIPS 180-2, February 2004, <http://
              csrc.nist.gov/publications/fips/fips180-2/
              fips180-2withchangenotice.pdf>.

   [FIPS197-AES]
              National Institute of Standards and Technology,
              "Specification for the Advanced Encryption Standard
              (AES)", FIPS 197, November 2001, <http://csrc.nist.gov/
              publications/fips/fips197/fips-197.pdf>.

   [PKCS-1]   RSA Laboratories, "RSA Cryptography Standard", PKCS #1
              Version 2.1, June 2002,
              <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [PKCS-5]   RSA Laboratories, "Password-Based Cryptography Standard",
              PKCS #5 Version 2.0, March 1999,
              <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [PKCS-5-XML]
              RSA Laboratories, "XML Schema for PKCS #5 Version 2.0",
              PKCS #5 Version 2.0 Amd.1 (FINAL DRAFT), October 2006,
              <http://www.rsasecurity.com/rsalabs/pkcs/>.



Doherty, et al.            Expires May 7, 2009                 [Page 81]


Internet-Draft                    DSKPP                    November 2008


   [PSKC]     "Portable Symmetric Key Container", 2008, <org/
              internet-drafts/
              draft-hoyer-keyprov-portable-symmetric-key-container-
              03.txt>.

   [RFC2104]  Krawzcyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104,
              February 1997, <http://www.ietf.org/rfc/rfc2104.txt>.

   [RFC2119]  "Key words for use in RFCs to Indicate Requirement
              Levels", BCP 14, RFC 2119, March 1997,
              <http://www.ietf.org/rfc/rfc2119.txt>.

   [RFC3629]  "UTF-8, a transformation format of ISO10646", STD 63,
              RFC 3629, November 2003,
              <http://www.ietf.org/rfc/rfc3629.txt>.

   [UNICODE]  Davis, M. and M. Duerst, "Unicode Normalization Forms",
              March 2001,
              <http://www.unicode.org/unicode/reports/tr15/
              tr15-21.html>.

   [XMLDSIG]  W3C, "XML Signature Syntax and Processing",
              W3C Recommendation, February 2002,
              <http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/>.

   [XMLENC]   W3C, "XML Encryption Syntax and Processing",
              W3C Recommendation, December 2002,
              <http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/>.

15.2.  Informative references

   [CT-KIP-P11]
              RSA Laboratories, "PKCS #11 Mechanisms for the
              Cryptographic Token Key Initialization Protocol", PKCS #11
              Version 2.20 Amd.2, December 2005,
              <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [FAQ]      RSA Laboratories, "Frequently Asked Questions About
              Today's Cryptography",  Version 4.1, 2000.

   [ISO3309]  "ISO Information Processing Systems - Data Communication -
              High-Level Data Link Control Procedure - Frame Structure",
              IS 3309, 3rd Edition, October 1984.

   [NIST-PWD]
              National Institute of Standards and Technology, "Password
              Usage", FIPS 112, May 1985,



Doherty, et al.            Expires May 7, 2009                 [Page 82]


Internet-Draft                    DSKPP                    November 2008


              <http://www.itl.nist.gov/fipspubs/fip112.htm>.

   [NIST-SP800-38B]
              International Organization for Standardization,
              "Recommendations for Block Cipher Modes of Operation: The
              CMAC Mode for Authentication", NIST SP800-38B, May 2005, <
              http://csrc.nist.gov/publications/nistpubs/800-38B/
              SP_800-38B.pdf>.

   [NIST-SP800-57]
              National Institute of Standards and Technology,
              "Recommendation for Key Management - Part I: General
              (Revised)", NIST 800-57, March 2007, <http://
              csrc.nist.gov/publications/nistpubs/800-57/
              sp800-57-Part1-revised2_Mar08-2007.pdf>.

   [PKCS-11]  RSA Laboratories, "Cryptographic Token Interface
              Standard", PKCS #11 Version 2.20, June 2004,
              <http://www.rsasecurity.com/rsalabs/pkcs/>.

   [PKCS-12]  "Personal Information Exchange Syntax Standard", PKCS #12
              Version 1.0, 2005,
              <ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-12/
              pkcs-12v1.pdf>.

   [RFC2396]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifiers (URI): Generic Syntax", RFC 2396,
              August 1998, <http://www.ietf.org/rfc/rfc2396.txt>.

   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, "Hypertext
              Transfer Protocol -- HTTP/1.1", RFC 2616, June 1999,
              <http://www.ietf.org/rfc/rfc2616.txt>.

   [RFC3203]  Murata, M., St. Laurent, S., and D. Kohn, "XML Media
              Types", RFC 3203, January 2001,
              <http://www.ietf.org/rfc/rfc3203.txt>.

   [RFC3575]  Aboba, B., "IANA Considerations for RADIUS", RFC 3575,
              July 2003, <http://www.ietf.org/rfc/rfc3575.txt>.

   [RFC3688]  Mealling, M., "The IETF XML Registry", RFC 3688, BCP 81,
              January 2004, <http://www.ietf.org/rfc/rfc3688.txt>.

   [RFC4758]  RSA, The Security Division of EMC, "Cryptographic Token
              Key Initialization Protocol (CT-KIP)", November 2006,
              <http://www.ietf.org/rfc/rfc4758.txt>.




Doherty, et al.            Expires May 7, 2009                 [Page 83]


Internet-Draft                    DSKPP                    November 2008


   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, May 2008,
              <http://www.ietf.org/rfc/rfc5280.txt>.

   [SKPC-ASN.1]
              "Symmetric Key Package Content Type", 2007, <http://
              www.ietf.org/internet-drafts/
              draft-ietf-keyprov-symmetrickeyformat-01.txt>.

   [XMLNS]    W3C, "Namespaces in XML", W3C Recommendation,
              January 1999,
              <http://www.w3.org/TR/1999/REC-xml-names-19990114 >.


Appendix A.  Examples

   This appendix contains example messages that illustrate parameters,
   encoding, and semantics in four-and two- pass DSKPP exchanges.  The
   examples are written using XML, and are syntactically correct.  MAC
   and cipher values are fictitious however.





























Doherty, et al.            Expires May 7, 2009                 [Page 84]


Internet-Draft                    DSKPP                    November 2008


A.1.  Trigger Message

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:KeyProvTrigger Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0">
     <dskpp:InitializationTrigger>
       <dskpp:DeviceIdentifierData>
         <dskpp:DeviceId>
           <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
           <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
           <pskc:Model>U2</pskc:Model>
         </dskpp:DeviceId>
       </dskpp:DeviceIdentifierData>
       <dskpp:KeyID>SE9UUDAwMDAwMDAx</dskpp:KeyID>
       <dskpp:TokenPlatformInfo KeyLocation="Hardware"
         AlgorithmLocation="Software"/>
       <dskpp:TriggerNonce>112dsdfwf312asder394jw==</dskpp:TriggerNonce>
       <dskpp:ServerUrl>https://www.somekeyprovservice.com/
         </dskpp:ServerUrl>
     </dskpp:InitializationTrigger>
   </dskpp:KeyProvTrigger>

A.2.  Four-Pass Protocol



























Doherty, et al.            Expires May 7, 2009                 [Page 85]


Internet-Draft                    DSKPP                    November 2008


A.2.1.  <KeyProvClientHello> Without a Preceding Trigger

<?xml version="1.0" encoding="UTF-8"?>
<dskpp:KeyProvClientHello Version="1.0"
  xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
  xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
  xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
  <dskpp:DeviceIdentifierData>
    <dskpp:DeviceId>
      <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
      <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
      <pskc:Model>U2</pskc:Model>
    </dskpp:DeviceId>
  </dskpp:DeviceIdentifierData>
  <dskpp:SupportedKeyTypes>
    <dskpp:Algorithm>http://www.ietf.org/keyprov/pskc#hotp
      </dskpp:Algorithm>
    <dskpp:Algorithm>http://www.rsa.com/rsalabs/otps/schemas/2005/09/
      otps-wst#SecurID-AES</dskpp:Algorithm>
  </dskpp:SupportedKeyTypes>
  <dskpp:SupportedEncryptionAlgorithms>
    <dskpp:Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5
      </dskpp:Algorithm>
    <dskpp:Algorithm>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
      </dskpp:Algorithm>
  </dskpp:SupportedEncryptionAlgorithms>
  <dskpp:SupportedMacAlgorithms>
    <dskpp:Algorithm>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
      </dskpp:Algorithm>
  </dskpp:SupportedMacAlgorithms>
  <dskpp:SupportedProtocolVariants><dskpp:FourPass/>
    </dskpp:SupportedProtocolVariants>
  <dskpp:SupportedKeyPackages>
    <dskpp:KeyPackageFormat>
      http://www.ietf.org/keyprov/pskc#KeyContainer
    </dskpp:KeyPackageFormat>
  </dskpp:SupportedKeyPackages>
</dskpp:KeyProvClientHello>













Doherty, et al.            Expires May 7, 2009                 [Page 86]


Internet-Draft                    DSKPP                    November 2008


A.2.2.  <KeyProvClientHello> Assuming a Preceding Trigger

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:KeyProvClientHello Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
     <dskpp:DeviceIdentifierData>
       <dskpp:DeviceId>
         <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
         <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
         <pskc:Model>U2</pskc:Model>
       </dskpp:DeviceId>
     </dskpp:DeviceIdentifierData>
     <dskpp:KeyID>SE9UUDAwMDAwMDAx</dskpp:KeyID>
     <dskpp:TriggerNonce>112dsdfwf312asder394jw==</dskpp:TriggerNonce>
     <dskpp:SupportedKeyTypes>
       <dskpp:Algorithm>http://www.ietf.org/keyprov/pskc#hotp</dskpp:Algorithm>
       <dskpp:Algorithm>http://www.rsa.com/rsalabs/otps/schemas/2005/09/
         otps-wst#SecurID-AES</dskpp:Algorithm>
     </dskpp:SupportedKeyTypes>
     <dskpp:SupportedEncryptionAlgorithms>
       <dskpp:Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5
       </dskpp:Algorithm>
     <dskpp:Algorithm>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
       </dskpp:Algorithm>
     </dskpp:SupportedEncryptionAlgorithms>
     <dskpp:SupportedMacAlgorithms>
       <dskpp:Algorithm>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
         </dskpp:Algorithm>
     </dskpp:SupportedMacAlgorithms>
     <dskpp:SupportedProtocolVariants><dskpp:FourPass/>
       </dskpp:SupportedProtocolVariants>
     <dskpp:SupportedKeyPackages>
       <dskpp:KeyPackageFormat>
         http://www.ietf.org/keyprov/pskc#KeyContainer
       </dskpp:KeyPackageFormat>
     </dskpp:SupportedKeyPackages>
   </dskpp:KeyProvClientHello>












Doherty, et al.            Expires May 7, 2009                 [Page 87]


Internet-Draft                    DSKPP                    November 2008


A.2.3.  <KeyProvServerHello> Without a Preceding Trigger

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:KeyProvServerHello Version="1.0" SessionID="4114" Status="Continue"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
     <dskpp:KeyType>
       http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
     </dskpp:KeyType>
     <dskpp:EncryptionAlgorithm>
       http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
     </dskpp:EncryptionAlgorithm>
     <dskpp:MacAlgorithm>
       http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
     </dskpp:MacAlgorithm>
     <dskpp:EncryptionKey>
       <ds:KeyName>KEY-1</ds:KeyName>
     </dskpp:EncryptionKey>
     <dskpp:KeyPackageFormat>
       http://www.ietf.org/keyprov/pskc#KeyContainer
     </dskpp:KeyPackageFormat>
     <dskpp:Payload>
       <dskpp:Nonce>qw2ewasde312asder394jw==</dskpp:Nonce>
     </dskpp:Payload>
   </dskpp:KeyProvServerHello>

























Doherty, et al.            Expires May 7, 2009                 [Page 88]


Internet-Draft                    DSKPP                    November 2008


A.2.4.  <KeyProvServerHello> Assuming a Preceding Trigger

 <?xml version="1.0" encoding="UTF-8"?>
 <dskpp:KeyProvServerHello Version="1.0" SessionID="4114"
   Status="Continue"
   xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
   xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
   xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
   <dskpp:KeyType>
     urn:ietf:params:xml:schema:keyprov:otpalg#SecurID-AES
   </dskpp:KeyType>
   <dskpp:EncryptionAlgorithm>
     http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
   </dskpp:EncryptionAlgorithm>
   <dskpp:MacAlgorithm>
     http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
   </dskpp:MacAlgorithm>
   <dskpp:EncryptionKey>
     <ds:KeyName>KEY-1</ds:KeyName>
   </dskpp:EncryptionKey>
   <dskpp:KeyPackageFormat>
     http://www.ietf.org/keyprov/pskc#KeyContainer
   </dskpp:KeyPackageFormat>
   <dskpp:Payload>
     <dskpp:Nonce>qw2ewasde312asder394jw==</dskpp:Nonce>
   </dskpp:Payload>
   <dskpp:Mac
     MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128">
     cXcycmFuZG9tMzEyYXNkZXIzOTRqdw==
   </dskpp:Mac>
 </dskpp:KeyProvServerHello>

A.2.5.  <KeyProvClientNonce> Using Default Encryption

   This message contains the nonce chosen by the cryptographic module,
   R_C, encrypted by the specified encryption key and encryption
   algorithm.














Doherty, et al.            Expires May 7, 2009                 [Page 89]


Internet-Draft                    DSKPP                    November 2008


   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:KeyProvClientNonce Version="1.0" SessionID="4114"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0">
     <dskpp:EncryptedNonce>VXENc+Um/9/NvmYKiHDLaErK0gk=
       </dskpp:EncryptedNonce>
     <dskpp:AuthenticationData>
       <dskpp:ClientID>31300257</dskpp:ClientID>
       <dskpp:AuthenticationCodeMac>
         <dskpp:IterationCount>512</dskpp:IterationCount>
         <dskpp:Mac>4bRJf9xXd3KchKoTenHJiw==</dskpp:Mac>
       </dskpp:AuthenticationCodeMac>
     </dskpp:AuthenticationData>
   </dskpp:KeyProvClientNonce>






































Doherty, et al.            Expires May 7, 2009                 [Page 90]


Internet-Draft                    DSKPP                    November 2008


A.2.6.  <KeyProvServerFinished> Using Default Encryption

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:KeyProvServerFinished Version="1.0" SessionID="4114" Status="Success"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0">
     <dskpp:KeyPackage>
       <dskpp:KeyPackage Version="1.0">
         <pskc:MACAlgorithm>http://www.w3.org/2000/09/xmldsig#hmac-sha1
         </pskc:MACAlgorithm>
         <pskc:Device>
           <pskc:Key
             KeyAlgorithm="http://www.rsa.com/rsalabs/otps/schemas/2005/09/
               otps-wst#SecurID-AES"
             KeyId="XL0000000001234">
             <pskc:Issuer>CredentialIssuer</pskc:Issuer>
             <pskc:Usage OTP="true">
               <pskc:ResponseFormat Format="DECIMAL" Length="6"/>
             </pskc:Usage>
             <pskc:FriendlyName>MyFirstToken</pskc:FriendlyName>
             <pskc:Data>
               <pskc:Time>
                 <pskc:PlainValue>0</pskc:PlainValue>
               </pskc:Time>
             </pskc:Data>
             <pskc:ExpiryDate>2012-12-31T00:00:00</pskc:ExpiryDate>
           </pskc:Key>
         </pskc:Device>
       </dskpp:KeyPackage>
     </dskpp:KeyPackage>
     <dskpp:Mac
       MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128">
       miidfasde312asder394jw==
     </dskpp:Mac>
   </dskpp:KeyProvServerFinished>

A.3.  Two-Pass Protocol

A.3.1.  Example Using the Key Transport Profile

   The client indicates support all the Key Transport, Key Wrap, and
   Passphrase-Based Key Wrap profiles:

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:KeyProvClientHello Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#">



Doherty, et al.            Expires May 7, 2009                 [Page 91]


Internet-Draft                    DSKPP                    November 2008


     <dskpp:DeviceIdentifierData>
       <dskpp:DeviceId>
         <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
         <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
         <pskc:Model>U2</pskc:Model>
       </dskpp:DeviceId>
     </dskpp:DeviceIdentifierData>
     <dskpp:ClientNonce>xwQzwEl0CjPAiQeDxwRJdQ==</dskpp:ClientNonce>
     <dskpp:SupportedKeyTypes>
       <dskpp:Algorithm>http://www.ietf.org/keyprov/pskc#hotp
         </dskpp:Algorithm>
       <dskpp:Algorithm>
         http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
       </dskpp:Algorithm>
     </dskpp:SupportedKeyTypes>
     <dskpp:SupportedEncryptionAlgorithms>
       <dskpp:Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5
         </dskpp:Algorithm>
       <dskpp:Algorithm>http://www.w3.org/2001/04/xmlenc#kw-aes128
         </dskpp:Algorithm>
       <dskpp:Algorithm>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
         </dskpp:Algorithm>
     </dskpp:SupportedEncryptionAlgorithms>
     <dskpp:SupportedMacAlgorithms>
       <dskpp:Algorithm>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
         </dskpp:Algorithm>
     </dskpp:SupportedMacAlgorithms>
     <dskpp:SupportedProtocolVariants>
       <dskpp:TwoPass>
         <dskpp:SupportedKeyProtectionMethod>
           urn:ietf:params:xml:schema:keyprov:dskpp#wrap
         </dskpp:SupportedKeyProtectionMethod>
         <dskpp:Payload>
             <ds:KeyInfo xsi:type="ds:KeyInfoType">
                 <ds:KeyName>Key_001</ds:KeyName>
             </ds:KeyInfo>
         </dskpp:Payload>
         <dskpp:SupportedKeyProtectionMethod>
           urn:ietf:params:xml:schema:keyprov:dskpp#transport
         </dskpp:SupportedKeyProtectionMethod>
         <dskpp:SupportedKeyProtectionMethod>
           urn:ietf:params:xml:schema:keyprov:dskpp#passphrase-wrap
         </dskpp:SupportedKeyProtectionMethod>
         <dskpp:Payload>
            <ds:KeyInfo xsi:type="ds:KeyInfoType">
                <ds:X509Data>
                    <ds:X509Certificate>miib</ds:X509Certificate>
                </ds:X509Data>



Doherty, et al.            Expires May 7, 2009                 [Page 92]


Internet-Draft                    DSKPP                    November 2008


            </ds:KeyInfo>
         </dskpp:Payload>
       </dskpp:TwoPass>
     </dskpp:SupportedProtocolVariants>
     <dskpp:SupportedKeyPackages>
       <dskpp:KeyPackageFormat>
         http://www.ietf.org/keyprov/pskc#KeyContainer
       </dskpp:KeyPackageFormat>
     </dskpp:SupportedKeyPackages>
     <dskpp:AuthenticationData>
       <dskpp:ClientID>31300257</dskpp:ClientID>
       <dskpp:AuthenticationCodeMac>
         <dskpp:IterationCount>512</dskpp:IterationCount>
         <dskpp:Mac>4bRJf9xXd3KchKoTenHJiw==</dskpp:Mac>
       </dskpp:AuthenticationCodeMac>
     </dskpp:AuthenticationData>
   </dskpp:KeyProvClientHello>

   In this example, the server responds to the previous request using
   the key transport profile.

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:KeyProvServerFinished Version="1.0" SessionID="4114"
     Status="Success"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     xmlns:xenc="http://www.w3.org/2001/04/xmlenc#">
     <dskpp:KeyPackage>
       <dskpp:ServerID>https://www.somedskppservice.com/</dskpp:ServerID>
         <dskpp:KeyProtectionMethod>
           urn:ietf:params:xml:schema:keyprov:dskpp#transport
         </dskpp:KeyProtectionMethod>
       <dskpp:KeyPackage Version="1.0">
         <pskc:EncryptionKey>
           <ds:X509Data>
             <ds:X509Certificate>miib</ds:X509Certificate>
           </ds:X509Data>
         </pskc:EncryptionKey>
         <pskc:Device>
           <pskc:DeviceInfo>
             <pskc:Manufacturer>ACME</pskc:Manufacturer>
             <pskc:SerialNo>0755225266</pskc:SerialNo>
           </pskc:DeviceInfo>
           <pskc:Key KeyAlgorithm="http://www.ietf.org/keyprov/pskc#hotp"
             KeyId="0755225266">
             <pskc:Issuer>AnIssuer</pskc:Issuer>
             <pskc:Usage OTP="true">



Doherty, et al.            Expires May 7, 2009                 [Page 93]


Internet-Draft                    DSKPP                    November 2008


               <pskc:ResponseFormat Length="8" Format="DECIMAL"/>
             </pskc:Usage>
             <pskc:Data>
               <pskc:Secret>
                 <pskc:EncryptedValue Id="ED">
                   <xenc:EncryptionMethod
                     Algorithm="http://www.w3.org/2001/04/xmlenc#rsa_1_5"/>
                   <xenc:CipherData>
                     <xenc:CipherValue>rf4dx3rvEPO0vKtKL14NbeVu8nk=
                     </xenc:CipherValue>
                   </xenc:CipherData>
                 </pskc:EncryptedValue>
               </pskc:Secret>
               <pskc:Counter>
                 <pskc:PlainValue>0</pskc:PlainValue>
               </pskc:Counter>
             </pskc:Data>
           </pskc:Key>
         </pskc:Device>
       </dskpp:KeyPackage>
     </dskpp:KeyPackage>
     <dskpp:Mac
       MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128">
       miidfasde312asder394jw==
     </dskpp:Mac>
     <dskpp:AuthenticationData>
       <dskpp:Mac>4bRJf9xXd3KchKoTenHJiw==</dskpp:Mac>
     </dskpp:AuthenticationData>
   </dskpp:KeyProvServerFinished>

A.3.2.  Example Using the Key Wrap Profile

   The client sends a request that specifies a shared key to protect the
   K_TOKEN, and the server responds using the Key Wrap Profile.
   Authentication data in this example is based on an authentication
   code rather than a device certificate.

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:KeyProvClientHello Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     xmlns:pkcs-5=
       "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#">
     <dskpp:DeviceIdentifierData>
       <dskpp:DeviceId>
         <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
         <pskc:SerialNo>XL0000000001234</pskc:SerialNo>



Doherty, et al.            Expires May 7, 2009                 [Page 94]


Internet-Draft                    DSKPP                    November 2008


         <pskc:Model>U2</pskc:Model>
       </dskpp:DeviceId>
     </dskpp:DeviceIdentifierData>
     <dskpp:ClientNonce>xwQzwEl0CjPAiQeDxwRJdQ==</dskpp:ClientNonce>
     <dskpp:SupportedKeyTypes>
       <dskpp:Algorithm>http://www.ietf.org/keyprov/pskc#hotp
         </dskpp:Algorithm>
       <dskpp:Algorithm>http://www.rsa.com/rsalabs/otps/schemas/2005/09/
         otps-wst#SecurID-AES</dskpp:Algorithm>
     </dskpp:SupportedKeyTypes>
     <dskpp:SupportedEncryptionAlgorithms>
       <dskpp:Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5
         </dskpp:Algorithm>
       <dskpp:Algorithm>http://www.w3.org/2001/04/xmlenc#kw-aes128
         </dskpp:Algorithm>
       <dskpp:Algorithm>http://www.rsasecurity.com/rsalabs/pkcs/schemas/
         pkcs-5#pbes2</dskpp:Algorithm>
       <dskpp:Algorithm>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
         </dskpp:Algorithm>
     </dskpp:SupportedEncryptionAlgorithms>
     <dskpp:SupportedMacAlgorithms>
       <dskpp:Algorithm>http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
         </dskpp:Algorithm>
     </dskpp:SupportedMacAlgorithms>
     <dskpp:SupportedProtocolVariants>
       <dskpp:TwoPass>
         <dskpp:SupportedKeyProtectionMethod>
           urn:ietf:params:xml:schema:keyprov:dskpp#wrap
         </dskpp:SupportedKeyProtectionMethod>
         <dskpp:Payload>
           <ds:KeyInfo xsi:type="ds:KeyInfoType">
             <ds:KeyName>Key_001</ds:KeyName>
           </ds:KeyInfo>
         </dskpp:Payload>
       </dskpp:TwoPass>
     </dskpp:SupportedProtocolVariants>
     <dskpp:SupportedKeyPackages>
       <dskpp:KeyPackageFormat>
         http://www.ietf.org/keyprov/pskc#KeyContainer
       </dskpp:KeyPackageFormat>
     </dskpp:SupportedKeyPackages>
     <dskpp:AuthenticationData>
       <dskpp:ClientID>31300257</dskpp:ClientID>
       <dskpp:AuthenticationCodeMac>
         <dskpp:IterationCount>512</dskpp:IterationCount>
         <dskpp:Mac>4bRJf9xXd3KchKoTenHJiw==</dskpp:Mac>
       </dskpp:AuthenticationCodeMac>
     </dskpp:AuthenticationData>



Doherty, et al.            Expires May 7, 2009                 [Page 95]


Internet-Draft                    DSKPP                    November 2008


   </dskpp:KeyProvClientHello>

   In this example, the server responds to the previous request using
   the key wrap profile.

   <?xml version="1.0" encoding="UTF-8"?>

   <dskpp:KeyProvServerFinished Version="1.0" Status="Success"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     xmlns:xenc="http://www.w3.org/2001/04/xmlenc#">
     <dskpp:KeyPackage>
       <dskpp:ServerID>https://www.somedskppservice.com/</dskpp:ServerID>
       <dskpp:KeyProtectionMethod>
         urn:ietf:params:xml:schema:keyprov:dskpp#wrap
       </dskpp:KeyProtectionMethod>
       <dskpp:KeyPackage Version="1.0">
        <pskc:EncryptionKey>
          <ds:KeyName>PRE_SHARED_KEY</ds:KeyName>
        </pskc:EncryptionKey>
        <pskc:MACAlgorithm>http://www.w3.org/2000/09/xmldsig#hmac-sha1
        </pskc:MACAlgorithm>
        <pskc:Device>
          <pskc:Key KeyAlgorithm="http://www.ietf.org/keyprov/pskc#hotp"
            KeyId="312345678">
            <pskc:Issuer>CredentialIssuer</pskc:Issuer>
            <pskc:Usage OTP="true">
              <pskc:ResponseFormat Format="DECIMAL" Length="6"/>
            </pskc:Usage>
            <pskc:FriendlyName>MyFirstToken</pskc:FriendlyName>
              <pskc:Data>
                <pskc:Secret>
                  <pskc:EncryptedValue>
                    <xenc:EncryptionMethod
                      Algorithm="http://www.w3.org/2001/04/xmlenc#aes256-cbc"/>
                    <xenc:CipherData>
                      <xenc:CipherValue>
                        kyzrWTJuhJKQHhZtf2CWbKC5H3LdfAPvKzHHQ8SdxyE=
                      </xenc:CipherValue>
                    </xenc:CipherData>
                  </pskc:EncryptedValue>
                  <pskc:ValueMAC>cwJI898rRpGBytTqCAsegaQqPZA=
                  </pskc:ValueMAC>
                </pskc:Secret>
                <pskc:Counter>
                  <pskc:PlainValue>1/pskc:PlainValue>
                </pskc:Counter>



Doherty, et al.            Expires May 7, 2009                 [Page 96]


Internet-Draft                    DSKPP                    November 2008


              </pskc:Data>
              <pskc:ExpiryDate>2012-12-31T00:00:00</pskc:ExpiryDate>
            </pskc:Key>
          </pskc:Device>
       </dskpp:KeyPackage>
     </dskpp:KeyPackage>
     <dskpp:Mac
       MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128">
       miidfasde312asder394jw==
     </dskpp:Mac>
     <dskpp:AuthenticationData>
       <dskpp:Mac>4bRJf9xXd3KchKoTenHJiw==</dskpp:Mac>
     </dskpp:AuthenticationData>
   </dskpp:KeyProvServerFinished>

A.3.3.  Example Using the Passphrase-Based Key Wrap Profile

   The client sends a request similar to that in Appendix A.3.1 with
   authentication data based on an authentication code, and the server
   responds using the Passphrase-Based Key Wrap Profile.  The
   authentication data is set in clear text when it is sent over a
   secure transport channel such as TLS.

   <?xml version="1.0" encoding="UTF-8"?>
   <dskpp:KeyProvClientHello Version="1.0"
     xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0"
     xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0"
     xmlns:ds="http://www.w3.org/2000/09/xmldsig#"
     xmlns:pkcs-5=
       "http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#">
     <dskpp:DeviceIdentifierData>
       <dskpp:DeviceId>
         <pskc:Manufacturer>ManufacturerABC</pskc:Manufacturer>
         <pskc:SerialNo>XL0000000001234</pskc:SerialNo>
         <pskc:Model>U2</pskc:Model>
       </dskpp:DeviceId>
     </dskpp:DeviceIdentifierData>
     <dskpp:ClientNonce>xwQzwEl0CjPAiQeDxwRJdQ==</dskpp:ClientNonce>
     <dskpp:SupportedKeyTypes>
       <dskpp:Algorithm>http://www.ietf.org/keyprov/pskc#hotp
         </dskpp:Algorithm>
       <dskpp:Algorithm>
         http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES
       </dskpp:Algorithm>
     </dskpp:SupportedKeyTypes>
     <dskpp:SupportedEncryptionAlgorithms>
       <dskpp:Algorithm>http://www.w3.org/2001/05/xmlenc#rsa_1_5
         </dskpp:Algorithm>



Doherty, et al.            Expires May 7, 2009                 [Page 97]


Internet-Draft                    DSKPP                    November 2008


       <dskpp:Algorithm>http://www.w3.org/2001/04/xmlenc#kw-aes128
         </dskpp:Algorithm>
       <dskpp:Algorithm>
         http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2
       </dskpp:Algorithm>
       <dskpp:Algorithm>
         http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
       </dskpp:Algorithm>
     </dskpp:SupportedEncryptionAlgorithms>
     <dskpp:SupportedMacAlgorithms>
       <dskpp:Algorithm>
         http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128
       </dskpp:Algorithm>
     </dskpp:SupportedMacAlgorithms>
     <dskpp:SupportedProtocolVariants>
       <dskpp:TwoPass>
         <dskpp:SupportedKeyProtectionMethod>
           urn:ietf:params:xml:schema:keyprov:dskpp#wrap
         </dskpp:SupportedKeyProtectionMethod>
         <dskpp:Payload>
           <ds:KeyInfo xsi:type="ds:KeyInfoType">
             <ds:KeyName>Key_001</ds:KeyName>
           </ds:KeyInfo>
         </dskpp:Payload>
         <dskpp:SupportedKeyProtectionMethod>
           urn:ietf:params:xml:schema:keyprov:dskpp#passphrase-wrap
         </dskpp:SupportedKeyProtectionMethod>
       </dskpp:TwoPass>
     </dskpp:SupportedProtocolVariants>
     <dskpp:SupportedKeyPackages>
       <dskpp:KeyPackageFormat>
         http://www.ietf.org/keyprov/pskc#KeyContainer
       </dskpp:KeyPackageFormat>
     </dskpp:SupportedKeyPackages>
     <dskpp:AuthenticationData>
       <dskpp:ClientID>31300257</dskpp:ClientID>
       <dskpp:AuthenticationCodeMac>
         <dskpp:IterationCount>512</dskpp:IterationCount>
         <dskpp:Mac>4bRJf9xXd3KchKoTenHJiw==</dskpp:Mac>
       </dskpp:AuthenticationCodeMac>
     </dskpp:AuthenticationData>
   </dskpp:KeyProvClientHello>

   In this example, the server responds to the previous request using
   the Passphrase-Based Key Wrap Profile.

   (preamble)
<?xml version="1.0" encoding="UTF-8"?>



Doherty, et al.            Expires May 7, 2009                 [Page 98]


Internet-Draft                    DSKPP                    November 2008


<dskpp:KeyProvServerFinished Version="1.0" SessionID="4114" Status="Success" xmlns:dskpp="urn:ietf:params:xml:ns:keyprov:dskpp:1.0" xmlns:pskc="urn:ietf:params:xml:ns:keyprov:pskc:1.0" xmlns:pkcs-5="http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#" xmlns:ds="http://www.w3.org/2000/09/xmldsig#" xmlns:xenc="http://www.w3.org/2001/04/xmlenc#" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:ietf:params:xml:ns:keyprov:dskpp:1.0 keyprov-dskpp-1.0-local.xsd http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0# pkcs-5v2-0a1.xsd">
  <dskpp:KeyPackage>
    <dskpp:ServerID>https://www.somedskppservice.com/</dskpp:ServerID>
    <dskpp:KeyProtectionMethod>
       urn:ietf:params:xml:schema:keyprov:protocol#passphrase-wrap
    </dskpp:KeyProtectionMethod>
    <dskpp:KeyPackage Version="1.0">
      <pskc:EncryptionKey>
        <pskc:DerivedKey>
          <pskc:CarriedKeyName>Passphrase1</pskc:CarriedKeyName>
          <pskc:KeyDerivationMethod Algorithm="http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbkdf2">
            <pkcs-5:PBKDF2-params>
              <Salt>
                <Specified>P1ciQdGbrI0=</Specified>
              </Salt>
              <IterationCount>2000</IterationCount>
              <KeyLength>16</KeyLength>
              <PRF/>
            </pkcs-5:PBKDF2-params>
          </pskc:KeyDerivationMethod>
          <xenc:ReferenceList>
            <xenc:DataReference URI="#ED"/>
          </xenc:ReferenceList>
       </pskc:DerivedKey>
      </pskc:EncryptionKey>
      <pskc:Device>
        <pskc:DeviceInfo>
          <pskc:Manufacturer>Manufacturer</pskc:Manufacturer>
          <pskc:SerialNo>0755225266</pskc:SerialNo>
        </pskc:DeviceInfo>
        <pskc:Key KeyAlgorithm="http://www.ietf.org/keyprov/pskc#hotp" KeyId="0755225266">
          <pskc:Issuer>AnIssuer</pskc:Issuer>
          <pskc:Usage OTP="true">
            <pskc:ResponseFormat Length="6" Format="DECIMAL"/>
          </pskc:Usage>
          <pskc:Data>
            <pskc:Secret>
              <pskc:EncryptedValue>
                <xenc:EncryptionMethod Algorithm="http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2">
                  <pskc:EncryptionScheme Algorithm="http://www.w3.org/2001/04/xmlenc#aes128-cbc"/>
                </xenc:EncryptionMethod>
                <xenc:CipherData>
                  <xenc:CipherValue>rf4dx3rvEPO0vKtKL14NbeVu8nk=
                    </xenc:CipherValue>
                </xenc:CipherData>
              </pskc:EncryptedValue>
            </pskc:Secret>
            <pskc:Counter>



Doherty, et al.            Expires May 7, 2009                 [Page 99]


Internet-Draft                    DSKPP                    November 2008


              <pskc:PlainValue>0</pskc:PlainValue>
            </pskc:Counter>
          </pskc:Data>
        </pskc:Key>
      </pskc:Device>
    </dskpp:KeyPackage>
  </dskpp:KeyPackage>
  <dskpp:Mac MacAlgorithm="http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes">
     miidfasde312asder394jw==
  </dskpp:Mac>
  <dskpp:AuthenticationData>
    <dskpp:Mac>4bRJf9xXd3KchKoTenHJiw==</dskpp:Mac>
  </dskpp:AuthenticationData>
</dskpp:KeyProvServerFinished>
   (postamble)


Appendix B.  Integration with PKCS #11

   A DSKPP client that needs to communicate with a connected
   cryptographic module to perform a DSKPP exchange MAY use PKCS #11
   [PKCS-11] as a programming interface.

B.1.  The 4-pass Variant

   When performing 4-pass DSKPP with a cryptographic module using the
   PKCS #11 programming interface, the procedure described in
   [CT-KIP-P11], Appendix B, is RECOMMENDED.

B.2.  The 2-pass Variant

   A suggested procedure to perform 2-pass DSKPP with a cryptographic
   module through the PKCS #11 interface using the mechanisms defined in
   [CT-KIP-P11] is as follows:

   a.  On the client side,
       1.  The client selects a suitable slot and token (e.g. through
           use of the <DeviceIdentifier> or the <PlatformInfo> element
           of the DSKPP trigger message).
       2.  A nonce R is generated, e.g. by calling C_SeedRandom and
           C_GenerateRandom.
       3.  The client sends its first message to the server, including
           the nonce R.
   b.  On the server side,







Doherty, et al.            Expires May 7, 2009                [Page 100]


Internet-Draft                    DSKPP                    November 2008


       1.  A generic key K_PROV = K_TOKEN | K_MAC (where '|' denotes
           concatenation) is generated, e.g. by calling C_GenerateKey
           (using key type CKK_GENERIC_SECRET).  The template for K_PROV
           MUST allow it to be exported (but only in wrapped form, i.e.
           CKA_SENSITIVE MUST be set to CK_TRUE and CKA_EXTRACTABLE MUST
           also be set to CK_TRUE), and also to be used for further key
           derivation.  From K, a token key K_TOKEN of suitable type is
           derived by calling C_DeriveKey using the PKCS #11 mechanism
           CKM_EXTRACT_KEY_FROM_KEY and setting the CK_EXTRACT_PARAMS to
           the first bit of the generic secret key (i.e. set to 0).
           Likewise, a MAC key K_MAC is derived from K_PROV by calling
           C_DeriveKey using the CKM_EXTRACT_KEY_FROM_KEY mechanism,
           this time setting CK_EXTRACT_PARAMS to the length of K_PROV
           (in bits) divided by two.
       2.  The server wraps K_PROV with either the public key of the
           DSKPP client or device, the pre-shared secret key, or the
           derived shared secret key by using C_WrapKey.  If use of the
           DSKPP key wrap algorithm has been negotiated then the
           CKM_KIP_WRAP mechanism MUST be used to wrap K. When calling
           C_WrapKey, the hKey handle in the CK_KIP_PARAMS structure
           MUST be set to NULL_PTR.  The pSeed parameter in the
           CK_KIP_PARAMS structure MUST point to the nonce R provided by
           the DSKPP client, and the ulSeedLen parameter MUST indicate
           the length of R. The hWrappingKey parameter in the call to
           C_WrapKey MUST be set to refer to the key wrapping key.
       3.  Next, the server needs to calculate a MAC using K_MAC.  If
           use of the DSKPP MAC algorithm has been negotiated, then the
           MAC is calculated by calling C_SignInit with the CKM_KIP_MAC
           mechanism followed by a call to C_Sign.  In the call to
           C_SignInit, K_MAC MUST be the signature key, the hKey
           parameter in the CK_KIP_PARAMS structure MUST be set to
           NULL_PTR, the pSeed parameter of the CT_KIP_PARAMS structure
           MUST be set to NULL_PTR, and the ulSeedLen parameter MUST be
           set to zero.  In the call to C_Sign, the pData parameter MUST
           be set to the concatenation of the string ServerID and the
           nonce R, and the ulDataLen parameter MUST be set to the
           length of the concatenated string.  The desired length of the
           MAC MUST be specified through the pulSignatureLen parameter
           and MUST be set to the length of R.
       4.  If the server also needs to authenticate its message (due to
           an existing K_TOKEN being replaced), the server MUST
           calculate a second MAC.  Again, if use of the DSKPP MAC
           algorithm has been negotiated, then the MAC is calculated by
           calling C_SignInit with the CKM_KIP_MAC mechanism followed by
           a call to C_Sign.  In this call to C_SignInit, the K_MAC'
           existing before this DSKPP protocol run MUST be the signature
           key (the implementation may specify K_MAC' to be the value of
           the K_TOKEN that is being replaced, or a version of K_MAC



Doherty, et al.            Expires May 7, 2009                [Page 101]


Internet-Draft                    DSKPP                    November 2008


           from the previous protocol run), the hKey parameter in the
           CK_KIP_PARAMS structure MUST be set to NULL, the pSeed
           parameter of the CT_KIP_PARAMS structure MUST be set to
           NULL_PTR, and the ulSeedLen parameter MUST be set to zero.
           In the call to C_Sign, the pData parameter MUST be set to the
           concatenation of the string ServerID and the nonce R, and the
           ulDataLen parameter MUST be set to the length of concatenated
           string.  The desired length of the MAC MUST be specified
           through the pulSignatureLen parameter and MUST be set to the
           length of R.
       5.  The server sends its message to the client, including the
           wrapped key K_TOKEN, the MAC and possibly also the
           authenticating MAC.
   c.  On the client side,
       1.  The client calls C_UnwrapKey to receive a handle to K. After
           this, the client calls C_DeriveKey twice: Once to derive
           K_TOKEN and once to derive K_MAC.  The client MUST use the
           same mechanism (CKM_EXTRACT_KEY_FROM_KEY) and the same
           mechanism parameters as used by the server above.  When
           calling C_UnwrapKey and C_DeriveKey, the pTemplate parameter
           MUST be used to set additional key attributes in accordance
           with local policy and as negotiated and expressed in the
           protocol.  In particular, the value of the <KeyID> element in
           the server's response message MAY be used as CKA_ID for
           K_TOKEN.  The key K_PROV MUST be destroyed after deriving
           K_TOKEN and K_MAC.
       2.  The MAC is verified in a reciprocal fashion as it was
           generated by the server.  If use of the CKM_KIP_MAC mechanism
           has been negotiated, then in the call to C_VerifyInit, the
           hKey parameter in the CK_KIP_PARAMS structure MUST be set to
           NULL_PTR, the pSeed parameter MUST be set to NULL_PTR, and
           ulSeedLen MUST be set to 0.  The hKey parameter of
           C_VerifyInit MUST refer to K_MAC.  In the call to C_Verify,
           pData MUST be set to the concatenation of the string ServerID
           and the nonce R, and the ulDataLen parameter MUST be set to
           the length of the concatenated string, pSignature to the MAC
           value received from the server, and ulSignatureLen to the
           length of the MAC.  If the MAC does not verify the protocol
           session ends with a failure.  The token MUST be constructed
           to not "commit" to the new K_TOKEN or the new K_MAC unless
           the MAC verifies.
       3.  If an authenticating MAC was received (REQUIRED if the new
           K_TOKEN will replace an existing key on the token), then it
           is verified in a similar vein but using the K_MAC' associated
           with this server and existing before the protocol run (the
           implementation may specify K_MAC' to be the value of the
           K_TOKEN that is being replaced, or a version of K_MAC from
           the previous protocol run).  Again, if the MAC does not



Doherty, et al.            Expires May 7, 2009                [Page 102]


Internet-Draft                    DSKPP                    November 2008


           verify the protocol session ends with a failure, and the
           token MUST be constructed no to "commit" to the new K_TOKEN
           or the new K_MAC unless the MAC verifies.


Appendix C.  Example of DSKPP-PRF Realizations

C.1.  Introduction

   This example appendix defines DSKPP-PRF in terms of AES [FIPS197-AES]
   and HMAC [RFC2104].

C.2.  DSKPP-PRF-AES

C.2.1.  Identification

   For cryptographic modules supporting this realization of DSKPP-PRF,
   the following URL MAY be used to identify this algorithm in DSKPP:

   http://www.ietf.org/keyprov/dskpp#dskpp-prf-aes-128

   When this URL is used to identify the encryption algorithm, the
   method for encryption of R_C values described in Section 3.4.3 MUST
   be used.

C.2.2.  Definition

   DSKPP-PRF-AES (k, s, dsLen)

   Input:

   k         Encryption key to use
   s         Octet string consisting of randomizing material.  The
             length of the string s is sLen.
   dsLen     Desired length of the output

   Output:

   DS        A pseudorandom string, dsLen-octets long

   Steps:

   1.  Let bLen be the output block size of AES in octets:

       bLen = (AES output block length in octets)
       (normally, bLen = 16)





Doherty, et al.            Expires May 7, 2009                [Page 103]


Internet-Draft                    DSKPP                    November 2008


   2.  If dsLen > (2**32 - 1) * bLen, output "derived data too long" and
       stop

   3.  Let n be the number of bLen-octet blocks in the output data,
       rounding up, and let j be the number of octets in the last block:

       n = CEILING( dsLen / bLen)
       j = dsLen - (n - 1) * bLen

   4.  For each block of the pseudorandom string DS, apply the function
       F defined below to the key k, the string s and the block index to
       compute the block:

       B1 = F (k, s, 1) ,
       B2 = F (k, s, 2) ,
       ...
       Bn = F (k, s, n)

   The function F is defined in terms of the CMAC construction from
   [NIST-SP800-38B], using AES as the block cipher:

   F (k, s, i) = CMAC-AES (k, INT (i) || s)

   where INT (i) is a four-octet encoding of the integer i, most
   significant octet first, and the output length of CMAC is set to
   bLen.

   Concatenate the blocks and extract the first dsLen octets to product
   the desired data string DS:

   DS = B1 || B2 || ... || Bn<0..j-1>

   Output the derived data DS.

C.2.3.  Example

   If we assume that dsLen = 16, then:

   n = 16 / 16 = 1

   j = 16 - (1 - 1) * 16 = 16

   DS = B1 = F (k, s, 1) = CMAC-AES (k, INT (1) || s)

C.3.  DSKPP-PRF-SHA256






Doherty, et al.            Expires May 7, 2009                [Page 104]


Internet-Draft                    DSKPP                    November 2008


C.3.1.  Identification

   For cryptographic modules supporting this realization of DSKPP-PRF,
   the following URL MAY be used to identify this algorithm in DSKPP:

   http://www.ietf.org/keyprov/dskpp#dskpp-prf-sha256

   When this URL is used to identify the encryption algorithm to use,
   the method for encryption of R_C values described in Section 3.4.3
   MUST be used.

C.3.2.  Definition

   DSKPP-PRF-SHA256 (k, s, dsLen)

   Input:

   k         Encryption key to use
   s         Octet string consisting of randomizing material.  The
             length of the string s is sLen.
   dsLen     Desired length of the output

   Output:

   DS        A pseudorandom string, dsLen-octets long

   Steps:

   1.  Let bLen be the output size of SHA-256 in octets of [FIPS180-SHA]
       (no truncation is done on the HMAC output):

       bLen = 32
       (normally, bLen = 16)

   2.  If dsLen > (2**32 - 1) * bLen, output "derived data too long" and
       stop

   3.  Let n be the number of bLen-octet blocks in the output data,
       rounding up, and let j be the number of octets in the last block:

       n = CEILING( dsLen / bLen)
       j = dsLen - (n - 1) * bLen

   4.  For each block of the pseudorandom string DS, apply the function
       F defined below to the key k, the string s and the block index to
       compute the block:

       B1 = F (k, s, 1),



Doherty, et al.            Expires May 7, 2009                [Page 105]


Internet-Draft                    DSKPP                    November 2008


       B2 = F (k, s, 2),
       ...
       Bn = F (k, s, n)

   The function F is defined in terms of the HMAC construction from
   [RFC2104], using SHA-256 as the digest algorithm:

   F (k, s, i) = HMAC-SHA256 (k, INT (i) || s)

   where INT (i) is a four-octet encoding of the integer i, most
   significant octet first, and the output length of HMAC is set to
   bLen.

   Concatenate the blocks and extract the first dsLen octets to product
   the desired data string DS:

   DS = B1 || B2 || ... || Bn<0..j-1>

   Output the derived data DS.

C.3.3.  Example

   If we assume that sLen = 256 (two 128-octet long values) and dsLen =
   16, then:

   n = CEILING( 16 / 32 ) = 1

   j = 16 - (1 - 1) * 32 = 16

   B1 = F (k, s, 1) = HMAC-SHA256 (k, INT (1) || s)

   DS = B1<0 ... 15>

   That is, the result will be the first 16 octets of the HMAC output.


Authors' Addresses

   Andrea Doherty
   RSA, The Security Division of EMC
   174 Middlesex Tpk.
   Bedford, MA  01730
   USA

   Email: andrea.doherty@rsa.com






Doherty, et al.            Expires May 7, 2009                [Page 106]


Internet-Draft                    DSKPP                    November 2008


   Mingliang Pei
   Verisign, Inc.
   487 E. Middlefield Road
   Mountain View, CA  94043
   USA

   Email: mpei@verisign.com


   Salah Machani
   Diversinet Corp.
   2225 Sheppard Avenue East, Suite 1801
   Toronto, Ontario  M2J 5C2
   Canada

   Email: smachani@diversinet.com


   Magnus Nystrom
   RSA, The Security Division of EMC
   Arenavagen 29
   Stockholm, Stockholm Ln  121 29
   SE

   Email: magnus.nystrom@rsa.com


























Doherty, et al.            Expires May 7, 2009                [Page 107]


Internet-Draft                    DSKPP                    November 2008


Full Copyright Statement

   Copyright (C) The IETF Trust (2008).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.











Doherty, et al.            Expires May 7, 2009                [Page 108]




