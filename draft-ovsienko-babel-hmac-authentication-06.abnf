First-Hash = H(Ko XOR Ipad || Text)

Second-Hash = H(Ko XOR Opad || First-Hash)

R = St + MaxDigestsOut * Sh =
                      = 8  + MaxDigestsOut * (4 + Lmax)

AuthKeyOctets=Key26}}}

AuthKeyOctets=Key70}}}

This=key=is=exactly=70=octets=long.=ABCDEFGHIJKLMNOPQRSTUVWXYZ01234567

       *  Key70 in hexadecimal:

   54:68:69:73:3d:6b:65:79:3d:69:73:3d:65:78:61:63
   74:6c:79:3d:37:30:3d:6f:63:74:65:74:73:3d:6c:6f
   6e:67:2e:3d:41:42:43:44:45:46:47:48:49:4a:4b:4c
   4d:4e:4f:50:51:52:53:54:55:56:57:58:59:5a:30:31
   32:33:34:35:36:37

       The length of each key was picked to relate (in the terms of
       Section 2.4) with the properties of respective hash algorithm as
       follows:
       *  the digest length (L) of both RIPEMD-160 and SHA-1 is 20
          octets,

       *  the internal block size (B) of both RIPEMD-160 and SHA-1 is 64
          octets,

       *  the length of Key26 (26) is greater than L but less than B,
          and

       *  the length of Key70 (70) is greater than B (and thus greater
          than L).

       KeyStartAccept, KeyStopAccept, KeyStartGenerate and
       KeyStopGenerate were set to make both authentication keys valid.

   2.  The instance of the original protocol of the speaker produced a
       Babel packet (PktO) to be sent from the interface.  Table 2
       provides a decoding of PktO, contents of which is below:

   2a:02:00:14:04:06:00:00:09:25:01:90:08:0a:00:40
   00:00:ff:ff:68:21:ff:ff

   3.  The authentication mechanism appended one TS/PC TLV and two HMAC
       TLVs to the packet body, updated the "Body length" packet header
       field and padded the Digest field of the HMAC TLVs using the
       link-local IPv6 address of the interface and necessary amount of
       zeroes.  Table 3 provides a decoding of the resulting temporary
       packet (PktT), contents of which is below:

   2a:02:00:4c:04:06:00:00:09:25:01:90:08:0a:00:40
   00:00:ff:ff:68:21:ff:ff:0b:06:00:01:52:1d:7e:8b
   0c:16:00:c8:fe:80:00:00:00:00:00:00:0a:11:96:ff
   fe:1c:10:c8:00:00:00:00:0c:16:00:64:fe:80:00:00
   00:00:00:00:0a:11:96:ff:fe:1c:10:c8:00:00:00:00

   4.  The authentication mechanism produced two HMAC results,
       performing the computations as follows:

       *  For H=RIPEMD-160, K=Key26, and Text=PktT the HMAC result is:

   c6:f1:06:13:30:3c:fa:f3:eb:5d:60:3a:ed:fd:06:55
   83:f7:ee:79

       *  For H=SHA-1, K=Key70, and Text=PktT the HMAC result is:

   df:32:16:5e:d8:63:16:e5:a6:4d:c7:73:e0:b5:22:82
   ce:fe:e2:3c
   5.  The authentication mechanism placed each HMAC result into
       respective HMAC TLV, producing the final authenticated Babel
       packet (PktA), which was eventually sent from the interface.
       Table 4 provides a decoding of PktA, contents of which is below:

   2a:02:00:4c:04:06:00:00:09:25:01:90:08:0a:00:40
   00:00:ff:ff:68:21:ff:ff:0b:06:00:01:52:1d:7e:8b
   0c:16:00:c8:c6:f1:06:13:30:3c:fa:f3:eb:5d:60:3a
   ed:fd:06:55:83:f7:ee:79:0c:16:00:64:df:32:16:5e
   d8:63:16:e5:a6:4d:c7:73:e0:b5:22:82:ce:fe:e2:3c

   Interpretation of this process is to be done in the view of Figure 1,
   differently for the sending and the receiving directions.

   For the sending direction, given a Babel speaker configured using the
   IPv6 address and the sequence of CSAs as described above, the
   implementation SHOULD (see notes in Section 5.3) produce exactly the
   temporary packet PktT if the original protocol instance produces
   exactly the packet PktO to be sent from the interface.  If the
   temporary packet exactly matches PktT, the HMAC results computed
   afterwards MUST exactly match respective results above and the final
   authenticated packet MUST exactly match the PktA above.

   For the receiving direction, given a Babel speaker configured using
   the sequence of CSAs as described above (but a different IPv6
   address), the implementation MUST (assuming the TS/PC check didn't
   fail) produce exactly the temporary packet PktT above if its network
   stack receives through the interface exactly the packet PktA above
   from the source IPv6 address above.  The first HMAC result computed
   afterwards MUST match the first result above.  The receiving
   procedure doesn't compute the second HMAC result in this case, but if
   the implementor decides to compute it anyway for the verification
   purpose, it MUST exactly match the second result above.


