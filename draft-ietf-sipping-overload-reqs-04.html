<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Requirements for Management of Overload in the Session Initiation
Protocol</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Requirements for Management of Overload in the Session Initiation
Protocol">
<meta name="keywords" content="SIP, Overload">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">SIPPING</td><td class="header">J. Rosenberg</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">Cisco</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">May 24, 2008</td></tr>
<tr><td class="header">Expires: November 25, 2008</td><td class="header">&nbsp;</td></tr>
</table></td></tr></table>
<h1><br />Requirements for Management of Overload in the Session Initiation
Protocol<br />draft-ietf-sipping-overload-reqs-04</h1>

<h3>Status of this Memo</h3>
<p>
By submitting this Internet-Draft,
each author represents that any applicable patent or other IPR claims of which
he or she is aware have been or will be disclosed,
and any of which he or she becomes aware will be disclosed,
in accordance with Section&nbsp;6 of BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on November 25, 2008.</p>

<h3>Abstract</h3>

<p>Overload occurs in Session Initiation Protocol (SIP)
networks when proxies and user agents have insuffient resources to
complete the processing of a request. SIP provides limited support for
overload handling through its 503 response code, which tells an
upstream element that it is overloaded. However, numerous problems
have been identified with this mechanism. This draft summarizes the
problems with the existing 503 mechanism, and provides some
requirements for a solution.
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#anchor1">1.</a>&nbsp;
Introduction<br />
<a href="#anchor2">2.</a>&nbsp;
Causes of Overload<br />
<a href="#anchor3">3.</a>&nbsp;
Terminology<br />
<a href="#anchor4">4.</a>&nbsp;
Current SIP Mechanisms<br />
<a href="#anchor5">5.</a>&nbsp;
Problems with the Mechanism<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor6">5.1.</a>&nbsp;
Load Amplification<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor7">5.2.</a>&nbsp;
Underutilization<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor8">5.3.</a>&nbsp;
The Off/On Retry-After Problem<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor9">5.4.</a>&nbsp;
Ambiguous Usages<br />
<a href="#anchor10">6.</a>&nbsp;
Solution Requirements<br />
<a href="#anchor11">7.</a>&nbsp;
Security Considerations<br />
<a href="#anchor12">8.</a>&nbsp;
IANA Considerations<br />
<a href="#anchor13">9.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">10.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Author's Address<br />
<a href="#rfc.copyright">&#167;</a>&nbsp;
Intellectual Property and Copyright Statements<br />
</p>
<br clear="all" />

<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>Overload occurs in Session Initiation Protocol (SIP)
<a class='info' href='#RFC3261'>[RFC3261]<span> (</span><span class='info'>Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &ldquo;SIP: Session Initiation Protocol,&rdquo; June&nbsp;2002.</span><span>)</span></a> networks when proxies and user agents have
insuffient resources to complete the processing of a request or a
response. SIP provides limited support for overload handling through
its 503 response code. This code allows a server to tell an upstream
element that it is overloaded. However, numerous problems have been
identified with this mechanism.

</p>
<p> This draft describes the general problem of SIP overload, and then
reviews the current SIP mechanisms for dealing with overload. It then
explains some of the problems with these mechanisms. Finally, the
document provides a set of requirements for fixing these problems.

</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Causes of Overload</h3>

<p>Overload occurs when an element, such as a SIP user agent or proxy,
has insufficient resources to successfully process all of the traffic
it is receiving. Resources include all of the capabilities of the
element used to process a request, including CPU processing, memory,
I/O, or disk resources. It can also include external resources, such
as a database or DNS server, in which case the CPU, processing,
memory, I/O and disk resources of those servers are effectively part
of the logical element processing the request. Overload can occur for
many reasons, including:

</p>
<blockquote class="text"><dl>
<dt>Poor Capacity Planning:</dt>
<dd> SIP networks need to be
designed with sufficient numbers of servers, hardware, disks, and so
on, in order to meet the needs of the subscribers they are expected to
serve. Capacity planning is the process of determining these needs. It
is based on the number of expected subscribers and the types of flows
they are expected to use. If this work is not done properly, the
network may have insufficient capacity to handle predictable usages,
including regular usages and predictably high ones (such as high voice
calling volumes on Mothers Day).

</dd>
<dt>Dependency Failures:</dt>
<dd> A SIP element can become
overloaded because a resource on which it is dependent has failed or
become overloaded, greatly reducing the logical capacity of the
element. In these cases, even minimal traffic might cause the server
to go into overload. Examples of such dependency overloads include DNS
servers, databases, disks and network interfaces.

</dd>
<dt>Component Failures:</dt>
<dd> A SIP element can become overloaded
when it is a member of a cluster of servers which each share the load
of traffic, and one or more of the other members in the cluster
fail. In this case, the remaining elements take over the work of the
failed elements. Normally, capacity planning takes such failures into
account, and servers are typically run with enough spare capacity to
handle failure of another element. However, unusual failure conditions
can cause many elements to fail at once. This is often the case with
software failures, where a bad packet or bad database entry hits the
same bug in a set of elements in a cluster.

</dd>
<dt>Avalanche Restart:</dt>
<dd> One of the most troubling sources of
overload is avalanche restart. This happens when a large number of
clients all simultaneously attempt to connect to the network with a
SIP registration. Avalanche restart can be caused by several
events. One is the "Manhattan Reboots" scenario, where there is a
power failure in a large metropolitan area, such as Manhattan. When
power is restored, all of the SIP phones, whether in PCs or standalone
devices, simultaneously power on and begin booting. They will all then
connect to the network and register, causing a flood of SIP REGISTER
messages. Another cause of avalanche restart is failure of a large
network connection, for example, the access router for an
enterprise. When it fails, SIP clients will detect the failure rapidly
using the mechanisms in <a class='info' href='#I-D.ietf-sip-outbound'>[I&#8209;D.ietf&#8209;sip&#8209;outbound]<span> (</span><span class='info'>Jennings, C., &ldquo;Managing Client Initiated Connections in the Session Initiation Protocol  (SIP),&rdquo; June&nbsp;2009.</span><span>)</span></a>. When
connectivity is restored, this is detected, and clients re-REGISTER,
all within a short time period. Another source of avalanche restart is
failure of a proxy server. If clients had all connected to the server
with TCP, its failure will be detected, followed by re-connection and
re-registration to another server. Note that <a class='info' href='#I-D.ietf-sip-outbound'>[I&#8209;D.ietf&#8209;sip&#8209;outbound]<span> (</span><span class='info'>Jennings, C., &ldquo;Managing Client Initiated Connections in the Session Initiation Protocol  (SIP),&rdquo; June&nbsp;2009.</span><span>)</span></a> does provide some remedies to this
case. 

</dd>
<dt>Flash Crowds:</dt>
<dd> A flash crowd occurs when an extremely
large number of users all attempt to simultaneously make a call. One
example of how this can happen is a television
commercial that advertises a number to call to receive a free gift. If
the gift is compelling and many people see the ad, many calls can be
simultaneously made to the same number. This can send the system into
overload. 

</dd>
</dl></blockquote>
<p> Unfortunately, the overload problem tends to compound itself. When
a network goes into overload, this can frequently cause failures of
the elements that are trying to process the traffic. This causes even
more load on the remaining elements. Furthermore, during overload, the
overall capacity of functional elements goes down, since much of their
resources are spent just rejecting or treating load that they cannot
actually process. In addition, overload tends to cause SIP messages to
be delayed or lost, which causes retransmissions to be sent, further
increasing the amount of work in the network. This compounding factor
can produce substantial multipliers on the load in the system. Indeed,
in the case of UDP, with as many as 7 retransmits of an INVITE request
prior to timeout, overload can multiply the already-heavy message
volume by as much as seven!
</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Terminology</h3>

<p> The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL
NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in
this document are to be interpreted as described in <a class='info' href='#RFC2119'>RFC 2119<span> (</span><span class='info'>Bradner, S., &ldquo;Key words for use in RFCs to Indicate Requirement Levels,&rdquo; March&nbsp;1997.</span><span>)</span></a> [RFC2119].  
</p>
<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Current SIP Mechanisms</h3>

<p>
SIP provides very basic support for overload. It defines the 503
response code, which is sent by an element that is overloaded. RFC 3261
defines it thusly: 

</p><div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

     The server is temporarily unable to process the request due to
     a temporary overloading or maintenance of the server.  The
     server MAY indicate when the client should retry the request in
     a Retry-After header field.  If no Retry-After is given, the
     client MUST act as if it had received a 500 (Server Internal
     Error) response.

     A client (proxy or UAC) receiving a 503 (Service Unavailable)
     SHOULD attempt to forward the request to an alternate server.
     It SHOULD NOT forward any other requests to that server for the
     duration specified in the Retry-After header field, if present.

     Servers MAY refuse the connection or drop the request instead of
     responding with 503 (Service Unavailable).
</pre></div>
<p>
The objective is to provide a mechanism to move the work of the
overloaded server to another server, so that the request can be
processed. The Retry-After header field, when present, is meant to
allow a server to tell an upstream element to back off for a period of
time, so that the overloaded server can work through its backlog of
work. 

</p>
<p> RFC3261 also instructs proxies to not forward 503 responses
upstream, at SHOULD NOT strength. This is to avoid the upstream server
of mistakingly concluding that the proxy is overloaded, when in fact
the problem was an element further downstream.

</p>
<a name="anchor5"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Problems with the Mechanism</h3>

<p> At the surface, the 503 mechanism seems workable.  Unfortunately,
this mechanism has had numerous problems in actual deployment. These
problems are described here.
</p>
<a name="anchor6"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.1"></a><h3>5.1.&nbsp;
Load Amplification</h3>

<p>
The principal problem with the 503 mechanism is that it tends to
substantially amplify the load in the network when the network is
overloaded, causing further escalation of the problem and introducing
the very real possibility of congestive collapse. Consider the
topology in <a class='info' href='#fig:lb'>Figure&nbsp;1</a>.

</p><br /><hr class="insert" />
<a name="fig:lb"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>

                                      +------+
                                    &gt; |      |
                                   /  |  S1  |
                                  /   |      |
                                 /    +------+
                                /
                               /
                              /
                             /
                   +------+ /         +------+
         --------&gt; |      |/          |      |
                   |  P1  |---------&gt; |  S2  |
         --------&gt; |      |\          |      |
                   +------+ \         +------+
                             \
                              \
                               \
                                \
                                 \
                                  \   +------+
                                   \  |      |
                                    &gt; |  S3  |
                                      |      |
                                      +------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
Proxy P1 receives SIP requests from many sources, and acts solely as a
load balancer, proxying the requests to servers S1, S2 and S3 for
processing. The input load increases to the point where all three
servers become overloaded. Server S1, when it receives its next
request, generates a 503. However, because the server is loaded, it
might take some time to generate the 503. If SIP is being run over
UDP, this may result in request retransmissions which further increase
the work on S1. Even in the case of TCP, if the server is loaded and
the kernel cannot send TCP acknowledgements fast enough, TCP
retransmits may occur. When the 503 is received by P1, it retries the
request on S2. S2 is also overloaded, and eventually generates a 503,
but in the interim may also be hit with retransmits. P1 once again
tries another server, this time S3, which also eventually rejects it
with a 503.

</p>
<p> Thus, the processing of this request, which ultimately failed,
involved four SIP transactions (client to P1, P1 to S1, P1 to S2, P1
to S3), each of which may have involved many retransmissions - up to 7
in the case of UDP. Thus, under unloaded conditions, a single request
from a client would generate one request (to S1, S2 or S3) and two
responses (from S1 to P1, then P1 to the client). When the network is
overloaded, a single request from the client, before timing out, could
generate as many as 18 requests and as many responses when UDP is
used! The situation is better with TCP (or any reliable transport in
general), but even if there was never a TCP segment retransmitted, a
single request from the client can generate 3 requests and four
responses. Each server had to expend resources to process these
messages. Thus, more messages and more work were sent into the network
at the point at which the elements became overloaded. The 503
mechanism works well when a single element is overloaded. But, when
the problem is overall network load, the 503 mechanism actually
generates more messages and more work for all servers, ultimately
resulting in the rejection of the request anyway.  
</p>
<p>
The problem becomes amplified further if one considers proxies
upstream from P1, as shown in <a class='info' href='#fig:lb2'>Figure&nbsp;2</a>.

</p><br /><hr class="insert" />
<a name="fig:lb2"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>



                             +------+
                           &gt; |      | &lt;
                          /  |  S1  |  \\
                         /   |      |    \\
                        /    +------+      \\
                       /                     \
                      /                       \\
                     /                          \\
                    /                             \
         +------+  /         +------+           +------+
         |      | /          |      |           |      |
         |  P1  | ---------&gt; |  S2  |&lt;----------|  P2  |
         |      | \          |      |           |      |
         +------+  \         +------+           +------+
             ^      \                             / ^
              \      \                          // /
               \      \                       //  /
                \      \                    //   /
                 \      \                  /    /
                  \      \   +------+    //    /
                   \      \  |      |  //     /
                    \      &gt; |  S3  | &lt;      /
                     \       |      |       /
                      \      +------+      /
                       \                  /
                        \                /
                         \              /
                          \            /
                           \          /
                            \        /
                             \      /
                              \    /
                             +------+
                             |      |
                             |  PA  |
                             |      |
                             +------+
                              ^   ^
                              |   |
                              |   |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p> Here, proxy PA receives requests, and sends these to proxies P1 or
P2. P1 and P2 both load balance across S1 through S3. Assuming again
S1 through S3 are all overloaded, a request arrives at PA, which tries
P1 first. P1 tries S1, S2 and then S3, and each transaction resulting
in many request retransmits if UDP is used. Since P1 is unable to
eventually process the request, it rejects it. However, since all of
its downstream dependencies are busy, it decides to send a 503. This
propagates to PA, which tries P2, which tries S1 through S3 again,
resulting in a 503 once more. Thus, in this case, we have doubled the
number of SIP transactions and overall work in the network compared to
the previous case. The problem here is that the fact that S1 through
S3 were overloaded was known to P1, but this information was not
passed back to PA and through to P2, so that P2 will retry S1 through
S3 again. 
</p>
<a name="anchor7"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.2"></a><h3>5.2.&nbsp;
Underutilization</h3>

<p> Interestingly, there are also examples of deployments where the
network capacity was greatly reduced as a consequence of the overload
mechanism. Consider again <a class='info' href='#fig:lb'>Figure&nbsp;1</a>. Unfortunately, RFC
3261 is unclear on the scope of a 503. When it is received by P1, does
the proxy cease sending requests to that IP address? To the hostname?
To the URI? Some implementations have chosen the hostname as the
scope. When the hostname for a URI points to an SRV record in the DNS,
which, in turn, maps to a cluster of downstream servers (S1, S2 and S3
in the example), a 503 response from a single one of them will make
the proxy believe that the entire cluster is overloaded. Consequently,
proxy P1 will cease sending any traffic to any element in the
cluster, even though there are elements in the cluster that are
underutilized. 

</p>
<a name="anchor8"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.3"></a><h3>5.3.&nbsp;
The Off/On Retry-After Problem</h3>

<p>
The Retry-After mechanism allows a server to tell an upstream element
to stop sending traffic for a period of time. The work that would have
otherwise been sent to that server is instead sent to another
server. The mechanism is an all-or-nothing technique. A server can
turn off all traffic towards it, or none of it. There is nothing in
between. This tends to cause highly oscillatory behavior under even
mild overload. Consider a proxy P1 which is balancing requests between
two servers S1 and S2. The input load just reaches the point where both S1
and S2 are at 100% capacity. A request arrives at P1, and is sent to
S1. S1 rejects this request with a 503 , and decides to use
Retry-After to clear its backlog. P1 stops sending all traffic to
S1. Now, S2 gets traffic, but it is seriously overloaded - at 200%
capacity! It decides to reject a request with a 503 and a Retry-After,
which now forces P1 to reject all traffic until S1's Retry-After timer
expires. At that point, all load is shunted back to S1, which reaches
overload, and the cycle repeats. 

</p>
<p>
Its important to observe that this problem is only observed for
servers where there are a small number of upstream elements sending it
traffic, as is the case in these examples. If a proxy was accessed by
a large number of clients, each of which sends a small amount of
traffic, the 503 mechanism with Retry-After is quite effective when
utilized with a subset of the clients. This is because spreading the
503 out amongst the clients has the effect of providing the proxy more
fine-grained controls on the amount of work it receives.

</p>
<a name="anchor9"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5.4"></a><h3>5.4.&nbsp;
Ambiguous Usages</h3>

<p>
Unfortunately, the specific instances under which a server is to send
a 503 are ambiguous. The result is that implementations generate 503
for many reasons, only some of which are related to actual
overload. For example, RFC 3398 <a class='info' href='#RFC3398'>[RFC3398]<span> (</span><span class='info'>Camarillo, G., Roach, A., Peterson, J., and L. Ong, &ldquo;Integrated Services Digital Network (ISDN) User Part (ISUP) to Session Initiation Protocol (SIP) Mapping,&rdquo; December&nbsp;2002.</span><span>)</span></a>, which
specifies interworking from SIP to ISUP, defines the usage of 503 when
the gateway receives certain ISUP cause codes from downstream
switches. In these cases, the gateway has ample capacity; its just
that this specific request could not be processed because of a
downstream problem. All subsequent requests might succeed if they take
a different route in the PSTN.

</p>
<p>
This causes two problems. Firstly, during periods of overload, it
exacerbates the problems above because it causes additional 503 to be
fed into the system, causing further work to be generated in
conditions of overload. The other problem is that it becomes hard for
an upstream element to know whether to retry when a 503 is
received. There are classes of failures where trying on another server
won't help, since the reason for the failure was that a common
downstream resource is unavailable. For example, if servers S1 and S2
share a database, and the database fails. A request sent to S1 will
result in a 503, but retrying on S2 won't help since the same database
is unavailable.

</p>
<a name="anchor10"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Solution Requirements</h3>

<p>
In this section, we propose requirements for an overload control
mechanism for SIP which addresses these problems.

</p>
<blockquote class="text"><dl>
<dt>REQ 1:</dt>
<dd>The overload mechanism shall strive to maintain
the overall useful throughput (taking into consideration the
quality-of-service needs of the using applications) of a SIP server at
reasonable levels even when the incoming load on the network is far in
excess of its capacity. The overall throughput under load is the
ultimate measure of the value of an overload control mechanism.  
</dd>
<dt>REQ 2:</dt>
<dd>When a single network element fails, goes into
overload, or suffers from reduced processing capacity, the
mechanism should strive to limit the impact of this on other elements
in the network. This helps to prevent a small-scale failure from
becoming a widespread outage.  
</dd>
<dt>REQ 3:</dt>
<dd> The mechanism should seek to minimize the amount
of configuration required in order to work. For example, it is better
to avoid needing to configure a server with its SIP message
throughput, as these kinds of quantities are hard to determine.

</dd>
<dt>REQ 4:</dt>
<dd> The mechanism must be capable of dealing with
elements which do not support it, so that a network can consist of a
mix of ones which do and don't support it. In other words, the
mechanism should not work only in environments where all elements
support it. It is reasonable to assume that it works better in such
environments, of course. Ideally, there should be incremental
improvements in overall network throughput as increasing numbers of
elements in the network support the mechanism.  
</dd>
<dt>REQ 5:</dt>
<dd> The mechanism should not assume that it will
only be deployed in environments with completely trusted elements. It
should seek to operate as effectively as possible in environments
where other elements are malicious, including preventing malicious
elements from obtaining more than a fair share of service.

</dd>
<dt>REQ 6:</dt>
<dd>When overload is signaled by means of a specific
message, the message must clearly indicate that it is being sent
because of overload, as opposed to other, non-overload based failure
conditions. This requirement is meant to avoid some of the problems
that have arisen from the reuse of the 503 response code for multiple
purposes. Of course, overload is also signaled by lack of response to
requests. This requirement applies only to explicit overload
signals. 
</dd>
<dt>REQ 7:</dt>
<dd> The mechanism shall provide a way for an element
to throttle the amount of traffic it receives from an upstream
element. This throttling shall be graded, so that it is not all or
nothing as with the current 503 mechanism. This recognizes the
fact that "overload" is not a binary state, and there are degrees of
overload. 

</dd>
<dt>REQ 8:</dt>
<dd> The mechanism shall ensure that, when a request
was not processed successfully due to overload (or failure) of a
downstream element, the request will not be retried on another
element which is also overloaded or whose status is unknown. This
requirement derives from REQ 1.

</dd>
<dt>REQ 9:</dt>
<dd> That a request has
been rejected from an overloaded element shall not unduly restrict the
ability of that request to be submitted to and processed by an element
that is not overloaded. This requirement derives from REQ 1.  
</dd>
<dt>REQ 10:</dt>
<dd> The mechanism should support servers that
receive requests from a large number of different upstream elements,
where the set of upstream elements is not enumerable.

</dd>
<dt>REQ 11:</dt>
<dd> The mechanism should support servers that
receive requests from a finite set of upstream elements, where the set
of upstream elements is enumerable.

</dd>
<dt>REQ 12:</dt>
<dd> The mechanism should work between servers in
different domains.

</dd>
<dt>REQ 13:</dt>
<dd> The mechanism must not dictate a specific
algorithm for prioritizing the processing of work within a proxy
during times of overload.  It must permit a proxy to prioritize
requests based on any local policy, so that certain ones (such as a
call for emergency services or a call with a specific value of the
Resource-Priority header field <a class='info' href='#RFC4412'>[RFC4412]<span> (</span><span class='info'>Schulzrinne, H. and J. Polk, &ldquo;Communications Resource Priority for the Session Initiation Protocol (SIP),&rdquo; February&nbsp;2006.</span><span>)</span></a>) are given
preferential treatment,such as not being dropped, being given
additional retransmission, or being processed ahead of others. 
</dd>
<dt>REQ 14:</dt>
<dd> The mechanism should provide unambigous
directions to clients on when they should retry a request, and when
they should not. This especially applies to TCP connection
establishment and SIP registrations, in order to mitigate against
avalanche restart.

</dd>
<dt>REQ 15:</dt>
<dd> In cases where a network element fails, is so
overloaded that it cannot process messages, or cannot communicate due
to a network failure or network partition, it will not be able to
provide explicit indications of the nature of the failure or its
levels of congestion. The mechanism must properly function in these
cases. 
</dd>
<dt>REQ 16:</dt>
<dd> The mechanism should attempt to minimize the
overhead of the overload control messaging. 

</dd>
<dt>REQ 17:</dt>
<dd>The overload mechanism must not provide an
avenue for malicious attack.
</dd>
<dt>REQ 18:</dt>
<dd>The overload mechanism should be unambiguous
about whether a load indication applies to a specific IP address,
host, or URI, so that an upstream element can determine the load of
the entity to which a request is to be sent.

</dd>
<dt>REQ 19:</dt>
<dd>The specification for the overload mechanism
should give guidance on which message types might be desirable to
process over others during times of overload, based on SIP-specific
considerations. For example, it may be more beneficial to process a
SUBSCRIBE refresh with Expires of zero than a SUBSCRIBE refresh with a
non-zero expiration, since the former reduces the overall amount of
load on the element, or to process re-INVITEs over new INVITEs.  
</dd>
<dt>REQ 20:</dt>
<dd> In a mixed
environment of elements that do and do not implement the overload
mechanism, no disproportionate benefit shall accrue to the users or
operators of the elements that do not implement the mechanism.

</dd>
<dt>REQ 21:</dt>
<dd> The overload mechanism should ensure that the
system remains stable. When the offered load drops from above the
overall capacity of the network to below the overall capacity, the
throughput should stabilize and become equal to the offered load. 

</dd>
<dt>REQ 22:</dt>
<dd> It must be possible to disable the reporting of
load information towards upstream targets based on the identity of
those targets. This allows a domain administrator who considers the
load of their elements to be sensitive information, to restrict access
to that information. Of course, in such cases, there is no expectation
that the overload mechanism itself will help prevent overload from
that upstream target.

</dd>
<dt>REQ 23:</dt>
<dd> It must be possible for the overload
mechanism to work in cases where there is a load balancer in front
of a farm of proxies. 

</dd>
</dl></blockquote>
<a name="anchor11"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Security Considerations</h3>

<p>
Like all protocol mechanisms, a solution for overload handling must
prevent against malicious inside and outside attacks. This document
includes requirements for such security functions.

</p>
<a name="anchor12"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
IANA Considerations</h3>

<p>
None.

</p>
<a name="anchor13"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.9"></a><h3>9.&nbsp;
Acknowledgements</h3>

<p>The author would like to thank Steve Mayer, Mouli Chandramouli,
Robert Whent, Mark Perkins, Joe Stone, Vijay Gurbani, Steve Norreys,
Volker Hilt, Spencer Dawkins, Matt Mathis, and Dale Worley for their
contributions to this document. 

</p>
<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>10.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="RFC3261">[RFC3261]</a></td>
<td class="author-text">Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &ldquo;<a href="http://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a>,&rdquo; RFC&nbsp;3261, June&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3261.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3398">[RFC3398]</a></td>
<td class="author-text">Camarillo, G., Roach, A., Peterson, J., and L. Ong, &ldquo;<a href="http://tools.ietf.org/html/rfc3398">Integrated Services Digital Network (ISDN) User Part (ISUP) to Session Initiation Protocol (SIP) Mapping</a>,&rdquo; RFC&nbsp;3398, December&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3398.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4412">[RFC4412]</a></td>
<td class="author-text">Schulzrinne, H. and J. Polk, &ldquo;<a href="http://tools.ietf.org/html/rfc4412">Communications Resource Priority for the Session Initiation Protocol (SIP)</a>,&rdquo; RFC&nbsp;4412, February&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4412.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-sip-outbound">[I-D.ietf-sip-outbound]</a></td>
<td class="author-text">Jennings, C., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-sip-outbound-20.txt">Managing Client Initiated Connections in the Session Initiation Protocol  (SIP)</a>,&rdquo; draft-ietf-sip-outbound-20 (work in progress), June&nbsp;2009 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-sip-outbound-20.txt">TXT</a>).</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Author's Address</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Jonathan Rosenberg</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Cisco</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Edison, NJ</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:jdrosen@cisco.com">jdrosen@cisco.com</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.jdrosen.net">http://www.jdrosen.net</a></td></tr>
</table>
<a name="rfc.copyright"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Full Copyright Statement</h3>
<p class='copyright'>
Copyright &copy; The IETF Trust (2008).</p>
<p class='copyright'>
This document is subject to the rights,
licenses and restrictions contained in BCP&nbsp;78,
and except as set forth therein,
the authors retain all their rights.</p>
<p class='copyright'>
This document and the information contained herein are provided
on an &ldquo;AS IS&rdquo; basis and THE CONTRIBUTOR,
THE ORGANIZATION HE/SHE REPRESENTS
OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST
AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT
THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY
IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
PURPOSE.</p>
<h3>Intellectual Property</h3>
<p class='copyright'>
The IETF takes no position regarding the validity or scope of any
Intellectual Property Rights or other rights that might be claimed
to pertain to the implementation or use of the technology
described in this document or the extent to which any license
under such rights might or might not be available; nor does it
represent that it has made any independent effort to identify any
such rights.
Information on the procedures with respect to
rights in RFC documents can be found in BCP&nbsp;78 and BCP&nbsp;79.</p>
<p class='copyright'>
Copies of IPR disclosures made to the IETF Secretariat and any
assurances of licenses to be made available,
or the result of an attempt made to obtain a general license or
permission for the use of such proprietary rights by implementers or
users of this specification can be obtained from the IETF on-line IPR
repository at <a href='http://www.ietf.org/ipr'>http://www.ietf.org/ipr</a>.</p>
<p class='copyright'>
The IETF invites any interested party to bring to its attention
any copyrights,
patents or patent applications,
or other
proprietary rights that may cover technology that may be required
to implement this standard.
Please address the information to the IETF at <a href='mailto:ietf-ipr@ietf.org'>ietf-ipr@ietf.org</a>.</p>
</body></html>
