<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="robots" content="index,follow" />

        <link rel="icon" href="./css/images/rfc.png" type="image/png" />
        <link rel="shortcut icon" href="./css/images/rfc.png" type="image/png" />
        <title>rfc8072</title>
    
        <link rel="stylesheet" type="text/css" href="./css/errata-base.css"/>
        <link rel="stylesheet" type="text/css" href="./css/errata-color.css" title="Default: Basic Colors"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-monochrome.css" title="Monochrome"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-printer.css" title="Printer"/>

        <script src="./css/errata.js"></script>
    </head>
    <body>
        <div class='Verified-headnote-styling'>
<span style="font-weight: bold;">This is a purely informative rendering of an RFC that includes verified errata.  This rendering may not be used as a reference.</span>
<br/>
<br/>
The following 'Verified' errata have been incorporated in this document:
 <a href='#eid5131'>EID 5131</a>
</div>

        <pre>
Internet Engineering Task Force (IETF)                        A. Bierman
Request for Comments: 8072                                     YumaWorks
Category: Standards Track                                   M. Bjorklund
ISSN: 2070-1721                                           Tail-f Systems
                                                               K. Watsen
                                                        Juniper Networks
                                                           February 2017


                         YANG Patch Media Type

Abstract

   This document describes a method for applying patches to
   configuration datastores using data defined with the YANG data
   modeling language.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 7841.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc8072.

Copyright Notice

   Copyright (c) 2017 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust&#x27;s Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1. Introduction ....................................................3
      1.1. Terminology ................................................3
           1.1.1. NETCONF .............................................3
           1.1.2. HTTP ................................................4
           1.1.3. YANG ................................................4
           1.1.4. RESTCONF ............................................4
           1.1.5. YANG Patch ..........................................5
           1.1.6. Examples ............................................5
           1.1.7. Tree Diagram Notations ..............................6
   2. YANG Patch ......................................................6
      2.1. Target Resource ............................................7
      2.2. yang-patch Request .........................................8
      2.3. yang-patch-status Response .................................9
      2.4. Target Data Node ..........................................10
      2.5. Edit Operations ...........................................11
      2.6. Successful Edit Response Handling .........................11
      2.7. Error Handling ............................................12
      2.8. &quot;:yang-patch&quot; RESTCONF Capability .........................12
   3. YANG Module ....................................................13
   4. IANA Considerations ............................................22
      4.1. Registrations for New URI and YANG Module .................22
      4.2. Media Types ...............................................23
           4.2.1. Media Type &quot;application/yang-patch+xml&quot; ............23
           4.2.2. Media Type &quot;application/yang-patch+json&quot; ...........24
      4.3. RESTCONF Capability URNs ..................................25
   5. Security Considerations ........................................25
   6. References .....................................................26
      6.1. Normative References ......................................26
      6.2. Informative References ....................................27
   Appendix A. Example YANG Module ...................................28
     A.1. YANG Patch Examples ........................................29
       A.1.1. Add Resources: Error ...................................29
       A.1.2. Add Resources: Success .................................33
       A.1.3. Insert List Entry ......................................35
       A.1.4. Move List Entry ........................................36
       A.1.5. Edit Datastore Resource ................................37
   Acknowledgements ..................................................39
   Authors&#x27; Addresses ................................................39

1.  Introduction

   There is a need for standard mechanisms to patch datastores defined
   in [RFC6241], which contain conceptual data that conforms to schema
   specified with YANG [RFC7950].  An &quot;ordered &#x27;edit&#x27; list&quot; approach is
   needed to provide RESTCONF client developers with more precise
   RESTCONF client control of the edit procedure than the &quot;plain patch&quot;
   mechanism found in [RFC8040].

   This document defines a media type for a YANG-based editing mechanism
   that can be used with the HTTP PATCH method [RFC5789].  YANG Patch is
   designed to support the RESTCONF protocol, defined in [RFC8040].
   This document only specifies the use of the YANG Patch media type
   with the RESTCONF protocol.

   It may be possible to use YANG Patch with other protocols besides
   RESTCONF.  This is outside the scope of this document.  For any
   protocol that supports the YANG Patch media type, if the entire patch
   document cannot be successfully applied, then the server MUST NOT
   apply any of the changes.  It may be possible to use YANG Patch with
   datastore types other than a configuration datastore.  This is
   outside the scope of this document.

1.1.  Terminology

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [RFC2119].

1.1.1.  NETCONF

   The following terms are defined in [RFC6241]:

   o  configuration data

   o  datastore

   o  configuration datastore

   o  protocol operation

   o  running configuration datastore

   o  state data

   o  user

1.1.2.  HTTP

   The following terms are defined in [RFC7230]:

   o  header field

   o  message-body

   o  query

   o  request URI

   The following terms are defined in [RFC7231]:

   o  method

   o  request

   o  resource

1.1.3.  YANG

   The following terms are defined in [RFC7950]:

   o  container

   o  data node

   o  leaf

   o  leaf-list

   o  list

1.1.4.  RESTCONF

   The following terms are defined in [RFC8040]:

   o  application/yang-data+xml

   o  application/yang-data+json

   o  data resource

   o  datastore resource

   o  patch

   o  RESTCONF capability

   o  target resource

   o  YANG data template

1.1.5.  YANG Patch

   The following terms are used within this document:

   o  RESTCONF client: a client that implements the RESTCONF protocol.

   o  RESTCONF server: a server that implements the RESTCONF protocol.

   o  YANG Patch: a conceptual edit request using the &quot;yang-patch&quot; YANG
      Patch template, defined in Section 3.  In HTTP, refers to a PATCH
      method where a representation uses either the media type
      &quot;application/yang-patch+xml&quot; or &quot;application/yang-patch+json&quot;.

   o  YANG Patch Status: a conceptual edit status response using the
      YANG &quot;yang-patch-status&quot; YANG data template, defined in Section 3.
      In HTTP, refers to a response message for a PATCH method, where it
      has a representation with either the media type
      &quot;application/yang-data+xml&quot; or &quot;application/yang-data+json&quot;.

   o  YANG Patch template: similar to a YANG data template, except that
      it has a representation with the media type
      &quot;application/yang-patch+xml&quot; or &quot;application/yang-patch+json&quot;.

1.1.6.  Examples

   Some protocol message lines within examples throughout this document
   are split into multiple lines for display purposes only.  When a line
   ends with a backslash (&quot;\&quot;) as the last character, the line is
   wrapped for display purposes.  It is to be considered to be joined to
   the next line by deleting the backslash, the following line break,
   and the leading whitespace of the next line.

1.1.7.  Tree Diagram Notations

   A simplified graphical representation of the data model is used in
   this document.  The meanings of the symbols in these diagrams are as
   follows:

   o  Brackets &quot;[&quot; and &quot;]&quot; enclose list keys.

   o  Abbreviations before data node names: &quot;rw&quot; means configuration
      data (read-write), &quot;ro&quot; means state data (read-only), and &quot;x&quot;
      means operation resource (executable).

   o  Symbols after data node names: &quot;?&quot; means an optional node, and &quot;*&quot;
      denotes a &quot;list&quot; and &quot;leaf-list&quot;.

   o  Parentheses enclose choice and case nodes, and case nodes are also
      marked with a colon (&quot;:&quot;).

   o  Ellipsis (&quot;...&quot;) stands for contents of subtrees that are not
      shown.

2.  YANG Patch

   A &quot;YANG Patch&quot; is an ordered list of edits that are applied to the
   target datastore by the RESTCONF server.  The specific fields are
   defined in the YANG module in Section 3.

   The YANG Patch operation is invoked by the RESTCONF client by
   sending a PATCH method request with a representation using either
   the media type &quot;application/yang-patch+xml&quot; or
   &quot;application/yang-patch+json&quot;.  This message-body representing the
   YANG Patch input parameters MUST be present.

   YANG Patch has some features that are not possible with the
   &quot;plain-patch&quot; mechanism defined in RESTCONF [RFC8040]:

   o  YANG Patch allows multiple sub-resources to be edited within the
      same PATCH method.

   o  YANG Patch allows a more precise edit operation than the
      &quot;plain patch&quot; mechanism found in [RFC8040].  There are seven
      operations supported (&quot;create&quot;, &quot;delete&quot;, &quot;insert&quot;, &quot;merge&quot;,
      &quot;move&quot;, &quot;replace&quot;, and &quot;remove&quot;).

   o  YANG Patch uses an &quot;edit&quot; list with an explicit processing order.
      The edits are processed in client-specified order, and error
      processing can be precise even when multiple errors occur in the
      same YANG Patch request.

   The YANG Patch &quot;patch-id&quot; may be useful for debugging and SHOULD be
   present in any audit logging records generated by the RESTCONF server
   for a patch.

   The RESTCONF server MUST return the &quot;Accept-Patch&quot; header field in an
   OPTIONS response, as specified in [RFC5789], which includes the
   media type for YANG Patch.  This is needed by a client to determine
   the message-encoding formats supported by the server (e.g., XML,
   JSON, or both).  The following is an example of an &quot;Accept-Patch&quot;
   header:

    Accept-Patch: application/yang-patch+xml,application/yang-patch+json

   Note that YANG Patch can only edit data resources.  The PATCH method
   cannot be used to replace the datastore resource.  Although the
   &quot;ietf-yang-patch&quot; YANG module is written using YANG version 1.1
   [RFC7950], an implementation of YANG Patch can be used with content
   defined in YANG version 1 [RFC6020] as well.

   A YANG Patch can be encoded in XML format according to
   [W3C.REC-xml-20081126].  It can also be encoded in JSON according to
   &quot;JSON Encoding of Data Modeled with YANG&quot; [RFC7951].  If any metadata
   needs to be sent in a JSON message, it is encoded according to
   &quot;Defining and Using Metadata with YANG&quot; [RFC7952].

2.1.  Target Resource

   The YANG Patch operation uses the RESTCONF target resource URI to
   identify the resource that will be patched.  This can be the
   datastore resource itself, i.e., &quot;{+restconf}/data&quot;, to edit
   top-level configuration data resources, or it can be a configuration
   data resource within the datastore resource, e.g.,
   &quot;{+restconf}/data/ietf-interfaces:interfaces&quot;, to edit sub-resources
   within a top-level configuration data resource.

   The target resource MUST identify exactly one resource instance.  If
   more than one resource instance is identified, then the request
   MUST NOT be processed and a &quot;400 Bad Request&quot; error response MUST be
   sent by the server.  If the target resource does not identify any
   existing resource instance, then the request MUST NOT be processed
   and a &quot;404 Not Found&quot; error response MUST be sent by the server.

   Each edit with a YANG Patch identifies a target data node for the
   associated edit.  This is described in Section 2.4.

2.2.  yang-patch Request

<div class='Verified-endnote-styling' id='eid5131'>
<pre>
<b><i><a href='https://www.rfc-editor.org/errata/eid5131'>EID 5131</a> (Verified) is as follows:</i></b>

<b>Section:</b> 2.2

<b>Original Text:</b>

Regarding section 2.2 of RFC 8072, the third paragraph states:


                                       ... If the edit does not identify
    any existing resource instance and the operation for the edit is not
    &quot;create&quot;, then the request MUST NOT be processed and a &quot;404 Not
    Found&quot; error response MUST be sent by the server.

<b>Corrected Text:</b>

                                      ... If the edit does not identify
   any existing resource instance and the operation for the edit is
   &quot;delete&quot; or &quot;move&quot; then the request MUST NOT be processed and a
   &quot;404 Not Found&quot; error response MUST be sent by the server.
</pre>
<b>Notes:</b><br/>
As per the second paragraph of section 2.2 of RFC 8072, the operations are expected to mirror the semantics of the &quot;operation&quot; attribute described in Section 7.2 of [RFC6241].<br/><br/>The spec also doesn&#x27;t specify what happens if it is a &quot;create&quot; operation and the resource already exists.  It should probably also state that &quot;400 Bad Request&quot; is returned.
</div>
   A YANG Patch is identified by a unique &quot;patch-id&quot;, and it may have an
   optional comment.  A patch is an ordered collection of edits.  Each
   edit is identified by an &quot;edit-id&quot;, and it has an edit operation
   (&quot;create&quot;, &quot;delete&quot;, &quot;insert&quot;, &quot;merge&quot;, &quot;move&quot;, &quot;replace&quot;, or
   &quot;remove&quot;) that is applied to the target resource.  Each edit can be
   applied to a sub-resource &quot;target&quot; within the target resource.  If
   the operation is &quot;insert&quot; or &quot;move&quot;, then the &quot;where&quot; parameter
   indicates how the node is inserted or moved.  For values &quot;before&quot; and
   &quot;after&quot;, the &quot;point&quot; parameter specifies the data node insertion
   point.

   The &quot;merge&quot;, &quot;replace&quot;, &quot;create&quot;, &quot;delete&quot;, and &quot;remove&quot; edit
   operations have exactly the same meanings as those defined for the
   &quot;operation&quot; attribute described in Section 7.2 of [RFC6241].

   Each edit within a YANG Patch MUST identify exactly one data resource
   instance.  If an edit represents more than one resource instance,
   then the request MUST NOT be processed and a &quot;400 Bad Request&quot; error
   response MUST be sent by the server.  If the edit does not identify
   any existing resource instance and the operation for the edit is not
   &quot;create&quot;, then the request MUST NOT be processed and a &quot;404 Not
   Found&quot; error response MUST be sent by the server.  A
   &quot;yang-patch-status&quot; response MUST be sent by the server identifying
   the edit or edits that are not valid.

   YANG Patch does not provide any access to specific datastores.  How a
   server processes an edit if it is co-located with a Network
   Configuration Protocol (NETCONF) server that does provide access to
   individual datastores is left up to the implementation.  A complete
   datastore cannot be replaced in the same manner as that provided by
   the &lt;copy-config&gt; operation defined in Section 7.3 of [RFC6241].
   Only the specified nodes in a YANG Patch are affected.

   A message-body representing the YANG Patch is sent by the RESTCONF
   client to specify the edit operation request.  When used with the
   HTTP PATCH method, this data is identified by the YANG Patch
   media type.

   YANG tree diagram for &quot;yang-patch&quot; container:

     +---- yang-patch
           +---- patch-id    string
           +---- comment?    string
           +---- edit* [edit-id]
              +---- edit-id      string
              +---- operation    enumeration
              +---- target       target-resource-offset
              +---- point?       target-resource-offset
              +---- where?       enumeration
              +---- value?

2.3.  yang-patch-status Response

   A message-body representing the YANG Patch Status is returned to the
   RESTCONF client to report the detailed status of the edit operation.
   When used with the HTTP PATCH method, this data is identified by the
   YANG Patch Status media type; the syntax specification is defined in
   Section 3.

   YANG tree diagram for &quot;yang-patch-status&quot; container:

     +---- yang-patch-status
           +---- patch-id       string
           +---- (global-status)?
           |  +--:(global-errors)
           |  |  +---- errors
           |  |     +---- error*
           |  |        +---- error-type       enumeration
           |  |        +---- error-tag        string
           |  |        +---- error-app-tag?   string
           |  |        +---- error-path?      instance-identifier
           |  |        +---- error-message?   string
           |  |        +---- error-info?
           |  +--:(ok)
           |     +---- ok?            empty
           +---- edit-status
              +---- edit* [edit-id]
                 +---- edit-id    string
                 +---- (edit-status-choice)?
                    +--:(ok)
                    |  +---- ok?        empty
                    +--:(errors)
                       +---- errors
                          +---- error*
                             +---- error-type       enumeration
                             +---- error-tag        string
                             +---- error-app-tag?   string
                             +---- error-path?      instance-identifier
                             +---- error-message?   string
                             +---- error-info?

2.4.  Target Data Node

   The target data node for each edit operation is determined by the
   value of the target resource in the request and the &quot;target&quot; leaf
   within each &quot;edit&quot; entry.

   If the target resource specified in the request URI identifies a
   datastore resource, then the path string in the &quot;target&quot; leaf is
   treated as an absolute path expression identifying the target data
   node for the corresponding edit.  The first node specified in the
   &quot;target&quot; leaf is a top-level data node defined within a YANG module.
   The &quot;target&quot; leaf MUST NOT contain a single forward slash (&quot;/&quot;),
   since this would identify the datastore resource, not a data
   resource.

   If the target resource specified in the request URI identifies a
   configuration data resource, then the path string in the &quot;target&quot;
   leaf is treated as a relative path expression.  The first node
   specified in the &quot;target&quot; leaf is a child configuration data node of
   the data node associated with the target resource.  If the &quot;target&quot;
   leaf contains a single forward slash (&quot;/&quot;), then the target data node
   is the target resource data node.

2.5.  Edit Operations

   Each YANG Patch edit specifies one edit operation on the target data
   node.  The set of operations is aligned with the NETCONF edit
   operations but also includes some new operations.

   +-----------+-------------------------------------------------------+
   | Operation | Description                                           |
   +-----------+-------------------------------------------------------+
   | create    | create a new data resource if it does not already     |
   |           | exist; if it already exists, return an error          |
   |           |                                                       |
   | delete    | delete a data resource if it already exists; if it    |
   |           | does not exist, return an error                       |
   |           |                                                       |
   | insert    | insert a new user-ordered data resource               |
   |           |                                                       |
   | merge     | merge the edit value with the target data resource;   |
   |           | create if it does not already exist                   |
   |           |                                                       |
   | move      | reorder the target data resource                      |
   |           |                                                       |
   | replace   | replace the target data resource with the edit value  |
   |           |                                                       |
   | remove    | remove a data resource if it already exists           |
   +-----------+-------------------------------------------------------+

                        YANG Patch Edit Operations

2.6.  Successful Edit Response Handling

   If a YANG Patch is completed without errors, the RESTCONF server MUST
   return a &quot;yang-patch-status&quot; message with a &quot;global-status&quot; choice
   set to &quot;ok&quot;.

   Refer to Appendix A.1.2 for an example of a successful YANG Patch
   response.

2.7.  Error Handling

   If a well-formed, schema-valid YANG Patch message is received, then
   the RESTCONF server will process the supplied edits in ascending
   order.  The following error modes apply to the processing of this
   &quot;edit&quot; list:

   If a YANG Patch is completed with errors, the RESTCONF server SHOULD
   return a &quot;yang-patch-status&quot; message.  It is possible (e.g., within a
   distributed implementation) that an invalid request will be rejected
   before the YANG Patch edits are processed.  In this case, the server
   MUST send the appropriate HTTP error response instead.

   Refer to Appendix A.1.1 for an example of an error YANG Patch
   response.

2.8.  &quot;:yang-patch&quot; RESTCONF Capability

   A URI is defined to identify the YANG Patch extension to the base
   RESTCONF protocol.  If the RESTCONF server supports the YANG Patch
   media type, then the &quot;:yang-patch&quot; RESTCONF capability defined in
   Section 4.3 MUST be present in the &quot;capability&quot; leaf-list in the
   &quot;ietf-restconf-monitoring&quot; module defined in [RFC8040].

3.  YANG Module

   The &quot;ietf-yang-patch&quot; module defines conceptual definitions with the
   &quot;yang-data&quot; extension statements, which are not meant to be
   implemented as datastore contents by a RESTCONF server.

   The &quot;ietf-restconf&quot; module from [RFC8040] is used by this module for
   the &quot;yang-data&quot; extension definition.

   &lt;CODE BEGINS&gt;

   file &quot;ietf-yang-patch@2017-02-22.yang&quot;

   module ietf-yang-patch {
     yang-version 1.1;
     namespace &quot;urn:ietf:params:xml:ns:yang:ietf-yang-patch&quot;;
     prefix &quot;ypatch&quot;;

     import ietf-restconf { prefix rc; }

     organization
       &quot;IETF NETCONF (Network Configuration) Working Group&quot;;

     contact
       &quot;WG Web:   &lt;https://datatracker.ietf.org/wg/netconf/&gt;
        WG List:  &lt;mailto:netconf@ietf.org&gt;

        Author:   Andy Bierman
                  &lt;mailto:andy@yumaworks.com&gt;

        Author:   Martin Bjorklund
                  &lt;mailto:mbj@tail-f.com&gt;

        Author:   Kent Watsen
                  &lt;mailto:kwatsen@juniper.net&gt;&quot;;

     description
       &quot;This module contains conceptual YANG specifications
        for the YANG Patch and YANG Patch Status data structures.

        Note that the YANG definitions within this module do not
        represent configuration data of any kind.
        The YANG grouping statements provide a normative syntax
        for XML and JSON message-encoding purposes.

        Copyright (c) 2017 IETF Trust and the persons identified as
        authors of the code.  All rights reserved.

        Redistribution and use in source and binary forms, with or
        without modification, is permitted pursuant to, and subject
        to the license terms contained in, the Simplified BSD License
        set forth in Section 4.c of the IETF Trust&#x27;s Legal Provisions
        Relating to IETF Documents
        (http://trustee.ietf.org/license-info).

        This version of this YANG module is part of RFC 8072; see
        the RFC itself for full legal notices.&quot;;

     revision 2017-02-22 {
       description
         &quot;Initial revision.&quot;;
       reference
         &quot;RFC 8072: YANG Patch Media Type.&quot;;
     }

     typedef target-resource-offset {
       type string;
       description
         &quot;Contains a data resource identifier string representing
          a sub-resource within the target resource.
          The document root for this expression is the
          target resource that is specified in the
          protocol operation (e.g., the URI for the PATCH request).

          This string is encoded according to the same rules as those
          for a data resource identifier in a RESTCONF request URI.&quot;;
       reference
          &quot;RFC 8040, Section 3.5.3.&quot;;
     }

     rc:yang-data &quot;yang-patch&quot; {
       uses yang-patch;
     }

     rc:yang-data &quot;yang-patch-status&quot; {
       uses yang-patch-status;
     }

     grouping yang-patch {

       description
         &quot;A grouping that contains a YANG container representing the
          syntax and semantics of a YANG Patch edit request message.&quot;;

       container yang-patch {
         description
           &quot;Represents a conceptual sequence of datastore edits,
            called a patch.  Each patch is given a client-assigned
            patch identifier.  Each edit MUST be applied
            in ascending order, and all edits MUST be applied.
            If any errors occur, then the target datastore MUST NOT
            be changed by the YANG Patch operation.

            It is possible for a datastore constraint violation to occur
            due to any node in the datastore, including nodes not
            included in the &#x27;edit&#x27; list.  Any validation errors MUST
            be reported in the reply message.&quot;;

         reference
           &quot;RFC 7950, Section 8.3.&quot;;

         leaf patch-id {
           type string;
           mandatory true;
           description
             &quot;An arbitrary string provided by the client to identify
              the entire patch.  Error messages returned by the server
              that pertain to this patch will be identified by this
              &#x27;patch-id&#x27; value.  A client SHOULD attempt to generate
              unique &#x27;patch-id&#x27; values to distinguish between
              transactions from multiple clients in any audit logs
              maintained by the server.&quot;;
         }

         leaf comment {
           type string;
           description
             &quot;An arbitrary string provided by the client to describe
              the entire patch.  This value SHOULD be present in any
              audit logging records generated by the server for the
              patch.&quot;;
         }

         list edit {
           key edit-id;
           ordered-by user;

           description
             &quot;Represents one edit within the YANG Patch request message.
              The &#x27;edit&#x27; list is applied in the following manner:

                - The first edit is conceptually applied to a copy
                  of the existing target datastore, e.g., the
                  running configuration datastore.
                - Each ascending edit is conceptually applied to
                  the result of the previous edit(s).
                - After all edits have been successfully processed,
                  the result is validated according to YANG constraints.
                - If successful, the server will attempt to apply
                  the result to the target datastore.&quot;;

           leaf edit-id {
             type string;
             description
               &quot;Arbitrary string index for the edit.
                Error messages returned by the server that pertain
                to a specific edit will be identified by this value.&quot;;
           }

           leaf operation {
             type enumeration {
               enum create {
                 description
                   &quot;The target data node is created using the supplied
                    value, only if it does not already exist.  The
                    &#x27;target&#x27; leaf identifies the data node to be
                    created, not the parent data node.&quot;;
               }
               enum delete {
                 description
                   &quot;Delete the target node, only if the data resource
                    currently exists; otherwise, return an error.&quot;;
               }

               enum insert {
                 description
                   &quot;Insert the supplied value into a user-ordered
                    list or leaf-list entry.  The target node must
                    represent a new data resource.  If the &#x27;where&#x27;
                    parameter is set to &#x27;before&#x27; or &#x27;after&#x27;, then
                    the &#x27;point&#x27; parameter identifies the insertion
                    point for the target node.&quot;;
               }
               enum merge {
                 description
                   &quot;The supplied value is merged with the target data
                    node.&quot;;
               }
               enum move {
                 description
                   &quot;Move the target node.  Reorder a user-ordered
                    list or leaf-list.  The target node must represent
                    an existing data resource.  If the &#x27;where&#x27; parameter
                    is set to &#x27;before&#x27; or &#x27;after&#x27;, then the &#x27;point&#x27;
                    parameter identifies the insertion point to move
                    the target node.&quot;;
               }
               enum replace {
                 description
                   &quot;The supplied value is used to replace the target
                    data node.&quot;;
               }
               enum remove {
                 description
                   &quot;Delete the target node if it currently exists.&quot;;
               }
             }
             mandatory true;
             description
               &quot;The datastore operation requested for the associated
                &#x27;edit&#x27; entry.&quot;;
           }

           leaf target {
             type target-resource-offset;
             mandatory true;
             description
               &quot;Identifies the target data node for the edit
                operation.  If the target has the value &#x27;/&#x27;, then
                the target data node is the target resource.
                The target node MUST identify a data resource,
                not the datastore resource.&quot;;
           }

           leaf point {
             when &quot;(../operation = &#x27;insert&#x27; or ../operation = &#x27;move&#x27;)&quot;
                + &quot;and (../where = &#x27;before&#x27; or ../where = &#x27;after&#x27;)&quot; {
               description
                 &quot;This leaf only applies for &#x27;insert&#x27; or &#x27;move&#x27;
                  operations, before or after an existing entry.&quot;;
             }
             type target-resource-offset;
             description
               &quot;The absolute URL path for the data node that is being
                used as the insertion point or move point for the
                target of this &#x27;edit&#x27; entry.&quot;;
           }

           leaf where {
             when &quot;../operation = &#x27;insert&#x27; or ../operation = &#x27;move&#x27;&quot; {
               description
                 &quot;This leaf only applies for &#x27;insert&#x27; or &#x27;move&#x27;
                  operations.&quot;;
             }
             type enumeration {
               enum before {
                 description
                   &quot;Insert or move a data node before the data resource
                    identified by the &#x27;point&#x27; parameter.&quot;;
               }
               enum after {
                 description
                   &quot;Insert or move a data node after the data resource
                    identified by the &#x27;point&#x27; parameter.&quot;;
               }

               enum first {
                 description
                   &quot;Insert or move a data node so it becomes ordered
                    as the first entry.&quot;;
               }
               enum last {
                 description
                   &quot;Insert or move a data node so it becomes ordered
                    as the last entry.&quot;;
               }
             }
             default last;
             description
               &quot;Identifies where a data resource will be inserted
                or moved.  YANG only allows these operations for
                list and leaf-list data nodes that are
                &#x27;ordered-by user&#x27;.&quot;;
           }

           anydata value {
             when &quot;../operation = &#x27;create&#x27; &quot;
                + &quot;or ../operation = &#x27;merge&#x27; &quot;
                + &quot;or ../operation = &#x27;replace&#x27; &quot;
                + &quot;or ../operation = &#x27;insert&#x27;&quot; {
               description
                 &quot;The anydata &#x27;value&#x27; is only used for &#x27;create&#x27;,
                  &#x27;merge&#x27;, &#x27;replace&#x27;, and &#x27;insert&#x27; operations.&quot;;
             }
             description
               &quot;Value used for this edit operation.  The anydata &#x27;value&#x27;
                contains the target resource associated with the
                &#x27;target&#x27; leaf.

                For example, suppose the target node is a YANG container
                named foo:

                    container foo {
                      leaf a { type string; }
                      leaf b { type int32; }
                    }

                The &#x27;value&#x27; node contains one instance of foo:

                    &lt;value&gt;
                       &lt;foo xmlns=&#x27;example-foo-namespace&#x27;&gt;
                          &lt;a&gt;some value&lt;/a&gt;
                          &lt;b&gt;42&lt;/b&gt;
                       &lt;/foo&gt;
                    &lt;/value&gt;
                 &quot;;
           }
         }
       }

     } // grouping yang-patch

     grouping yang-patch-status {

       description
         &quot;A grouping that contains a YANG container representing the
          syntax and semantics of a YANG Patch Status response
          message.&quot;;

       container yang-patch-status {
         description
           &quot;A container representing the response message sent by the
            server after a YANG Patch edit request message has been
            processed.&quot;;

         leaf patch-id {
           type string;
           mandatory true;
           description
             &quot;The &#x27;patch-id&#x27; value used in the request.&quot;;
         }

         choice global-status {
           description
             &quot;Report global errors or complete success.
              If there is no case selected, then errors
              are reported in the &#x27;edit-status&#x27; container.&quot;;

           case global-errors {
             uses rc:errors;
             description
               &quot;This container will be present if global errors that
                are unrelated to a specific edit occurred.&quot;;
           }
           leaf ok {
             type empty;
             description
               &quot;This leaf will be present if the request succeeded
                and there are no errors reported in the &#x27;edit-status&#x27;
                container.&quot;;
           }
         }

         container edit-status {
           description
             &quot;This container will be present if there are
              edit-specific status responses to report.
              If all edits succeeded and the &#x27;global-status&#x27;
              returned is &#x27;ok&#x27;, then a server MAY omit this
              container.&quot;;

           list edit {
             key edit-id;

             description
               &quot;Represents a list of status responses,
                corresponding to edits in the YANG Patch
                request message.  If an &#x27;edit&#x27; entry was
                skipped or not reached by the server,
                then this list will not contain a corresponding
                entry for that edit.&quot;;

             leaf edit-id {
               type string;
                description
                  &quot;Response status is for the &#x27;edit&#x27; list entry
                   with this &#x27;edit-id&#x27; value.&quot;;
             }

             choice edit-status-choice {
               description
                 &quot;A choice between different types of status
                  responses for each &#x27;edit&#x27; entry.&quot;;
               leaf ok {
                 type empty;
                 description
                   &quot;This &#x27;edit&#x27; entry was invoked without any
                    errors detected by the server associated
                    with this edit.&quot;;
               }
               case errors {
                 uses rc:errors;
                 description
                   &quot;The server detected errors associated with the
                    edit identified by the same &#x27;edit-id&#x27; value.&quot;;
               }
             }
           }
         }
       }
     }  // grouping yang-patch-status

   }

   &lt;CODE ENDS&gt;

4.  IANA Considerations

4.1.  Registrations for New URI and YANG Module

   This document registers one URI as a namespace in the &quot;IETF XML
   Registry&quot; [RFC3688].  It follows the format in RFC 3688.

      URI: urn:ietf:params:xml:ns:yang:ietf-yang-patch
      Registrant Contact: The IESG.
      XML: N/A; the requested URI is an XML namespace.

   This document registers one YANG module in the &quot;YANG Module Names&quot;
   registry [RFC6020].

      name:         ietf-yang-patch
      namespace:    urn:ietf:params:xml:ns:yang:ietf-yang-patch
      prefix:       ypatch
      reference:    RFC 8072

4.2.  Media Types

4.2.1.  Media Type &quot;application/yang-patch+xml&quot;

   Type name: application

   Subtype name: yang-patch+xml

   Required parameters: None

   Optional parameters: None

   Encoding considerations: 8-bit
      The &quot;utf-8&quot; charset is always used for this type.
      Each conceptual YANG data node is encoded according to the
      XML Encoding Rules and Canonical Format for the specific
      YANG data node type defined in [RFC7950].
      In addition, the &quot;yang-patch&quot; YANG Patch template found
      in RFC 8072 defines the structure of a YANG Patch request.

   Security considerations: Security considerations related
      to the generation and consumption of RESTCONF messages
      are discussed in Section 5 of RFC 8072.
      Additional security considerations are specific to the
      semantics of particular YANG data models.  Each YANG module
      is expected to specify security considerations for the
      YANG data defined in that module.

   Interoperability considerations: RFC 8072 specifies the format
      of conforming messages and the interpretation thereof.

   Published specification: RFC 8072

   Applications that use this media type: Instance document
      data parsers used within a protocol or automation tool
      that utilize the YANG Patch data structure.

   Fragment identifier considerations: The syntax and semantics
      of fragment identifiers are the same as the syntax and semantics
      specified for the &quot;application/xml&quot; media type.

   Additional information:

      Deprecated alias names for this type: N/A
      Magic number(s): N/A
      File extension(s): None
      Macintosh file type code(s): &quot;TEXT&quot;

   Person &amp; email address to contact for further information: See
      the Authors&#x27; Addresses section of RFC 8072.

   Intended usage: COMMON

   Restrictions on usage: N/A

   Author: See the Authors&#x27; Addresses section of RFC 8072.

   Change controller: Internet Engineering Task Force
      (mailto:iesg@ietf.org).

   Provisional registration? (standards tree only): no

4.2.2.  Media Type &quot;application/yang-patch+json&quot;

   Type name: application

   Subtype name: yang-patch+json

   Required parameters: None

   Optional parameters: None

   Encoding considerations: 8-bit
      The &quot;utf-8&quot; charset is always used for this type.
      Each conceptual YANG data node is encoded according to
      RFC 7951.  A metadata annotation is encoded according to
      RFC 7952.  In addition, the &quot;yang-patch&quot; YANG Patch
      template found in RFC 8072 defines the structure of a
      YANG Patch request.

   Security considerations: Security considerations related
      to the generation and consumption of RESTCONF messages
      are discussed in Section 5 of RFC 8072.
      Additional security considerations are specific to the
      semantics of particular YANG data models.  Each YANG module
      is expected to specify security considerations for the
      YANG data defined in that module.

   Interoperability considerations: RFC 8072 specifies the format
      of conforming messages and the interpretation thereof.

   Published specification: RFC 8072

   Applications that use this media type: Instance document
      data parsers used within a protocol or automation tool
      that utilize the YANG Patch data structure.

   Fragment identifier considerations: The syntax and semantics
      of fragment identifiers are the same as the syntax and semantics
      specified for the &quot;application/json&quot; media type.

   Additional information:

      Deprecated alias names for this type: N/A
      Magic number(s): N/A
      File extension(s): None
      Macintosh file type code(s): &quot;TEXT&quot;

   Person &amp; email address to contact for further information: See
      the Authors&#x27; Addresses section of RFC 8072.

   Intended usage: COMMON

   Restrictions on usage: N/A

   Author: See the Authors&#x27; Addresses section of RFC 8072.

   Change controller: Internet Engineering Task Force
      (mailto:iesg@ietf.org).

   Provisional registration? (standards tree only): no

4.3.  RESTCONF Capability URNs

   This document registers one capability identifier in the &quot;RESTCONF
   Capability URNs&quot; registry [RFC8040].  The review policy for this
   registry is &quot;IETF Review&quot; [RFC5226].

   Index           Capability Identifier
   ------------------------------------------------------------------
   :yang-patch     urn:ietf:params:restconf:capability:yang-patch:1.0

5.  Security Considerations

   The YANG Patch media type does not introduce any significant new
   security threats, beyond what is described in [RFC8040].  This
   document defines edit processing instructions for a variant of the
   PATCH method, as used within the RESTCONF protocol.  Message
   integrity is provided by the RESTCONF protocol.  There is no
   additional capability to validate that a patch has not been altered.

   It may be possible to use YANG Patch with other protocols besides
   RESTCONF; this topic is outside the scope of this document.

   For RESTCONF, both the client and server MUST be authenticated
   according to Section 2 of [RFC8040].  It is important for RESTCONF
   server implementations to carefully validate all the edit request
   parameters in some manner.  If the entire YANG Patch request cannot
   be completed, then no configuration changes to the system are done.
   A PATCH request MUST be applied atomically, as specified in Section 2
   of [RFC5789].

   A RESTCONF server implementation SHOULD attempt to prevent system
   disruption due to incremental processing of the YANG Patch
   &quot;edit&quot; list.  It may be possible to construct an attack on such a
   RESTCONF server, which relies on the edit processing order mandated
   by YANG Patch.  A server SHOULD apply only the fully validated
   configuration to the underlying system.  For example, an &quot;edit&quot; list
   that deleted an interface and then recreated it could cause system
   disruption if the &quot;edit&quot; list was incrementally applied.

   A RESTCONF server implementation SHOULD attempt to prevent system
   disruption due to excessive resource consumption required to fulfill
   YANG Patch edit requests.  On such an implementation, it may be
   possible to construct an attack that attempts to consume all
   available memory or other resource types.

6.  References

6.1.  Normative References

   [RFC2119]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              &lt;http://www.rfc-editor.org/info/rfc2119&gt;.

   [RFC3688]  Mealling, M., &quot;The IETF XML Registry&quot;, BCP 81, RFC 3688,
              DOI 10.17487/RFC3688, January 2004,
              &lt;http://www.rfc-editor.org/info/rfc3688&gt;.

   [RFC5789]  Dusseault, L. and J. Snell, &quot;PATCH Method for HTTP&quot;,
              RFC 5789, DOI 10.17487/RFC5789, March 2010,
              &lt;http://www.rfc-editor.org/info/rfc5789&gt;.

   [RFC6020]  Bjorklund, M., Ed., &quot;YANG - A Data Modeling Language for
              the Network Configuration Protocol (NETCONF)&quot;, RFC 6020,
              DOI 10.17487/RFC6020, October 2010,
              &lt;http://www.rfc-editor.org/info/rfc6020&gt;.

   [RFC6241]  Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed.,
              and A. Bierman, Ed., &quot;Network Configuration Protocol
              (NETCONF)&quot;, RFC 6241, DOI 10.17487/RFC6241, June 2011,
              &lt;http://www.rfc-editor.org/info/rfc6241&gt;.

   [RFC7159]  Bray, T., Ed., &quot;The JavaScript Object Notation (JSON) Data
              Interchange Format&quot;, RFC 7159, DOI 10.17487/RFC7159,
              March 2014, &lt;http://www.rfc-editor.org/info/rfc7159&gt;.

   [RFC7230]  Fielding, R., Ed., and J. Reschke, Ed., &quot;Hypertext
              Transfer Protocol (HTTP/1.1): Message Syntax and Routing&quot;,
              RFC 7230, DOI 10.17487/RFC7230, June 2014,
              &lt;http://www.rfc-editor.org/info/rfc7230&gt;.

   [RFC7231]  Fielding, R., Ed., and J. Reschke, Ed., &quot;Hypertext
              Transfer Protocol (HTTP/1.1): Semantics and Content&quot;,
              RFC 7231, DOI 10.17487/RFC7231, June 2014,
              &lt;http://www.rfc-editor.org/info/rfc7231&gt;.

   [RFC7950]  Bjorklund, M., Ed., &quot;The YANG 1.1 Data Modeling Language&quot;,
              RFC 7950, DOI 10.17487/RFC7950, August 2016,
              &lt;http://www.rfc-editor.org/info/rfc7950&gt;.

   [RFC7951]  Lhotka, L., &quot;JSON Encoding of Data Modeled with YANG&quot;,
              RFC 7951, DOI 10.17487/RFC7951, August 2016,
              &lt;http://www.rfc-editor.org/info/rfc7951&gt;.

   [RFC7952]  Lhotka, L., &quot;Defining and Using Metadata with YANG&quot;,
              RFC 7952, DOI 10.17487/RFC7952, August 2016,
              &lt;http://www.rfc-editor.org/info/rfc7952&gt;.

   [RFC8040]  Bierman, A., Bjorklund, M., and K. Watsen, &quot;RESTCONF
              Protocol&quot;, RFC 8040, DOI 10.17487/RFC8040, January 2017,
              &lt;http://www.rfc-editor.org/info/rfc8040&gt;.

   [W3C.REC-xml-20081126]
              Bray, T., Paoli, J., Sperberg-McQueen, M., Maler, E., and
              F. Yergeau, &quot;Extensible Markup Language (XML) 1.0
              (Fifth Edition)&quot;, World Wide Web Consortium
              Recommendation REC-xml-20081126, November 2008,
              &lt;http://www.w3.org/TR/2008/REC-xml-20081126&gt;.

6.2.  Informative References

   [RFC5226]  Narten, T. and H. Alvestrand, &quot;Guidelines for Writing an
              IANA Considerations Section in RFCs&quot;, BCP 26, RFC 5226,
              DOI 10.17487/RFC5226, May 2008,
              &lt;http://www.rfc-editor.org/info/rfc5226&gt;.

Appendix A.  Example YANG Module

   The example YANG module used in this document represents a simple
   media jukebox interface.  The &quot;example-jukebox&quot; YANG module is
   defined in [RFC8040].

   YANG tree diagram for the &quot;example-jukebox&quot; module:

      +--rw jukebox!
         +--rw library
         |  +--rw artist* [name]
         |  |  +--rw name     string
         |  |  +--rw album* [name]
         |  |     +--rw name     string
         |  |     +--rw genre?   identityref
         |  |     +--rw year?    uint16
         |  |     +--rw admin
         |  |     |  +--rw label?              string
         |  |     |  +--rw catalogue-number?   string
         |  |     +--rw song* [name]
         |  |        +--rw name        string
         |  |        +--rw location    string
         |  |        +--rw format?     string
         |  |        +--rw length?     uint32
         |  +--ro artist-count?   uint32
         |  +--ro album-count?    uint32
         |  +--ro song-count?     uint32
         +--rw playlist* [name]
         |  +--rw name           string
         |  +--rw description?   string
         |  +--rw song* [index]
         |     +--rw index    uint32
         |     +--rw id       instance-identifier
         +--rw player
            +--rw gap?   decimal64

     rpcs:

      +---x play
         +--ro input
            +--ro playlist       string
            +--ro song-number    uint32

A.1.  YANG Patch Examples

   This section includes RESTCONF examples.  Most examples are shown in
   JSON encoding [RFC7159], and some are shown in XML encoding
   [W3C.REC-xml-20081126].

A.1.1.  Add Resources: Error

   The following example shows several songs being added to an existing
   album.  Each edit contains one song.  The first song already exists,
   so an error will be reported for that edit.  The rest of the edits
   were not attempted, since the first edit failed.  XML encoding is
   used in this example.

   Request from the RESTCONF client:

      PATCH /restconf/data/example-jukebox:jukebox/\
         library/artist=Foo%20Fighters/album=Wasting%20Light HTTP/1.1
      Host: example.com
      Accept: application/yang-data+xml
      Content-Type: application/yang-patch+xml

      &lt;yang-patch xmlns=&quot;urn:ietf:params:xml:ns:yang:ietf-yang-patch&quot;&gt;
        &lt;patch-id&gt;add-songs-patch&lt;/patch-id&gt;
        &lt;edit&gt;
          &lt;edit-id&gt;edit1&lt;/edit-id&gt;
          &lt;operation&gt;create&lt;/operation&gt;
          &lt;target&gt;/song=Bridge%20Burning&lt;/target&gt;
          &lt;value&gt;
            &lt;song xmlns=&quot;http://example.com/ns/example-jukebox&quot;&gt;
              &lt;name&gt;Bridge Burning&lt;/name&gt;
              &lt;location&gt;/media/bridge_burning.mp3&lt;/location&gt;
              &lt;format&gt;MP3&lt;/format&gt;
              &lt;length&gt;288&lt;/length&gt;
            &lt;/song&gt;
          &lt;/value&gt;
        &lt;/edit&gt;

        &lt;edit&gt;
          &lt;edit-id&gt;edit2&lt;/edit-id&gt;
          &lt;operation&gt;create&lt;/operation&gt;
          &lt;target&gt;/song=Rope&lt;/target&gt;
          &lt;value&gt;
            &lt;song xmlns=&quot;http://example.com/ns/example-jukebox&quot;&gt;
              &lt;name&gt;Rope&lt;/name&gt;
              &lt;location&gt;/media/rope.mp3&lt;/location&gt;
              &lt;format&gt;MP3&lt;/format&gt;
              &lt;length&gt;259&lt;/length&gt;
            &lt;/song&gt;
          &lt;/value&gt;
        &lt;/edit&gt;
        &lt;edit&gt;
          &lt;edit-id&gt;edit3&lt;/edit-id&gt;
          &lt;operation&gt;create&lt;/operation&gt;
          &lt;target&gt;/song=Dear%20Rosemary&lt;/target&gt;
          &lt;value&gt;
            &lt;song xmlns=&quot;http://example.com/ns/example-jukebox&quot;&gt;
              &lt;name&gt;Dear Rosemary&lt;/name&gt;
              &lt;location&gt;/media/dear_rosemary.mp3&lt;/location&gt;
              &lt;format&gt;MP3&lt;/format&gt;
              &lt;length&gt;269&lt;/length&gt;
            &lt;/song&gt;
          &lt;/value&gt;
        &lt;/edit&gt;
      &lt;/yang-patch&gt;

   XML response from the RESTCONF server:

      HTTP/1.1 409 Conflict
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
      Content-Type: application/yang-data+xml

      &lt;yang-patch-status
         xmlns=&quot;urn:ietf:params:xml:ns:yang:ietf-yang-patch&quot;&gt;
        &lt;patch-id&gt;add-songs-patch&lt;/patch-id&gt;
        &lt;edit-status&gt;
          &lt;edit&gt;
             &lt;edit-id&gt;edit1&lt;/edit-id&gt;
             &lt;errors&gt;
                &lt;error&gt;
                   &lt;error-type&gt;application&lt;/error-type&gt;
                   &lt;error-tag&gt;data-exists&lt;/error-tag&gt;
                   &lt;error-path
                     xmlns:jb=&quot;http://example.com/ns/example-jukebox&quot;&gt;
                     /jb:jukebox/jb:library
                     /jb:artist[jb:name=&#x27;Foo Fighters&#x27;]
                     /jb:album[jb:name=&#x27;Wasting Light&#x27;]
                     /jb:song[jb:name=&#x27;Bridge Burning&#x27;]
                   &lt;/error-path&gt;
                   &lt;error-message&gt;
                     Data already exists; cannot be created
                   &lt;/error-message&gt;
                &lt;/error&gt;
             &lt;/errors&gt;
          &lt;/edit&gt;
       &lt;/edit-status&gt;
     &lt;/yang-patch-status&gt;

   JSON response from the RESTCONF server:

   The following response is shown in JSON format to highlight the
   difference in the &quot;error-path&quot; object encoding.  For JSON, the
   instance-identifier encoding specified in [RFC7951] is used.

      HTTP/1.1 409 Conflict
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
      Content-Type: application/yang-data+json

      {
        &quot;ietf-yang-patch:yang-patch-status&quot; : {
          &quot;patch-id&quot; : &quot;add-songs-patch&quot;,
          &quot;edit-status&quot; : {
            &quot;edit&quot; : [
              {
                &quot;edit-id&quot; : &quot;edit1&quot;,
                &quot;errors&quot; : {
                  &quot;error&quot; : [
                    {
                      &quot;error-type&quot;: &quot;application&quot;,
                      &quot;error-tag&quot;: &quot;data-exists&quot;,
                      &quot;error-path&quot;: &quot;/example-jukebox:jukebox/library\
                         /artist[name=&#x27;Foo Fighters&#x27;]\
                         /album[name=&#x27;Wasting Light&#x27;]\
                         /song[name=&#x27;Bridge Burning&#x27;]&quot;,
                      &quot;error-message&quot;:
                        &quot;Data already exists; cannot be created&quot;
                    }
                  ]
                }
              }
            ]
          }
        }
      }

A.1.2.  Add Resources: Success

   The following example shows several songs being added to an existing
   album.

   o  Each of two edits contains one song.

   o  Both edits succeed, and new sub-resources are created.

   Request from the RESTCONF client:

      PATCH /restconf/data/example-jukebox:jukebox/\
         library/artist=Foo%20Fighters/album=Wasting%20Light \
         HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
      Content-Type: application/yang-patch+json

      {
        &quot;ietf-yang-patch:yang-patch&quot; : {
          &quot;patch-id&quot; : &quot;add-songs-patch-2&quot;,
          &quot;edit&quot; : [
            {
              &quot;edit-id&quot; : &quot;edit1&quot;,
              &quot;operation&quot; : &quot;create&quot;,
              &quot;target&quot; : &quot;/song=Rope&quot;,
              &quot;value&quot; : {
                &quot;song&quot; : [
                  {
                    &quot;name&quot; : &quot;Rope&quot;,
                    &quot;location&quot; : &quot;/media/rope.mp3&quot;,
                    &quot;format&quot; : &quot;MP3&quot;,
                    &quot;length&quot; : 259
                  }
                ]
              }
            },
            {
              &quot;edit-id&quot; : &quot;edit2&quot;,
              &quot;operation&quot; : &quot;create&quot;,
              &quot;target&quot; : &quot;/song=Dear%20Rosemary&quot;,
              &quot;value&quot; : {
                &quot;song&quot; : [
                  {
                    &quot;name&quot; : &quot;Dear Rosemary&quot;,
                    &quot;location&quot; : &quot;/media/dear_rosemary.mp3&quot;,
                    &quot;format&quot; : &quot;MP3&quot;,
                    &quot;length&quot; : 269
                  }
                ]
              }
            }
          ]
        }
      }

   Response from the RESTCONF server:

      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
      Content-Type: application/yang-data+json

      {
        &quot;ietf-yang-patch:yang-patch-status&quot; : {
          &quot;patch-id&quot; : &quot;add-songs-patch-2&quot;,
          &quot;ok&quot; : [null]
        }
      }

A.1.3.  Insert List Entry

   The following example shows a song being inserted within an existing
   playlist.  Song &quot;6&quot; in playlist &quot;Foo-One&quot; is being inserted after
   song &quot;5&quot; in the playlist.  The operation succeeds, so a non-error
   reply can be provided.

    Request from the RESTCONF client:

      PATCH /restconf/data/example-jukebox:jukebox/\
        playlist=Foo-One HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
      Content-Type: application/yang-patch+json

      {
        &quot;ietf-yang-patch:yang-patch&quot; : {
          &quot;patch-id&quot; : &quot;insert-song-patch&quot;,
          &quot;comment&quot; : &quot;Insert song 6 after song 5&quot;,
          &quot;edit&quot; : [
            {
              &quot;edit-id&quot; : &quot;edit1&quot;,
              &quot;operation&quot; : &quot;insert&quot;,
              &quot;target&quot; : &quot;/song=6&quot;,
              &quot;point&quot; : &quot;/song=5&quot;,
              &quot;where&quot; : &quot;after&quot;,
              &quot;value&quot; : {
                &quot;example-jukebox:song&quot; : [
                  {
                    &quot;index&quot; : 6,
                    &quot;id&quot; : &quot;/example-jukebox:jukebox/library\
                      /artist[name=&#x27;Foo Fighters&#x27;]\
                      /album[name=&#x27;Wasting Light&#x27;]\
                      /song[name=&#x27;Bridge Burning&#x27;]&quot;
                  }
                ]
              }
            }
          ]
        }

   Response from the RESTCONF server:

     HTTP/1.1 200 OK
     Date: Thu, 26 Jan 2017 20:56:30 GMT
     Server: example-server
     Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
     Content-Type: application/yang-data+json

     {
       &quot;ietf-yang-patch:yang-patch-status&quot; : {
         &quot;patch-id&quot; : &quot;insert-song-patch&quot;,
         &quot;ok&quot; : [null]
       }
     }

A.1.4.  Move List Entry

   The following example shows a song being moved within an existing
   playlist.  Song &quot;1&quot; in playlist &quot;Foo-One&quot; is being moved after
   song &quot;3&quot; in the playlist.  Note that no &quot;value&quot; parameter is needed
   for a &quot;move&quot; operation.  The operation succeeds, so a non-error reply
   can be provided.

   Request from the RESTCONF client:

      PATCH /restconf/data/example-jukebox:jukebox/\
        playlist=Foo-One HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
      Content-Type: application/yang-patch+json

      {
        &quot;ietf-yang-patch:yang-patch&quot; : {
          &quot;patch-id&quot; : &quot;move-song-patch&quot;,
          &quot;comment&quot; : &quot;Move song 1 after song 3&quot;,
          &quot;edit&quot; : [
            {
              &quot;edit-id&quot; : &quot;edit1&quot;,
              &quot;operation&quot; : &quot;move&quot;,
              &quot;target&quot; : &quot;/song=1&quot;,
              &quot;point&quot; : &quot;/song=3&quot;,
              &quot;where&quot; : &quot;after&quot;
            }
          ]
        }
      }

   Response from the RESTCONF server:

      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Last-Modified: Thu, 26 Jan 2017 20:56:30 GMT
      Content-Type: application/yang-data+json

      {
        &quot;ietf-restconf:yang-patch-status&quot; : {
          &quot;patch-id&quot; : &quot;move-song-patch&quot;,
          &quot;ok&quot; : [null]
        }
      }

A.1.5.  Edit Datastore Resource

   The following example shows how three top-level data nodes from
   different modules can be edited at the same time.

   Example module &quot;foo&quot; defines leaf X.  Example module &quot;bar&quot; defines
   container Y, with child leafs A and B.  Example module &quot;baz&quot; defines
   list Z, with key C and child leafs D and E.

   Request from the RESTCONF client:

      PATCH /restconf/data HTTP/1.1
      Host: example.com
      Accept: application/yang-data+json
      Content-Type: application/yang-patch+json

      {
        &quot;ietf-yang-patch:yang-patch&quot; : {
          &quot;patch-id&quot; : &quot;datastore-patch-1&quot;,
          &quot;comment&quot; : &quot;Edit 3 top-level data nodes at once&quot;,
          &quot;edit&quot; : [
            {
              &quot;edit-id&quot; : &quot;edit1&quot;,
              &quot;operation&quot; : &quot;create&quot;,
              &quot;target&quot; : &quot;/foo:X&quot;,
              &quot;value&quot; : {
                &quot;foo:X&quot; : 42
              }
            },
            {
              &quot;edit-id&quot; : &quot;edit2&quot;,
              &quot;operation&quot; : &quot;merge&quot;,
              &quot;target&quot; : &quot;/bar:Y&quot;,
              &quot;value&quot; : {
                &quot;bar:Y&quot; : {
                  &quot;A&quot; : &quot;test1&quot;,
                  &quot;B&quot; : 99
                }
              }
            },
            {
              &quot;edit-id&quot; : &quot;edit3&quot;,
              &quot;operation&quot; : &quot;replace&quot;,
              &quot;target&quot; : &quot;/baz:Z=2&quot;,
              &quot;value&quot; : {
                &quot;baz:Z&quot; : [
                  {
                    &quot;C&quot; : 2,
                    &quot;D&quot; : 100,
                    &quot;E&quot; : false
                  }
                ]
              }
            }
          ]
        }
      }

   Response from the RESTCONF server:

      HTTP/1.1 200 OK
      Date: Thu, 26 Jan 2017 20:56:30 GMT
      Server: example-server
      Last-Modified: Thu, 26 Jan 2017 20:55:30 GMT
      Content-Type: application/yang-data+json

      {
        &quot;ietf-yang-patch:yang-patch-status&quot; : {
          &quot;patch-id&quot; : &quot;datastore-patch-1&quot;,
          &quot;ok&quot; : [null]
        }
      }

Acknowledgements

   The authors would like to thank Rex Fernando for his contributions to
   this document.

   Contributions to this material by Andy Bierman are based upon work
   supported by the United States Army, Space &amp; Terrestrial
   Communications Directorate (S&amp;TCD) under Contract
   No. W15P7T-13-C-A616.  Any opinions, findings, and conclusions or
   recommendations expressed in this material are those of the author(s)
   and do not necessarily reflect the views of the S&amp;TCD.

Authors&#x27; Addresses

   Andy Bierman
   YumaWorks

   Email: andy@yumaworks.com


   Martin Bjorklund
   Tail-f Systems

   Email: mbj@tail-f.com


   Kent Watsen
   Juniper Networks

   Email: kwatsen@juniper.net


        </re>
        
    </body>
</html>
