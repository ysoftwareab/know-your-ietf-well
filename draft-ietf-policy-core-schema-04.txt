
 Policy Framework Working Group                             J. Strassner
 Internet-draft                                            Cisco Systems
 Category: Standards Track                                   E. Ellesson
                                                                B. Moore
                                                         IBM Corporation
                                                               June 1999




                     Policy Framework LDAP Core Schema
                    draft-ietf-policy-core-schema-04.txt
                            June 25, 1999 13:39

   Status of this Memo

   This document is an Internet-Draft and is in full conformance with all
   provisions of Section 10 of RFC2026.

   Internet-Drafts are working documents of the Internet Engineering Task
   Force (IETF), its areas, and its working groups.  Note that other
   groups may also distribute working documents as Internet-Drafts.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   The list of current Internet-Drafts can be accessed at
   http://www.ietf.org/ietf/1id-abstracts.txt

   The list of Internet-Draft Shadow Directories can be accessed at
   http://www.ietf.org/shadow.html

   Copyright Notice

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

   Abstract

   This document takes as its starting point the object-oriented
   information model for representing policy information currently under
   joint development in the Service Level Agreements (SLA) Policy working
   group of the Distributed Management Task Force (DMTF) and in the
   IETF's Policy Framework working group.  The IETF document defining
   this information model is the "Policy Framework Core Information
   Model" [10].  This model defines two hierarchies of object classes:
   structural classes representing policy information and control of
   policies, and relationship classes that indicate how instances of the
   structural classes are related to each other. In general, both of
   these class hierarchies will need to be mapped to a particular data
   store.

   This draft defines the mapping of these information model classes to a
   directory that uses LDAPv3 as its access protocol. When mapping to an

 Strassner, et. al.     Expires: December 25, 1999              [Page 1]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   LDAP schema, the structural classes can be mapped more or less
   directly.  The relationship hierarchy, however, must be mapped to a
   form suitable for directory implementation.  Since this mapping of the
   relationship classes could be done in a number of different ways,
   there is the risk of non-interoperable implementations.  To avoid this
   possibility, this document provides a single mapping that all
   implementations using an LDAP directory as their policy repository
   SHALL use.

   Classes are also added to the LDAP schema to improve the performance
   of a client's interactions with an LDAP server when the client is
   retrieving large amounts of policy-related information.  These classes
   exist only to optimize LDAP retrievals:  there are no classes in the
   information model that correspond to them.

   The LDAP schema described in this document consists of six very
   general classes: policy (an abstract class), policyGroup, policyRule,
   policyCondition, policyTimePeriodCondition, and policyAction.  The
   schema also contains two less general classes:  vendorPolicyCondition
   and vendorPolicyAction. To achieve the mapping of the information
   model's relationships, the schema contains two auxiliary classes:
   policyGroupContainmentAuxClass and policyRuleContainmentAuxClass.
   Finally, the schema includes two classes policySubtreesPtrAuxClass and
   policyElement for optimizing LDAP retrievals, and a structural class
   policyInstance for attaching auxiliary classes representing policy
   conditions and policy actions.  In all, therefore, the schema contains
   13 classes.

   Within the context of this document, the term "Core [Policy] Schema"
   is used to refer to the LDAP class definitions it contains.
























 Strassner, et. al.     Expires: December 25, 1999              [Page 2]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   Table of Contents
   1. Introduction......................................................3
   2. The Policy Core Information Model.................................4
   3. Inheritance Hierarchy for the LDAP Core Policy Schema.............5
   4. General Discussion of Mapping the Information Model to LDAP.......5
      4.1. Summary of Class and Relationship Mappings...................6
      4.2. Naming Attributes in the Core Schema.........................7
      4.3. Flexibility Gained through Auxiliary Classes.................8
      4.4. Location and Retrieval of Policy Objects in the Directory....9
      4.4.1. Aliases...................................................12
   5. Class Definitions................................................13
      5.1. The Abstract Class "policy".................................13
      5.2. The Class policyGroup.......................................14
      5.3. The Class policyRule........................................14
      5.4. The Class policyCondition...................................19
      5.5. The Class policyTimePeriodCondition.........................19
      5.6. The Class vendorPolicyCondition.............................21
      5.7. The Class policyAction......................................22
      5.8. The Class vendorPolicyAction................................22
      5.9. The Class policyInstance....................................23
      5.10. The Auxiliary Class policyElement..........................23
      5.11. The Auxiliary Class policySubtreesPtrAuxClass..............24
      5.11.1. The Attribute policySubtreesAuxContainedSet..............25
      5.12. The Auxiliary Class policyGroupContainmentAuxClass.........25
      5.12.1. The Attribute policyGroupsAuxContainedSet................26
      5.13. The Auxiliary Class policyRuleContainmentAuxClass..........26
      5.13.1. The Attribute policyRulesAuxContainedSet.................27
   6. Extending the Core Schema........................................27
      6.1. Subclassing policyCondition and policyAction................27
      6.2. Using the Vendor Policy Encoding Attributes.................28
      6.3. Using Time Validity Periods.................................28
   7. Security Considerations..........................................29
   8. Intellectual Property............................................31
   9. Acknowledgments..................................................31
   10. References......................................................31
   11. Authors' Addresses..............................................32
   12. Full Copyright Statement........................................32



 1. Introduction

   This document takes as its starting point the object-oriented
   information model for representing policy information currently under
   joint development in the Service Level Agreements working group of the
   Distributed Management Task Force (DMTF) and in the IETF's Policy
   Framework working group.  The IETF document defining this information
   model is the "Policy Framework Core Information Model" [10].  This
   model defines two hierarchies of object classes:  structural classes
   representing policy information and control of policies, and
   relationship classes that indicate how instances of the structural



 Strassner, et. al.     Expires: December 25, 1999              [Page 3]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   classes are related to each other. In general, both of these class
   hierarchies will need to be mapped to a particular data store.

   This draft defines the mapping of these information model classes to a
   directory that uses LDAPv3 as its access protocol. Two types of
   mappings are involved:

   o For the structural classes in the information model, the mapping is
     basically one-for-one: information model classes map to LDAP
     classes, information model properties map to LDAP attributes.

   o For the relationship classes in the information model, different
     mappings are possible.  In this document the information model's
     relationship classes and their properties are mapped in three ways:
     to LDAP auxiliary classes, to attributes representing DN pointers,
     and to "composite" attributes representing DN pointers with
     additional data elements.

   Implementations that use an LDAP directory as their policy repository
   SHALL use the LDAP policy schema defined in this document.  The use of
   the information model defined in reference [10] as the starting point
   enables the schema and the relationship class hierarchy to be
   extensible, such that other types of policy repositories, such as
   relational databases, can also use this information.

   This document fits into the overall framework for representing,
   deploying, and managing policies being developed by the Policy
   Framework Working Group.  The initial work to define this framework is
   in reference [1].  More specifically, this document builds on the core
   policy classes first introduced in references [2] and [3].  It also
   draws on the work done for the Directory-enabled Networks (DEN)
   specification, reference [4].  Work on the DEN specification by the
   DEN Ad-Hoc Working Group itself has been completed.  Further work to
   standardize the models contained in it will be the responsibility of
   selected working groups of the Common Information Model (CIM) effort
   in the Distributed Management Task Force (DMTF).  Standardization of
   the core policy model is the responsibility of the SLA Policy working
   group.

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119, reference
   [5].


 2. The Policy Core Information Model

   This document contains an LDAP schema representing the Policy Core
   Information Model, which is defined in the companion document "Policy
   Framework Core Information Model" [10].  Other documents may
   subsequently be produced, with mappings of this same Core Information
   Model to other storage technologies.  Since the detailed semantics of


 Strassner, et. al.     Expires: December 25, 1999              [Page 4]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   the Core Policy classes appear only in reference [10], that document
   is a prerequisite for reading and understanding this document.


 3. Inheritance Hierarchy for the LDAP Core Policy Schema

   The following diagram illustrates the class hierarchy for the LDAP
   Core Policy Schema classes:

     top
      |
      +--policy (abstract)
      |   |
      |   +---policyGroup (structural)
      |   |
      |   +---policyRule (structural)
      |   |
      |   +---policyCondition (auxiliary)
      |   |          |
      |   |          +---policyTimePeriodCondition (auxiliary)
      |   |          |
      |   |          +---vendorPolicyCondition (auxiliary)
      |   |
      |   +---policyAction (auxiliary)
      |   |          |
      |   |          +---vendorPolicyAction (auxiliary)
      |   |
      |   +--policyInstance (structural)
      |   |
      |   +--policyElement (auxiliary)
      |
      +--policySubtreesPtrAuxClass (auxiliary)
      |
      +--policyGroupContainmentAuxClass (auxiliary)
      |
      +--policyRuleContainmentAuxClass (auxiliary)


   Figure 1.    LDAP Class Inheritance Hierarchy for the Core Policy
   Schema



 4. General Discussion of Mapping the Information Model to LDAP

   The classes described in Section 5 below contain certain optimizations
   for a directory that uses LDAP as its access protocol. One example of
   this is the use of auxiliary classes to represent some of the
   relationships defined in the information model.  Other data stores
   might need to implement these relationships differently.  A second
   example is the introduction of classes specifically designed to
   optimize retrieval of large amounts of policy-related data from a


 Strassner, et. al.     Expires: December 25, 1999              [Page 5]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   directory.  This section discusses some general topics related to the
   mapping from the information model to LDAP.

 4.1. Summary of Class and Relationship Mappings

   Eight of the classes in the LDAP Core Policy Schema come directly from
   corresponding classes in the information model.  Note that names of
   classes begin with an upper case character in the information model
   (although for CIM in particular, case is  not significant in class and
   property names), but with a lower case character in LDAP.

   +---------------------------+---------------------------+
   | Information Model         | LDAP Class                |
   +---------------------------+---------------------------+
   +---------------------------+---------------------------+
   | Policy                    | policy                    |
   +---------------------------+---------------------------+
   | PolicyGroup               | policyGroup               |
   +---------------------------+---------------------------+
   | PolicyRule                | policyRule                |
   +---------------------------+---------------------------+
   | PolicyCondition           | policyCondition           |
   +---------------------------+---------------------------+
   | PolicyAction              | policyAction              |
   +---------------------------+---------------------------+
   | VendorPolicyCondition     | vendorPolicyCondition     |
   +---------------------------+---------------------------+
   | VendorPolicyAction        | vendorPolicyAction        |
   +---------------------------+---------------------------+
   | PolicyTimePeriodCondition | policyTimePeriodCondition |
   +---------------------------+---------------------------+
   Figure 2.    Mapping of Information Model Classes to LDAP

   The relationships in the information model map to pointer attributes
   in LDAP.  Two of these attributes appear in auxiliary classes, which
   allows each of them to represent several associations from the
   information model.

















 Strassner, et. al.     Expires: December 25, 1999              [Page 6]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   +--------------------------------+---------------------------------+
   | Information Model Relationship | LDAP Attribute / Class          |
   +--------------------------------+---------------------------------+
   +--------------------------------+---------------------------------+
   | GroupJurisdiction              | policyGroupsAuxContainedSet in  |
   |                                |  policyGroupContainmentAuxClass |
   +--------------------------------+---------------------------------+
   | ContainedPolicyGroup           | policyGroupsAuxContainedSet in  |
   |                                |  policyGroupContainmentAuxClass |
   +--------------------------------+---------------------------------+
   | RuleJurisdiction               | policyRulesAuxContainedSet in   |
   |                                |  policyRuleContainmentAuxClass  |
   +--------------------------------+---------------------------------+
   | ContainedPolicyRule            | policyRulesAuxContainedSet in   |
   |                                |  policyRuleContainmentAuxClass  |
   +--------------------------------+---------------------------------+
   | ContainedPolicyCondition       | policyRuleConditionList in      |
   |                                |  policyRule                     |
   +--------------------------------+---------------------------------+
   | ContainedPolicyAction          | policyRuleActionList in         |
   |                                |  policyRule                     |
   +--------------------------------+---------------------------------+
   | PolicyRuleValidityPeriod       | policyRuleValidityPeriodList in |
   |                                |  policyRule                     |
   +--------------------------------+---------------------------------+
   Figure 3.    Mapping of Information Model Relationships to LDAP

   Of the remaining classes in the LDAP Core Schema, two (policyElement,
   and policySubtreesPtrAuxClass) are included to make navigation through
   the Directory Information Tree (DIT) and retrieval of the entries
   found there more efficient.  This topic is discussed in Section 4.4
   below.

   The final class in the LDAP Core Schema, policyInstance, plays the
   role of a structural class to which the auxiliary classes
   policyCondition and policyAction (and their subclasses) may be
   attached.  This topic is discussed in Section 4.3 below.

 4.2. Naming Attributes in the Core Schema

   Instances in a directory are identified by distinguished names (DNs),
   which provide the same type of hierarchical organization that a file
   system provides in a computer system.  A distinguished name is a
   sequence of relative distinguished names (RDNs), where an RDN provides
   a unique identifier for an instance within the context of its
   immediate superior, in the same way that a filename provides a unique
   identifier for a file within the context of the folder in which it
   resides.

   To preserve maximum naming flexibility for policy administrators, each
   of the structural classes defined in this schema has its own naming
   attribute. (The structural class policyInstance gets its naming


 Strassner, et. al.     Expires: December 25, 1999              [Page 7]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   attribute from one of two auxiliary classes defined in the schema:
   either policyConditionName from the auxiliary class policyCondition,
   or policyActionName from the auxiliary class policyAction.)  Since the
   naming attributes are different, a policy administrator can, by using
   these attributes, guarantee that there will be no name collisions
   between instances of different classes, even if the same VALUE is
   assigned to the instances' respective naming attributes.

   The X.500 attribute commonName (cn) is included as a MAY attribute in
   the abstract class policy, and thus by inheritance in policyGroup,
   policyRule, policyCondition, policyAction, policyInstance,
   policyElement, and all of their subclasses.  In X.500 commonName
   typically functions as an RDN attribute, for naming instances of such
   classes as X.500's person.

   Each of the Core Schema classes thus has two attributes suitable for
   naming:  cn and its own class-specific attribute.  Either of these
   attributes MAY be used for naming an instance of a Core Schema class.
   Consequently, implementations MUST be able to accommodate instances
   named in either of these ways.

 4.3. Flexibility Gained through Auxiliary Classes

   A key feature of the Core Schema is the use of auxiliary classes for
   modeling policy conditions and policy actions.  These auxiliary
   classes make it possible to model a policy rule in two different ways:

   o Simple Policy Rule:  The conditions and/or the actions for the rule
     are attached to the rule object itself.

   o Complex Policy Rule:  The conditions and/or the actions for the
     rule are attached to instances of the structural class
     policyInstance, and these instances are pointed to by one of three
     attributes in the policy rule object - policyRuleConditionList,
     policyRuleActionList, or policyRuleValidityPeriodList (for the
     special case of a policyTimePeriodCondition object).

   The simple/complex distinction for a policy rule is not all or
   nothing.  A policy rule may have its conditions attached to itself and
   its actions attached to instances of policyInstance, or it may have
   its actions attached to itself and its conditions attached to
   instances of policyInstance.  However, it SHALL NOT have either its
   conditions or its actions attached both to itself and to instances of
   policyInstance, with one exception:  a policy rule may point to its
   validity periods with the policyRuleValidityPeriodList attribute, but
   have its other conditions attached to itself.

   The tradeoffs between simple and complex policy rules are between the
   efficiency of simple rules and the flexibility and greater potential
   for reuse of complex rules.  With a simple policy rule, the semantic
   options are limited:



 Strassner, et. al.     Expires: December 25, 1999              [Page 8]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   o All conditions are ANDed together.  This combination can be
     represented in two ways in the DNF / CNF expressions characteristic
     of policy conditions:  as a DNF expression with a single AND group,
     or as a CNF expression with multiple single-condition OR groups.
     The first of these is arbitrarily chosen as the representation for
     the ANDed conditions in a simple policy rule.

   o If multiple actions are included, no order can be specified for
     them.

   Thus if a policy administrator needs to combine conditions in some
   other way, or if there is a set of actions that must be ordered, then
   the only option is to use a complex policy rule.  The cost of a
   complex rule lies in the overhead of following DN pointers from the
   rule object to condition and/or action objects.  Section 4.4 below
   describes a technique for minimizing this overhead, by making the
   following of these pointers a local operation for a PDP.

   The classes policyCondition and policyAction do not themselves
   represent actual conditions and actions:  these are introduced in
   subclasses of policyCondition and policyAction.  What policyCondition
   and policyAction do introduce, in addition to the naming attributes
   policyConditionName and policyActionName, are the semantics of being a
   policy condition or a policy action.  These are the semantics that all
   the subclasses of policyCondition and policyAction inherit.  Among
   these semantics are those of being an object to which, respectively,
   the policyRuleConditionList and policyRuleActionList attributes may
   point.

   In order to preserve the flexibility of attaching either to policyRule
   or to policyInstance, all the subclasses of policyCondition and
   policyAction MUST also be auxiliary classes.

 4.4. Location and Retrieval of Policy Objects in the Directory

   When a PDP goes to an LDAP directory to retrieve the policy object
   instances relevant to the PEPs it serves, it is faced with two related
   problems:

   o How does it locate and retrieve the directory entries that apply to
     its PEPs?  These entries may include instances of the Core Schema
     classes, instances of domain-specific subclasses of these classes,
     and instances of other classes modeling such resources as user
     groups, interfaces, and address ranges.

   o How does it retrieve the directory entries it needs in an efficient
     manner, so that retrieval of policy information from the directory
     does not become a roadblock to scaleability?  There are two facets
     to this efficiency:  retrieving only the relevant directory
     entries, and retrieving these entries using as few LDAP calls as
     possible.



 Strassner, et. al.     Expires: December 25, 1999              [Page 9]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   The placement of objects in the Directory Information Tree (DIT)
   involves considerations other than how the policy-related objects will
   be retrieved by a PDP.  Consequently, all that the Core Schema can do
   is to provide a "toolkit" of classes to assist the policy
   administrator as the DIT is being designed and built.  A PDP SHOULD be
   able to take advantage of any tools that the policy administrator is
   able to build into the DIT, but it MUST be able to use a less
   efficient means of retrieval if that is all it has available to it.

   The basic idea behind the LDAP optimization classes is a simple one:
   make it possible for a PDP to retrieve all the policy-related objects
   it needs, and only those objects, using as few LDAP calls as possible.
   Figure 4 illustrates how these goals can be accomplished.

                      +-----+
     ---------------->|  A  |
     DN pointer to    |     |    DN pointers to subtrees    +---+
     starting object  +-----+    +------------------------->| C |
                      |  o--+----+         +---+            +---+
                      |  o--+------------->| B |           /     \
                      +-----+              +---+          /       \
                     /       \            /     \        /   ...   \
                    /         \          /       \
                   /           \        /   ...   \

   Figure 4.      Using a policyContainer Object to Scope Policies

   The PDP is configured initially with a DN pointer to some entry in the
   DIT.  The structural class of this entry is not important; the PDP is
   interested only in the policySubtreesPtrAuxClass attached to it.  This
   auxiliary class contains a multi-valued attribute with DN pointers to
   objects that anchor subtrees containing policy-related objects of
   interest to the PDP.  Since policySubtreesPtrAuxClass is an auxiliary
   class, it can be attached to an entry that the PDP would need to
   access anyway - perhaps an entry containing initial configuration
   settings for the PDP, or for a PEP that uses the PDP.

   Once it has retrieved the DN pointers, the PDP will direct to each of
   the objects identified by them an LDAP request that all entries in its
   subtree be evaluated against the selection criteria specified in the
   request.  The LDAP-enabled directory then returns all entries in that
   subtree that satisfy the specified criteria.

   The selection criteria always specify that object class = "policy".
   Since all classes representing policy rules, policy conditions, and
   policy actions, both in the Core Schema and in any domain-specific
   schema derived from it, are subclasses of the abstract class policy,
   this criterion evaluates to TRUE for all instances of these classes.
   To accommodate special cases where a PDP needs to retrieve objects
   that are not inherently policy-related (for example, an IP address
   range object pointed to by a subclass of policyAction representing the
   DHCP action "assign from this address range), the auxiliary class


 Strassner, et. al.     Expires: December 25, 1999             [Page 10]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   policyElement can be used to "tag" an entry, so that it will be found
   by the selection criterion "object class = policy".

   The approach described in the preceding paragraph will not work for
   certain directory implementations, because these implementations do
   not support matching of auxiliary classes in the objectClass
   attribute.  For environments where these implementations are expected
   to be present, the "tagging" of entries as relevant to policy can be
   accomplished by inserting the special value "POLICY" into the list of
   values contained in the policyKeywords attribute.

   If a PDP needs only a subset of the policy-related objects in the
   indicated subtrees, then it can be configured with additional
   selection criteria based on the policyKeywords attribute defined in
   the policy class.  This attribute supports both standardized and
   administrator-defined values.  Thus a PDP could be configured to
   request only those policy-related objects containing the keywords
   "DHCP" and "Eastern US".

   To optimize what is expected to be a typical case, the initial request
   from the client includes not only the object to which its "seed" DN
   pointer points, but also the subtree contained under this object.  The
   filter for searching this subtree is whatever the client is going to
   use later to search the other subtrees:  "object class = policy",
   presence of the keyword "POLICY", or presence of a more specific
   policyKeyword.

   Returning to the example in Figure 4, we see that in the best case, a
   PDP can get all the policy-related objects it needs, and only these
   objects, with exactly three LDAP requests:  one to its starting object
   A to get the pointers to B and C, as well as the policy-related
   objects it needs from the subtree under A, and then one each to B and
   C to get all the policy-related objects that pass the selection
   criteria with which it was configured.  Once it has retrieved all of
   these objects, the PDP can then traverse their various DN pointers
   locally to understand the semantic relationships among them.  The PDP
   should also be prepared to find a pointer to another subtree attached
   to any of the objects it retrieves, and to follow this pointer first,
   before it follows any of the semantically significant pointers it has
   received.  This recursion permits a structured approach to identifying
   related policies.  In Figure 4, for example, if the subtree under B
   includes departmental policies and the one under C includes divisional
   policies, then there might be a pointer from the subtree under C to an
   object D that roots the subtree of corporate-level policies.

   Since a PDP has no guarantee that the entity that populates the
   directory won't use the policySubtreesPtrAuxClass, a PDP SHOULD
   understand this class, SHOULD be capable of retrieving and processing
   the entries in the subtrees it points to, and SHOULD be capable of
   doing all of this recursively.  The same requirements apply to any
   other entity needing to retrieve policy information from the
   directory.  Thus a Policy Management Tool that retrieves policy


 Strassner, et. al.     Expires: December 25, 1999             [Page 11]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   entries from the directory in order to perform validation and conflict
   detection SHOULD also understand and be capable of using the
   policySubtreesPtrAuxClass.  All of these requirements are "SHOULD"s
   rather than "MUST"s because an LDAP client that doesn't implement them
   can still access and retrieve the directory entries it needs .  The
   process of doing so will just be less efficient than it would have
   been if the client had implemented these optimizations.

   When it is serving as a tool for creating policy entries in the
   directory, a Policy Management Tool SHOULD support creation of
   policySubtreePrtAuxClass entries and their DN pointers.

 4.4.1. Aliases

   Additional flexibility in DIT structure is available to the policy
   administrator via LDAP aliasing.  Figure 5 illustrates this
   flexibility.

                      +-----+
     ---------------->|  A  |
     DN pointer to    |     |    DN pointers to subtrees    +---+
     starting object  +-----+    +------------------------->| C |
                      |  o--+----+         +---+            +---+
                      |  o--+------------->| B |           /     \
                      +-----+              +---+          /       \
                     /       \            /     \        /   ...   \
                    /         \          /       \
                   /           \        /         \
         +---+                         /  +------+ \
         | X |<***************************|aliasX|
         +---+                            +------+

   Figure 5.      Addition of an Alias Object

   Even if it is necessary to store a policy entry X in a directory
   location separate from the other policy entries, batch retrieval using
   policy subtrees can still be done.  The administrator simply inserts
   into one of the subtrees of policy entries an alias entry aliasX
   pointing to the outlying entry X.  When the PDP requests all entries
   in the subtree under B, a response will be returned for entry X, just
   as responses are returned for all the (non-alias) entries that
   actually are in the subtree.

   Since resolution of an alias to its true entry is handled entirely by
   the LDAP directory, and is invisible to directory clients, PDPs need
   not do anything extra to support aliases.  A Policy Management Tool
   MAY make available to a policy administrator the ability to create
   alias entries like the one in Figure 5.






 Strassner, et. al.     Expires: December 25, 1999             [Page 12]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


 5. Class Definitions

   The semantics for the LDAP classes mapped directly from the
   information model are detailed in reference [10].  Consequently, all
   that this document presents for these classes is a bare specification
   of the LDAP classes and attributes.  More details are provided for the
   attributes listed above in Figure 3, which realize in LDAP the
   relationships defined in the information model.  Finally, the classes
   that exist only in the LDAP Core Schema are documented fully in this
   document.

 5.1. The Abstract Class "policy"

   The abstract class policy is a direct mapping of the abstract class
   Policy from the Core Information Model.  The property
   CreationClassName maps to the LDAP attribute objectClass, which is
   inherited from "top".  The remaining properties in Policy map directly
   to attributes in the class policy.

   The class value "policy" is also used as the mechanism for identifying
   policy-related instances in the Directory Information Tree.  An
   instance of any class may be "tagged" with this class value by
   attaching to it the auxiliary class policyElement.

   The class definition is as follows:

     NAME             policy
     DESCRIPTION      An abstract class with four attributes for
                      describing a policy-related instance.
     DERIVED FROM     top
     TYPE             abstract
     AUXILIARY CLASSES    none
     OID              <to be assigned>
     MAY              cn caption description policyKeywords

   The attributes are defined as:

     NAME             commonName (cn)
     DESCRIPTION      A user-friendly name of a policy-related object.
     SYNTAX           DirectoryString
     OID              2.4.5.3
     EQUALITY         caseIgnoreMatch
     MULTI-VALUED

     NAME             caption
     DESCRIPTION      A one-line description of this policy-related
                      object.
     SYNTAX           IA5String
     OID              <to be assigned>
     EQUALITY         caseExactIA5Match
     SINGLE-VALUED



 Strassner, et. al.     Expires: December 25, 1999             [Page 13]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


     NAME             description
     DESCRIPTION      A long description of this policy-related object.
     SYNTAX           IA5String
     OID              <to be assigned>
     EQUALITY         caseExactIA5Match
     SINGLE-VALUED

     NAME             policyKeywords
     DESCRIPTION      A set of keywords to assist directory clients in
                      locating the policy objects applicable to them.
                      Standard keyword values are listed in the Policy
                      Core Information Model document.
     SYNTAX           IA5String
     OID              <to be assigned>
     EQUALITY         caseExactIA5Match
     MULTI-VALUED

 5.2. The Class policyGroup

   The class definition for policyGroup is as follows.  Note that this
   class definition does not include attributes to realize the
   ContainedPolicyRule and ContainedPolicyGroup associations from the
   object model, since a policyGroup object points to instances of
   policyGroup and policyRule via, respectively, the pointer in
   policyGroupContainmentAuxClass and the pointer in
   policyRuleContainmentAuxClass.

     NAME             policyGroup
     DESCRIPTION      A container for either a set of related policyRules
                      or a set of related policyGroups.
     DERIVED FROM     top
     TYPE             structural
     AUXILIARY CLASSES    policyGroupContainmentAuxClass,
                      policyRuleContainmentAuxClass
     POSSIBLE SUPERIORS   container, organization, organizationalUnit,
                      policyGroup
     OID              <to be assigned>
     MUST             policyGroupName

   The one attribute of PolicyGroup is defined as:

     NAME             policyGroupName
     DESCRIPTION      The user-friendly name of this policy group.
     SYNTAX           IA5String
     OID              <to be assigned>
     EQUALITY         caseExactIA5Match
     SINGLE-VALUED

 5.3. The Class policyRule

   This class represents the "If Condition then Action" semantics
   associated with a policy.  The conditions and actions associated with


 Strassner, et. al.     Expires: December 25, 1999             [Page 14]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   a policy rule are modeled, respectively, with auxiliary subclasses of
   the classes policyCondition and policyAction.  These auxiliary classes
   are attached either to an instance of policyRule itself, or to an
   instance of the structural class policyInstance identified by a DN
   pointer in an instance of policyRule.

   Of the ten attributes in the policyRule class, seven are mapped
   directly from corresponding properties in the information model.  The
   remaining three attributes realize three of the aggregations in the
   information model.  Since the PolicyRuleValidityPeriod aggregation has
   no "extra" properties (besides those that tie the aggregation to the
   aggregating and aggregated objects), the attribute
   policyRuleValidityPeriodList is simply a multi-valued DN pointer.
   This attribute provides an unordered set of DN pointers to one or more
   policyTimePeriodConditions, indicating when the policy rule is
   scheduled to be active and when it is scheduled to be inactive.  The
   rule is scheduled to be active if it is active according to AT LEAST
   ONE of the policyTimePeriodConditions pointed to by this attribute.

   The ContainedPolicyCondition and ContainedPolicyAction aggregations,
   however, have additional properties:  ContainedPolicyAction has an
   integer to sequence the actions, and ContainedPolicyCondition has an
   integer to group the conditions, and a boolean to specify whether a
   condition is to be negated.  To represent these additional properties,
   the attributes policyRuleConditionList and policyRuleActionList are
   defined as "structured DN pointers."  A structured DN pointer is, from
   the point of view of an LDAP directory implementation, a
   DirectoryString.  These DirectoryStrings, however, have embedded in
   them both a DN pointer and elements to represent the additional
   properties from the aggregations being mapped.  Figures 6 and 7
   illustrate the mappings:

    Contained Condition ------------------+
    Condition Negated --------------+     |
    Group Number ---------+         |     |
                          |         |     |
                          V         V     V
                         <integer>:<+|->:<DN>    policyRuleConditionList


   Figure 6.    Mapping of ContainedPolicyCondition Properties

   There is one subtlety here.  In the element "<+|->", the '+' indicates
   that the condition is not negated, and the '-' indicates that it is
   negated.  In the information model, however, this information is
   represented by the boolean-valued  property ConditionNegated in the
   ContainedPolicyCondition aggregation.  The mapping between the
   information model and the LDAP Core Schema is thus:

   o If ConditionNegated = TRUE (i.e., it's true that the condition is
     negated), use '-'.



 Strassner, et. al.     Expires: December 25, 1999             [Page 15]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   o If ConditionNegated = FALSE (i.e., it's false that the condition is
     negated), use '+'.

   For example, the Directory String "1:+:DN-C" points to the condition
   named by DN-C, places it in Group 1, and indicates that it is not
   negated.

    Contained Action ---------------+
    Action Order ---------+         |
                          |         |
                          V         V
                         <integer>:<DN>       policyRuleActionList


   Figure 7.    Mapping of ContainedPolicyAction Properties

   For example, the DirectoryString "2:DN-A" points to the action named
   by DN-A, and indicates that it is to be performed second.

   Since these structured DN pointers appear as DirectoryStrings to a
   directory implementation, the implementation does not apply DN-
   oriented operations to them.  In particular, if a condition or action
   pointed to by a DN pointer embedded in one of these strings has its
   name changed, the ModifyDN operation will NOT update the embedded DN
   pointer.

   The class definition of policyRule is as follows:

     NAME             policyRule
     DESCRIPTION      The central class for representing the "If
                      Condition then Action" semantics associated with a
                      policy rule.
     DERIVED FROM     top
     TYPE             structural
     AUXILIARY CLASSES    none
     POSSIBLE SUPERIORS   policyGroup
     OID              <to be assigned>
     MUST             policyRuleName
     MAY              policyRuleEnabled policyRuleConditionListType
                      policyRuleConditionList policyRuleActionList
                      policyRuleValidityPeriodList policyRuleUsage
                      policyRulePriority policyRuleMandatory
                      policyRuleSequencedActions

   The attributes of policyRule are as follows:

     NAME             policyRuleName
     DESCRIPTION      The user-friendly name of this policy rule.
     SYNTAX           IA5String
     OID              <to be assigned>
     EQUALITY         caseExactIA5Match
     SINGLE-VALUED


 Strassner, et. al.     Expires: December 25, 1999             [Page 16]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999




     NAME             policyRuleEnabled
     DESCRIPTION      An enumeration indicating whether a policy rule is
                      administratively enabled, administratively
                      disabled, or enabled for debug mode.  The defined
                      values for this attribute are enabled(1),
                      disabled(2), and enabledForDebug(3).
    SYNTAX           INTEGER
     OID              <to be assigned>
     EQUALITY         integerMatch
     SINGLE-VALUED
     DEFAULT VALUE    enabled(1)


     NAME             policyRuleConditionListType
     DESCRIPTION      Indicates whether the list of policy conditions
                      associated with this policy rule is in disjunctive
                      normal form (DNF) or conjunctive normal form (CNF).
                      Defined values are DNF(1) and CNF(2).
     SYNTAX           INTEGER
     OID              <to be assigned>
     EQUALITY         integerMatch
     SINGLE-VALUED
     DEFAULT VALUE    DNF(1)


     NAME             policyRuleConditionList
     DESCRIPTION      An unordered list of strings of the form
                      '<groupNumber>:<+|->:<DN>', indicating a set of
                      policy conditions that determine when the
                      policyRule is applicable.
     SYNTAX           DirectoryString
     OID              <to be assigned>
     EQUALITY         caseIgnoreSubstringsMatch
     MULTI-VALUED
     FORMAT           <groupNumber>:<+|->:<DN>


     NAME             policyRuleActionList
     DESCRIPTION      An unordered list of strings of the form 'n:DN',
                      indicating an ordered set of policy actions to be
                      performed if the associated condition(s) of the
                      policyRule evaluates to true.
     SYNTAX           DirectoryString
     OID              <to be assigned>
     EQUALITY         caseIgnoreSubstringsMatch
     MULTI-VALUED
     FORMAT           n:DN


     NAME             policyRuleValidityPeriodList


 Strassner, et. al.     Expires: December 25, 1999             [Page 17]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


     DESCRIPTION      Distinguished names of policyTimePeriodConditions
                      that determine when the policyRule is scheduled to
                      be active / inactive.  No order is implied.
     SYNTAX           DN
     OID              <to be assigned>
     EQUALITY         distinguishedNameMatch
     MULTI-VALUED


     NAME             policyRuleUsage
     DESCRIPTION      This attribute is used to provide guidelines on how
                      this policy should be used.
     SYNTAX           DirectoryString
     OID              <to be assigned>
     EQUALITY         caseIgnoreMatch
     SINGLE-VALUED


     NAME             policyRulePriority
     DESCRIPTION      A non-negative integer for prioritizing this
                      policyRule relative to other policyRules.  A larger
                      value indicates a higher priority.
     SYNTAX           INTEGER
     OID              <to be assigned>
     EQUALITY         integerMatch
     SINGLE-VALUED
     DEFAULT VALUE    0


     NAME             policyRuleMandatory
     DESCRIPTION      A flag indicating that the evaluation of the
                      policyConditions and execution of policyActions (if
                      the condition list evaluates to True) is required.
     SYNTAX           Boolean
     OID              <to be assigned>
     EQUALITY         booleanMatch
     SINGLE-VALUED
     DEFAULT VALUE    TRUE


     NAME             policyRuleSequencedActions
     DESCRIPTION      An enumeration indicating how to interpret the
                      action ordering indicated via the
                      policyRuleActionList attribute.  The defined values
                      for this attribute are mandatory(1),
                      recommended(2), and dontCare(3).

     SYNTAX           INTEGER
     OID              <to be assigned>
     EQUALITY         integerMatch
     SINGLE-VALUED
     DEFAULT VALUE    dontCare(3)


 Strassner, et. al.     Expires: December 25, 1999             [Page 18]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999




 5.4. The Class policyCondition

   The purpose of a policy condition is to determine whether or not the
   set of actions (contained in the policyRule that the condition applies
   to) should be executed or not.

   The class definition is as follows:

     NAME             policyCondition
     DESCRIPTION      A class representing a condition to be evaluated in
                      conjunction with a policy rule.
     DERIVED FROM     top
     TYPE             auxiliary
     AUXILIARY CLASSES    none
     POSSIBLE SUPERIORS   policyRule
     OID              <to be assigned>
     MUST             policyConditionName
     MAY


   The one attribute definition is as follows:

     NAME             policyConditionName
     DESCRIPTION      The user-friendly name of this policy condition.
     SYNTAX           IA5String
     OID              <to be assigned>
     EQUALITY         caseExactIA5Match
     SINGLE-VALUED

 5.5. The Class policyTimePeriodCondition

   This class provides a means of representing the time periods during
   which a policy rule is valid, i.e., active.  The class definition is
   as follows.  Note that instances of this class are named with the
   attributes cn and policyConditionName that they inherit, respectively,
   from policy and from policyCondition.

     NAME             policyTimePeriodCondition
     DESCRIPTION      A class that provides the capability of enabling /
                      disabling a policy rule according to a pre-
                      determined schedule.
     DERIVED FROM     policyCondition
     TYPE             auxiliary
     AUXILIARY CLASSES    none
     POSSIBLE SUPERIORS   policyRule
     OID              <to be assigned>
     MUST
     MAY              ptpConditionTime ptpConditionMonthOfYearMask
                      ptpConditionDayOfMonthMask



 Strassner, et. al.     Expires: December 25, 1999             [Page 19]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


                      ptpConditionDayOfWeekMask ptpConditionTimeOfDayMask
                      ptpConditionTimeZone

   The attributes of policyTimePeriodCondition are defined as follows:

     NAME             ptpConditionTime
     DESCRIPTION      The range of calendar dates on which a policy rule
                      is valid.
     SYNTAX           PrintableString
     OID              <to be assigned>
     EQUALITY         caseIgnoreMatch
     SINGLE-VALUED
     FORMAT           [yyyymmddhhmmss]:[yyyymmddhhmmss]


     NAME             ptpConditionMonthOfYearMask
     DESCRIPTION      A mask identifying the months of the year in which
                      a policy rule is valid.
     SYNTAX           Printable String
     OID              <to be assigned>
     EQUALITY         caseIgnoreMatch
     SINGLE-VALUED
     FORMAT           A string of 12 ASCII '0's and '1's.


     NAME             ptpConditionDayOfMonthMask
     DESCRIPTION      A mask identifying the days of the month on which a
                      policy rule is valid.
     SYNTAX           PrintableString
     OID              <to be assigned>
     EQUALITY         caseIgnoreMatch
     SINGLE-VALUED
     FORMAT           A string of 31 ASCII '0's and '1's.


     NAME             ptpConditionDayOfWeekMask
     DESCRIPTION      A mask identifying the days of the week on which a
                      policy rule is valid.
     SYNTAX           PrintableString
     OID              <to be assigned>
     EQUALITY         caseIgnoreMatch
     SINGLE-VALUED
     FORMAT           A string of 7 ASCII '0's and '1's.


     NAME             ptpConditionTimeOfDayMask
     DESCRIPTION      The range of times at which a policy rule is valid.
                      If the second time is earlier than the first, then
                      the interval spans midnight.
     SYNTAX           Printable String
     OID              <to be assigned>
     EQUALITY         caseIgnoreMatch


 Strassner, et. al.     Expires: December 25, 1999             [Page 20]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


     SINGLE-VALUED
     FORMAT           hhmmss:hhmmss


     NAME             ptpConditionTimeZone
     DESCRIPTION      The definition of the time zone for the
                      policyTimePeriodCondition.
     SYNTAX           PrintableString
     OID              <to be assigned>
     EQUALITY         caseIgnoreMatch
     SINGLE-VALUED
     FORMAT           either 'Z' (UTC) or <'+'|'-'><hhmm>


 5.6. The Class vendorPolicyCondition

   The class definition is as follows:

     NAME             vendorPolicyCondition
     DESCRIPTION      A class that defines a registered means to describe
                      a policy condition.
     DERIVED FROM     policyCondition
     TYPE             auxiliary
     AUXILIARY CLASSES    none
     POSSIBLE SUPERIORS   policyRule
     OID              <to be assigned>
     MUST             vendorPolicyConstraintData
                      vendorPolicyConstraintEncoding
     MAY

   The attribute definitions for vendorPolicyCondition are as follows:

     NAME             vendorPolicyConstraintData
     DESCRIPTION      Escape mechanism for representing constraints that
                      have not been modeled as specific attributes. The
                      format of the values is identified by the OID
                      stored in the attribute
                      vendorPolicyConstraintEncoding.
     SYNTAX           OctetString
     OID              <to be assigned>
     EQUALITY         octetStringMatch
     MULTI-VALUED


     NAME             vendorPolicyConstraintEncoding
     DESCRIPTION      An OID identifying the format and semantics for
                      this instance's vendorPolicyConstraintData
                      attribute.
     SYNTAX           OID
     OID              <to be assigned>
     EQUALITY         objectIdentifierMatch
     SINGLE-VALUED


 Strassner, et. al.     Expires: December 25, 1999             [Page 21]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999



 5.7. The Class policyAction

   The purpose of a policy action is to execute one or more operations
   that will affect network traffic and/or systems, devices, etc. in
   order to achieve a desired policy state.

   The class definition is as follows:

     NAME             policyAction
     DESCRIPTION      A class representing an action to be performed as a
                      result of a policy rule.
     DERIVED FROM     top
     TYPE             auxiliary
     AUXILIARY CLASSES    none
     POSSIBLE SUPERIORS   policyRule
     OID              <to be assigned>
     MUST             policyActionName
     MAY


   The one attribute definition is as follows:

     NAME             policyActionName
     DESCRIPTION      The user-friendly name of this policy action.
     SYNTAX           IA5String
     OID              <to be assigned>
     EQUALITY         caseExactIA5Match
     SINGLE-VALUED

 5.8. The Class vendorPolicyAction

   The class definition is as follows:

     NAME             vendorPolicyAction
     DESCRIPTION      A class that defines a registered means to describe
                      a policy action.
     DERIVED FROM     policyAction
     TYPE             auxiliary
     AUXILIARY CLASSES    none
     POSSIBLE SUPERIORS   policyRule
     OID              <to be assigned>
     MUST             vendorPolicyActionData vendorPolicyActionEncoding
     MAY

   The attribute definitions for vendorPolicyAction are as follows:

     NAME             vendorPolicyActionData
     DESCRIPTION      Escape mechanism for representing actions that have
                      not been modeled as specific attributes. The
                      format of the values is identified by the OID
                      stored in the attribute vendorPolicyActionEncoding.


 Strassner, et. al.     Expires: December 25, 1999             [Page 22]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


     SYNTAX           OctetString
     OID              <to be assigned>
     EQUALITY         octetStringMatch
     MULTI-VALUED


     NAME             vendorPolicyActionEncoding
     DESCRIPTION      An OID identifying the format and semantics for
                      this instance's vendorPolicyActionData attribute.
     SYNTAX           OID
     OID              <to be assigned>
     EQUALITY         objectIdentifierMatch
     SINGLE-VALUED

 5.9. The Class policyInstance

   This class introduces no additional attributes, beyond those defined
   in the class policy from which it is derived.  Its role in the Core
   Schema is to serve as the structural class to which the auxiliary
   classes policyCondition and policyAction may be attached when the
   complex policy rule structure is required.  With its attached
   auxiliary class, an instance of policyInstance represents a single
   policy condition or a single policy action, but not both.

   An instance of this class is named by an attribute it acquires via an
   attached auxiliary class.  In the Core Schema, the naming attributes
   available for this purpose are policyConditionName and
   policyActionName.

   The class definition is as follows:

       NAME           policyInstance
       DESCRIPTION    A structural class to which the auxiliary classes
                      policyCondition and policyAction may be attached,
                      when the complex policy rule structure is required.
       DERIVED FROM   policy
       TYPE           structural
       AUXILIARY CLASSES    policyCondition, policyAction
       OID            <to be assigned>

 5.10. The Auxiliary Class policyElement

   Like policyInstance, this class also introduces no additional
   attributes, beyond those defined in the class policy from which it is
   derived.  Its role is to "tag" an instance of a class defined outside
   the realm of policy as being nevertheless relevant to a policy
   specification.  This tagging can potentially take place at two levels:

   o Every instance to which policyElement is attached becomes an
     instance of the class policy, since policyElement is a subclass of
     policy.  Thus a DIT search with the filter "objectClass=policy"
     will return the instance.  (As noted earlier, this approach does


 Strassner, et. al.     Expires: December 25, 1999             [Page 23]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


     not work for some directory implementations.  To accommodate these
     implementations, policy-related entries SHOULD be tagged with the
     keyword "POLICY".)

   o With the policyKeywords attribute that it inherits from policy, an
     instance to which policyElement is attached can be tagged as being
     relevant to a particular type or category of policy, using standard
     keywords, administrator-defined keywords, or both.

   The class definition is as follows:

     NAME             policyElement
     DESCRIPTION      An auxiliary class used to tag instances of classes
                      defined outside the realm of policy as relevant to
                      a particular policy specification.
     DERIVED FROM     policy
     TYPE             auxiliary
     AUXILIARY CLASSES    none
     OID              <to be assigned>

 5.11. The Auxiliary Class policySubtreesPtrAuxClass

   This auxiliary class provides a single, multi-valued attribute that
   points to a set of objects that are at the root of DIT subtrees
   containing policy-related information.  By attaching this attribute to
   instances of various other classes, a policy administrator has a
   flexible way of providing an entry point into the directory that
   allows a client to locate and retrieve the policy information relevant
   to it.

   These entries may be placed in the DIT such that a well-known DN can
   be used by placing the structural entry (e.g. container) with the
   policySubtreesPtrAuxClass attached thereto in the root of the
   directory suffix.  In this case, the subtree entry point can contain
   and/or point to all related policy entries for any well-known policy
   disciplines.  Similarly, the subtree entry point may be placed in the
   DIT such that the PDPs starting point is a subtree with policy-related
   entries that are dependent on a hierarchically-related set of subtrees
   (e.g., region, division, corporate).  In this latter case, DNs may be
   provided to the PDPs via SNMP or other techniques.

   This object does not provide the semantic linkages between individual
   policy objects, such as those between a policy group and the policy
   rules that belong to it.  Its only role is to enable efficient bulk
   retrieval of policy-related objects, as described in Section 4.4.
   Once the objects have been retrieved, a directory client can determine
   the semantic linkages by following DN pointers such as
   policyRulesAuxContainedSet locally.

   Since policy-related objects will often be included in the DIT subtree
   beneath an object to which this auxiliary class is attached, a client
   SHOULD request the policy-related objects from the subtree under the


 Strassner, et. al.     Expires: December 25, 1999             [Page 24]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   object with these pointers at the same time that it requests the
   pointers themselves.  Since policySubtreesPtrAuxClass is a subclass of
   the abstract class "policy", this can be accomplished with a single
   search operation with scope set to subtree and a filter set to select
   policy-related objects.

   Since clients are expected to behave in this way, the policy
   administrator SHOULD make sure that this subtree does not contain so
   many objects unrelated to policy that an initial search done in this
   way results in a performance problem.  For example,
   policySubtreesPtrAuxClass SHOULD NOT be attached to the partition root
   for a large directory partition containing a relatively few policy-
   related objects along with a large number of objects unrelated to
   policy.  A better approach would be to introduce a container object
   immediately below the partition root, attach policySubtreesPtrAuxClass
   to this container object, and then place the policy-related objects in
   the subtree under it.

   The class definition is as follows:

     NAME             policySubtreesPtrAuxClass
     DESCRIPTION      An auxiliary class providing a DN pointer to roots
                      of DIT subtrees contained policy-related objects.
     DERIVED FROM     top
     TYPE             auxiliary
     AUXILIARY CLASSES    none
     OID              <to be assigned>
     MUST             policySubtreesAuxContainedSet

 5.11.1. The Attribute policySubtreesAuxContainedSet

   This attribute provides an unordered set of DN pointers to one or more
   objects under which policy-related information is present.  The
   objects pointed to may or may not themselves contain policy-related
   information.

   The attribute definition is as follows:

     NAME             policySubtreesAuxContainedSet
     DESCRIPTION      Distinguished names of objects that serve as roots
                      for DIT subtrees containing policy-related objects.
                      No order is implied.
     SYNTAX           DN
     OID              <to be assigned>
     EQUALITY         distinguishedNameMatch
     MULTI-VALUED

 5.12. The Auxiliary Class policyGroupContainmentAuxClass

   This auxiliary class provides a single, multi-valued attribute that
   points to a set of policyGroups.  By attaching this attribute to
   instances of various other classes, a policy administrator has a


 Strassner, et. al.     Expires: December 25, 1999             [Page 25]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   flexible way of providing an entry point into the directory that
   allows a client to locate and retrieve the policyGroups relevant to
   it.

   As is the case with policyRules, a policy administrator might have
   several different pointers to a policyGroup in the overall directory
   structure. The policyGroupContainmentAuxClass is the mechanism that
   makes it possible for the policy administrator to define all these
   pointers.

   The class definition is as follows:

       NAME                 policyGroupContainmentAuxClass
       DESCRIPTION          An auxiliary class used to bind policyGroups
                            to an appropriate container object.
       DERIVED FROM         top
       TYPE                 auxiliary
       AUXILIARY CLASSES    none
       OID                  <to be assigned>
       MUST                 policyGroupsAuxContainedSet


 5.12.1. The Attribute policyGroupsAuxContainedSet

   This attribute provides an unordered set of DN pointers to one or more
   policyGroups associated with the instance of a structural class to
   which this attribute has been appended.  The attribute definition is
   as follows:

       NAME           policyGroupsAuxContainedSet
       DESCRIPTION    Distinguished names of policyGroups associated in
                      some way with the instance to which this attribute
                      has been appended.  No order is implied.
       SYNTAX         DN
       OID            <to be assigned>
       EQUALITY       distinguishedNameMatch
       MULTI-VALUED


 5.13. The Auxiliary Class policyRuleContainmentAuxClass

   This auxiliary class provides a single, multi-valued attribute that
   points to a set of policyRules.  By attaching this attribute to
   instances of various other classes, a policy administrator has a
   flexible way of providing an entry point into the directory that
   allows a client to locate and retrieve the policyRules relevant to it.

   A policy administrator might have several different pointers to a
   policyRule in the overall directory structure.  For example, there
   might be pointers to all policyRules for traffic originating in a
   particular subnet from a directory entry that represents that subnet.
   At the same time, there might be pointers to all policyRules related


 Strassner, et. al.     Expires: December 25, 1999             [Page 26]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   to a particular DiffServ setting from an instance of a policyGroup
   explicitly introduced as a container for DiffServ-related policyRules.
   The policyRuleContainmentAuxClass is the mechanism that makes it
   possible for the policy administrator to define all these pointers.

   Note that the cn attribute does NOT need to be defined for this class.
   This is because an auxiliary class is used as a means to collect
   common attributes and treat them as properties of an object. A good
   analogy is a #include file, except that since an auxiliary class is a
   class, all the benefits of a class (e.g., inheritance) can be applied
   to an auxiliary class.

   The class definition is as follows:

     NAME             policyRuleContainmentAuxClass
     DESCRIPTION      An auxiliary class used to bind policyRules to an
                      appropriate container object.
     DERIVED FROM     top
     TYPE             auxiliary
     AUXILIARY CLASSES    none
     OID              <to be assigned>
     MUST             policyRulesAuxContainedSet

 5.13.1. The Attribute policyRulesAuxContainedSet

   This attribute provides an unordered set of DN pointers to one or more
   policyRules associated with the instance of a structural class to
   which this attribute has been appended.  The attribute definition is:

     NAME             policyRulesAuxContainedSet
     DESCRIPTION      Distinguished names of policyRules associated in
                      some way with the instance to which this attribute
                      has been appended.  No order is implied.
     SYNTAX           DN
     OID              <to be assigned>
     EQUALITY         distinguishedNameMatch
     MULTI-VALUED




 6. Extending the Core Schema

   The following subsections provide general guidance on how to create a
   domain-specific schema derived from the Core Schema, discuss how the
   vendor classes in the Core Schema should be used, and explain how
   policyTimePeriodConditions are related to other policy conditions.

 6.1. Subclassing policyCondition and policyAction

   In Section 4.3 above, there is a discussion of how, by representing
   policy conditions and policy actions as auxiliary classes in a schema,


 Strassner, et. al.     Expires: December 25, 1999             [Page 27]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   the flexibility is retained to instantiate a particular policy as
   either a simple policy rule or a complex one.  This flexibility is
   lost if a schema takes either of two "hard-coded" paths:

   o If the schema subclasses policyRule to add domain-specific
     characteristics that implicitly express a policy condition, a
     policy action, or both, then the schema supports only the simple
     policy rule form.

   o If the schema introduces structural subclasses of policyCondition,
     policyAction, or both, then the schema supports only the complex
     policy rule form.

   Even if the authors of a domain-specific schema can only envision one
   of these forms of policy rules being used when the schema is
   instantiated, it costs nothing extra to express the schema as
   auxiliary subclasses of policyCondition and policyAction.  For
   standardized schemata, this document specifies that domain-specific
   information MUST be expressed in auxiliary subclasses of
   policyCondition and policyAction.  It is RECOMMENDED that non-
   standardized schemata follow this practice as well.

 6.2. Using the Vendor Policy Encoding Attributes

   As discussed Section 5.6 "The Class vendorPolicyCondition", the
   attributes vendorPolicyConstraintData and
   vendorPolicyConstraintEncoding are included in the
   vendorPolicyCondition to provide an escape mechanism for representing
   "exceptional" policy conditions.  The attributes
   vendorPolicyActionData and vendorPolicyActionEncoding in the
   vendorPolicyAction class play the same role with respect to actions.
   This enables interoperability between different vendors.

   For example, imagine a network composed of access devices from vendor
   A, edge and core devices from vendor B, and a policy server from
   vendor C.  It is desirable for this policy server to be able to
   configure and manage all of the devices from vendors A and B.
   Unfortunately, these devices will in general have little in common
   (e.g., different mechanisms, different ways for controlling those
   mechanisms, different operating systems, different commands, and so
   forth).  The escape conditions provide a way for vendor-specific
   commands to be encoded as OctetStrings, so that devices from different
   vendors can be commonly managed by a single policy server.

 6.3. Using Time Validity Periods

   Time validity periods are defined as a subclass of policyCondition,
   called policyTimePeriodCondition.  This is to allow their inclusion in
   the AND/OR condition definitions for a policyRule.  Care should be
   taken not to subclass policyTimePeriodCondition to add domain-specific
   condition properties.  For example, it would be incorrect to add
   IPSec- or QoS-specific condition properties to the


 Strassner, et. al.     Expires: December 25, 1999             [Page 28]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   policyTimePeriodCondition class, just because IPSec or QoS includes
   time in its condition definition. The correct subclassing would be to
   create IPSec or QoS-specific subclasses of policyCondition and then
   combine instances of these domain-specific condition classes with the
   validity period criteria. This is accomplished using the AND/OR
   aggregation capabilities for policyConditions in policyRules.


 7. Security Considerations

   o General:  See reference [10].

   o Users:  See reference [10].

   o Administrators of Schema:  In general, most LDAP-accessible
      directories do not permit old or out-of-date schemas, or schema
      elements to be deleted.  Instead, they are rendered inactive.  This
      makes it that much more important to get it right the first time on
      an operational system, in order to avoid complex inactive schema
      artifacts from lying about in the operational directory.  The good
      news is that it is expected that large network operators will
      change schema design infrequently, and, when they do, the schema
      creation changes will be tested on an off-line copy of the
      directory before the operational directory is updated.  Typically,
      a small group of directory schema administrators will be authorized
      to make these changes in a service provider or enterprise
      environment.  The ability to maintain audit trails is also required
      here.

   o Administrators of Schema Content (Directory Entries): This group
      requires authorization to load values (entries) into a policy
      repository  directory schema, i.e. read/write access.  An audit
      trail capability is also required here.

   o Applications and PDPs:  These entities must be authorized for read-
      only access to the policy repository directory, so that they may
      acquire policy for the purposes of passing it to their respective
      enforcement entities.

   o Security Disciplines:

     o Audit Trail (Non-repudiation):  In general, standardizing
        mechanisms for non-repudiation is outside the scope of the IETF;
        however, we can certainly document the need for this function in
        systems which maintain and distribute policy.  The dependency for
        support of this function is on the implementers of these systems,
        and not on any specific standards for implementation.  The
        requirement for a policy system is that a minimum level of
        auditing via an auditing facility must be provided.  Logging
        should be enabled.  This working group will not specify what this
        minimal auditing function consists of.



 Strassner, et. al.     Expires: December 25, 1999             [Page 29]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


     o Access Control/Authorization:  Access Control List (ACL)
        functionality must be provided.  Standards for directories which
        use LDAPv3 as an access mechanism are still being worked on in
        the LDAPext working group, as of this writing.  The two
        administrative sets of users documented above will form the basis
        for two administrative use cases which require support.

     o Authentication:  In the LDAP-accessible directory case, both TLS
        and Kerboros are acceptable for authentication.  Existing LDAP
        implementations provide these functions within the context of the
        BIND request, which is adequate.  We advise against using weaker
        mechanisms, such as clear text and HTTP Digest.  Mutual
        authentication is recommended.  The LDAPv3 protocol supports
        this, but implementations vary in the functionality that they
        support.

      o Integrity/Privacy:  In the LDAP-accessible directory case, TLS
        is acceptable for encryption and data integrity on the wire.  If
        physical or virtual access to the policy repository is in
        question, it may also be necessary to encrypt the policy data as
        it is stored on the file system; however, specification of
        mechanisms for this purpose are outside the scope of this
        working group.  In any case, we recommend that the physical
        server be located in a physically secure environment.

      In the case of PDP-to-PEP communications, the use of IPSEC is
      recommended for providing confidentiality, data origin
      authentication, integrity and replay prevention.  See [RAPFRAME]
      reference.

   o Denial of Service:  We recommend the use of multiple policy
      repository directories, such that a denial of service attack on any
      one directory server  will not make all policy data inaccessible to
      legitimate users.  However, this still leaves a denial of service
      attack exposure.  Our belief is that the use of a policy schema, in
      a centrally administered but physically distributed policy
      directory, does not increase the risk of denial of service attacks;
      however, such attacks are still possible.  If executed
      successfully, such an attack could prevent PDPs from accessing a
      policy repository, and thus prevent them from acquiring new policy.
      In such a case, the
      PDPs, and associated PEPs would continue operating under the
      policies in force before the denial of service attack was launched.
      Note that exposure of policy systems to denial of service attacks
      is not any greater than the exposure of DNS with DNSSEC in place.

   o Other LDAP-accessible Directory Schema Considerations:

      o Replication:  Replication among directory copies across servers
        should also be protected.  Replicating over connections secured
        by SSL or IPSEC is recommended.



 Strassner, et. al.     Expires: December 25, 1999             [Page 30]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


 8. Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   intellectual property or other rights that might be claimed to pertain
   to the implementation or use of the technology described in this
   document or the extent to which any license under such rights might or
   might not be available; neither does it represent that it has made any
   effort to identify any such rights.  Information on the IETF's
   procedures with respect to rights in standards-track and standards-
   related documentation can be found in BCP-11.

   Copies of claims of rights made available for publication and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this specification
   can be obtained from the IETF Secretariat.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights which may cover technology that may be required to practice
   this standard.  Please address the information to the IETF Executive
   Director.


 9. Acknowledgments

   This document is closely aligned with the work being done in the
   Distributed Management Task Force (DMTF) Service Level Agreements and
   Networks working groups.  As noted, the Core Schema described here was
   initially defined in references [2] and [3]. We would especially like
   to thank Raju Rajan, Sanjay Kamat, Andrea Westerinen, Lee Rafalow, Raj
   Yavatkar, Glenn Waters, David Black, Michael Richardson, Mark Stevens,
   David Jones, and Hugh Mahon for their helpful comments.


 10. References

 [1]  J. Strassner and E. Ellesson, "Terminology for describing network
      policy and services", draft-strassner-policy-terms-02.txt, June
      1999.

 [2]  Bhattacharya, P., and R. Adams, W. Dixon, R. Pereira, R. Rajan, "An
      LDAP Schema for Configuration and Administration of IPSec based
      Virtual Private Networks (VPNs)", Internet-Draft work in progress,
      October 1998

 [3]  Rajan, R., and J. C. Martin, S. Kamat, M. See, R. Chaudhury, D.
      Verma, G. Powers, R. Yavatkar, "Schema for Differentiated Services
      and Integrated Services in Networks", Internet-Draft work in
      progress, October 1998




 Strassner, et. al.     Expires: December 25, 1999             [Page 31]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


 [4]  J. Strassner and S. Judd, "Directory-Enabled Networks", version
      3.0c5 (August 1998).

 [5]  Bradner, S., "Key words for use in RFCs to Indicate Requirement
      Levels", BCP 14, RFC 2119, March 1997.

 [6]  Hovey, R., and S. Bradner, "The Organizations Involved in the IETF
      Standards Process", BCP 11, RFC 2028, October 1996.

 [7]  Wahl, M., and S. Kille, T. Howes, "Lightweight Directory Access
      Protocol (v3):  UTF-8 String Representation of Distinguished
      Names", RFC 2253, December 1997.

 [8]  J. Strassner, policy architecture BOF presentation, 42nd IETF
      Meeting, Chicago, Illinois, October, 1998

 [9]  DMTF web site, http://www.dmtf.org.

 [10] Moore B., and E. Ellesson, J. Strassner, "Policy Framework Core
      Information Model", draft-ietf-policy-core-info-model-00.txt, June
      1999.


 11. Authors' Addresses

   John Strassner
       Cisco Systems, Bldg 1
       170 West Tasman Drive
       San Jose, CA 95134
       Phone:   +1 408-527-1069
       Fax:     +1 408-527-1722
       E-mail:  johns@cisco.com

   Ed Ellesson
      IBM Corporation, JDGA/501
      4205 S. Miami Blvd.
      Research Triangle Park, NC 27709
      Phone:   +1 919-254-4115
      Fax:     +1 919-254-6243
      E-mail:  ellesson@raleigh.ibm.com

   Bob Moore
      IBM Corporation, JDGA/501
      4205 S. Miami Blvd.
      Research Triangle Park, NC 27709
      Phone:   +1 919-254-4436
      Fax:     +1 919-254-6243
      E-mail:  remoore@us.ibm.com

 12. Full Copyright Statement

   Copyright (C) The Internet Society (1999).  All Rights Reserved.


 Strassner, et. al.     Expires: December 25, 1999             [Page 32]

 Internet Draft    draft-ietf-policy-core-schema-04.txt        June 1999


   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published and
   distributed, in whole or in part, without restriction of any kind,
   provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of developing
   Internet standards in which case the procedures for copyrights defined
   in the Internet Standards process must be followed, or as required to
   translate it into languages other than English.

   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT
   NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN
   WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.
































 Strassner, et. al.     Expires: December 25, 1999             [Page 33]
