<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head profile="http://dublincore.org/documents/2008/08/04/dc-html/">
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <meta name="robots" content="index,follow" />

        <link rel="icon" href="./css/images/rfc.png" type="image/png" />
        <link rel="shortcut icon" href="./css/images/rfc.png" type="image/png" />
        <title>rfc3981</title>
    
        <link rel="stylesheet" type="text/css" href="./css/errata-base.css"/>
        <link rel="stylesheet" type="text/css" href="./css/errata-color.css" title="Default: Basic Colors"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-monochrome.css" title="Monochrome"/>
        <link rel="alternative stylesheet" type="text/css" href="./css/errata-printer.css" title="Printer"/>

        <script src="./css/errata.js"></script>
    </head>
    <body>
        <div class='Verified-headnote-styling'>
<span style="font-weight: bold;">This is a purely informative rendering of an RFC that includes verified errata.  This rendering may not be used as a reference.</span>
<br/>
<br/>
The following 'Verified' errata have been incorporated in this document:
 <a href='#eid199'>EID 199</a>
</div>

        <pre>
Network Working Group                                          A. Newton
Request for Comments: 3981                                VeriSign, Inc.
Category: Standards Track                                        M. Sanz
                                                                DENIC eG
                                                            January 2005


  IRIS: The Internet Registry Information Service (IRIS) Core Protocol

Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (2005).

Abstract

   This document describes an application layer client-server protocol
   for a framework to represent the query and result operations of the
   information services of Internet registries.  Specified in the
   Extensible Markup Language (XML), the protocol defines generic query
   and result operations and a mechanism for extending these operations
   for specific registry service needs.

Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  2
       1.1.  Use of XML . . . . . . . . . . . . . . . . . . . . . . .  2
       1.2.  General Concepts . . . . . . . . . . . . . . . . . . . .  3
       1.3.  Framework Layers . . . . . . . . . . . . . . . . . . . .  4
       1.4.  Definitions  . . . . . . . . . . . . . . . . . . . . . .  4
       1.5.  Further Reading  . . . . . . . . . . . . . . . . . . . .  5
   2.  Document Terminology . . . . . . . . . . . . . . . . . . . . .  5
   3.  Protocol Identification  . . . . . . . . . . . . . . . . . . .  5
   4.  Exchange Description . . . . . . . . . . . . . . . . . . . . .  6
       4.1.  Request Format . . . . . . . . . . . . . . . . . . . . .  6
       4.2.  Response Format  . . . . . . . . . . . . . . . . . . . .  6
       4.3.  Extension Framework  . . . . . . . . . . . . . . . . . .  9
             4.3.1.  Derived Elements . . . . . . . . . . . . . . . .  9
             4.3.2.  Registry Type Identifier Requirements  . . . . . 10
             4.3.3.  Entity Classes . . . . . . . . . . . . . . . . . 10
             4.3.4.  Names of Entities  . . . . . . . . . . . . . . . 11

             4.3.5.  References to Entities . . . . . . . . . . . . . 11
             4.3.6.  Temporary Entities . . . . . . . . . . . . . . . 12
             4.3.7.  &lt;result&gt; Derived Elements  . . . . . . . . . . . 13
             4.3.8.  &lt;control&gt; and &lt;reaction&gt; Elements  . . . . . . . 16
       4.4.  Relay Bags . . . . . . . . . . . . . . . . . . . . . . . 18
   5.  Database Serialization . . . . . . . . . . . . . . . . . . . . 19
   6.  Formal XML Syntax  . . . . . . . . . . . . . . . . . . . . . . 22
   7.  The IRIS URI . . . . . . . . . . . . . . . . . . . . . . . . . 37
       7.1.  URI Definition . . . . . . . . . . . . . . . . . . . . . 37
       7.2.  Transport Specific Schemes . . . . . . . . . . . . . . . 38
       7.3.  URI Resolution . . . . . . . . . . . . . . . . . . . . . 38
             7.3.1.  Registry Dependent Resolution  . . . . . . . . . 38
             7.3.2.  Direct Resolution  . . . . . . . . . . . . . . . 39
             7.3.3.  Transport and Service Location . . . . . . . . . 39
       7.4.  IRIS URI Examples  . . . . . . . . . . . . . . . . . . . 40
   8.  Checklists . . . . . . . . . . . . . . . . . . . . . . . . . . 41
       8.1.  Registry Definition Checklist  . . . . . . . . . . . . . 41
       8.2.  Transport Mapping Checklist  . . . . . . . . . . . . . . 42
   9.  Internationalization Considerations  . . . . . . . . . . . . . 42
   10. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 43
   11. Security Considerations  . . . . . . . . . . . . . . . . . . . 43
   12. References . . . . . . . . . . . . . . . . . . . . . . . . . . 43
       12.1. Normative References . . . . . . . . . . . . . . . . . . 43
       12.2. Informative References . . . . . . . . . . . . . . . . . 45
   A.  S-NAPTR and IRIS Uses  . . . . . . . . . . . . . . . . . . . . 46
       A.1.  Examples of S-NAPTR with IRIS. . . . . . . . . . . . . . 46
       A.2.  Using S-NAPTR for Cohabitation . . . . . . . . . . . . . 47
   B.  IRIS Design Philosophy . . . . . . . . . . . . . . . . . . . . 48
       B.1.  The Basic Premise  . . . . . . . . . . . . . . . . . . . 48
       B.2.  The Lure of a Universal Client . . . . . . . . . . . . . 49
       B.3.  Server Considerations  . . . . . . . . . . . . . . . . . 49
       B.4.  Lookups, Searches, and Entity Classes  . . . . . . . . . 50
       B.5.  Entities References, Search Continuations, and Scope . . 50
   C.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 51
   Authors&#x27; Addresses . . . . . . . . . . . . . . . . . . . . . . . . 51
   Full Copyright Statement . . . . . . . . . . . . . . . . . . . . . 52

1.  Introduction

   The specification outlined in this document is based on the
   functional requirements described in CRISP [17].

1.1.  Use of XML

   This document describes the specification for the Internet Registry
   Information Service (IRIS), an XML text protocol intended to describe
   the query types and result types of various registry information
   services.  IRIS is specified by using the Extensible Markup Language

   (XML) 1.0 as described in [2], XML Schema notation as described in
   [4] and [5], and XML Namespaces as described in [3].

1.2.  General Concepts

   Each kind of Internet registry is identified by a registry type.  The
   identifier for a registry type is a Uniform Resource Name (URN) used
   within the XML instances to identify the XML schema that formally
   describes the set of queries, results, and entity classes allowed
   within that type of registry.

   The structure of these URNs makes no assumptions or restrictions on
   the types of registries they identify.  Therefore, IRIS may support
   multiple registry types of a disparate or similar nature; it is only
   a matter of definition.  For instance, a single registry type may be
   defined for domain name registries, and multiple registry types for
   the various IP address registries.

   A registry information server may handle queries and serve results
   for multiple registry types.  Each registry type that a particular
   registry operator serves is a registry service instance.

   IRIS and the XML schema formally describing IRIS do not specify any
   registry, registry identifier, or knowledge of a particular service
   instance or set of instances.  IRIS is a specification for a
   framework with which these registries can be defined, used and, in
   some cases, interoperate.  The framework merely specifies the
   elements for registry identification and the elements that must be
   used to derive queries and results.

   This framework allows a registry type to define its own structure for
   naming, entities, queries, etc., through the use of XML namespaces
   and XML schemas (hence, a registry type MUST be identified by the
   same URI that identifies its XML namespace).  To be compliant, a
   registry type&#x27;s specification must extend from this framework.

   The framework defines certain structures that can be common to all
   registry types, such as references to entities, search continuations,
   and entity classes.  A registry type may declare its own definitions
   for all of these, or it may mix its derived definitions with the base
   definitions.

   IRIS defines two types of referrals: an entity reference and a search
   continuation.  An entity reference indicates specific knowledge about
   an individual entity, and a search continuation allows distributed
   searches.  Both referrals may span differing registry types and
   instances.  No assumptions or specifications are made about the
   roots, bases, or meshes of entities.

1.3.  Framework Layers

   The IRIS framework can be thought of as having three layers.

                             -----------------------------
          Registry-Specific  |domain | address  | etc... |
                             -----------------------------
            Common-Registry  |          IRIS             |
                             -----------------------------
      Application-Transport  | beep  | iris-lwz | etc... |
                             -----------------------------

   In this figure, &quot;beep&quot; refers to the Blocks Extensible Exchange
   Protocol (BEEP) (see [20]), and &quot;iris-lwz&quot; refers to a theoretical
   UDP binding that uses compression.

   The differing layers have the following responsibilities:

      Registry-Specific :: defines queries, results, and entity classes
      of a specific type of registry.  Each specific type of registry is
      identified by a URN.
      Common-Registry :: defines base operations and semantics common to
      all registry types such as search sets, result sets, and
      referrals.  It also defines the syntaxes for talking about
      specific registry types.
      Application-Transport :: defines the mechanisms for
      authentication, message passing, connection and session
      management, etc.  It also defines the URI syntax specific to the
      application-transport mechanism.

1.4.  Definitions

   For clarity, the following definitions are supplied:

   o  registry type -- A registry serving a specific function, such as a
      domain registry or an address registry.  Each type of registry is
      assigned a URN.

   o  registry schema -- The definition for a registry type specifying
      the queries, results, and entity classes.

   o  authority -- A reference to the server or set of servers
      containing information.

   o  resolution method -- The technique used to locate an authority.

   o  entity class -- A group of entities with a common type or common
      set of characteristics.

   o  entity name -- The identifier used to refer to a single entity
      within an entity class.

   o  entity reference -- A pointer to an entity composed of an
      authority, an optional resolution method, a registry type, an
      entity class, and an entity name.  One type of entity reference is
      the IRIS URI (defined in Section 7).

   The terms &quot;derivative&quot;, &quot;derive&quot;, and &quot;derivation&quot; are used with the
   same meaning for deriving one type of element from another as
   specified in XML_SS [5].

1.5.  Further Reading

   Appendix B contains text answering the question, &quot;Why IRIS?&quot;.

   This document describes the structure at the core of IRIS.  The
   following documents describe the other aspects of IRIS relevant to
   CRISP [17]: iris-beep [1] and iris-dreg [18].

2.  Document Terminology

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in BCP 14, RFC 2119 [8].

3.  Protocol Identification

   The root element of all request XML instances MUST be &lt;request&gt;.  The
   root element of all response XML instances MUST be &lt;response&gt;.  These
   elements identify the start of the IRIS elements, the XML namespace
   used as the identifier for IRIS, and, optionally, the location of the
   schema.  These elements and the associated closing tag MUST be
   applied to all requests and responses sent by both clients and
   servers.

   The use of the schema location attribute &#x27;xsi:schemaLocation&#x27; is
   OPTIONAL with respect to this specification, and IRIS implementations
   MAY resolve it to retrieve the schema or MAY use a locally cached
   version of the schema.

   Versioning of the IRIS protocol is the responsibility of the
   application-transport layer but MUST be associated with the XML
   namespace [3] URI representing IRIS.  A change in this URI indicates
   a change of the underlying schema and, therefore, a new version of
   the protocol (and vice versa).

4.  Exchange Description

   This section describes the request and response exchanges of the
   protocol.  The descriptions contained within this section refer to
   XML elements and attributes and their relation to the exchange of
   data within the protocol.  These descriptions also contain
   specifications outside the scope of the formal XML syntax.
   Therefore, this section will use terms defined by RFC 2119 [8] to
   describe the specification outside the scope of the formal XML
   syntax.  While reading this section, please reference Section 6 for
   details on the formal XML syntax.

4.1.  Request Format

   A &lt;request&gt; element contains an optional &lt;control&gt; element and a set
   of &lt;searchSet&gt; elements.

   The &lt;searchSet&gt; elements enable a client to query a particular
   registry type by using the URN identifying the registry type.  This
   can be found in one of its two children: &lt;lookupEntity&gt; and &lt;query&gt;.

   The &lt;lookupEntity&gt; element describes the lookup of an entity in a
   specific registry.  This element has three attributes:
   &#x27;registryType&#x27;, &#x27;entityClass&#x27;, and &#x27;entityName&#x27;.  The &#x27;registryType&#x27;
   attribute contains the registry identifier for the registry type in
   which the lookup operation will take place.  The &#x27;entityClass&#x27;
   attribute contains the token identifying the index for which the
   lookup operation will take place, and the &#x27;entityName&#x27; attribute
   contains the name of the entity to look up.

   The &lt;query&gt; element is abstract and may not legally appear in an XML
   instance.  It provides the base type that registry schemas will use
   to define derived query types.  This derivation mechanism is
   described in Section 4.3.

   Each &lt;searchSet&gt; may also contain a &lt;bag&gt; element.  When this element
   appears as a child of &lt;searchSet&gt;, it MUST NOT contain the &#x27;id&#x27;
   attribute.  For a description of the &lt;bag&gt; element, see Section 4.4.

   The &lt;control&gt; element may contain one child element of any XML
   namespace.  This child element allows a client to signal a server for
   special states or processing.  An example of one such &lt;control&gt; child
   element may be found in Section 4.3.8.

4.2.  Response Format

   The &lt;response&gt; element contains an optional &lt;reaction&gt; element, a set
   of &lt;resultSet&gt; elements, and an optional &lt;bags&gt; element.

   The &lt;resultSet&gt; elements are responses to a &lt;searchSet&gt; request.  The
   contents of this element contain an &lt;answer&gt; element, an optional
   &lt;additional&gt; element, and error elements, if applicable.

   The children of the &lt;answer&gt; element are of the following types:

   o  &lt;result&gt; is an abstract element and may not be legally placed in
      an XML instance.  It provides the base type to be used by registry
      schemas to define derived result types.  This derivation mechanism
      is described in Section 4.3.

   o  &lt;entity&gt; is an element specifying an entity reference.  See
      Section 4.3.5.

   o  The &lt;searchContinuation&gt; element specifies a query referral.  Its
      one child is any element derived from &lt;query&gt; (see Section 4.3.1).
      To direct the query to a referent server, &lt;searchContinuation&gt; has
      a mandatory &#x27;authority&#x27; attribute and an optional &#x27;resolution&#x27;
      attribute.  The &lt;searchContinuation&gt; element may also contain a
      &#x27;bagRef&#x27; attribute.  For a description of the &#x27;bagRef&#x27; attribute,
      see Section 4.4.

   When following entity references and search continuations, clients
   SHOULD only follow an &lt;entity&gt; or &lt;searchContinuation&gt; response once.
   Failure to do so may result in the client process getting stuck in a
   never-ending query loop, commonly known as a referral loop.

   The &lt;additional&gt; element only contains &lt;result&gt; elements, as
   described above.  This element allows a server to indicate to a
   client results that were not specifically queried but that are
   related to the queried results, thus enabling the client to display
   this distinction to a user properly.  The &lt;additional&gt; element use is
   optional.

   The following elements, which represent error conditions, may be
   returned:

   o  &lt;insufficientResources&gt; -- The corresponding query requires
      resources unobtainable by the server.

   o  &lt;invalidName&gt; -- A name given in a query is not syntactically
      correct.

   o  &lt;invalidSearch&gt; -- Parameters of the corresponding query are not
      semantically meaningful.

   o  &lt;queryNotSupported&gt; -- The corresponding query is not supported by
      this server.

   o  &lt;limitExceeded&gt; -- The corresponding query requires more resources
      than allowed.

   o  &lt;nameNotFound&gt; -- The name given in a query does not match a known
      entity.

   o  &lt;permissionDenied&gt; -- The authentication given does not allow
      access to a specific result entry.

   o  &lt;bagUnrecognized&gt; -- The contents of a bag were unrecognized.  See
      Section 4.4.

   o  &lt;bagUnacceptable&gt; -- The contents of a bag were not and never will
      be acceptable.  See Section 4.4.

   o  &lt;bagRefused&gt; -- The contents of a bag were not acceptable at this
      time.  See Section 4.4.

   o  A derivative of &lt;genericCode&gt;, as described in Section 4.3.

   The &lt;resultSet&gt; section is divided into the &lt;answer&gt; and &lt;additional&gt;
   sections to allow easier processing and navigation of the results by
   a client.  Servers MUST return the direct answers to queries in the
   &lt;answer&gt; element and MAY return results in the &lt;additional&gt; element
   for which a reference has been made in the &lt;answer&gt; element.  Results
   in the &lt;additional&gt; element MUST have been referenced in the
   &lt;answer&gt;, either as direct children of the &lt;answer&gt; element or as
   deeper descendants of the &lt;answer&gt; element.

   This serves two purposes.  First, it may eliminate a requery by the
   client for references contained in the &lt;answer&gt; element.  Second, it
   distinguishes between results that are a direct result of a query and
   those that would have been returned had the client followed the
   appropriate referrals, thus hinting how clients could process or
   display the returned results.  For instance, clients constructing
   complex displays with tree navigation widgets will know that results
   in the &lt;answer&gt; element should all be directly beneath the root node
   of the tree, while results in the &lt;additional&gt; element are leaf nodes
   of those produced from the &lt;answer&gt; element.

   A &lt;reaction&gt; element (child of &lt;response&gt;) is a response to a
   &lt;control&gt; element, and provides a means for a server to advise a
   client of the effect of a &lt;control&gt; element.

   The &lt;bags&gt; element (child of &lt;response&gt;) is optional.  It contains
   &lt;bag&gt; elements, and the contents of each &lt;bag&gt; element constitute one
   element in any XML namespace.  Each &lt;bag&gt; element has an &#x27;id&#x27;
   attribute, which is referenced by the &#x27;bagRef&#x27; attribute of entity

   references (&lt;entity&gt;) and search continuations
   (&lt;searchContinuation&gt;).  See Section 4.4.

4.3.  Extension Framework

   Because the IRIS schema defines only one query type, and two stand-
   alone result types, and does not define a registry structure, it is
   of limited use by itself.  Extension of IRIS is accomplished through
   the use of a base IRIS schema, as defined in XML_SD [4] and XML_SS
   [5], and through extension of it by schemas constructed on top of
   IRIS.

4.3.1.  Derived Elements

   The XML Schema definition of IRIS requires schemas of registry types
   to derive element types from base types in the IRIS definition.  The
   registry schemas MUST derive elements to define typed queries and
   results.

   While the IRIS schema definition does not prohibit the derivation of
   any elements, registry schemas SHOULD restrict the derivations to the
   following types:

   o  &lt;query&gt; -- As defined, this element contains no content and has no
      valid attributes.  It is abstract and therefore only its
      derivatives appear in XML instances.  Registry schemas derive from
      this element to define the queries allowed.

   o  &lt;result&gt; -- As defined, this element contains no content and has
      five valid attributes: &#x27;authority&#x27;, &#x27;resolution&#x27; (optional),
      &#x27;registryType&#x27;, &#x27;entityClass&#x27;, &#x27;entityName&#x27;, and
      &#x27;temporaryReference&#x27; (optional, see Section 4.3.6).  It is
      abstract and therefore only its derivatives appear in XML
      instances.  Registry schemas derive from this element to define
      results that may be returned from a query.

   o  &lt;genericCode&gt; -- As defined, this element is an instance of
      &lt;codeType&gt;.  It contains the optional elements &lt;explanation&gt; and
      &lt;language&gt;, which further describe the nature of the error.

   o  &lt;entity&gt; -- Identifies a reference to an entity.  Registry schemas
      SHOULD use elements derived from &lt;entity&gt; but MAY use &lt;entity&gt;
      directly.  The advantage of deriving from &lt;entity&gt; vs. direct use
      is the chance to define the name of the element and to use that
      name descriptively -- for instance, as the role the entity plays
      with respect to another entity.  See Section 4.3.5.

   o  &lt;seeAlso&gt; -- Indicates a reference to an entity that has indirect
      association with a parent element representing an entity.  This
      element is derived from the &lt;entity&gt; element (Section 4.3.5).
      Registry schemas MAY derive from this element or MAY use it
      directly.

4.3.2.  Registry Type Identifier Requirements

   The identifier for a registry type and the XML namespace identifier
   used by the XML Schema describing the registry MUST be the same.
   These identifiers MUST be restricted to a URN [7] registered in the
   &#x27;ns&#x27; class of the IANA registry governed by XML_URN [9].  These
   identifiers are case insensitive.

   This is a restriction on XML_NS [3], which specifies that an XML
   namespace identifier is any valid URI [6].

   These identifiers MAY be abbreviated to the part following the class
   component and its separator of the URN.  For example, the full URN
   &quot;urn:ietf:params:xml:ns:dreg1&quot; may be abbreviated to &quot;dreg1&quot;.

   In use with IRIS, this abbreviation MUST NOT be used inside of XML
   instances in which the XML Schema [4] specifies the use of a URI for
   schema identification or where XML_NS [3] specifies the use of a URI
   for XML namespace identification.

4.3.3.  Entity Classes

   IRIS provides entity classes to help avoid collisions with entity
   names within any given registry type.  Their specification in queries
   also allows server implementations to narrow search or lookup scopes
   quickly to a single index.

   For instance, the entity name &quot;192.0.2.0&quot; might refer to separate
   entities in the &quot;name-server&quot; and &quot;network&quot; classes.  The entity
   &quot;192.0.2.0&quot; in the &quot;name-server&quot; class may refer to the name server
   host that is also multi-homed by address 192.0.2.255 and known in DNS
   as &quot;ns.example.com&quot;, whereas the entity &quot;192.0.2.0&quot; in the &quot;network&quot;
   class may refer to the network 192.0.2/30.

   IRIS defines two default entity classes of &quot;local&quot; and &quot;iris&quot;, which
   MUST NOT be redefined.  These entity classes MUST be valid in all
   registry types.

   The &quot;local&quot; class is reserved for entities defined locally by a
   server operator and does not denote any particular type of entity.  A
   lookup in this entity class MAY result in an entity reference or
   search continuation.  For example, &quot;iris:dreg1//example.com/local/

   myhosts&quot; may result in a search continuation yielding the nameservers
   for example.com.

   The &quot;iris&quot; class is reserved for entities specific to a particular
   service instance.  It MUST contain the following entity names (see
   Section 4.3.4):

   o  &quot;id&quot;, which yields a result of &lt;serviceIdentification&gt; (see
      Section 4.3.7.1).

   o  &quot;limits&quot;, which yields a result of &lt;limits&gt; (see Section 4.3.7.2).
      This entity class MAY contain other locally defined entities as
      well.

   The names of entity classes in a registry schema are of type token,
   as defined by XML_SD [4].  Their case sensitivity MUST be defined by
   the definition of the registry type.  In general, they SHOULD be case
   insensitive.

4.3.4.  Names of Entities

   The names of entities in a registry schema are of type token, as
   defined by XML_SD [4].

   Names of entities SHOULD be unique within an instance of any
   particular entity class within a registry.  Two entities SHOULD NOT
   have the same name, but a single entity MAY be known by multiple
   names.  In situations where a single name may result in two entities,
   the registry schema SHOULD make allowances by defining result types
   that contain entity references to both entities (e.g., &quot;example.com&quot;
   can refer to both the domain example.com and the host example.com).
   However, this type of conflict SHOULD generally be avoided by the
   proper use of entity classes.

   The case sensitivity of entity names is dependent on the entity class
   in which they reside.  The definition of a registry type MUST specify
   the case sensitivity for entity names.  A registry type MAY define
   the entity names of differing entity classes as having different case
   sensitivity.

4.3.5.  References to Entities

   The element &lt;entity&gt; allows references to entities in result sets,
   either as a direct child of &lt;resultSet&gt; or within a more complex
   structure deriving from &lt;result&gt;.  The &lt;entity&gt; element is defined by
   &#x27;entityType&#x27;.  Registry schemas SHOULD define elements derived from
   &lt;entity&gt; when referencing entities but may use the &lt;entity&gt; element
   directly.  Deriving a new element allows a registry schema to use the

   name of the new element to signify the relationship the referenced
   entity has with the referrer.  A derivative of &lt;entity&gt; MUST NOT be
   used as a substitute when the &lt;entity&gt; element is declared (such as
   in the &lt;answer&gt; section of the &lt;resultSet&gt;).

   The &lt;entity&gt; element (and elements of type &#x27;entityType&#x27;) can have
   child elements of &lt;displayName&gt; with an optional &#x27;language&#x27;
   attribute.  These are provided so that servers may provide clients
   with a more human-friendly description of the entity reference.  This
   is often useful to users navigating referral structures.

   The &lt;entity&gt; element (and its derivations) have the following
   attributes:

   o  &#x27;authority&#x27;, &#x27;resolution&#x27; (optional), &#x27;registryType&#x27;,
      &#x27;entityClass&#x27;, and &#x27;entityName&#x27; -- These attributes specify where
      the entity may be found.

   o  &#x27;temporaryReference&#x27; -- This attribute is optional.  See Section
      4.3.6.

   o  &#x27;referentType&#x27; -- This attribute contains the expected type of the
      entity being referenced and may contain the word &quot;ANY&quot; or a
      qualified XML name.  Unlike the other attributes of &lt;entity&gt;, this
      attribute is qualified and declared in the IRIS XML namespace.
      Therefore it will also be qualified with the prefix associated
      with the IRIS XML namespace (e.g., &#x27;iris:referentType&#x27;).  This
      allows clients to recognize entity references using an element
      derived from &lt;entity&gt;.

   o  &#x27;bagRef&#x27; -- This attribute is optional.  If present, it must
      contain an XML identifier to a &lt;bag&gt; element in the &lt;bags&gt; section
      of the result set.  For a description of the &#x27;bagRef&#x27; attribute,
      see Section 4.4.

4.3.6.  Temporary Entities

   Instances may exist in which an entity reference needs to be
   temporary.  For example, a particular type of result may only have
   one unique key.  If that key contains semantic meaning that may not
   be exposed to all users, a synthetic key will have to be substituted.

   Furthermore, there may be times when data in the data store is not
   normalized in the same manner as that expressed by the registry
   schema.  In the registry schema, objects of type A may reference
   objects of type B.  But in the data store, objects of type A may
   contain objects of type B.  Again, a synthetic key will have to be
   temporarily produced.

   To support such use cases, results and entity references can be
   declared temporary by using the &#x27;temporaryReference&#x27; attribute.  This
   attribute is of type boolean [4] and has a default value of &quot;false&quot;.
   It is optional for &lt;result&gt; derivatives and elements of type
   &#x27;entityType&#x27;.

   When this attribute is used, the entity reference data (e.g.,
   &#x27;entityClass&#x27;, &#x27;entityName&#x27;) is only valid within the response in
   which it appears and may not be consistent with subsequent responses.
   A server MUST include the referent of any temporary entity reference
   in the &lt;additional&gt; section of the same &lt;resultSet&gt;

4.3.7.  &lt;result&gt; Derived Elements

   The base IRIS framework contains three elements directly derived from
   the &lt;result&gt; element for use by any registry type.

4.3.7.1.  &lt;serviceIdentification&gt;

   An example of a &lt;serviceIdentification&gt; result:

   &lt;serviceIdentification
     authority=&quot;example.com&quot; registryType=&quot;dreg1&quot;
     entityClass=&quot;iris&quot;
     entityName=&quot;id&quot; &gt;
     &lt;authorities&gt;
       &lt;authority&gt; example.com &lt;/authority&gt;
       &lt;authority&gt; example.net &lt;/authority&gt;
       &lt;authority&gt; example.org &lt;/authority&gt;
     &lt;/authorities&gt;
     &lt;operatorName&gt;
       Internet Assigned Numbers Authority
     &lt;/operatorName&gt;
     &lt;eMail&gt;
       iana@iana.org
     &lt;/eMail&gt;
   &lt;/serviceIdentification&gt;

   The &lt;serviceIdentification&gt; element is provided to allow IRIS clients
   to reference IRIS service instances.  It contains the following
   elements:

   o  &lt;authorities&gt; -- This element contains one or more &lt;authority&gt;
      elements.  Each &lt;authority&gt; element contains a URI authority
      component for which the server has results.  Although a server MAY
      only return a partial list of its authority areas, depending on
      operator policy, it MUST return the authority for which the client
      has requested.

   o  &lt;operatorName&gt; -- This element contains the name of the operator
      of the server.

   o  &lt;eMail&gt; -- These optional elements contain email addresses of the
      operator of the service instance.

   o  &lt;phone&gt; -- These optional elements contain phone numbers of the
      operator of the service instance.

   o  &lt;seeAlso&gt; -- See Section 4.3.1 for its definition.

4.3.7.2.  &lt;limits&gt;

   An example of a &lt;limits&gt; result:

   &lt;limits
     authority=&quot;example.com&quot; registryType=&quot;dreg1&quot;
     entityClass=&quot;iris&quot; entityName=&quot;limits&quot;&gt;
     &lt;totalQueries&gt;
       &lt;perHour&gt;2&lt;/perHour&gt;
       &lt;perDay&gt;15&lt;/perDay&gt;
     &lt;/totalQueries&gt;
     &lt;totalResults&gt;
       &lt;perHour&gt;25&lt;/perHour&gt;
       &lt;perDay&gt;200&lt;/perDay&gt;
     &lt;/totalResults&gt;
     &lt;totalSessions&gt;
       &lt;perHour&gt;2&lt;/perHour&gt;
       &lt;perDay&gt;15&lt;/perDay&gt;
     &lt;/totalSessions&gt;
   &lt;/limits&gt;

   The &lt;limits&gt; element provides a mechanism allowing a server to inform
   a client of the limits it may encounter from overuse of the service.
   The contents describe the service limitations to a client at the
   current level of access.  The contents of this element are as
   follows:

   o  &lt;totalQueries&gt; -- This element describes the total number of
      queries that the server will accept.  The children of this element
      indicate this number per unit of time.  The children are
      &lt;perSecond&gt;, &lt;perMinute&gt;, &lt;perHour&gt;, and &lt;perDay&gt;.  Each child
      MUST only appear once as a child of &lt;totalQueries&gt;, but more than
      one child MAY be present.  For example, a server could indicate
      that it will accept 15 queries a minute but only 60 queries a day.

   o  &lt;totalResults&gt; -- This element describes the total number of
      results that the server will send to a client.  The children of
      this element indicate this number per unit of time in the same
      manner as &lt;totalQueries&gt;.

   o  &lt;totalSessions&gt; -- This element describes the total number of
      sessions that the server will accept from a client.  The children
      of this element indicate this number per unit of time in the same
      manner as &lt;totalQueries&gt;.  The definition of a session is defined
      the by application transport layer.

   o  &lt;otherRestrictions&gt; -- This element describes other restrictions
      that may only be expressible outside of the structured syntax of
      the other child elements of &lt;limits&gt;.  This element may have
      optional &lt;description&gt; child elements, each with a mandatory
      &#x27;language&#x27; attribute.

   o  &lt;seeAlso&gt; -- These elements are provided to reference other
      entities, such as a &lt;simpleEntity&gt; (Section 4.3.7.3) describing a
      published policy.  See &lt;seeAlso&gt; (Section 4.3.1).

   All of these child elements are optional, and a server may express
   that it has no limits by using a &lt;limits&gt; element with no content
   (e.g., &lt;limits authority=...  /&gt;).

4.3.7.3.  &lt;simpleEntity&gt;

   An example of a &lt;simpleEntity&gt; result:

   &lt;simpleEntity
     authority=&quot;example.com&quot; registryType=&quot;dreg1&quot;
     entityClass=&quot;local&quot;
     entityName=&quot;notice&quot; &gt;
     &lt;property name=&quot;legal&quot; language=&quot;en&quot;&gt;
       Example.com is reserved according to RFC 2606.
     &lt;/property&gt;
   &lt;/simpleEntity&gt;

   The &lt;simpleEntity&gt; element is provided so that service operators may
   make simple additions to other entities without deriving entirely new
   registry types.  Its definition allows service operators to reference
   it from other entities (using, for instance, a &lt;seeAlso&gt; element).
   The &lt;simpleEntity&gt; is meant to represent name and value pairs of
   strings, allowing each pair to be associated with a specific language
   qualifier and an optional URI pointing to more information.

   Clients may easily display such information in a two-column table.
   Applications using binary data or richer data structures are out of
   scope for this element.  When such usage scenarios arise, a client
   will likely need specific knowledge to handle such data, thus calling
   the need for a new registry type into question.

4.3.8.  &lt;control&gt; and &lt;reaction&gt; Elements

   The &lt;control&gt; (Section 4.1) and &lt;reaction&gt; (Section 4.2) elements
   allow the client to request from the server special states for the
   processing of queries.  The intent of these elements is to allow
   extensibility so that some jurisdictions may adopt policies for query
   processing without requiring re-versioning of IRIS or any registry
   type.

   This document defines one control, &lt;onlyCheckPermissions&gt;, and its
   requisite reaction, &lt;standardReaction&gt;, for compliance with CRISP
   [17].

   When a client sends an &lt;onlyCheckPermissions&gt; control, it is only
   asking the server to check to see whether adequate permissions are
   available to execute the queries in the associated request.  A server
   MUST respond to this control with a &lt;standardReaction&gt; element.

   The &lt;standardReaction&gt; element provides a server with a standard
   means to respond to controls (it may be used by other controls, but
   this is left to their definition).  It contains four children:

   o  &lt;controlAccepted&gt; -- the processing or state needed by the control
      has been accepted.

   o  &lt;controlDenied&gt; -- the processing or state needed by the control
      has been denied (a transient failure).

   o  &lt;controlDisabled&gt; -- the processing or state needed by the control
      cannot be activated (a permanent failure).

   o  &lt;controlUnrecognized&gt; -- the control is not recognized (a
      permanent failure).

   If &lt;onlyCheckPermissions&gt; is rejected, then the server MUST return
   all appropriate result sets (i.e., for every search set in the
   request), but all result sets MUST be empty of results and MUST
   contain no errors (a reaction is not part of a result set and is
   therefore not a result set error).  This control applies to all
   search sets or none of them; therefore a server MUST issue a
   rejection if &lt;onlyCheckPermissions&gt; cannot be accepted for all search
   sets in a request.

   An example of an IRIS XML exchange using these elements follows:

   C: &lt;?xml version=&quot;1.0&quot;?&gt;
   C: &lt;request xmlns=&quot;urn:ietf:params:xml:ns:iris1&quot;
   C:   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; &gt;
   C:
   C:   &lt;control&gt;
   C:     &lt;onlyCheckPermissions /&gt;
   C:   &lt;/control&gt;
   C:
   C:   &lt;searchSet&gt;
   C:
   C:     &lt;lookupEntity
   C:       registryType=&quot;dreg1&quot;
   C:       entityClass=&quot;local&quot;
   C:       entityName=&quot;AUP&quot; /&gt;
   C:
   C:   &lt;/searchSet&gt;
   C:
   C: &lt;/request&gt;

   S: &lt;?xml version=&quot;1.0&quot;?&gt;
   S: &lt;response xmlns=&quot;urn:ietf:params:xml:ns:iris1&quot;
   S:           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; &gt;
   S:
   S:   &lt;reaction&gt;
   S:     &lt;standardReaction&gt;
   S:       &lt;controlAccepted /&gt;
   S:     &lt;/standardReaction&gt;
   S:   &lt;/reaction&gt;
   S:
   S:   &lt;resultSet&gt;
   S:     &lt;answer&gt;
   S:
   S:       &lt;simpleEntity
   S:         authority=&quot;example.com&quot; registryType=&quot;dreg1&quot;
   S:         entityClass=&quot;local&quot; entityName=&quot;AUP&quot; &gt;
   S:         &lt;property name=&quot;legal&quot; language=&quot;en&quot;&gt;
   S:           It is illegal to use information from this service
   S:           for the purposes of sending unsolicited bulk email.
   S:         &lt;/property&gt;
   S:       &lt;/simpleEntity&gt;
   S:
   S:     &lt;/answer&gt;
   S:   &lt;/resultSet&gt;
   S:
   S: &lt;/response&gt;

4.4.  Relay Bags

   IRIS employs bags to allow a server to relay information to a
   referent server via the client.  These bags are generated by the
   queried server, passed to the client as opaque data, and then passed
   to the referent server for processing.  The contents of the bags are
   not defined by IRIS, and the client MUST NOT make any assumptions
   about the contents of a bag when relaying it from one server to
   another.

   When a server returns a result set to a client, the &lt;response&gt;
   element may contain a &lt;bags&gt; child element.  This child element
   contains one or more &lt;bag&gt; elements.  Each of these MUST contain an
   &#x27;id&#x27; attribute containing the XML data type ID.  Entity references
   and search continuations that have to specify a bag to be used when
   they are followed MUST have a &#x27;bagRef&#x27; attribute containing the XML
   data type IDREF.  See Section 4.2.  This allows the response to
   specify a bag only once but allows each entity reference or search
   continuation (in all result sets) to have a distinct bag, as needed.

   When following an entity reference or search continuation that
   specifies the use of a bag, the client MUST include the referenced
   bag in the search set as a child of the &lt;searchSet&gt; element.  See
   Section 4.1.

   See Section 4.2 for the list of errors a server may return to a
   client when a bag is received.  A server MUST NOT ignore a bag when
   it is received.  In case a bag cannot be recognized or accepted, one
   of the errors from Section 4.2 MUST be returned.

   An example of an IRIS XML exchange using these elements follows:

   C: &lt;?xml version=&quot;1.0&quot;?&gt;
   C: &lt;request xmlns=&quot;urn:ietf:params:xml:ns:iris1&quot;
   C:   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; &gt;
   C:
   C:   &lt;searchSet&gt;
   C:
   C:     &lt;bag&gt;
   C:       &lt;simpleBag xmlns=&quot;http://example.com/&quot;&gt;
   C:         XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
   C:       &lt;/simpleBag&gt;
   C:     &lt;/bag&gt;
   C:
   C:     &lt;lookupEntity
   C:       registryType=&quot;dreg1&quot;
   C:       entityClass=&quot;local&quot;
   C:       entityName=&quot;AUP&quot; /&gt;

   C:
   C:   &lt;/searchSet&gt;
   C:
   C: &lt;/request&gt;

   S: &lt;?xml version=&quot;1.0&quot;?&gt;
   S: &lt;response xmlns=&quot;urn:ietf:params:xml:ns:iris1&quot;
   S:           xmlns:iris=&quot;urn:ietf:params:xml:ns:iris1&quot;
   S:           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; &gt;
   S:
   S:   &lt;resultSet&gt;
   S:     &lt;answer&gt;
   S:
   S:       &lt;entity authority=&quot;example.com&quot; bagRef=&quot;x1&quot;
   S:         registryType=&quot;dreg1&quot;
   S:         entityClass=&quot;local&quot; entityName=&quot;AUP&quot;
   S:         iris:referentType=&quot;ANY&quot; &gt;
   S:         &lt;displayName language=&quot;en&quot;&gt;
   S:           Acceptable Usage Policy
   S:         &lt;/displayName&gt;
   S:       &lt;/entity&gt;
   S:
   S:     &lt;/answer&gt;
   S:   &lt;/resultSet&gt;
   S:
   S:   &lt;bags&gt;
   S:
   S:     &lt;bag id=&quot;x1&quot;&gt;
   S:       &lt;simpleBag xmlns=&quot;http://example.com/&quot;&gt;
   S:         AAAAB3NzaC1yc2EAAAABIwAAAIEA0ddD+W3Agl0Lel98G1r77fZ
   S:       &lt;/simpleBag&gt;
   S:     &lt;/bag&gt;
   S:
   S:   &lt;/bags&gt;
   S: &lt;/response&gt;

5.  Database Serialization

   This section describes a method for serializing IRIS registry
   entities.  The descriptions contained within this section refer to
   XML elements and attributes and their relation to this serialization
   process.  These descriptions also contain specifications outside the
   scope of the formal XML syntax.  This section will use terms defined
   by RFC 2119 [8] to describe these.  While reading this section,
   please reference Section 6 for needed details on the formal XML
   syntax.

   A database of IRIS entities can be serialized to file storage with
   XML [2] by using the IRIS defined &lt;serialization&gt; element.  This
   element contains &lt;result&gt; element derivatives and
   &lt;serializedReferral&gt; elements.

   Derivatives of the &lt;result&gt; element are entities.  Servers loading
   these entities MUST place the entity in the entity classes specified
   by the elements &#x27;registryType&#x27;, &#x27;entityClass&#x27;, and &#x27;entityName&#x27;
   attributes and in any entity classes the entities may apply according
   to explicitly defined children of that element.  For instance, if a
   registry type has two entity classes &quot;foo&quot; and &quot;bar&quot; and a &lt;result&gt;
   derivative has the attributes entityClass=&quot;foo&quot; and entityName=&quot;one&quot;
   and a child element &lt;bar&gt;two&lt;/bar&gt;, the server is to enter that
   entity into the entity class &quot;foo&quot; as the name &quot;one&quot; and into the
   entity class &quot;bar&quot; as the name &quot;two&quot;.

   Servers loading entities as serialized derivatives of the &lt;result&gt;
   element MAY translate the authority attribute.  Servers will likely
   have to do this if the authority for the entity has changed.

   &lt;serializedReferral&gt; elements allow the serialization of explicit
   entity references and search continuations.  This element has a child
   &lt;source&gt; element containing the &#x27;authority&#x27;, &#x27;resolution&#x27; (optional),
   &#x27;registryType&#x27;, &#x27;entityClass&#x27;, and &#x27;entityName&#x27; attributes.  The
   attributes of this element are used to signify the entity that can be
   referenced to yield this referral.

   As mentioned above, there may be times when a server needs to
   translate the authority attribute of a loaded entity.
   Implementations must also beware of this need for referrals.  During
   deserialization, servers MUST change the authority attribute of a
   referral (either &lt;entity&gt; or elements derived from &lt;entity&gt; or
   &lt;source&gt; child of &lt;serializedReferral&gt;) to contain a valid authority
   of the server if the serialized attribute is empty.  During
   serialization, servers and their related processes MUST leave the
   authority attribute empty for referrals in which the referent is an
   entity for which the server answers queries.

   The following is an example of serialized IRIS:

   &lt;iris:serialization
     xmlns:iris=&quot;urn:ietf:params:xml:ns:iris1&quot;
     xmlns=&quot;urn:ietf:params:xml:ns:iris1&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;

     &lt;serviceIdentification
       authority=&quot;iana.org&quot; registryType=&quot;dreg1&quot;
       entityClass=&quot;iris&quot;
       entityName=&quot;id&quot; &gt;
       &lt;authorities&gt;
         &lt;authority&gt; iana.org &lt;/authority&gt;
       &lt;/authorities&gt;
       &lt;operatorName&gt;
         Internet Assigned Numbers Authority
       &lt;/operatorName&gt;
       &lt;eMail&gt;
         dbarton@iana.org
       &lt;/eMail&gt;
       &lt;seeAlso
         iris:referentType=&quot;iris:simpleEntity&quot;
         authority=&quot;iana.org&quot; registryType=&quot;dreg1&quot;
         entityClass=&quot;local&quot;
         entityName=&quot;notice&quot;&gt;
         &lt;displayName language=&quot;en&quot;&gt;
           Legal Notice
         &lt;/displayName&gt;
       &lt;/seeAlso&gt;
     &lt;/serviceIdentification&gt;

     &lt;serializedReferral&gt;
       &lt;source
         authority=&quot;example.com&quot; registryType=&quot;dreg1&quot;
         entityClass=&quot;iris&quot;
         entityName=&quot;id&quot;/&gt;
       &lt;entity
         iris:referentType=&quot;iris:serviceIdentification&quot;
         authority=&quot;iana.org&quot; registryType=&quot;dreg1&quot;
         entityClass=&quot;iris&quot; entityName=&quot;id&quot;/&gt;
     &lt;/serializedReferral&gt;

     &lt;simpleEntity
       authority=&quot;iana.org&quot; registryType=&quot;dreg1&quot;
       entityClass=&quot;local&quot;
       entityName=&quot;notice&quot; &gt;
       &lt;property name=&quot;legal&quot; language=&quot;en&quot;&gt;
         Please use the net wisely!
       &lt;/property&gt;
     &lt;/simpleEntity&gt;

   &lt;/iris:serialization&gt;

6.  Formal XML Syntax

   IRIS is specified in XML Schema notation.  The formal syntax
   presented here is a complete schema representation of IRIS suitable
   for automated validation of IRIS XML instances.

   &lt;?xml version=&quot;1.0&quot;?&gt;
   &lt;schema xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot;
           xmlns:iris=&quot;urn:ietf:params:xml:ns:iris1&quot;
           targetNamespace=&quot;urn:ietf:params:xml:ns:iris1&quot;
           elementFormDefault=&quot;qualified&quot; &gt;

     &lt;annotation&gt;
       &lt;documentation&gt;
         Internet Registry Information Service (IRIS) Schema v1
       &lt;/documentation&gt;
     &lt;/annotation&gt;

     &lt;!-- ========================================= --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- The Transactions                          --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- ========================================= --&gt;

     &lt;element name=&quot;request&quot;&gt;
       &lt;complexType&gt;
         &lt;sequence&gt;
           &lt;element
             name=&quot;control&quot;
             type=&quot;iris:controlType&quot;
             minOccurs=&quot;0&quot;
             maxOccurs=&quot;1&quot; /&gt;
           &lt;element
             name=&quot;searchSet&quot;
             type=&quot;iris:searchSetType&quot;
             minOccurs=&quot;1&quot;
             maxOccurs=&quot;unbounded&quot; /&gt;
         &lt;/sequence&gt;
       &lt;/complexType&gt;
     &lt;/element&gt;

     &lt;element name=&quot;response&quot;&gt;
       &lt;complexType&gt;
         &lt;sequence&gt;
           &lt;element
             name=&quot;reaction&quot;
             type=&quot;iris:reactionType&quot;
             minOccurs=&quot;0&quot;

             maxOccurs=&quot;1&quot; /&gt;
           &lt;element
             name=&quot;resultSet&quot;
             type=&quot;iris:resultSetType&quot;
             minOccurs=&quot;1&quot;
             maxOccurs=&quot;unbounded&quot; /&gt;
           &lt;element
             name=&quot;bags&quot;
             type=&quot;iris:bagsType&quot;
             minOccurs=&quot;0&quot;
             maxOccurs=&quot;1&quot; /&gt;
         &lt;/sequence&gt;
       &lt;/complexType&gt;
     &lt;/element&gt;

     &lt;!-- ========================================= --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- Search Sets and Result Sets               --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- ========================================= --&gt;

     &lt;complexType
       name=&quot;searchSetType&quot; &gt;
       &lt;sequence&gt;
         &lt;element
           name=&quot;bag&quot;
           type=&quot;iris:bagType&quot;
           minOccurs=&quot;0&quot;
           maxOccurs=&quot;1&quot; /&gt;
         &lt;choice&gt;
           &lt;element
             name=&quot;lookupEntity&quot;
             type=&quot;iris:lookupEntityType&quot; /&gt;
           &lt;element
             ref=&quot;iris:query&quot; /&gt;
         &lt;/choice&gt;
       &lt;/sequence&gt;
     &lt;/complexType&gt;

     &lt;complexType
       name=&quot;resultSetType&quot; &gt;
       &lt;sequence&gt;
         &lt;element
           name=&quot;answer&quot;
           minOccurs=&quot;1&quot;
           maxOccurs=&quot;1&quot;&gt;
           &lt;complexType&gt;
             &lt;sequence&gt;

               &lt;element
                 ref=&quot;iris:result&quot;
                 minOccurs=&quot;0&quot;
                 maxOccurs=&quot;unbounded&quot; /&gt;
               &lt;element
                 ref=&quot;iris:entity&quot;
                 minOccurs=&quot;0&quot;
                 maxOccurs=&quot;unbounded&quot; /&gt;
               &lt;element
                 ref=&quot;iris:searchContinuation&quot;
                 minOccurs=&quot;0&quot;
                 maxOccurs=&quot;unbounded&quot; /&gt;
             &lt;/sequence&gt;
           &lt;/complexType&gt;
         &lt;/element&gt;
         &lt;element
           name=&quot;additional&quot;
           minOccurs=&quot;0&quot;
           maxOccurs=&quot;1&quot;&gt;
           &lt;complexType&gt;
             &lt;sequence&gt;
               &lt;element
                 ref=&quot;iris:result&quot;
                 minOccurs=&quot;1&quot;
                 maxOccurs=&quot;unbounded&quot; /&gt;
             &lt;/sequence&gt;
           &lt;/complexType&gt;
         &lt;/element&gt;
         &lt;choice
           minOccurs=&quot;0&quot;
           maxOccurs=&quot;1&quot; &gt;
           &lt;element
             name=&quot;insufficientResources&quot;
             type=&quot;iris:codeType&quot; /&gt;
           &lt;element
             name=&quot;invalidName&quot;
             type=&quot;iris:codeType&quot; /&gt;
           &lt;element
             name=&quot;invalidSearch&quot;
             type=&quot;iris:codeType&quot; /&gt;
           &lt;element
             name=&quot;queryNotSupported&quot;
             type=&quot;iris:codeType&quot; /&gt;
           &lt;element
             name=&quot;limitExceeded&quot;
             type=&quot;iris:codeType&quot; /&gt;
           &lt;element
             name=&quot;nameNotFound&quot;

             type=&quot;iris:codeType&quot; /&gt;
           &lt;element
             name=&quot;permissionDenied&quot;
             type=&quot;iris:codeType&quot; /&gt;
           &lt;element
             name=&quot;bagUnrecognized&quot;
             type=&quot;iris:codeType&quot; /&gt;
           &lt;element
             name=&quot;bagUnacceptable&quot;
             type=&quot;iris:codeType&quot; /&gt;
           &lt;element
             name=&quot;bagRefused&quot;
             type=&quot;iris:codeType&quot; /&gt;
           &lt;element
             ref=&quot;iris:genericCode&quot;/&gt;
         &lt;/choice&gt;
       &lt;/sequence&gt;
     &lt;/complexType&gt;

     &lt;!-- ========================================= --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- Controls and Reactions                    --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- ========================================= --&gt;

     &lt;complexType
       name=&quot;controlType&quot;&gt;
       &lt;sequence&gt;
         &lt;any
           namespace=&quot;##any&quot;
           processContents=&quot;skip&quot;
           minOccurs=&quot;1&quot;
           maxOccurs=&quot;1&quot; /&gt;
       &lt;/sequence&gt;
     &lt;/complexType&gt;

     &lt;complexType
       name=&quot;reactionType&quot;&gt;
       &lt;sequence&gt;
         &lt;any
           namespace=&quot;##any&quot;
           processContents=&quot;skip&quot;
           minOccurs=&quot;1&quot;
           maxOccurs=&quot;1&quot; /&gt;
       &lt;/sequence&gt;
     &lt;/complexType&gt;

     &lt;!-- ========================================= --&gt;

     &lt;!--                                           --&gt;
     &lt;!-- Queries and Lookups                       --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- ========================================= --&gt;

     &lt;complexType
       name=&quot;queryType&quot; /&gt;

     &lt;element
       name=&quot;query&quot;
       type=&quot;iris:queryType&quot;
       abstract=&quot;true&quot; /&gt;

     &lt;complexType
       name=&quot;lookupEntityType&quot; &gt;
       &lt;attribute
         name=&quot;registryType&quot;
         type=&quot;anyURI&quot;
         use=&quot;required&quot; /&gt;
       &lt;attribute
         name=&quot;entityClass&quot;
         type=&quot;token&quot;
         use=&quot;required&quot; /&gt;
       &lt;attribute
         name=&quot;entityName&quot;
         type=&quot;token&quot;
         use=&quot;required&quot; /&gt;
     &lt;/complexType&gt;

     &lt;!-- ========================================= --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- Results                                   --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- ========================================= --&gt;

     &lt;complexType
       name=&quot;resultType&quot;&gt;
       &lt;attribute
         name=&quot;authority&quot;
         use=&quot;required&quot;
         type=&quot;token&quot; /&gt;
       &lt;attribute
         name=&quot;resolution&quot;
         type=&quot;token&quot; /&gt;
       &lt;attribute
         name=&quot;registryType&quot;
         use=&quot;required&quot;
         type=&quot;anyURI&quot; /&gt;

       &lt;attribute
         name=&quot;entityClass&quot;
         use=&quot;required&quot;
         type=&quot;token&quot; /&gt;
       &lt;attribute
         name=&quot;entityName&quot;
         use=&quot;required&quot;
         type=&quot;token&quot; /&gt;
       &lt;attribute
         name=&quot;temporaryReference&quot;
         default=&quot;false&quot;
         type=&quot;boolean&quot; /&gt;
     &lt;/complexType&gt;

     &lt;element
       name=&quot;result&quot;
       type=&quot;iris:resultType&quot;
       abstract=&quot;true&quot; /&gt;

     &lt;!-- ========================================= --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- Errors                                    --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- ========================================= --&gt;

     &lt;complexType
       name=&quot;codeType&quot;&gt;
       &lt;sequence
         minOccurs=&quot;0&quot;
         maxOccurs=&quot;unbounded&quot;&gt;
         &lt;element
           name=&quot;explanation&quot;&gt;
           &lt;complexType&gt;
             &lt;simpleContent&gt;
               &lt;extension
                 base=&quot;string&quot;&gt;
                 &lt;attribute
                   use=&quot;required&quot;
                   name=&quot;language&quot;
                   type=&quot;language&quot; /&gt;
               &lt;/extension&gt;
             &lt;/simpleContent&gt;
           &lt;/complexType&gt;
         &lt;/element&gt;
       &lt;/sequence&gt;
     &lt;/complexType&gt;
     &lt;element
       name=&quot;genericCode&quot;

       type=&quot;iris:codeType&quot;
       abstract=&quot;true&quot; /&gt;

     &lt;!-- ========================================= --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- Entity References and                     --&gt;
     &lt;!-- Search Continuations                      --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- ========================================= --&gt;

     &lt;complexType
       name=&quot;entityType&quot;&gt;
       &lt;sequence&gt;
         &lt;element
           name=&quot;displayName&quot;
           minOccurs=&quot;0&quot;
           maxOccurs=&quot;unbounded&quot;&gt;
           &lt;complexType&gt;
             &lt;simpleContent&gt;
               &lt;extension
                 base=&quot;string&quot;&gt;
                 &lt;attribute
                   name=&quot;language&quot;
                   use=&quot;required&quot;
                   type=&quot;language&quot; /&gt;
               &lt;/extension&gt;
             &lt;/simpleContent&gt;
           &lt;/complexType&gt;
         &lt;/element&gt;
       &lt;/sequence&gt;
       &lt;attribute
         name=&quot;authority&quot;
         use=&quot;required&quot;
         type=&quot;token&quot; /&gt;
       &lt;attribute
         name=&quot;resolution&quot;
         type=&quot;token&quot; /&gt;
       &lt;attribute
         name=&quot;registryType&quot;
         use=&quot;required&quot;
         type=&quot;anyURI&quot; /&gt;
       &lt;attribute
         name=&quot;entityClass&quot;
         use=&quot;required&quot;
         type=&quot;token&quot; /&gt;
       &lt;attribute
         name=&quot;entityName&quot;
         use=&quot;required&quot;

         type=&quot;token&quot; /&gt;
       &lt;attribute
         name=&quot;referentType&quot;
         use=&quot;required&quot;
         form=&quot;qualified&quot;
         type=&quot;iris:referentTypeType&quot; /&gt;
       &lt;attribute
         name=&quot;temporaryReference&quot;
         default=&quot;false&quot;
         type=&quot;boolean&quot; /&gt;
       &lt;attribute
         name=&quot;bagRef&quot;
         type=&quot;IDREF&quot; /&gt;
     &lt;/complexType&gt;

     &lt;element
       name=&quot;entity&quot;
       type=&quot;iris:entityType&quot; /&gt;

     &lt;simpleType
       name=&quot;referentTypeType&quot;&gt;
       &lt;union
         memberTypes=&quot;QName iris:anyLiteralType&quot; /&gt;
     &lt;/simpleType&gt;

     &lt;simpleType
       name=&quot;anyLiteralType&quot;&gt;
       &lt;restriction
         base=&quot;string&quot;&gt;
         &lt;enumeration
           value=&quot;ANY&quot; /&gt;
       &lt;/restriction&gt;
     &lt;/simpleType&gt;

     &lt;complexType
       name=&quot;searchContinuationType&quot;&gt;
       &lt;sequence&gt;
         &lt;element ref=&quot;iris:query&quot; /&gt;
       &lt;/sequence&gt;
       &lt;attribute
         name=&quot;bagRef&quot;
         type=&quot;IDREF&quot; /&gt;
       &lt;attribute
         name=&quot;authority&quot;
         type=&quot;token&quot;
         use=&quot;required&quot; /&gt;
       &lt;attribute
         name=&quot;resolution&quot;

         type=&quot;token&quot; /&gt;
     &lt;/complexType&gt;

     &lt;element
       name=&quot;searchContinuation&quot;
       type=&quot;iris:searchContinuationType&quot; /&gt;

     &lt;!-- ========================================= --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- Bags                                      --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- ========================================= --&gt;

     &lt;complexType
       name=&quot;bagsType&quot;&gt;
       &lt;sequence&gt;
         &lt;element
           name=&quot;bag&quot;
           minOccurs=&quot;1&quot;
           maxOccurs=&quot;unbounded&quot;&gt;
           &lt;complexType&gt;
             &lt;complexContent&gt;
               &lt;extension
                 base=&quot;iris:bagType&quot;&gt;
                 &lt;attribute
                   use=&quot;required&quot;
                   name=&quot;id&quot;
                   type=&quot;ID&quot; /&gt;
               &lt;/extension&gt;
             &lt;/complexContent&gt;
           &lt;/complexType&gt;
         &lt;/element&gt;
       &lt;/sequence&gt;
     &lt;/complexType&gt;

     &lt;complexType
       name=&quot;bagType&quot;&gt;
       &lt;sequence&gt;
         &lt;any
           namespace=&quot;##any&quot;
           processContents=&quot;skip&quot;
           minOccurs=&quot;1&quot;
           maxOccurs=&quot;1&quot; /&gt;
       &lt;/sequence&gt;
     &lt;/complexType&gt;
     &lt;!-- ========================================= --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- Derived Results for use with all          --&gt;

     &lt;!-- registry types.                           --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- ========================================= --&gt;

     &lt;!--                                           --&gt;
     &lt;!-- See Also                                  --&gt;
     &lt;!--                                           --&gt;

     &lt;element
       name=&quot;seeAlso&quot;
       type=&quot;iris:entityType&quot; /&gt;

     &lt;!--                                           --&gt;
     &lt;!-- Service Identification                    --&gt;
     &lt;!--                                           --&gt;

     &lt;complexType
       name=&quot;serviceIdentificationType&quot;&gt;
       &lt;complexContent&gt;
         &lt;extension
           base=&quot;iris:resultType&quot;&gt;
           &lt;sequence&gt;
             &lt;element
               name=&quot;authorities&quot;
               minOccurs=&quot;1&quot;
               maxOccurs=&quot;1&quot;&gt;
               &lt;complexType&gt;
                 &lt;sequence&gt;
                   &lt;element
                     name=&quot;authority&quot;
                     type=&quot;token&quot;
                     minOccurs=&quot;1&quot;
                     maxOccurs=&quot;unbounded&quot; /&gt;
                 &lt;/sequence&gt;
               &lt;/complexType&gt;
             &lt;/element&gt;
             &lt;element
               name=&quot;operatorName&quot;
               type=&quot;string&quot;
               minOccurs=&quot;0&quot;
               maxOccurs=&quot;1&quot; /&gt;
             &lt;element
               name=&quot;eMail&quot;
               type=&quot;string&quot;
               minOccurs=&quot;0&quot;
               maxOccurs=&quot;unbounded&quot; /&gt;
             &lt;element
               name=&quot;phone&quot;

               type=&quot;string&quot;
               minOccurs=&quot;0&quot;
               maxOccurs=&quot;unbounded&quot; /&gt;
             &lt;element
               ref=&quot;iris:seeAlso&quot;
               minOccurs=&quot;0&quot;
               maxOccurs=&quot;unbounded&quot; /&gt;
           &lt;/sequence&gt;
         &lt;/extension&gt;
       &lt;/complexContent&gt;
     &lt;/complexType&gt;

     &lt;element
       name=&quot;serviceIdentification&quot;
       type=&quot;iris:serviceIdentificationType&quot;
       substitutionGroup=&quot;iris:result&quot; /&gt;

     &lt;!--                                           --&gt;
     &lt;!-- Limits                                    --&gt;
     &lt;!--                                           --&gt;

     &lt;complexType
       name=&quot;limitsType&quot;&gt;
       &lt;complexContent&gt;
         &lt;extension
           base=&quot;iris:resultType&quot;&gt;
           &lt;sequence&gt;
             &lt;element
               name=&quot;totalQueries&quot;
               minOccurs=&quot;0&quot;
               maxOccurs=&quot;1&quot; &gt;
               &lt;complexType&gt;
                 &lt;group
                   ref=&quot;iris:timeLimitsGroup&quot;
                   minOccurs=&quot;1&quot;
                   maxOccurs=&quot;4&quot; /&gt;
               &lt;/complexType&gt;
             &lt;/element&gt;
             &lt;element
               name=&quot;totalResults&quot;
               minOccurs=&quot;0&quot;
               maxOccurs=&quot;1&quot; &gt;
               &lt;complexType&gt;
                 &lt;group
                   ref=&quot;iris:timeLimitsGroup&quot;
                   minOccurs=&quot;1&quot;
                   maxOccurs=&quot;4&quot; /&gt;
               &lt;/complexType&gt;

             &lt;/element&gt;
             &lt;element
               name=&quot;totalSessions&quot;
               minOccurs=&quot;0&quot;
               maxOccurs=&quot;1&quot; &gt;
               &lt;complexType&gt;
                 &lt;group
                   ref=&quot;iris:timeLimitsGroup&quot;
                   minOccurs=&quot;1&quot;
                   maxOccurs=&quot;4&quot; /&gt;
               &lt;/complexType&gt;
             &lt;/element&gt;
             &lt;element
               name=&quot;otherRestrictions&quot;
               minOccurs=&quot;0&quot;
               maxOccurs=&quot;1&quot;&gt;
               &lt;complexType&gt;
                 &lt;sequence&gt;
                   &lt;element
                     name=&quot;description&quot;
                     minOccurs=&quot;0&quot;
                     maxOccurs=&quot;unbounded&quot;&gt;
                     &lt;complexType&gt;
                       &lt;simpleContent&gt;
                         &lt;extension
                           base=&quot;string&quot;&gt;
                           &lt;attribute
                             name=&quot;language&quot;
                             type=&quot;language&quot;
                             use=&quot;required&quot; /&gt;
                         &lt;/extension&gt;
                       &lt;/simpleContent&gt;
                     &lt;/complexType&gt;
                   &lt;/element&gt;
                 &lt;/sequence&gt;
               &lt;/complexType&gt;
             &lt;/element&gt;
             &lt;element
               ref=&quot;iris:seeAlso&quot;
               minOccurs=&quot;0&quot;
               maxOccurs=&quot;unbounded&quot; /&gt;
           &lt;/sequence&gt;
         &lt;/extension&gt;
       &lt;/complexContent&gt;
     &lt;/complexType&gt;
     &lt;element
       name=&quot;limits&quot;
       type=&quot;iris:limitsType&quot;

       substitutionGroup=&quot;iris:result&quot; /&gt;

     &lt;group
       name=&quot;timeLimitsGroup&quot;&gt;
       &lt;choice&gt;
         &lt;element
           name=&quot;perSecond&quot;
           type=&quot;nonNegativeInteger&quot; /&gt;
         &lt;element
           name=&quot;perMinute&quot;
           type=&quot;nonNegativeInteger&quot; /&gt;
         &lt;element
           name=&quot;perHour&quot;
           type=&quot;nonNegativeInteger&quot; /&gt;
         &lt;element
           name=&quot;perDay&quot;
           type=&quot;nonNegativeInteger&quot; /&gt;
       &lt;/choice&gt;
     &lt;/group&gt;

     &lt;!--                                           --&gt;
     &lt;!-- Simple Entity                             --&gt;
     &lt;!--                                           --&gt;

     &lt;complexType
       name=&quot;simpleEntityType&quot;&gt;
       &lt;complexContent&gt;
         &lt;extension
           base=&quot;iris:resultType&quot;&gt;
           &lt;sequence&gt;
             &lt;element
               name=&quot;property&quot;
               minOccurs=&quot;1&quot;
               maxOccurs=&quot;unbounded&quot;&gt;
               &lt;complexType&gt;
                 &lt;simpleContent&gt;
                   &lt;extension
                     base=&quot;string&quot;&gt;
                     &lt;attribute
                       name=&quot;name&quot;
                       type=&quot;string&quot;
                       use=&quot;required&quot; /&gt;
                     &lt;attribute
                       name=&quot;language&quot;
                       type=&quot;language&quot;
                       use=&quot;required&quot; /&gt;
                     &lt;attribute
                       name=&quot;uri&quot;

                       type=&quot;anyURI&quot; /&gt;
                   &lt;/extension&gt;
                 &lt;/simpleContent&gt;
               &lt;/complexType&gt;
             &lt;/element&gt;
           &lt;/sequence&gt;
         &lt;/extension&gt;
       &lt;/complexContent&gt;
     &lt;/complexType&gt;

     &lt;element
       name=&quot;simpleEntity&quot;
       type=&quot;iris:simpleEntityType&quot;
       substitutionGroup=&quot;iris:result&quot; /&gt;

     &lt;!-- ========================================= --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- Derived Controls and Reactions            --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- ========================================= --&gt;

     &lt;!--                                           --&gt;
     &lt;!-- Only Check Permissions                    --&gt;
     &lt;!--                                           --&gt;

     &lt;element
       name=&quot;onlyCheckPermissions&quot; &gt;
       &lt;complexType /&gt;
     &lt;/element&gt;

     &lt;!--                                           --&gt;
     &lt;!-- Standard Reaction                         --&gt;
     &lt;!--                                           --&gt;

     &lt;element
       name=&quot;standardReaction&quot; &gt;
       &lt;complexType&gt;
         &lt;choice&gt;
           &lt;element
             name=&quot;controlAccepted&quot;&gt;
             &lt;complexType/&gt;
           &lt;/element&gt;
           &lt;element
             name=&quot;controlDenied&quot;&gt;
             &lt;complexType/&gt;
           &lt;/element&gt;
           &lt;element
             name=&quot;controlDisabled&quot;&gt;

             &lt;complexType/&gt;
           &lt;/element&gt;
           &lt;element
             name=&quot;controlUnrecognized&quot;&gt;
             &lt;complexType/&gt;
           &lt;/element&gt;
         &lt;/choice&gt;
       &lt;/complexType&gt;
     &lt;/element&gt;

     &lt;!-- ========================================= --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- Serialization                             --&gt;
     &lt;!--                                           --&gt;
     &lt;!-- ========================================= --&gt;

     &lt;complexType
       name=&quot;serializedReferralType&quot;&gt;
       &lt;sequence&gt;
         &lt;element name=&quot;source&quot;&gt;
           &lt;complexType&gt;
             &lt;attribute
               name=&quot;authority&quot;
               use=&quot;required&quot;
               type=&quot;token&quot; /&gt;
             &lt;attribute
               name=&quot;resolution&quot;
               type=&quot;token&quot; /&gt;
             &lt;attribute
               name=&quot;registryType&quot;
               type=&quot;anyURI&quot;
               use=&quot;required&quot; /&gt;
             &lt;attribute
               name=&quot;entityClass&quot;
               type=&quot;token&quot;
               use=&quot;required&quot; /&gt;
             &lt;attribute
               name=&quot;entityName&quot;
               type=&quot;token&quot;
               use=&quot;required&quot; /&gt;
           &lt;/complexType&gt;
         &lt;/element&gt;
         &lt;choice&gt;
           &lt;element
             ref=&quot;iris:searchContinuation&quot; /&gt;
           &lt;element
             ref=&quot;iris:entity&quot; /&gt;
         &lt;/choice&gt;

       &lt;/sequence&gt;
     &lt;/complexType&gt;

     &lt;element
       name=&quot;serialization&quot;&gt;
       &lt;complexType&gt;
         &lt;choice
           minOccurs=&quot;1&quot;
           maxOccurs=&quot;unbounded&quot;&gt;
           &lt;element
             ref=&quot;iris:result&quot; /&gt;
           &lt;element
             name=&quot;serializedReferral&quot;
             type=&quot;iris:serializedReferralType&quot; /&gt;
         &lt;/choice&gt;
       &lt;/complexType&gt;
     &lt;/element&gt;

   &lt;/schema&gt;

                                Figure 8

7.  The IRIS URI

   The IRIS URI has a very rigid structure.  All IRIS URIs have the same
   fields and look similar to users.

   But the IRIS URIs are flexible because they allow different methods
   to be employed to find servers and allow the use of multiple
   transports (with BEEP being the default).

7.1.  URI Definition

   An IRIS URI [6] has the following general syntax.

   iris:&lt;registry&gt;/&lt;resolution&gt;/&lt;authority&gt;/&lt;class&gt;/&lt;name&gt;

   The full ABNF [11] follows, with certain values included from RFC
   2396 [6] and RFC 2732 [15].

      iris-uri           = scheme &quot;:&quot; registry-urn &quot;/&quot;
                           [ resolution-method ] &quot;/&quot; authority
                           [ &quot;/&quot; entity-class &quot;/&quot; entity-name ]
      scheme             = &quot;iris&quot;
      authority          = // as specified by RFC2396
      registry-urn       = // as specified by IRIS
      resolution-method  = *(unreserved | escaped)
      entity-class       = *(unreserved | escaped)

      entity-name        = *(unreserved | escaped)
      unreserved         = // as specified by RFC2396
      escaped            = // as specified by RFC2396

   An IRIS URI MUST NOT be a relative URI.  The resolution method,
   entity class, and entity name MUST be of the UTF-8 [12] character set
   encoded with &quot;application/x-www-form-urlencoded&quot;, as specified by
   URL_ENC [14].

   When the entity-class and entity-name components are not specified,
   the defaults &quot;iris&quot; and &quot;id&quot; MUST be implied.  For example,
   &quot;iris:dreg1//com&quot; is interpreted as &quot;iris:dreg1//com/iris/id&quot;.

   When the resolution-method is not specified, the default is the
   direct resolution method described in Section 7.3.2.

7.2.  Transport Specific Schemes

   The &quot;iris&quot; scheme name is not application transport specific.  The
   URI resolution process MAY determine the application transport.  An
   example of such a process is direct resolution (Section 7.3.2), which
   uses the steps outlined in Section 7.3.3 to determine the application
   transport.

   A mapping between an application transport and IRIS MAY define a
   scheme name signifying its use with the semantics of the IRIS URI.

   The rules for determining which application transport to use are as
   follows:

   o  If an application transport specific scheme name is present, the
      application transport it signifies SHOULD be used if possible.

   o  If a client has a preferred transport and the resolution process
      allows for its use, the client MAY use that application transport.

   o  Otherwise, the default application transport specified by IRIS-
      BEEP [1] MUST be used.

7.3.  URI Resolution

7.3.1.  Registry Dependent Resolution

   Interpretation and resolution of the authority component of an IRIS
   URI may be altered with the specification of a resolution-method in
   the URI.  If no resolution-method component is specified in the URI,
   the default is the direct resolution method (see Section 7.3.2).

   Alternate resolution methods MAY be specified by registry types.  The
   identifiers for these methods MUST conform to the ABNF in Section
   7.1.

7.3.2.  Direct Resolution

   In the direct resolution process, the authority component of an IRIS
   URI may only contain a domain name, a domain name accompanied by a
   port number, an IP address, or an IP address accompanied by a port
   number.  The authority component of the scheme indicates the server
   or set of servers authoritatively responsible for a domain according
   to records in DNS (Section 7.3.3) if a domain is specified.  If an IP
   address is specified, it indicates the specific server to be queried.

   The rules for resolution are as follows:

   o  If the authority component is a domain name accompanied by a port
      number as specified by RFC 2396, the domain name is converted to
      an IP address via an A or AAAA record to the DNS.

   o  If the authority component is a domain name by itself, the
      service/transport location (Section 7.3.3) process is used.  If
      this process produces no results, then the DNS is queried for the
      A or AAAA RRs corresponding to the domain name, and the port
      number used is the well-known port of the transport used according
      to Section 7.2.

   o  If the authority component is an IP address, then the DNS is not
      queried, and the IP address is used directly.  If the port number
      is present, it is used directly; otherwise, the port number used
      is the well-known port of the transport used according to Section
      7.2.

   The use of an IPv6 address in the authority component MUST conform to
   RFC 2732 [15].

7.3.3.  Transport and Service Location

   The direct resolution method (Section 7.3.2) uses the profiled use of
   the NAPTR and SRV resource records defined in S-NAPTR [10] to
   determine both the location of a set of servers for a given service
   and the set of possible transports that may be used.  It is
   RECOMMENDED that any resolution method not making explicit use of the
   direct resolution process should use S-NAPTR [10] in whatever process
   it does define.

   S-NAPTR [10] requires an application service label.  The direct
   resolution method (Section 7.3.2) uses the abbreviated form of the
   registry URN as the application service label.  Other resolution
   methods MAY specify other application service labels.

   See Appendix A for sample uses of S-NAPTR.

7.4.  IRIS URI Examples

   Here are some examples of IRIS URIs and their meaning:

   o  iris:dreg1//example.com/domain/example.com
      *  Finds a server authoritative for &quot;example.com&quot; according to the
         rules of direct resolution (Section 7.3.2).
      *  The server is asked for &quot;example.com&quot; in the &quot;domain&quot; index, or
         entity class, of the &quot;dreg1&quot; registry.

   o  iris:dreg1//example.com
      *  Finds a server authoritative for &quot;example.com&quot; according to the
         rules of direct resolution (Section 7.3.2).
      *  The server is asked for &quot;id&quot; in the &quot;iris&quot; index, or entity
         class, of the &quot;dreg1&quot; registry.

   o  iris:dreg1//com/domain/example.com
      *  Finds a server authoritative for &quot;com&quot; according to the rules
         of direct-resolution (Section 7.3.2).
      *  The server is asked for &quot;example.com&quot; in the &quot;domain&quot; index, or
         entity class, of the &quot;dreg1&quot; registry.

   o  iris:dreg1//192.0.2.1:44/domain/example.com
      *  Following the rules of direct-resolution (Section 7.3.2), the
         server at IP address 192.0.2.1 on port 44 is queried by using
         BEEP.
      *  The server is asked for &quot;example.com&quot; in the &quot;domain&quot; index, or
         entity class, of the &quot;dreg1&quot; registry.

   o  iris.lwz:dreg1//192.0.2.1:44/domain/example.com
      *  Following the rules of direct-resolution (Section 7.3.2), the
         server at IP address 192.0.2.1 on port 44 is queried by using a
         lightweight application transport.
      *  The server is asked for &quot;example.com&quot; in the &quot;domain&quot; index, or
         entity class, of the &quot;dreg1&quot; registry.

   o  iris.beep:dreg1//com/domain/example.com
      *  Finds a server authoritative for &quot;com&quot; according to the rules
         of direct-resolution (Section 7.3.2).
      *  Uses the BEEP application transport.
      *  The server is asked for &quot;example.com&quot; in the &quot;domain&quot; index, or
         entity class, of the &quot;dreg1&quot; registry.

   o  iris:dreg1/bottom/example.com/domain/example.com
      *  Finds a server authoritative for &quot;example.com&quot; according to the
         rules of the resolution method &#x27;bottom&#x27; as defined by the
         registry type urn:ietf:params:xml:ns:dreg1.
      *  The application transport used is determined by the &#x27;bottom&#x27;
         resolution method.
      *  The server is asked for &quot;example.com&quot; in the &quot;domain&quot; index, or
         entity class, of the &quot;dreg1&quot; registry.

   o  iris.beep:dreg1/bottom/example.com/domain/example.com
      *  Finds a server authoritative for &quot;example.com&quot; according to the
         rules of the resolution method &#x27;bottom&#x27; as defined by the
         registry type urn:ietf:params:xml:ns:dreg1.
      *  Uses the BEEP application transport.
      *  The server is asked for &quot;example.com&quot; in the &quot;domain&quot; index, or
         entity class, of the &quot;dreg1&quot; registry.

8.  Checklists

8.1.  Registry Definition Checklist

   Specifications of registry types MUST include the following explicit
   definitions:

   o  Formal XML syntax deriving from the IRIS XML.

   o  An identifying registry URN.

   o  Any registry specific resolution methods.

   o  A registration of the abbreviated registry URN as an application
      service label for compliance with S-NAPTR [10].  Note that this is
      a different IANA registry than the registry type URN IANA
      registry.

   o  A list of well-known entity classes.

   o  A statement regarding the case sensitivity of the names in each
      entity class.

8.2.  Transport Mapping Checklist

   Specifications of transport mappings MUST include the following
   explicit definitions:

   o  A URI scheme name specific to the transport.

   o  An application protocol label for compliance with S-NAPTR [10].
      See Section 7.3.3.  Note that although this is a different IANA
      registry than the URI scheme name IANA registry, it is RECOMMENDED
      that they be the same string of characters.

   o  The set of allowable character set encodings for the exchange of
      XML (see Section 9).

   o  The set of security mechanisms.

9.  Internationalization Considerations

   IRIS is represented in XML.  XML processors are obliged to recognize
   both UTF-8 and UTF-16 [12] encodings.  XML provides for mechanisms to
   identify and use other character encodings by means of the &quot;encoding&quot;
   attribute in the &lt;xml&gt; declaration.  Absence of this attribute or a
   byte order mark (BOM) indicates a default of UTF-8 [13] encoding.
   Thus, for compatibility reasons and per RFC 2277 [16], use of UTF-8
   [13] is RECOMMENDED with IRIS.

   The complete list of character set encoding identifiers is maintained
   by IANA at [21].

   The application-transport layer MUST define a common set of character
   set encodings to be understood by both client and server.

   Localization of internationalized strings may require additional
   information from the client.  Entity definitions SHOULD use the
   &quot;language&quot; type defined by XML_SD [4] to aid clients in the
   localization process.  See Section 4.3.7.3 for an example.

10.  IANA Considerations

   This document uses a proposed XML namespace and schema registry
   specified in XML_URN [9].  Accordingly, the following registration
   information is provided for the IANA:

   o  URN/URI:
      *  urn:ietf:params:xml:ns:iris1
   o  Contact:
      *  Andrew Newton &lt;andy@hxr.us&gt;
      *  Marcos Sanz &lt;sanz@denic.de&gt;
   o  XML:
      *  The XML Schema specified in Section 6

11.  Security Considerations

   The IRIS XML layer provides no authentication or privacy facilities
   of its own.  It relies on the application-transport layer for all of
   these abilities.  Application-transports should explicitly define
   their security mechanisms (see Section 8.2).

   Referral IRIS registry results may contain entity lookups and search
   continuations that result in a client query operation against another
   registry service.  Clients SHOULD NOT use authentication credentials
   and mechanisms subject to replay attacks to conduct subsequent entity
   lookups and search continuations.

12.  References

12.1.  Normative References

   [1]  Newton, A. and M. Sanz, &quot;Using the Internet Registry Information
        Service (IRIS) over the Blocks Extensible Exchange Protocol
        (BEEP)&quot;, RFC 3983, January 2005.

   [2]  World Wide Web Consortium, &quot;Extensible Markup Language (XML)
        1.0&quot;, W3C XML, February 1998, &lt;http://www.w3.org/TR/1998/REC-
        xml-19980210&gt;.

   [3]  World Wide Web Consortium, &quot;Namespaces in XML&quot;, W3C XML
        Namespaces, January 1999, &lt;http://www.w3.org/TR/1999/REC-xml-
        names-19990114&gt;.

   [4]  World Wide Web Consortium, &quot;XML Schema Part 2: Datatypes&quot;, W3C
        XML Schema, October 2000, &lt;http://www.w3.org/TR/2001/REC-
        xmlschema-2-20010502/&gt;.

   [5]  World Wide Web Consortium, &quot;XML Schema Part 1: Structures&quot;, W3C
        XML Schema, October 2000, &lt;http://www.w3.org/TR/2001/REC-
        xmlschema-1-20010502/&gt;.

   [6]  Berners-Lee, T., Fielding, R., and L. Masinter, &quot;Uniform
        Resource Identifiers (URI): Generic Syntax&quot;, RFC 2396, August
        1998.

   [7]  Moats, R., &quot;URN Syntax&quot;, RFC 2141, May 1997.

   [8]  Bradner, S., &quot;Key words for use in RFCs to Indicate Requirement
        Levels&quot;, BCP 14, RFC 2119, March 1997.

   [9]  Mealling, M., &quot;The IETF XML Registry&quot;, BCP 81, RFC 3688, January
        2004.

   [10] Daigle, L. and A. Newton, &quot;Domain-based Application Service
        Location Using SRV RRs and the Dynamic Delegation Discovery
        Service (DDDS)&quot;, RFC 3958, January 2005.

   [11] Crocker, D. and P. Overell, &quot;Augmented BNF for Syntax
        Specifications: ABNF&quot;, RFC 2234, November 1997.

   [12] The Unicode Consortium, &quot;The Unicode Standard, Version 3&quot;, ISBN
        0-201-61633-5, 2000, &lt;The Unicode Standard, Version 3&gt;.

   [13] Yergeau, F., &quot;UTF-8, a transformation format of ISO 10646&quot;, STD
        63, RFC 3629, November 2003.

   [14] Connolly, D. and L. Masinter, &quot;The &#x27;text/html&#x27; Media Type&quot;, RFC
        2854, June 2000.

   [15] Hinden, R., Carpenter, B., and L. Masinter, &quot;Format for Literal
        IPv6 Addresses in URL&#x27;s&quot;, RFC 2732, December 1999.

   [16] Alvestrand, H., &quot;IETF Policy on Character Sets and Languages&quot;,
        BCP 18, RFC 2277, January 1998.

12.2.  Informative References

   [17] Newton, A., &quot;Cross Registry Internet Service Protocol (CRISP)
        Requirements&quot;, RFC 3707, February 2004.

   [18] Newton, A. and M. Sanz, &quot;IRIS:  A Domain Registry (dreg) Type
        for the Internet Registry Information Service (IRIS)&quot;, RFC 3982,
        January 2005.

   [19] Daigle, L., &quot;WHOIS Protocol Specification&quot;, RFC 3912, September
        2004.

   [20] Rose, M., &quot;The Blocks Extensible Exchange Protocol Core&quot;, RFC
        3080, March 2001.

URIs

   [21] &lt;http://www.iana.org/assignments/character-sets&gt;

Appendix A.  S-NAPTR and IRIS Uses

<div class='Verified-endnote-styling' id='eid199'>
<pre>
<b><i><a href='https://www.rfc-editor.org/errata/eid199'>EID 199</a> (Verified) is as follows:</i></b>

<b>Section:</b> 99Appendix A says:

<b>Original Text:</b>

he whois application protocol label refers to RFC 954 [19].

<b>Corrected Text:</b>

he whois application protocol label refers to RFC 3912 [19].
</pre>
<b>Notes:</b><br/>

</div>
A.1.  Example of S-NAPTR with IRIS

   This section shows an example of S-NAPTR [10] use by IRIS.  In this
   example, there are two registry types: REGA and REGB.  There are also
   two IRIS application transports: iris-a and iris-b.  Given this, the
   use of S-NAPTR offers the following:

   1. A means by which an operator can split the set of servers running
      REGA from the set of servers running REGB.  This is to say, the
      operator is able to split out the set of servers serving up data
      for REGA from the set of servers serving up data for REGB.

   2. A means by which an operator can distinguish the set of servers
      running iris-a from the set of servers running iris-b.  This is to
      say, the operator is able to split out the set of servers running
      protocol iris-a serving REGA and REGB data from the set of servers
      running protocol iris-b serving REGA and REGB data.

   3. A means by which an operator can specify which set of the servers
      to operate and which set of the above servers to delegate to
      another operator.

   To implement the first feature, the operator deploys the following in
   his or her DNS zone:

example.com.
;;        order  pref  flags service               re replacement
IN NAPTR  100    10    &quot;&quot;    &quot;REGA:iris-a:iris-b&quot;  &quot;&quot; rega.example.com
IN NAPTR  100    10    &quot;&quot;    &quot;REGB:iris-a:iris-b&quot;  &quot;&quot; regb.example.com

   To implement the second feature, the operator then adds the following
   in their DNS zone:

rega.example.com.
;;        order  pref flags service        re  replacement
IN NAPTR  100    10   &quot;s&quot;   &quot;REGA:iris-a&quot;  &quot;&quot;  _iris-a._udp.example.com
regb.example.com.
IN NAPTR  100    10   &quot;s&quot;   &quot;REGA:iris-b&quot;  &quot;&quot;  _iris-b._tcp.example.com

_iris-a._udp.example.com.
;;        pref  weight port  target
IN SRV    10    0      34    big-a.example.com.
IN SRV    20    0      34    small-a.example.com.

_iris-b._tcp.example.com.
;;        pref  weight port  target
IN SRV    10    0      34    big-b.example.com.
IN SRV    20    0      34    small-b.example.com.

   Finally, an operator may decide to operate the REGA services while
   delegating the REGB services to somebody else.  Here is how that is
   done:

example.com.
;;       order pref flags service              re replacement
IN NAPTR 100   10   &quot;&quot;    &quot;REGA:iris-a:iris-b&quot; &quot;&quot; rega.example.com
IN NAPTR 100   10   &quot;&quot;    &quot;REGB:iris-a:iris-b&quot; &quot;&quot; somebodyelse.com

   Or the operator may decide to operate REGB services under the iris-a
   protocol/transport while delegating the REGB services under the
   iris-b protocol/transport to somebody else.

example.com.
;;       order pref flags service       re replacement
IN NAPTR 100   10   &quot;&quot;    &quot;REGB:iris-a:iris-b&quot; &quot;&quot; regb.example.com
IN NAPTR 100   10   &quot;s&quot;   &quot;REGB:iris-a&quot; &quot;&quot; _iris-a._udp.example.com
IN NAPTR 100   10   &quot;s&quot;   &quot;REGB:iris-b&quot; &quot;&quot; _iris-b._tcp.somebodyelse.com

_iris-a._udp.example.com.
;;        pref  weight port  target
IN SRV    10    0      34    big-a.example.com.
IN SRV    20    0      34    small-a.example.com.

   Note that while this last example is possible, it is probably not
   advisable because of the operational issues involved in synchronizing
   the data between example.com and somebodyelse.com.  It is provided
   here as an example of what is possible.

A.2.  Using S-NAPTR for Cohabitation

   Given the examples in Appendix A.1, the use of S-NAPTR could be part
   of a transition strategy for cohabitation of protocols solving the
   problems of CRISP [17].

   For example, the type of data for domain information could be given
   the application service label of &quot;DREG1&quot;.  Given this, the service
   field of an S-NAPTR compliant NAPTR record could read

      &quot;DREG1:whois:iris-beep&quot;

   This service field conveys that domain data, as defined by CRISP, is
   available via both the iris-beep protocol and the whois protocol.
   The whois application protocol label refers to RFC 954 [19].

Appendix B.  IRIS Design Philosophy

   Beyond the concrete arguments that could be placed behind a
   thoughtful analysis of the bits flying across the ether, there are
   other abstract reasons for the development of IRIS.  This section
   attempts an explanation.

B.1.  The Basic Premise

   IRIS has been designed as a directory service for public-facing
   registries of Internet resources.  The basic premise is this:

   o  A client should be able to look up any single piece of data from
      any type of registry.  This lookup should involve a straight-
      forward and consistent definition for finding the registry and
      should entail a hit to a single data index in the registry.

   o  Anything more, such as searches up and down the DNS tree to find
      the registry or searches across multiple indexes in a registry,
      requires a client with special knowledge of the data relationships
      contained within a registry.

   Therefore, IRIS does the following:

   o  It specifies the basic schema language used by all registries to
      specify their schemas.

      o  It provides the basic framework for a registry to make a
      reference to an entity in another type of registry.

   And, therefore, IRIS does not do the following:

   o  It does not specify a common query language across all types of
      registries.  A common query language imposed across multiple types
      of registries usually results in the disabling of certain
      functions by a server operator in order to meet acceptable levels
      of performance, leaving a common query language that does not
      commonly work.

   o  It does not impose any relationship between sets of data in any
      type of registry, such as specifying a tree.  There are many types
      of Internet resources, and they do not all share the same style of

      relationship with their contained sets of data.  When it is not a
      natural fit, an imposition of a common relationship is often a
      concern and not a benefit.

B.2.  The Lure of a Universal Client

   The design premise of IRIS signifies that, for directory services,
   there is no such thing as a universal client (or that if there is
   one, it is commonly called the &quot;web browser&quot;).

   For IRIS, the closest thing to a universal client is one that may
   &quot;look up&quot; data and may be able to display the data in a rudimentary
   fashion.  For a client to be able to &quot;search&quot; data or display it in a
   truly user-friendly manner, it must have specific knowledge about the
   type of data it is retrieving.

   Attempts to outfit a universal client with a common query language
   are also not very useful.  A common query language may be applied to
   a specific problem domain, which would require a user to have
   expertise in both the common query language and the problem domain.
   In the end, the outcome is usually the development of a client
   specific to the problem domain but saddled with translation of the
   user&#x27;s desires and the lowest-common-denominator aspect of the query
   language.

B.3.  Server Considerations

   As mentioned above, IRIS was designed for the directory service needs
   of public-facing registries.  In this light, certain aspects of more
   generalized directory services are a hindrance in an environment that
   does not have the same control and safety considerations as a managed
   network.

   For instance, a common query language can provide great flexibility
   to both the power user and the abusive user.  An abusive user could
   easily submit a query across multiple indexes with partial values.
   Such a query would have no utility other than to cause denial of
   service to other users.  To combat this, a service operator must
   restrict the types of queries that cause harm to overall performance,
   and this act obsoletes the benefit of a common query language.

   Another consideration for server performance is the lack of a
   required data relationship.  Because sets of data often have
   differing relationships, a one-size-fits-all approach does not fit
   well with all types of registries.  In addition, public-facing
   services tend to have service level requirements that cannot
   reasonably be met by transforming complete data stores from a native
   format into a format enforcing an artificial set of relationships.

   To combat these issues, operators of public-facing services tend to
   create their own custom query parsers and back-end data stores.  But
   doing so brings into question the use of a generalized directory
   service.

   Finally, IRIS is built upon a set of standard technological layers.
   This allows service operators to switch components to meet the needs
   of their particular environment.

B.4.  Lookups, Searches, and Entity Classes

   IRIS supports both lookups and searches.  Conceptually, the
   difference between the two is as follows:

      A &quot;lookup&quot; is a single query with a discrete value on a single
      index.

      Anything more, such as partial value queries, queries across
      multiple indexes, or multiple queries to a single index is a
      &quot;search&quot;.

   Lookups are accomplished through the defined query &lt;lookupEntity&gt;.
   This query specifies a discrete name, called the entity name, to be
   queried in a single index, called the entity class.  Therefore,
   implementations may consider a type of registry to be composed of
   multiple indexes, one for each defined entity class.

   There are no standard searches in IRIS.  Each type of registry
   defines its own set of searches.

B.5.  Entities References, Search Continuations, and Scope

   Due to its effect on client behavior and the side effects such
   behavior may have on servers, IRIS makes a clear distinction between
   entity references (&lt;entity&gt;) and search continuations
   (&lt;searchContinuation&gt;).  It is not an add-on, but a fundamental core
   of the protocol.

   The distinction is very important to a client:

      &quot;Go look over there and you will find what you seek.&quot;  &quot;Go look
      over there and you may find what you seek, or you may find some
      other stuff, or you may find nothing.&quot;

   Finally, because IRIS makes no assumptions about and places no
   requirements on the relationship of data in a registry, this also
   extends to data of the same registry type spread across multiple
   authority areas.  This means that IRIS makes no requirements as to

   the scope of entity references or search continuations.  The scope is
   determined by what the registry type needs and by what the registry
   type allows a service operator.

Appendix C.  Acknowledgments

   The terminology used in this document to describe namespaces and
   namespaces of namespaces is now much clearer thanks to the skillful
   debate tactics of Leslie Daigle.  Previously, it was much more
   confusing.  In addition, Leslie has provided great insight into the
   details of URIs, URNs, and NAPTR/SRV resource records.

   Many other technical complexities were proved unnecessary by David
   Blacka and have been removed.  And his IRIS implementation has helped
   smooth out the rougher edges.

Authors&#x27; Addresses

   Andrew L. Newton
   VeriSign, Inc.
   21345 Ridgetop Circle
   Sterling, VA  20166
   USA

   Phone: +1 703 948 3382
   EMail: anewton@verisignlabs.com; andy@hxr.us
   URI:   http://www.verisignlabs.com/


   Marcos Sanz
   DENIC eG
   Wiesenhuettenplatz 26
   D-60329 Frankfurt
   Germany

   EMail: sanz@denic.de
   URI:   http://www.denic.de/

Full Copyright Statement

   Copyright (C) The Internet Society (2005).

   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   &quot;AS IS&quot; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the IETF&#x27;s procedures with respect to rights in IETF Documents can
   be found in BCP 78 and BCP 79.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at ietf-
   ipr@ietf.org.

Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.


        </re>
        
    </body>
</html>
