<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>C-Bindings for IPsec Application Programming Interfaces</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="C-Bindings for IPsec Application Programming Interfaces">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 40em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 40em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 40em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">Better than Nothing Security</td><td class="header">M. Richardson</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header"> Williams</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">SSW</td></tr>
<tr><td class="header">Expires: September 25, 2009</td><td class="header">M. Komu</td></tr>
<tr><td class="header">&nbsp;</td><td class="header"> Tarkoma</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Helsinki Institute for Information</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">Technology</td></tr>
<tr><td class="header">&nbsp;</td><td class="header">March 24, 2009</td></tr>
</table></td></tr></table>
<h1><br />C-Bindings for IPsec Application Programming Interfaces<br />draft-ietf-btns-c-api-04</h1>

<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted to IETF in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.
This document may not be modified, and derivative works of it may
not be created, except to format it for publication as an RFC or
to translate it into languages other than English.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF), its areas, and its working groups.
Note that other groups may also distribute working documents as
Internet-Drafts.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
The list of current Internet-Drafts can be accessed at
<a href='http://www.ietf.org/ietf/1id-abstracts.txt'>http://www.ietf.org/ietf/1id-abstracts.txt</a>.</p>
<p>
The list of Internet-Draft Shadow Directories can be accessed at
<a href='http://www.ietf.org/shadow.html'>http://www.ietf.org/shadow.html</a>.</p>
<p>
This Internet-Draft will expire on September 25, 2009.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2009 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents in effect on the date of
publication of this document (http://trustee.ietf.org/license-info).
Please review these documents carefully, as they describe your
rights and restrictions with respect to this document.</p>

<h3>Abstract</h3>

<p>IPsec based security is usually transparent for applications and
     they have no standard APIs for gathering information on connection
     security properties. This document specifies an API that increases the
     visibility of IPsec to applications.  The API allows applications to
     allow BTNS extensions, control the channel bindings, and control also
     other security properties related to IPsec. This document presents 
     C-bindings to the abstract BTNS API.
  
</p><a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#sec:intro">1.</a>&nbsp;
Introduction<br />
<a href="#sec:ipsec_apis">2.</a>&nbsp;
IPsec APIs<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:identity_tokens">2.1.</a>&nbsp;
Identity Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor1">2.1.1.</a>&nbsp;
Creation of Identity Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor2">2.1.2.</a>&nbsp;
Attributes of Identity Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:token_attr">2.2.</a>&nbsp;
Token Attributes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:pTokens">2.3.</a>&nbsp;
Protection Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:pToken_struct">2.3.1.</a>&nbsp;
Creation of Protection Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:pToken_attr">2.3.2.</a>&nbsp;
Attributes of Protection Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:pToken_socket">2.3.3.</a>&nbsp;
Connection Oriented Communications<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:pToken_func">2.3.4.</a>&nbsp;
Datagram Oriented Communications<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sec:pToken_misc">2.3.5.</a>&nbsp;
Equivalency of Protection Tokens<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#anchor3">2.3.6.</a>&nbsp;
Duplication of Protection Tokens<br />
<a href="#anchor4">3.</a>&nbsp;
Security Considerations<br />
<a href="#sec:iana">4.</a>&nbsp;
IANA Considerations<br />
<a href="#sec:acknowledgements">5.</a>&nbsp;
Acknowledgements<br />
<a href="#rfc.references1">6.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">6.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">6.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="sec:intro"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>
The "better than nothing" (BTNS) extensions for IKE <a class='info' href='#I-D.ietf-btns-core'>[I&#8209;D.ietf&#8209;btns&#8209;core]<span> (</span><span class='info'>Williams, N. and M. Richardson, &ldquo;Better-Than-Nothing-Security: An Unauthenticated Mode of IPsec,&rdquo; August&nbsp;2008.</span><span>)</span></a> are intended to protect network traffic
on their own (Stand Alone BTNS, or SAB), and may be useful in
providing network layer security that can be authenticated by higher
layers in the protocol stack, called Channel Bound BTNS (CBB). The
motivation for SAB is to remove the need to deploy authentication
information altogether.  The motivation for CBB is to remove the need
for redundant authentication at multiple layers.  This document
defines APIs for these purposes.  The APIs can also be used by other
protocols such as the Host Identity Protocol (HIP) <a class='info' href='#RFC5201'>[RFC5201]<span> (</span><span class='info'>Moskowitz, R., Nikander, P., Jokela, P., and T. Henderson, &ldquo;Host Identity Protocol,&rdquo; April&nbsp;2008.</span><span>)</span></a> and Session Initiation Protocol (SIP) <a class='info' href='#RFC3261'>[RFC3261]<span> (</span><span class='info'>Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &ldquo;SIP: Session Initiation Protocol,&rdquo; June&nbsp;2002.</span><span>)</span></a>. For example, a SIP user agent can use the
presented APIs for determining whether or not required integrity and
confidentiality protection is already in use. For certain networks and
configuration this is expected to reduce overhead associated with the
security mechanisms.

</p>
<p>The network communications of applications are usually secured
explicitly with TLS on transport layer <a class='info' href='#RFC4346'>[RFC4346]<span> (</span><span class='info'>Dierks, T. and E. Rescorla, &ldquo;The Transport Layer Security (TLS) Protocol Version 1.1,&rdquo; April&nbsp;2006.</span><span>)</span></a>, or
using even higher layer interfaces such as GSS <a class='info' href='#RFC2744'>[RFC2744]<span> (</span><span class='info'>Wray, J., &ldquo;Generic Security Service API Version 2 : C-bindings,&rdquo; January&nbsp;2000.</span><span>)</span></a> or SASL <a class='info' href='#RFC4422'>[RFC4422]<span> (</span><span class='info'>Melnikov, A. and K. Zeilenga, &ldquo;Simple Authentication and Security Layer (SASL),&rdquo; June&nbsp;2006.</span><span>)</span></a> APIs. However, such interfaces do
not exist for IPsec because it operates on lower layers and is mostly
transparent to applications. Using IPsec to protect existing
applications is therefore easier than with, for example, TLS because
IPsec does not require changes in the application.  However, it is
difficult for an application to detect when network connections are
secured using IPsec.  IPsec can be used as an "all or nothing"
security measure, which can be problematic especially in deployments
where the number of IPsec enabled machines is small.  An alternative
approach is to use IPsec when peer supports it.  However, the
application or the user may not have any knowledge that the
communications was actually protected by IPsec in this case.  In
addition, it is more efficient to remove redundant authentications
when IPsec and TLS are being used for the same connection.


</p>
<p>
In this document, we define APIs that increase the visibility of the
IPsec layer to the applications. This document fulfills the BTNS
requirements presented in <a class='info' href='#I-D.ietf-btns-ipsec-apireq'>[I&#8209;D.ietf&#8209;btns&#8209;ipsec&#8209;apireq]<span> (</span><span class='info'>Richardson, M. and B. Sommerfeld, &ldquo;Requirements for an IPsec API,&rdquo; April&nbsp;2006.</span><span>)</span></a>
and present C-bindings to the abstract APIs <a class='info' href='#I-D.ietf-btns-abstract-api'>[I&#8209;D.ietf&#8209;btns&#8209;abstract&#8209;api]<span> (</span><span class='info'>Richardson, M., &ldquo;An abstract interface between applications and IPsec,&rdquo; November&nbsp;2008.</span><span>)</span></a>.  The APIs defined in this
document are based on the sockets API <a class='info' href='#POSIX'>[POSIX]<span> (</span><span class='info'>Institute of Electrical and Electronics Engineers, &ldquo;IEEE Std. 1003.1-2001 Standard for Information Technology -             Portable Operating System Interface (POSIX),&rdquo; Dec&nbsp;2001.</span><span>)</span></a>.
For
related API work, please refer to <a class='info' href='#I-D.ietf-hip-native-api'>[I&#8209;D.ietf&#8209;hip&#8209;native&#8209;api]<span> (</span><span class='info'>Komu, M. and T. Henderson, &ldquo;Basic Socket Interface Extensions for Host Identity Protocol (HIP),&rdquo; January&nbsp;2010.</span><span>)</span></a>, <a class='info' href='#mcdonald'>[mcdonald]<span> (</span><span class='info'>Internet Engineering Task Force, &ldquo;A Simple IP Security API Extension to BSD Sockets,&rdquo; Mar&nbsp;1997.</span><span>)</span></a> and
<a class='info' href='#atkinson'>[atkinson]<span> (</span><span class='info'>USENIX 1996 Annual Technical Conference, &ldquo;Implementation of IPv6 in 4.4 BSD,&rdquo; Jan&nbsp;1996.</span><span>)</span></a>.

</p>
<p>
The documents defines an explicit way of enabling IPsec in
applications. This API allows the dual use of both IPsec and higher
layer security mechanisms (TLS, GSS or SASL) simultaneously. The
security and performance related benefits of this are described in
more detail in <a class='info' href='#I-D.ietf-btns-prob-and-applic'>[I&#8209;D.ietf&#8209;btns&#8209;prob&#8209;and&#8209;applic]<span> (</span><span class='info'>Touch, J., Black, D., and Y. Wang, &ldquo;Problem and Applicability Statement for Better Than Nothing Security  (BTNS),&rdquo; July&nbsp;2008.</span><span>)</span></a>.

</p><br /><hr class="insert" />
<a name="fig:layering"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
                +---------+---------+---------+---------+
                | App # 1 | App # 2 | App # 3 | App #4  |
                +-----+---+-----+---+---+-----+----+----+
                      |         |       |           |
                      |     +---v-------v--+        |
                      |     | TLS/GSS/SASL |        |
                +-----v-----+-------+------+        |
Appl. Layer     |   IPsec APIs      |   |           |
                +-----+---------+---+   |           |
                      |         |       |           |
                +-----v---------v-------v-----------v---+
Sockets Layer   |           IPv4 and IPv6 APIs          |
                +-----------+--------------+------------+
Transport Layer |    SCTP   |      TCP     |    UDP     |
                +-----------+--------------+------------+
IPsec Layer     |                  IPsec                |
                +--------------------+------------------+
Network Layer   |        IPv4        |      IPv6        |
                +--------------------+------------------+
Link Layer      |       Ethernet     |        Etc       |
                +--------------------+------------------+
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1: API Layering&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
<a class='info' href='#fig:layering'>Figure&nbsp;1<span> (</span><span class='info'>API Layering</span><span>)</span></a> illustrates four different applications.  The first
   application is using only the IPsec APIs based on either IKE based
   authentication or Stand-alone BTNS.  The second application is using
   both TLS (or other similar APIs) and IPsec APIs.  In this case, the
   application can skip IKE authentication because of it is already
   provided by TLS.  On the other hand, the application can avoid the
   use of TLS altogether when IKE authentication is available. The third
   application is using only TLS and the fourth one is using neither
   IPsec or TLS APIs.

</p>
<p>
  In the first three cases, the application is explicitly modified to
   use either TLS or IPsec.  In contrast, the fourth application is not
   using either TLS or IPsec explicitly, but it may be using IPsec
   implicitly.  This document covers the use of applications one and
   two.

</p>
<a name="sec:ipsec_apis"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
IPsec APIs</h3>

<p>
   The IPSec APIs are accessed by using tokens. The pToken has a 
   per-process scope and is used to access the IPSec API. This token 
   can be obtained, for example, from a connected socket, a received 
   datagram, or a file descriptor. This token cannot be serialized. The 
   iToken is a serializable token and represents the identity of a 
   remote system.
 
</p>
<p>
   This section defines constants, data structures and functions for
   manipulating IPsec related data structures.  The definitions are
   based on C-language.  The integer values are always in host byte
   order.

</p>
<a name="sec:identity_tokens"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1"></a><h3>2.1.&nbsp;
Identity Tokens</h3>

<p>
   Application can use identity tokes for querying the peer identity
   and for requiring certain channel bindings for a socket to
   implement ACLs or for logging purposes.  Then, the application can
   communicate with a peer through the socket and the communication
   succeeds only when channel bindings are acceptable to the
   application.  The application can also communicate with an peer of
   unknown identity, and to store and require the same peer identity
   in subsequent communications.

</p>
<a name="anchor1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.1"></a><h3>2.1.1.&nbsp;
Creation of Identity Tokens</h3>

<p>
   Identity tokens, iTokens, are machine-readable, opaque data
   structures.  They can present either the local or remote identity,
   such as a public key.  The iToken has a typedef which is illustrated
<a class='info' href='#fig:iToken'>Figure&nbsp;2</a>.

</p><br /><hr class="insert" />
<a name="fig:iToken"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  typedef struct ipsec_iToken * ipsec_iToken_t;
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
    Operating environments that support the IPSec API will
    provide appropriate constructor and destructor for the
    iToken objects.  Because applications will often not be
    aware of the byte-representation of the iToken object, nor 
    will they know which attributes to initialize upon construction,
    applications MUST only use the provided constructor to
    create an iToken object. When an iToken object is no longer 
    needed, applications MUST use the provided destructor to destroy 
    it.  <a class='info' href='#fig:create_iToken'>Figure&nbsp;3</a> illustrates this API.

</p><br /><hr class="insert" />
<a name="fig:create_iToken"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  ipsec_iToken_t ipsec_create_iToken();
  int ipsec_free_iToken(ipsec_iToken_t p);
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
   Function ipsec_create_iToken() allocates memory for a iToken and
   initializes it.  The function returns the created iToken, or NULL
   upon failure.

</p>
<p>
   Function ipsec_free_iToken() deinitializes and frees the memory
   allocated to an iToken.  It returns zero on success, and non-zero
   upon failure.

</p>
<a name="anchor2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.1.2"></a><h3>2.1.2.&nbsp;
Attributes of Identity Tokens</h3>

<p>
   This section describes the c-language bindings to section 8 in
   <a class='info' href='#I-D.ietf-btns-abstract-api'>[I&#8209;D.ietf&#8209;btns&#8209;abstract&#8209;api]<span> (</span><span class='info'>Richardson, M., &ldquo;An abstract interface between applications and IPsec,&rdquo; November&nbsp;2008.</span><span>)</span></a>. Identity token
   attributes are shown in <a class='info' href='#fig:iTokenAttr'>Figure&nbsp;4</a>. They are
   accessed using the functions defined in <a class='info' href='#sec:token_attr'>Section&nbsp;2.2<span> (</span><span class='info'>Token Attributes</span><span>)</span></a>.

</p><br /><hr class="insert" />
<a name="fig:iTokenAttr"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  enum {
       IPSEC_API_ATTR_auditString,
       IPSEC_API_ATTR_authenticationMethod,
       IPSEC_API_ATTR_certificateAuthorityDN,
       IPSEC_API_ATTR_certificateDN,
       IPSEC_API_ATTR_pubKeyID,
       IPSEC_API_ATTR_channelBinding
  } iToken_attribute;

  enum {
       IPSEC_API_ATTR_authMeth_NONE,
       IPSEC_API_ATTR_authMeth_BTNS,
       IPSEC_API_ATTR_authMeth_LEAPOFFAITH,
       IPSEC_API_ATTR_authMeth_PRESHAREDKEY,
       IPSEC_API_ATTR_authMeth_GROUPKEY,
       IPSEC_API_ATTR_authMeth_XAUTH,
       IPSEC_API_ATTR_authMeth_EAP,
       IPSEC_API_ATTR_authMeth_PKIX_TRUSTED,
       IPSEC_API_ATTR_authMeth_PKIX_INLINE,
       IPSEC_API_ATTR_authMeth_PKIX_OFFLINE
  } iToken_auth_meth;
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
   The group of attributes defined in iToken_attribute enumeration
   cannot be modified.  The auditString attribute is a character array
   ending with a zero byte.  It contains a human-readable description of
   the peer identity.  The authenticationMethod attribute defines the
   key manager authentication method in an unsigned integer of two
   octets.  
   
</p>
<p>
    The certificateAuthorityDN attribute is a character array ending 
   with a zero byte and contains a human-readable description of the peer 
   certificate authority.  The pubKeyID attribute contains a binary 
   presentation of the peer public key.  The channelBinding attribute is a 
   character array ending with a zero byte.  It contains a human-readable 
   description of the channel binding.  Two channel bindings can be compared 
   with the memcmp() function.
   
</p>
<p>
   The group of attributes in iToken_auth_meth enumeration
   contains a list of authentication methods.  These attributes are both
   writable before network communications and readable after network
   communications.  Here the use of the attributes is described only
   from the point of view of writing.
   
</p>
<p>
   The attributes in this group are 2-octet unsigned integer
   values, with values IPSEC_API_ATTR_ENABLE, IPSEC_API_ATTR_DISABLE and
   IPSEC_API_ATTR_ANY.  The first two of the values enable or disable
   the attribute, and third one refers that the application relies on
   the system defaults. 
   
</p>
<p>
      The attributes of the iToken_auth_meth are defined in <a class='info' href='#I-D.ietf-btns-abstract-api'>[I&#8209;D.ietf&#8209;btns&#8209;abstract&#8209;api]<span> (</span><span class='info'>Richardson, M., &ldquo;An abstract interface between applications and IPsec,&rdquo; November&nbsp;2008.</span><span>)</span></a>.
   
</p>
<p>
   The first NONE attribute describes that no authentication should be
   used. The BTNS attribute enables or disables the extensions 
   defined in <a class='info' href='#I-D.ietf-btns-core'>[I&#8209;D.ietf&#8209;btns&#8209;core]<span> (</span><span class='info'>Williams, N. and M. Richardson, &ldquo;Better-Than-Nothing-Security: An Unauthenticated Mode of IPsec,&rdquo; August&nbsp;2008.</span><span>)</span></a>

</p>
<p>
The LEAPOFFAITH attribute declares that the peer 
   was authenticated using a key which was previously cached, but was 
   previously received inline, and was not verified in anyway. 

</p>
<p>
 The PRESHAREDKEY attribute denotes that a unique preshared key should be 
   used and GROUPKEY correspondingly refers to a non-unique group 
   key. 
</p>
<p>
   The XAUTH, EAP, and PKIX attributes refer to the respective 
   authentication methods.  
</p>
<a name="sec:token_attr"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.2"></a><h3>2.2.&nbsp;
Token Attributes</h3>

<p>
IPsec properties are handled indirectly using objects called
tokens. They are are opaque data structures that must not be
manipulated directly. Instead, the application uses accessor
functions shown in <a class='info' href='#fig:pToken_attr'>Figure&nbsp;5</a>. 

</p><br /><hr class="insert" />
<a name="fig:pToken_attr"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  int ipsec_get_token_attr(const void *token,
                           uint32_t attr_type,
                           uint32_t *attr_len,
                           void *attr_val);
  int ipsec_set_token_attr(const void *token,
                           uint32_t attr_type,
                           uint32_t attr_len,
                           const void *attr_val);
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
Both of the functions can be applied both to policy and identity
tokens to retrieve or change the low-level attributes.

</p>
<p>
   Function ipsec_token_attr_get() searches for the given attribute type
   (attr_type) from the token and writes it to attr_val. Parameter attr_len
   defines the size of attr_val structure in bytes.
 
</p>
<p>
  Function ipsec_set_token_attr() writes the attribute (attr_val) to
  the token.  The type and length of the attribute must be set in
  attr_type and attr_len. The attr_val must not be NULL and attr_len
  must have the size of the allocated object.
</p>
<p>
  Both of the functions return zero on success. They return -1 on
  error and set errno accordingly.

</p>
<a name="sec:pTokens"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3"></a><h3>2.3.&nbsp;
Protection Tokens</h3>

<p>
An application creates a "protection token" and attaches some
attributes for it. For example, the application can define in the
attributes of protection token that it accepts BTNS extensions for a
certain socket.

</p>
<a name="sec:pToken_struct"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.1"></a><h3>2.3.1.&nbsp;
Creation of Protection Tokens</h3>

<p>
   Application uses protection tokens, or pTokens, as "handles" to the key
   management or the IPsec module of the host.  The application uses pToken
   attributes to e.g. enabled the BTNS extensions and to control
   iTokens.  The former allows the use of IPSec without authentication,
   and the latter allows e.g. querying of channel bindings.

</p>
<p>
   The data structure that represents a pToken is contained in an opaque
   ipsec_pToken structure.  The application must not alter the data
   structure contents directly, but rather use the accessor functions
   introduced in the following sections.  The application can use
   ipsec_pToken_t typedef as a short hand for the policy structure.  The
   typedef is shown in <a class='info' href='#fig:pToken_t'>Figure&nbsp;6</a>.

</p><br /><hr class="insert" />
<a name="fig:pToken_t"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  typedef struct ipsec_pToken * ipsec_pToken_t;
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
The size of a policy is variable and applications MUST NOT declare
them directly. Instead, the application uses the constructor and
destructor functions shown in  <a class='info' href='#fig:create_pToken'>Figure&nbsp;7</a>.

</p><br /><hr class="insert" />
<a name="fig:create_pToken"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  ipsec_pToken_t ipsec_create_pToken(void);
  int ipsec_free_pToken(ipsec_pToken_t p);
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;7&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
Function ipsec_create_pToken() allocates memory for a pToken and
initializes it.  The function returns the created pToken, or NULL upon
failure.

</p>
<p>
Function ipsec_free_pToken() deinitializes and frees the memory
allocated to a pToken.  It returns zero on success, and non-zero upon
failure.

</p>
<a name="sec:pToken_attr"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.2"></a><h3>2.3.2.&nbsp;
Attributes of Protection Tokens</h3>

<p>
This section defines c-bindings for section 7 in <a class='info' href='#I-D.ietf-btns-abstract-api'>[I&#8209;D.ietf&#8209;btns&#8209;abstract&#8209;api]<span> (</span><span class='info'>Richardson, M., &ldquo;An abstract interface between applications and IPsec,&rdquo; November&nbsp;2008.</span><span>)</span></a>.  Protection token attributes
are shown in <a class='info' href='#fig:pTokenAttr'>Figure&nbsp;8</a>.  They are get or set
using the functions defined in <a class='info' href='#sec:token_attr'>Section&nbsp;2.2<span> (</span><span class='info'>Token Attributes</span><span>)</span></a>.

</p><br /><hr class="insert" />
<a name="fig:pTokenAttr"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  enum {
       IPSEC_API_ATTR_privacyProtected,
       IPSEC_API_ATTR_integrityProtected,
       IPSEC_API_ATTR_compressionAvailable,
       IPSEC_API_ATTR_policyName,
       IPSEC_API_ATTR_iToken,
       IPSEC_API_ATTR_remote_iToken,
       IPSEC_API_ATTR_tunnelMode,
       IPSEC_API_ATTR_ipoptionsProtected,
       IPSEC_API_ATTR_auditString,
       IPSEC_API_ATTR_informationString
  } pToken_attribute;
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;8&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
The attributes of the pToken_attribute structure are defined in <a class='info' href='#I-D.ietf-btns-abstract-api'>[I&#8209;D.ietf&#8209;btns&#8209;abstract&#8209;api]<span> (</span><span class='info'>Richardson, M., &ldquo;An abstract interface between applications and IPsec,&rdquo; November&nbsp;2008.</span><span>)</span></a>.

</p>
<p>
   Here the use of the attributes is described only from writing point
   of view.  Attribute value IPSEC_API_ATTR_DISABLE defines that the 
   attribute should not be used.  Value IPSEC_API_ATTR_ENABLE describes 
   that the corresponding attribute should be used.  

</p>
<p>It is possible to 
   enable an attribute by declaring the "level" of the attribute with
   IPSEC_API_ATTR_LEVEL_LOW, IPSEC_API_ATTR_LEVEL_MEDIUM or
   IPSEC_API_ATTR_LEVEL_HIGH.

</p>
<p>
   The privacy, integrity and compression attributes are 2-octet
   unsigned integer values.  These attributes are writable before
   network communication and readable after network communications.
   They can be used to enforce and negotiate required attribute values.

</p>
<p>
   privacyProtection - unsigned integer.  Set to
 IPSEC_API_ATTR_DISABLE if the connection has either no privacy
 configured (AH, ESP-null), or if the privacy configured is known to
 be untrustworthy by the administrator.

</p>
<p>
   integrityProtection - unsigned integer.  Set to
      IPSEC_API_ATTR_DISABLE if there is no data integrity protection
      other than the UDP/TCP checksum.

</p>
<p>

      compressionAvailable - unsigned integer.  Set to IPSEC_API_ATTR_DISABLE 
      if data count sent/ received from socket maps directly  to data sent/received on
      wire.


</p>
<p>
 policyName - string.  A handle which describes the system policy
      which was used (or is desired), to establish the connection. 

</p>
<p>
   iToken - object.  Set to iToken object which represents identity
   of remote system.

</p>
<p>
 remote_iToken - object.  Set to iToken object which was used to
      represent our identity to the remote system.


</p>
<p>
tunnelMode - unsigned integer.  Set if tunnel mode was used, or if it is
      desired.


</p>
<p>
ipoptionsProtected - unsigned integer.  Set if ip options (and IPv6 header
      extensions), are protected.


</p>
<p>
   auditString - string.  The auditString is a character array 
   ending in zero byte and contains a human readable description of 
   the protection token.

</p>
<p>
informationString - string. Readonly.  Not part of a template.
      Valid only after connection establishment.  Contains a string
      which can be displayed to a user, informing them of what kind of
      security association was established for this connection.  This
      string may be localized.  No session keys are disclosed by this
      string.


</p>
<a name="sec:pToken_socket"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.3"></a><h3>2.3.3.&nbsp;
Connection Oriented Communications</h3>

<p>
Declaring a pToken does not affect the networking communications of
   an application.  For connection oriented communications, the
   application must first attach the pToken to the socket before the
   pToken is effective.  It is also possible to query for the pToken
   attached to a socket as shown in  <a class='info' href='#fig:socket_pToken'>Figure&nbsp;9</a>.

</p><br /><hr class="insert" />
<a name="fig:socket_pToken"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  int ipsec_set_socket_pToken(int fd, const ipsec_pToken_t pToken);
  int ipsec_get_socket_pToken(int fd, ipsec_pToken_t pToken);
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;9&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
   Both functions input an socket descriptor as the first argument and a
   pToken as the second argument.  Function ipsec_set_socket_pToken()
   attaches the given pToken to the socket descriptor fd. Function
   ipsec_get_socket_pToken() assumes that the application has allocated
   the policy token beforehand with ipsec_create_pToken().

</p>
<p>
Both functions return zero upon success, and non-zero upon failure.

</p>
<a name="sec:pToken_func"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.4"></a><h3>2.3.4.&nbsp;
Datagram Oriented Communications</h3>

<p>
The previous section covered the use of connected sockets. Datagram
oriented communications based on sendmsg() and recvmsg() functions are
supported in the API. Datagram related functions are
applicable both to incoming and outgoing packets. The IPsec API
functions related sendmsg() and recvmsg() are shown in <a class='info' href='#fig:msg_pToken'>Figure&nbsp;10</a>.

</p><br /><hr class="insert" />
<a name="fig:msg_pToken"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  int ipsec_set_msg_pToken(struct msghdr *msg,
                           const ipsec_pToken_t pToken);
  int ipsec_get_msg_pToken(const struct msghdr *msg,
                           ipsec_pToken_t pToken);
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;10&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
Function ipsec_set_msg_pToken() attaches the given pToken to the
ancillary data of msg. The pToken of a msg can be queried using
ipsec_get_msg_pToken() that assumes the application has allocated
the policy token beforehand with ipsec_create_pToken.

</p>
<p>
Both functions return zero on success. The functions return -1 on error
and set errno accordingly.

</p>
<p>
It should be noticed that these functions can be applied only to
sendto() and recvmsg() as they support per packet anchillary
data. Applications using sendto() and recvfrom() can apply the
"stream-based" functions described in the other sections of the
document with certain restrictions. TBD: discuss.

</p>
<a name="sec:pToken_misc"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.5"></a><h3>2.3.5.&nbsp;
Equivalency of Protection Tokens</h3>

<p>
An application is not allowed to read or write to pTokens
directly. The same restriction applies also to comparison of pTokens.
The function for comparing two pTokens is shown in <a class='info' href='#fig:cmp_pToken'>Figure&nbsp;11</a>.

</p><br /><hr class="insert" />
<a name="fig:cmp_pToken"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  int ipsec_cmp_pToken(ipsec_pToken_t p1,
                       ipsec_pToken_t p2);
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;11&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>
   Function ipsec_cmp_pToken() inputs two policies, p1 and p2, and
   returns zero if they represent two SAs that cover identical SPD
   ranges, and have equivalent cryptographic security properties. The
   function returns a nonzero value if p1 is not equal to p2. The two
   SAs need not represent SAs that identical --- they might vary in
   many different ways, including, but not limited to:

</p>
<p>
</p>
<ul class="text">
<li>Time: One SA may have been created later, but both are valid.
</li>
<li>Jitter/performance properties: One SA may be on hardware and
                   the other on software, and have different properties
                   about what kind of latency or jitter a packet might
                   experience
</li>
<li>Algorithm: one SA might use AES128-CBC while the other uses
                      AES128-CTR (DISCUSS) for performance reasons.
</li>
<li>IPsec SA endpoints. The two SAs may cover the same inner
                   IP packets, but might connect using differing outer
                   IP addresses, and be used in some kind of multipath
                   IPsec (such as MOBIKE).
</li>
</ul><p>

</p>
<a name="anchor3"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2.3.6"></a><h3>2.3.6.&nbsp;
Duplication of Protection Tokens</h3>

<p>
Byte-wise copying of pTokens is not allowed e.g. with memcpy().
Function ipsec_dup_pToken() duplicates given pToken p and writes it to
p_dup. The function allocates the memory for duplicated pToken that
the caller is responsible of freeing.  Return value is zero on success
and non-zero on failure.

</p><br /><hr class="insert" />
<a name="fig:dup_pToken"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
  int ipsec_dup_pToken(const ipsec_pToken_t p,
                       ipsec_pToken_t *p_dup);
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;12&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="anchor4"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
Security Considerations</h3>

<p>
   The BTNS Stand Alone mode allows applications to omit network layer
   authentication.  In this case, an application is using a higher level
   security mechanism, such as TLS, and thus the required level of
   security is maintained.  Thus, the application avoids
   applying duplicate security measures on the network connection.

</p>
<p>
   The channel bindings allow applications to create and manage security
   channels.  Given that applications omit higher layer security
   techniques based on information in an existing pToken and the
   corresponding channel binding, there is a possibility for a security
   channel downgrade attack.  In this attack, another application
   modifies the current application's channel binding in such a way that
   the application believes that an authenticated IPsec security channel
   to be active even though there is no such channel.  If the application
   omits TLS or other higher level security mechanism, then there will
   not be a secured channel and transmitted data is exposed.


</p>
<a name="sec:iana"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
IANA Considerations</h3>

<p>There are no registries created by this document.  The names (and
   language specific enum) of the pToken and iToken properties are 
   internal to a single system, and therefore do not need
   standardization.

</p>
<a name="sec:acknowledgements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Acknowledgements</h3>

<p>Thanks for Love H&ouml;rnquist &Aring;trand, Julien Laganier and Vijay
   Gurbani for feedback, ideas and discussion on the topic. The
   authors wish to thank also Simon Josefsson and Daniel McDonald for
   comments on the draft.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>6.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-btns-abstract-api">[I-D.ietf-btns-abstract-api]</a></td>
<td class="author-text">Richardson, M., &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-btns-abstract-api-02.txt">An abstract interface between applications and IPsec</a>,&rdquo; draft-ietf-btns-abstract-api-02 (work in progress), November&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-btns-abstract-api-02.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-btns-core">[I-D.ietf-btns-core]</a></td>
<td class="author-text">Williams, N. and M. Richardson, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-btns-core-07.txt">Better-Than-Nothing-Security: An Unauthenticated Mode of IPsec</a>,&rdquo; draft-ietf-btns-core-07 (work in progress), August&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-btns-core-07.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-btns-ipsec-apireq">[I-D.ietf-btns-ipsec-apireq]</a></td>
<td class="author-text">Richardson, M. and B. Sommerfeld, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-btns-ipsec-apireq-00.txt">Requirements for an IPsec API</a>,&rdquo; draft-ietf-btns-ipsec-apireq-00 (work in progress), April&nbsp;2006 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-btns-ipsec-apireq-00.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="I-D.ietf-btns-prob-and-applic">[I-D.ietf-btns-prob-and-applic]</a></td>
<td class="author-text">Touch, J., Black, D., and Y. Wang, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-btns-prob-and-applic-07.txt">Problem and Applicability Statement for Better Than Nothing Security  (BTNS)</a>,&rdquo; draft-ietf-btns-prob-and-applic-07 (work in progress), July&nbsp;2008 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-btns-prob-and-applic-07.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="POSIX">[POSIX]</a></td>
<td class="author-text">Institute of Electrical and Electronics Engineers, &ldquo;IEEE Std. 1003.1-2001 Standard for Information Technology -
            Portable Operating System Interface (POSIX),&rdquo; Dec&nbsp;2001.</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>6.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-hip-native-api">[I-D.ietf-hip-native-api]</a></td>
<td class="author-text">Komu, M. and T. Henderson, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-hip-native-api-12.txt">Basic Socket Interface Extensions for Host Identity Protocol (HIP)</a>,&rdquo; draft-ietf-hip-native-api-12 (work in progress), January&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-hip-native-api-12.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2744">[RFC2744]</a></td>
<td class="author-text"><a href="mailto:John_Wray@Iris.com">Wray, J.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2744">Generic Security Service API Version 2 : C-bindings</a>,&rdquo; RFC&nbsp;2744, January&nbsp;2000 (<a href="http://www.rfc-editor.org/rfc/rfc2744.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3261">[RFC3261]</a></td>
<td class="author-text">Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, &ldquo;<a href="http://tools.ietf.org/html/rfc3261">SIP: Session Initiation Protocol</a>,&rdquo; RFC&nbsp;3261, June&nbsp;2002 (<a href="http://www.rfc-editor.org/rfc/rfc3261.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4346">[RFC4346]</a></td>
<td class="author-text">Dierks, T. and E. Rescorla, &ldquo;<a href="http://tools.ietf.org/html/rfc4346">The Transport Layer Security (TLS) Protocol Version 1.1</a>,&rdquo; RFC&nbsp;4346, April&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4346.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC4422">[RFC4422]</a></td>
<td class="author-text">Melnikov, A. and K. Zeilenga, &ldquo;<a href="http://tools.ietf.org/html/rfc4422">Simple Authentication and Security Layer (SASL)</a>,&rdquo; RFC&nbsp;4422, June&nbsp;2006 (<a href="http://www.rfc-editor.org/rfc/rfc4422.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC5201">[RFC5201]</a></td>
<td class="author-text">Moskowitz, R., Nikander, P., Jokela, P., and T. Henderson, &ldquo;<a href="http://tools.ietf.org/html/rfc5201">Host Identity Protocol</a>,&rdquo; RFC&nbsp;5201, April&nbsp;2008 (<a href="http://www.rfc-editor.org/rfc/rfc5201.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="atkinson">[atkinson]</a></td>
<td class="author-text">USENIX 1996 Annual Technical Conference, &ldquo;Implementation of IPv6 in 4.4 BSD,&rdquo; Jan&nbsp;1996.</td></tr>
<tr><td class="author-text" valign="top"><a name="mcdonald">[mcdonald]</a></td>
<td class="author-text">Internet Engineering Task Force, &ldquo;A Simple IP Security API Extension to BSD Sockets,&rdquo; Mar&nbsp;1997.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Michael C. Richardson</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Sandelman Software Works</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">470 Dawson Avenue</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Ottawa, ON  K1Z 5V7</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">CA</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:mcr@sandelman.ottawa.on.ca">mcr@sandelman.ottawa.on.ca</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.sandelman.ottawa.on.ca/">http://www.sandelman.ottawa.on.ca/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Nicolas Williams</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">SUN Microsystems</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">5300 Riata Trace Ct</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Austin, TX  TX  78727</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">US</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:Nicolas.Williams@sun.com">Nicolas.Williams@sun.com</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Miika Komu</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Helsinki Institute for Information Technology</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Metsnneidonkuja 4</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Espoo</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Finland</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+358503841531</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text">+35896949768</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:miika@iki.fi">miika@iki.fi</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.iki.fi/miika/">http://www.iki.fi/miika/</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Sasu Tarkoma</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Helsinki Institute for Information Technology</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Metsnneidonkuja 4</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Espoo</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Finland</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+358503841517</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text">+35896949768</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:sasu.tarkoma@hiit.fi">sasu.tarkoma@hiit.fi</a></td></tr>
<tr><td class="author" align="right">URI:&nbsp;</td>
<td class="author-text"><a href="http://www.cs.helsinki.fi/u/starkoma/">http://www.cs.helsinki.fi/u/starkoma/</a></td></tr>
</table>
</body></html>
