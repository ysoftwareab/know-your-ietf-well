<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en"><head><title>Observing Resources in CoAP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="Observing Resources in CoAP">
<meta name="keywords" content="Internet-Draft">
<meta name="generator" content="xml2rfc v1.35 (http://xml.resource.org/)">
<meta name="viewport" content="width=600;" />
<style type='text/css'><!--
        body {
                font-family: verdana, charcoal, helvetica, arial, sans-serif;
                font-size: 85%;
		max-width: 60em; 
		color: #000; background-color: #FFF;
                margin: 2em;
        }
        h1, h2, h3, h4, h5, h6 {
                font-family: helvetica, monaco, "MS Sans Serif", arial, sans-serif;
                font-weight: bold; font-style: normal;
        }
        h1 { color: #900; background-color: transparent; text-align: right; }
        h3 { color: #333; background-color: transparent; }

        td.RFCbug {
                font-size: x-small; text-decoration: none;
                width: 30px; height: 30px; padding-top: 2px;
                text-align: justify; vertical-align: middle;
                background-color: #000;
        }
        td.RFCbug span.RFC {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: bold; color: #666;
        }
        td.RFCbug span.hotText {
                font-family: charcoal, monaco, geneva, "MS Sans Serif", helvetica, verdana, sans-serif;
                font-weight: normal; text-align: center; color: #FFF;
        }

        table.TOCbug { width: 30px; height: 15px; }
        td.TOCbug {
                text-align: center; width: 30px; height: 15px;
                color: #FFF; background-color: #900;
        }
        td.TOCbug a {
                font-family: monaco, charcoal, geneva, "MS Sans Serif", helvetica, sans-serif;
                font-weight: bold; font-size: x-small; text-decoration: none;
                color: #FFF; background-color: transparent;
        }

        td.header {
                font-family: arial, helvetica, sans-serif; font-size: x-small;
                vertical-align: top; width: 33%;
                color: #FFF; background-color: #666;
        }
        td.author { font-weight: bold; font-size: x-small; margin-left: 4em; }
        td.author-text { font-size: x-small; }

        /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
        a.info {
                /* This is the key. */
                position: relative;
                z-index: 24;
                text-decoration: none;
        }
        a.info:hover {
                z-index: 25;
                color: #FFF; background-color: #900;
        }
        a.info span { display: none; }
        a.info:hover span.info {
                /* The span will display just on :hover state. */
                display: block;
                position: absolute;
                font-size: smaller;
                top: 2em; left: -5em; width: 15em;
                padding: 2px; border: 1px solid #333;
                color: #900; background-color: #EEE;
                text-align: left;
        }

        a { font-weight: bold; }
        a:link    { color: #900; background-color: transparent; }
        a:visited { color: #633; background-color: transparent; }
        a:active  { color: #633; background-color: transparent; }

        p { margin-left: 2em; margin-right: 2em; }
        p.copyright { font-size: x-small; }
        p.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; margin-left: 3em; }
        table.toc { margin: 0 0 0 3em; padding: 0; border: 0; vertical-align: text-top; }
        td.toc { font-size: 85%;
		max-width: 60em; 
		font-weight: bold; vertical-align: text-top; }

        ol.text { margin-left: 2em; margin-right: 2em; }
        ul.text { margin-left: 2em; margin-right: 2em; }
        li      { margin-left: 3em; }

        /* RFC-2629 <spanx>s and <artwork>s. */
        em     { font-style: italic; }
        strong { font-weight: bold; }
        dfn    { font-weight: bold; font-style: normal; }
        cite   { font-weight: normal; font-style: normal; }
        tt     { color: #036; }
        tt, pre, pre dfn, pre em, pre cite, pre span {
                font-family: "Courier New", Courier, monospace; font-size: small;
        }
        pre {
                text-align: left; padding: 4px;
                color: #000; background-color: #CCC;
        }
        pre dfn  { color: #900; }
        pre em   { color: #66F; background-color: #FFC; font-weight: normal; }
        pre .key { color: #33C; font-weight: bold; }
        pre .id  { color: #900; }
        pre .str { color: #000; background-color: #CFF; }
        pre .val { color: #066; }
        pre .rep { color: #909; }
        pre .oth { color: #000; background-color: #FCF; }
        pre .err { background-color: #FCC; }

        /* RFC-2629 <texttable>s. */
        table.all, table.full, table.headers, table.none {
                font-size: 85%;
		max-width: 60em; 
		text-align: center; border-width: 2px;
                vertical-align: top; border-collapse: collapse;
        }
        table.all, table.full { border-style: solid; border-color: black; }
        table.headers, table.none { border-style: none; }
        th {
                font-weight: bold; border-color: black;
                border-width: 2px 2px 3px 2px;
        }
        table.all th, table.full th { border-style: solid; }
        table.headers th { border-style: none none solid none; }
        table.none th { border-style: none; }
        table.all td {
                border-style: solid; border-color: #333;
                border-width: 1px 2px;
        }
        table.full td, table.headers td, table.none td { border-style: none; }

        hr { height: 1px; }
        hr.insert {
                width: 80%; border-style: none; border-width: 0;
                color: #CCC; background-color: #CCC;
        }
--></style>
</head>
<body>
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<table summary="layout" width="66%" border="0" cellpadding="0" cellspacing="0"><tr><td><table summary="layout" width="100%" border="0" cellpadding="2" cellspacing="1">
<tr><td class="header">CoRE Working Group</td><td class="header">K. Hartke</td></tr>
<tr><td class="header">Internet-Draft</td><td class="header">C. Bormann</td></tr>
<tr><td class="header">Intended status: Informational</td><td class="header">Universität Bremen TZI</td></tr>
<tr><td class="header">Expires: December 23, 2010</td><td class="header">June 21, 2010</td></tr>
</table></td></tr></table>
<h1><br />Observing Resources in CoAP<br />draft-hartke-coap-observe-00</h1>

<h3>Abstract</h3>

<p>
      The state of a resource can change over time. We want to give clients
       of the CoRE WG CoAP protocol the ability to observe this change.

        This short I-D provides an example design for such an addition
        to CoAP, in order to be able to discuss the design
        alternatives in specific terms.

      
</p>
<h3>Status of this Memo</h3>
<p>
This Internet-Draft is submitted  in full
conformance with the provisions of BCP&nbsp;78 and BCP&nbsp;79.</p>
<p>
Internet-Drafts are working documents of the Internet Engineering
Task Force (IETF).  Note that other groups may also distribute
working documents as Internet-Drafts.  The list of current
Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>
Internet-Drafts are draft documents valid for a maximum of six months
and may be updated, replaced, or obsoleted by other documents at any time.
It is inappropriate to use Internet-Drafts as reference material or to cite
them other than as &ldquo;work in progress.&rdquo;</p>
<p>
This Internet-Draft will expire on December 23, 2010.</p>

<h3>Copyright Notice</h3>
<p>
Copyright (c) 2010 IETF Trust and the persons identified as the
document authors.  All rights reserved.</p>
<p>
This document is subject to BCP 78 and the IETF Trust's Legal
Provisions Relating to IETF Documents
(http://trustee.ietf.org/license-info) in effect on the date of
publication of this document.  Please review these documents
carefully, as they describe your rights and restrictions with respect
to this document. Code Components extracted from this document must
include Simplified BSD License text as described in Section 4.e of
the Trust Legal Provisions and are provided without warranty as
described in the Simplified BSD License.</p>
<a name="toc"></a><br /><hr />
<h3>Table of Contents</h3>
<p class="toc">
<a href="#introduction">1.</a>&nbsp;
Introduction<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#design-pattern">1.1.</a>&nbsp;
Design Pattern<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#architecture">1.2.</a>&nbsp;
Architecture<br />
<a href="#requirements">2.</a>&nbsp;
Requirements<br />
<a href="#the-design">3.</a>&nbsp;
The Design<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#state">3.1.</a>&nbsp;
State<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#subscription-lifetime">3.2.</a>&nbsp;
Subscription Lifetime<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#messages">3.3.</a>&nbsp;
Messages<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#requests">3.3.1.</a>&nbsp;
Requests<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#replies">3.3.2.</a>&nbsp;
Replies<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#notifications">3.3.3.</a>&nbsp;
Notifications<br />
<a href="#message-exchanges">4.</a>&nbsp;
Message Exchanges<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#subscribing-to-a-resource">4.1.</a>&nbsp;
Subscribing to a resource<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#notifying-of-state-changes">4.2.</a>&nbsp;
Notifying of state changes<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#unsubscribing-from-a-resource">4.3.</a>&nbsp;
Unsubscribing from a resource<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#retrieving-resource-state">4.4.</a>&nbsp;
Retrieving resource state<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#changing-resource-state">4.5.</a>&nbsp;
Changing resource state<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#deleting-a-resource">4.6.</a>&nbsp;
Deleting a resource<br />
<a href="#cache">5.</a>&nbsp;
Caching<br />
<a href="#identify">6.</a>&nbsp;
Identifying notifications and subscriptions<br />
<a href="#open-issues">7.</a>&nbsp;
Open issues<br />
<a href="#rfc.references1">8.</a>&nbsp;
References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references1">8.1.</a>&nbsp;
Normative References<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rfc.references2">8.2.</a>&nbsp;
Informative References<br />
<a href="#rfc.authors">&#167;</a>&nbsp;
Authors' Addresses<br />
</p>
<br clear="all" />

<a name="introduction"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1"></a><h3>1.&nbsp;
Introduction</h3>

<p>The state of a resource can change over time. We want to give CoAP
<a class='info' href='#I-D.ietf-core-coap'>[I&#8209;D.ietf&#8209;core&#8209;coap]<span> (</span><span class='info'>Shelby, Z., Frank, B., and D. Sturek, &ldquo;Constrained Application Protocol (CoAP),&rdquo; June&nbsp;2010.</span><span>)</span></a> clients the ability to observe this change.
</p>
<p>This short I-D provides an example design for such an addition
to CoAP, in order to be able to discuss the design
alternatives in specific terms.
</p>
<a name="design-pattern"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.1"></a><h3>1.1.&nbsp;
Design Pattern</h3>

<p>Many designs are possible for the observe capability of CoAP.
So that we don’t end up with a random, arbitrary design, we base our
considerations on the well-known subject/observer design pattern. In
this pattern, an object, called the subject, maintains a list of
interested parties, called observers, and notifies them automatically
of any state changes.
</p>
<p>There are a number of variants of that design pattern.
We like one that explicitly considers the way the
evolution of the resource state might end <a class='info' href='#DUAL'>[DUAL]<span> (</span><span class='info'>Meijer, E., &ldquo;Subject/Observer is Dual to Iterator,&rdquo; June&nbsp;2010.</span><span>)</span></a>.
In detail, this variant of the design pattern consists of the following elements:
</p>
<p></p>
<ul class="text">
<li>A <em>subject</em>, which sends notifications to observers. It
has a single method, SUBSCRIBE, which is called by observers that wish to
receive notifications from the subject.
</li>
<li>An <em>observer</em>, which receives notifications from a subject.
It has three methods: YIELD, which supplies the observer with new or current
information; THROW, which informs the observer that the subject experienced
an error condition; and BREAK, which indicates that the subject has finished
sending notifications. The grammar of notifications to be expected over time
therefore is:
</li>
</ul>

<p></p>
<blockquote class="text">
<p>YIELD* ( BREAK | THROW )?
</p>
</blockquote>

<p></p>
<ul class="text">
<li>A <em>subscription</em>, which represents the interest of an
observer in a subject. It has a single method, UNSUBSCRIBE, which enables
the subject to unsubscribe observers when notification has finished.
Observers receive a reference to the subscription from the SUBSCRIBE method,
so they can also call the UNSUBSCRIBE method to unsubscribe before the
subject has finished sending notifications.
</li>
</ul>

<p>In this document, we describe an architecture and a protocol design
that realizes a meaningful rendition of this design pattern within the
REST-based <a class='info' href='#REST'>[REST]<span> (</span><span class='info'>Fielding, R., &ldquo;Architectural Styles and the Design of Network-based Software Architectures,&rdquo; 2000.</span><span>)</span></a> environment of CoAP.
</p>
<a name="architecture"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.1.2"></a><h3>1.2.&nbsp;
Architecture</h3>

<p>We interpret resources as the <em>subjects</em> of the subject/observer
pattern.  The <em>subscription</em> causes the subject to continuously supply
an <em>observer</em> with the state of the resource: once upon subscription
and then whenever the state of the resource changes. We call a CoAP node
offering a resource <em>server</em>, and a CoAP node subscribing an observer to a
resource <em>client</em>.  As with the existing REST methods, this
architecture is about exchanging representations of resources, not
about the messages (or method calls).
</p>
<p>The design is REST-based, as it maintains REST’s uniform interface and
its four interface constraints (<a class='info' href='#REST'>[REST]<span> (</span><span class='info'>Fielding, R., &ldquo;Architectural Styles and the Design of Network-based Software Architectures,&rdquo; 2000.</span><span>)</span></a>, section 5.1.5):
</p>
<p></p>
<ul class="text">
<li>Identification of resources by the uniform mechanism of URIs <a class='info' href='#RFC3986'>[RFC3986]<span> (</span><span class='info'>Berners-Lee, T., Fielding, R., and L. Masinter, &ldquo;Uniform Resource Identifier (URI): Generic Syntax,&rdquo; January&nbsp;2005.</span><span>)</span></a>;
</li>
<li>Resource manipulation through the exchange of resource state representations;
</li>
<li>Self-describing messages (potentially with multiple representation formats);
</li>
<li>Hypermedia as the engine of application state: A server premediates
application state transitions by providing links in resources.;
</li>
</ul>

<p>While this is not a necessary implication of the design described
here, the assumption is that the subscription itself is modeled on the
level of conversation state, not as a resource by itself.  (This, of
course, does not imply that there can’t be resources that help nodes
decide whether to create subscriptions, but these are
application-specific and outside the scope of CoAP.)
</p>
<a name="requirements"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.2"></a><h3>2.&nbsp;
Requirements</h3>

<p>The requirements for implementing the subject/observer design pattern over
UDP stem largely from the the fact that UDP is an unreliable,
connectionless transport. This means that method calls must be expressed as
messages, that preparation must be taken for the case that messages arrive
out of order, appear duplicated, or go missing without notice, and that the
transport keeps no state between messages that can be utilized.
</p>
<p>The detailed requirements that follow from this are:
</p>
<p></p>
<ul class="text">
<li>An invocation of the SUBSCRIBE method on an observable resource is
implemented by sending a message (a subscription request) from the
subscribing client to the server that offers the resource.  <br />
<br />

The client must be able to determine if a subscription request was received
by the server, and, if not, must be able to retransmit the request.  <br />
<br />

The server must acknowledge the subscription request, and must be prepared
to receive duplicated subscription requests.  <br />
<br />

Since subscribing can be made idempotent (<a class='info' href='#identify'>Section&nbsp;6<span> (</span><span class='info'>Identifying notifications and subscriptions</span><span>)</span></a>), the
server need not be able to detect a duplicated subscription request as such.  <br />
<br />

The client must be able to relate the acknowledgement to the subscription
request.
</li>
<li>The usual considerations for retrieving the representation of a
resource in a REST-based protocol apply, e.g.:  <br />
<br />

A subscribing client must be able to influence the representation format in
which the server supplies the resource state to the client.
</li>
<li>Upon subscription, an observer must be supplied with the current state of
the resource in the requested format.  <br />
<br />

If the observer cannot be supplied with the current state (for example,
because the resource does not exist, the state cannot be represented in
the requested format, the client lacks authorization, or a general error
condition occurred), the server must inform the client of the error
condition.  <br />
<br />

For efficiency, this initial notification may be sent within the same
datagram that acknowledges the subscription request.  <br />
<br />

The initial notification might not include the actual representation
(e.g., take the form of a “304 not modified”) if the client already
has a valid representation of the resource.  The client should be
able to supply information (e.g., Etags or a modification date)
to enable the server to make this determination.
</li>
<li>To take advantage of the multicast capabilities of the transport, it should
be possible to subscribe a UDP multicast group to a resource. In contrast to
subscribing multiple clients individually to the resource, the server in this
case must treat the multicast group as a single observer.
</li>
<li>For robustness, a subscription has to be maintained through periodic
refreshing. If a subscription is not refreshed, its lifetime must end after
a certain duration that is negotiated as part of the message exchange that
implements the SUBSCRIBE method call.  <br />
<br />

So a subscribing client must be able to specify a subscription lifetime
duration in a subscription request. A server must be able to return the
negotiated subscription lifetime duration back to the client.  <br />
<br />

Since the client is responsible for taking care of the subscription, refreshing a
subscription must be implemented by sending a message (a subscription
refresh request) from the subscribed client to the server.  <br />
<br />

The client must be able to determine if a subscription refresh request
was received by the server, and, if not, must be able to retransmit the request.  <br />
<br />

The server must acknowledge the request. It must be prepared to receive
duplicated requests. It must be able to relate a refresh request to a
subscription.  <br />
<br />

The client must be able to relate the acknowledgement to the subscription
refresh request.  <br />
<br />

The server must be prepared for a refresh request to arrive after the
subscription expired. In this case, the subscription refresh request is
treated the same as a subscription request, since the client expressed the
desire to continue being subscribed to the resource.
</li>
<li>For notifications, the equivalent of an invocation of the YIELD,
BREAK or THROW method on an
observer must be implemented by sending a notification message from the
server offering the resource to the subscribed client.  <br />
<br />

The subscribed client must be able to relate a notification message to a
subscription and/or to a resource (see also <a class='info' href='#identify'>Section&nbsp;6<span> (</span><span class='info'>Identifying notifications and subscriptions</span><span>)</span></a>).  <br />
<br />

It is not a requirement that a subscribed client receives every single notification
messages sent by a server, or that the server sends a notification message
for every single state change. However, the state observed by an observer must
eventually become consistent with the actual state of the observed resource.
</li>
<li>The representation format used during the lifetime of a subscription must
not change. If the server is unable to continue notifying a client in the
requested representation format, it must invoke the THROW method on the
observer.
</li>
<li>A server must not send any further notification messages after sending a
notification message that denotes a BREAK or THROW.  <br />
<br />

However, a client must be prepared to receive notification messages after
receiving such a notification message. (In this case, it discards
the excessive notification messages.)
</li>
<li>For robustness, a server can request the acknowledgement of a notification
message from a client. (For example, in order to check if the client is
still there, or to make sure that an observer observes a particular resource
state.) Such a notification is called a <em>confirmable</em> notification message.  <br />
<br />

A server must be able to determine if a confirmable notification message was
received by the client, and, if not, must retransmit the message.  <br />
<br />

If the client cannot relate the confirmable notification message to a
subscription, it must reject the message. Otherwise, it must acknowledge
the message.  <br />
<br />

The server must be able to relate the acknowledgement or rejection to the
confirmable notification message.  <br />
<br />

There is no support for multicasting confirmable notification messages.
</li>
<li>To end a subscription before the lifetime of the subscription
expires (UNSUSBCRIBE method), a message (an ‘unsubscribe’ request)
can be sent from the subscribed client to the server that maintains
the subscription.  <br />
<br />

The client must be able to determine if an ‘unsubscribe’ request was
indeed received by the server, and, if not, must be able to
retransmit the request.  <br />
<br />

The server must acknowledge the ‘unsubscribe’ request, and must be prepared
to receive duplicated requests (which also need to be acknowledged).  <br />
<br />

The client must be able to relate the acknowledgement to the request.
</li>
</ul>

<p>Note that, in a REST-based environment, all these message exchanges
should also work correctly through proxies.
</p>
<a name="the-design"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3"></a><h3>3.&nbsp;
The Design</h3>

<a name="state"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.1"></a><h3>3.1.&nbsp;
State</h3>

<p>The state required on nodes as indicated by the requirements, can be summarized
as follows:
</p>
<p></p>
<ul class="text">
<li>Nodes that send requests must keep track of pending requests.
(For non-idempotent requests, the node that receives the request
also must retain state to deduplicate requests.)
</li>
<li>A server offering a resource must keep track of the observers of the
resource. Similarly, a proxy must keep track of the observers that
observe a resource through that proxy.
</li>
<li>Due to the initial notification of an observer upon subscription, the server
must also keep track the resource state itself. (It cannot just notify all
observers when the state changes and then immediately forget the state.)
</li>
<li>A client subscribed to a resource may have to keep track of the
subscriptions to the resource in order to be able to relate
notifications to the subscription and in order to be able to refresh
the subscription before the subscription lifetime ends (<a class='info' href='#identify'>Section&nbsp;6<span> (</span><span class='info'>Identifying notifications and subscriptions</span><span>)</span></a>).
</li>
<li>A client (or a proxy) may optionally keep a cache of resource states.
</li>
</ul>

<a name="subscription-lifetime"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.2"></a><h3>3.2.&nbsp;
Subscription Lifetime</h3>

<p>To summarize, the lifetime of a subscription begins with a subscription
request, and it ends when
</p>
<p></p>
<ul class="text">
<li>the subscription lifetime expires (as defined by the subscription duration
option in the subscription request),
</li>
<li>the client unsubscribes from the resource,
</li>
<li>the client rejects a request related to a subscription,
</li>
<li>an error condition related to a subscription occurred, or
</li>
<li>the observed resource has finished sending notifications.
</li>
</ul>

<p>A client can extend the lifetime of a subscription before its end by sending
a subscription refresh request.
</p>
<a name="messages"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3"></a><h3>3.3.&nbsp;
Messages</h3>

<p>The following message types and elements can be gathered from the requirements.
</p>
<a name="requests"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.1"></a><h3>3.3.1.&nbsp;
Requests</h3>

<p>Requests are messages that need to be acknowledged by the
recipient. As with other request in CoAP, they are retransmitted by
the sender using an exponential back-off delay until the
acknowledgment is received.
</p>
<p>The request message types as indicated by the requirements can be summarized
as follows:
</p>
<p></p>
<ul class="text">
<li>A SUBSCRIBE request creates a new subscription or refreshes an existing
subscription.
</li>
<li>An UNSUBSCRIBE request ends an existing subscription.
</li>
</ul>

<p>To put this into perspective, the existing GET, PUT, POST and DELETE messages
have request semantics as well.
</p>
<p></p>
<ul class="text">
<li>A GET request retrieves a representation of the current resource state.
</li>
<li>A PUT request provides a new resource state in some representation format.
</li>
<li>A POST request creates or extends a resource.
</li>
<li>A DELETE request deletes a resource.
</li>
</ul>

<p>A request message includes a <em>transaction identifier</em> which allows the
recipient to detect duplicated requests and, by inclusion of the transaction
identifier in the acknowledgement to the request, enables the sender to
relate the acknowledgement to the request.
</p>
<a name="replies"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.2"></a><h3>3.3.2.&nbsp;
Replies</h3>

<p>Replies are messages that are sent in reply to a request. They carry the
aforementioned transaction identifier.
</p>
<p>The reply messages types as indicated by the requirements can be summarized
as follows:
</p>
<p></p>
<ul class="text">
<li>An ACK reply indicates an acknowledgement of a request.
</li>
<li>A RST reply indicates the rejection of a request.
</li>
</ul>

<p>(Responses in CoAP are replies that may carry a resource representation.)
</p>
<a name="notifications"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.3.3.3"></a><h3>3.3.3.&nbsp;
Notifications</h3>

<p>Matching the methods of an observer, the notification message types can be
summarized as follows:
</p>
<p></p>
<ul class="text">
<li>A YIELD notification supplies the subscribed client with the state
of a resource in some representation.
</li>
<li>A BREAK notification indicates that the observed resource has
finished sending notifications.
</li>
<li>A THROW notification informs the subscribed client of an error condition.
</li>
</ul>

<p>Each of these notification messages can be sent as a message that does not
require acknowledgement, as a confirmable message that does require
acknowledgement (which makes it a request), or (in case of an initial
notification) piggy-backed with the ACK message that is sent in reply to the
subscription request.
</p>
<a name="message-exchanges"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4"></a><h3>4.&nbsp;
Message Exchanges</h3>

<p>The following message exchanges can be derived from the requirements.
</p>
<a name="subscribing-to-a-resource"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.1"></a><h3>4.1.&nbsp;
Subscribing to a resource</h3>
<br /><hr class="insert" />
<a name="client-server-client-server-subscribe-subscribe-ackyield-ack-or-time-passes-yield-c-ack-if-c-"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Client             Server                  Client             Server
   |                 |                        |                 |
   |    SUBSCRIBE    |                        |    SUBSCRIBE    |
   +----------------&gt;|                        +----------------&gt;|
   |                 |                        |                 |
   |    ACK+YIELD    |                        |       ACK       |
   |&lt;----------------+           or           |&lt;----------------+
   |                 |                        |                 |
                                              ... Time Passes ...
                                              |                 |
                                              |   YIELD [c?]    |
                                              |&lt;----------------+
                                              |                 |
                                              |    ACK (if c)   |
                                              +----------------&gt;|
                                              |                 |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;1&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The workflow for subscribing an observer to an observable resource or
refreshing a subscription is as follows:
</p>
<p></p>
<ol class="text">
<li>The subscribing client sends a SUBSCRIBE request to the server that
is offering the observable resource. The subscription request includes
the identifier of a representation format in which the notifications
have to be sent, specifies a subscription lifetime duration and
optionally indicates states cached by the client (by Etag or Date) and
other information that might be relayed in a GET request.
</li>
<li>The server creates a new subscription if no subscription exists
(<a class='info' href='#identify'>Section&nbsp;6<span> (</span><span class='info'>Identifying notifications and subscriptions</span><span>)</span></a>), and changes the lifetime duration of the subscription
to the duration specified in the subscription request, or any shorter
duration if it so desires. The server then acknowledges the request
and indicates the actual lifetime
with a ACK reply (or with a ACK+THROW, ACK+BREAK or ACK+YIELD reply as
described in the next step).
</li>
<li>The server performs one of the following actions:  
<ul class="text">
<li>If an error occurred, the server sends a THROW notification (either as
THROW request or as ACK+THROW reply to the SUBSCRIBE request).
</li>
<li>If the resource has finished sending notifications, the server
sends a BREAK notification
(either as BREAK request or as ACK+BREAK reply to the SUBSCRIBE request).
</li>
<li>Otherwise, the server supplies the observer with the current resource
state in the requested representation format, or indicates that the cached
state is the current state (either as YIELD request or as ACK+YIELD
reply to the SUBSCRIBE request).
</li>
</ul>
If the server sends a THROW, BREAK or YIELD request, the request is treated
like any other notification (i.e. the client must acknowledge it if
the message is marked as confirmable, etc.).
</li>
<li>If the client does not receive the ACK, ACK+THROW, ACK+BREAK or ACK+YIELD
reply within a certain time frame (because the request or the reply went
missing), the client retransmits the SUBSCRIBE request using the same
request identifier.
</li>
</ol>

<a name="notifying-of-state-changes"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.2"></a><h3>4.2.&nbsp;
Notifying of state changes</h3>
<br /><hr class="insert" />
<a name="client-server-client-server-yield-yield-c-or-ack-"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Client             Server                  Client             Server
   |                 |                        |                 |
   |      YIELD      |                        |    YIELD [c]    |
   |&lt;----------------+           or           |&lt;----------------+
   |                 |                        |                 |
                                              |       ACK       |
                                              +----------------&gt;|
                                              |                 |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;2&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The workflow for notifying an observer of a state change is as follows:
</p>
<p></p>
<ol class="text">
<li>The server performs one of the following actions:  
<ul class="text">
<li>If the resource experienced an error condition, the server sends a THROW
request to the client.
</li>
<li>If the resource has finished sending notifications, the server
sends a BREAK request to the client.
</li>
<li>If the state of the resource changed, the server sends a YIELD request
with the current resource state in the requested representation format.
</li>
</ul>
The server may or may not mark the request sent as confirmable (<tt>[c]</tt>). The server
marks a request as confirmable because it wants to check if the
observer is still alive, or because there might not be another
notification in the near future and the confirmation process is
therefore needed to ensure eventual consistency.
</li>
<li>If the request is marked as confirmable, the subscribed client performs one of
the following actions:  
<ul class="text">
<li>If the notification cannot be related to a subscription, the client sends
a RST reply.
</li>
<li>Otherwise, the client sends an ACK reply.
</li>
</ul>
</li>
<li>If the request is marked as confirmable and the server does not receive the ACK
reply or the RST reply within a given time frame, the server retransmits
the request using the same transaction identifier.
</li>
</ol>

<p>(Note that it is entirely the decision of the server whether to
request an acknowledgement by marking the request as confirmable – it
might want to employ different strategies to determine this,
e.g. based on frequency of change, management of state etc.)
</p>
<a name="unsubscribing-from-a-resource"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.3"></a><h3>4.3.&nbsp;
Unsubscribing from a resource</h3>
<br /><hr class="insert" />
<a name="client-server-unsubscribe-ack-"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Client             Server
   |                 |
   |   UNSUBSCRIBE   |
   +----------------&gt;|
   |                 |
   |       ACK       |
   |&lt;----------------+
   |                 |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;3&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>The workflow for unsubscribing an observer from an observed resource is as
follows:
</p>
<p></p>
<ol class="text">
<li>The subscribed client sends an UNSUBSCRIBE request to the server offering
the observed resource.
</li>
<li>The server changes the lifetime duration of the subscription to zero,
which immediately expires the subscription. The server then acknowledges
the request with a ACK reply.
</li>
<li>If the client does not receive the ACK reply within a certain time frame,
the client retransmits the UNSUBSCRIBE request using the same request
identifier.
</li>
</ol>

<p>Note that an subscribed client can also unsubscribe by “forgetting”
the subscription and subsequently replying with a RST to the next
notification.  (In order to allow sending that RST even for messages
that are not marked as confirmable, an otherwise redundant transaction
identifier is sent in all messages.)
</p>
<p>(An UNSUBSCRIBE message might be implemented as a SUBSCRIBE message
with a lifetime duration of 0, but this has some unintended
consequences.  See <a class='info' href='#identify'>Section&nbsp;6<span> (</span><span class='info'>Identifying notifications and subscriptions</span><span>)</span></a>.)
</p>
<a name="retrieving-resource-state"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.4"></a><h3>4.4.&nbsp;
Retrieving resource state</h3>

<p>Note that a GET request matches closely the first steps of subscribing, except that the
GET request does not create or update an subscription.  (A GET request is likely
to mark the yield as confirmable.)
</p>
<p>The second form in <a class='info' href='#GET'>Figure&nbsp;4</a> solves the long-poll case.
</p><br /><hr class="insert" />
<a name="GET"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Client             Server                  Client             Server
   |                 |                        |                 |
   |       GET       |                        |       GET       |
   +----------------&gt;|                        +----------------&gt;|
   |                 |                        |                 |
   |    ACK+YIELD    |                        |       ACK       |
   |&lt;----------------+           or           |&lt;----------------+
   |                 |                        |                 |
                                              ... Time Passes ...
                                              |                 |
                                              |    YIELD [c]    |
                                              |&lt;----------------+
                                              |                 |
                                              |       ACK       |
                                              +----------------&gt;|
                                              |                 |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;4&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<a name="changing-resource-state"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.5"></a><h3>4.5.&nbsp;
Changing resource state</h3>
<br /><hr class="insert" />
<a name="PUT"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Client             Server                  Client             Server
   |                 |                        |                 |
   |       PUT       |                        |       PUT       |
   +----------------&gt;|                        +----------------&gt;|
   |                 |                        |                 |
   |    ACK+BREAK    |                        |       ACK       |
   |&lt;----------------+           or           |&lt;----------------+
   |                 |                        |                 |
                                              ... Time Passes ...
                                              |                 |
                                              |    BREAK [c]    |
                                              |&lt;----------------+
                                              |                 |
                                              |       ACK       |
                                              +----------------&gt;|
                                              |                 |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;5&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>(The motivation for the BREAK component of the response is: PUT, like
GET, can experience some error condition, so we need a place in the
state machine to put the THROW response; therefore we also need a
BREAK response.  The second case in <a class='info' href='#PUT'>Figure&nbsp;5</a> is motivated by: PUT, like
GET, can take some time to be processed, so we must be able to send an
ACK immediately and the THROW or BREAK response later.)
</p>
<p>Obviously, changing the state of this resource
leads to notification of any observers of new state.
PUT is idempotent,
but if we add notifications it may be a bit surprising that a
duplicated or retransmitted PUT might send notifications
twice.  To prevent that, the resource might check whether it is being
changed to the same state it had before and not send notifications in
that case.
</p>
<a name="deleting-a-resource"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.4.6"></a><h3>4.6.&nbsp;
Deleting a resource</h3>

<p>A DELETE request is the same as a PUT request, except that the resource is
not created or its state changed, but deleted.
</p><br /><hr class="insert" />
<a name="client-server-delete-ackbreak-"></a>
<div style='display: table; width: 0; margin-left: 3em; margin-right: auto'><pre>
Client             Server
   |                 |
   |     DELETE      |
   +----------------&gt;|
   |                 |
   |    ACK+BREAK    |
   |&lt;----------------+
   |                 |
</pre></div><table border="0" cellpadding="0" cellspacing="2" align="center"><tr><td align="center"><font face="monaco, MS Sans Serif" size="1"><b>&nbsp;Figure&nbsp;6&nbsp;</b></font><br /></td></tr></table><hr class="insert" />

<p>If a resource is observed, deleting the resource leads to an error condition
of which the observers are notified with a THROW notification or THROW request.
</p>
<a name="cache"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.5"></a><h3>5.&nbsp;
Caching</h3>

<p>An observer may cache part or all of a resource’s state changes. This allows
clients to make conditional requests: If a subscribing client has cached a
particular resource state, the server offering the resource does not need to
send a full notification.
</p>
<p></p>
<ul class="text">
<li>A client informs the server of its cached resource states by
including Etags of cached resource states in the subscription request.
This can be multiple Etags, as this enables the server to just send
a “304 not modified” for a different Etag instead of a different
representation if the resource switches around between multiple states.
(Note that this list might be updated by a subscription refresh.)
</li>
<li>A server notifies a client of a change to a cached state by omitting the
representation of the resource state in the notification and including a
flag (“304 not modified”) that indicates that the state changed to a cached state.
</li>
</ul>

<p>Another approach to caching multiple values for a resource is to
express each possible value of the resource’s representation by a
reference to another (unchanging) resource.  This lets a resource
change states between a set of such references that then provide the
actual state information. A subscribed client fetches the individual
resources on demand and caches the results for future use.
</p>
<a name="identify"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.6"></a><h3>6.&nbsp;
Identifying notifications and subscriptions</h3>

<p>There are two ways that a notification could be related to the resource that it is about:
</p>
<p></p>
<ol class="text">
<li>The notification could name the resource (its URI).
</li>
<li>The notification could name a target that relates to a
subscription, which in turn relates back to the resource.
</li>
</ol>

<p>One or both ways could be implemented in CoAP, there are not
</p>
<p>For way 1, each notification would contain the URI of the resource.
This is particularly useful for multicast messages, but could be relatively wasteful.
Also, it is not entirely clear that all servers will be aware of their own authority.
Apart from cached states (<a class='info' href='#cache'>Section&nbsp;5<span> (</span><span class='info'>Caching</span><span>)</span></a>) and other information that could
be part of a GET,
a subscription would simply be the triple
</p>
<p></p>
<blockquote class="text">
<p>[URI, observer transport address, lifetime]
</p>
</blockquote>

<p>Resubscribing (or a duplicate subscription request) for the same
[URI, observer transport address] pair simply updates the lifetime;
thus, the subscription operation is idempotent.
Similarly, resubscribing with a lifetime of 0 will serve to delete the
subscription (however, a SUBSCRIBE message will be replied to with the
current state of the resource; a SUBSCRIBE with lifetime 0 is thus
equivalent to a GET with the side effect of deleting the subscription).
</p>
<p>The notification then needs to contain the URI (and might occasionally
contain a remaining lifetime):
</p>
<p></p>
<blockquote class="text">
<p>[resource representation, resource metadata, URI, lifetime?]
</p>
</blockquote>

<p>For way 2, the subscription request would also contain a target
identifier that is to be used in every notification, identifying the
specific observer object that is to receive the notification.
Again apart from cached states (<a class='info' href='#cache'>Section&nbsp;5<span> (</span><span class='info'>Caching</span><span>)</span></a>) and other information that could
be part of a GET,
the subscription would be the quadruple:
</p>
<p></p>
<blockquote class="text">
<p>[URI, observer transport address, target, lifetime]
</p>
</blockquote>

<p>(Note that the combination of the observer transport address and the
target could be expressed as another URI, with the transport address
as the authority and the target as the path.  Alternatively, the
target could be a short byte string.  By varying the transport
address, i.e. the port number, the target could also made to be always
empty.)
</p>
<p>Resubscribing (or a duplicate subscription request) for the same [URI,
observer transport address, target] triple simply updates the lifetime,
thus, the subscription operation again is idempotent.  (The same
comment as with way 1 applies to SUBSCRIBE with lifetime 0.)
</p>
<p>As the notification already implicitly contains the transport address,
it would just list the target (and might occasionally contain a
remaining lifetime):
</p>
<p></p>
<blockquote class="text">
<p>[resource representation, resource metadata, target, lifetime?]
</p>
</blockquote>

<p>In both cases, it would be beneficial if rebooting nodes could obtain
the same transport address they had before, because a resubscription
after the reboot does not create additional state.
</p>
<p>Multicast works nicely in way 1 (except that the URI may be large).
In way 2, we can give each observer in a multicast group the same
target name, so multicast works.
</p>
<p>For normal subscriptions, the observer transport address can be
implied from the source address of the subscription request.  For
multicast, there needs to be a way to explicitly indicate that
transport address.  (This may be beneficial for unicast, too.)
</p>
<a name="open-issues"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.7"></a><h3>7.&nbsp;
Open issues</h3>

<p>Add discussion of messages that get reordered.
</p>
<p>Add detailed message and option formats, once the semantics are agreed.
</p>
<p>Describe how to map this to HTTP long-polls, WebSockets, and other
asynchronous forms of HTTP.
</p>
<a name="rfc.references"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<a name="rfc.section.8"></a><h3>8.&nbsp;
References</h3>

<a name="rfc.references1"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>8.1.&nbsp;Normative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="I-D.ietf-core-coap">[I-D.ietf-core-coap]</a></td>
<td class="author-text">Shelby, Z., Frank, B., and D. Sturek, &ldquo;<a href="http://www.ietf.org/internet-drafts/draft-ietf-core-coap-00.txt">Constrained Application Protocol (CoAP)</a>,&rdquo; draft-ietf-core-coap-00 (work in progress), June&nbsp;2010 (<a href="http://www.ietf.org/internet-drafts/draft-ietf-core-coap-00.txt">TXT</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2119">[RFC2119]</a></td>
<td class="author-text"><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>,&rdquo; BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997 (<a href="http://www.rfc-editor.org/rfc/rfc2119.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2119.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2119.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC2616">[RFC2616]</a></td>
<td class="author-text"><a href="mailto:fielding@ics.uci.edu">Fielding, R.</a>, <a href="mailto:jg@w3.org">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com">Mogul, J.</a>, <a href="mailto:frystyk@w3.org">Frystyk, H.</a>, <a href="mailto:masinter@parc.xerox.com">Masinter, L.</a>, <a href="mailto:paulle@microsoft.com">Leach, P.</a>, and <a href="mailto:timbl@w3.org">T. Berners-Lee</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>,&rdquo; RFC&nbsp;2616, June&nbsp;1999 (<a href="http://www.rfc-editor.org/rfc/rfc2616.txt">TXT</a>, <a href="http://www.rfc-editor.org/rfc/rfc2616.ps">PS</a>, <a href="http://www.rfc-editor.org/rfc/rfc2616.pdf">PDF</a>, <a href="http://xml.resource.org/public/rfc/html/rfc2616.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc2616.xml">XML</a>).</td></tr>
<tr><td class="author-text" valign="top"><a name="RFC3986">[RFC3986]</a></td>
<td class="author-text"><a href="mailto:timbl@w3.org">Berners-Lee, T.</a>, <a href="mailto:fielding@gbiv.com">Fielding, R.</a>, and <a href="mailto:LMM@acm.org">L. Masinter</a>, &ldquo;<a href="http://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>,&rdquo; STD&nbsp;66, RFC&nbsp;3986, January&nbsp;2005 (<a href="http://www.rfc-editor.org/rfc/rfc3986.txt">TXT</a>, <a href="http://xml.resource.org/public/rfc/html/rfc3986.html">HTML</a>, <a href="http://xml.resource.org/public/rfc/xml/rfc3986.xml">XML</a>).</td></tr>
</table>

<a name="rfc.references2"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>8.2.&nbsp;Informative References</h3>
<table width="99%" border="0">
<tr><td class="author-text" valign="top"><a name="DUAL">[DUAL]</a></td>
<td class="author-text">Meijer, E., &ldquo;Subject/Observer is Dual to Iterator,&rdquo; June&nbsp;2010.</td></tr>
<tr><td class="author-text" valign="top"><a name="REST">[REST]</a></td>
<td class="author-text">Fielding, R., &ldquo;Architectural Styles and the Design of Network-based Software Architectures,&rdquo; 2000.</td></tr>
</table>

<a name="rfc.authors"></a><br /><hr />
<table summary="layout" cellpadding="0" cellspacing="2" class="TOCbug" align="right"><tr><td class="TOCbug"><a href="#toc">&nbsp;TOC&nbsp;</a></td></tr></table>
<h3>Authors' Addresses</h3>
<table width="99%" border="0" cellpadding="0" cellspacing="0">
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Klaus Hartke</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Universität Bremen TZI</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Postfach 330440</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Bremen  D-28359</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Germany</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+49-421-218-63908</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text">+49-421-218-7000</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:hartke@tzi.org">hartke@tzi.org</a></td></tr>
<tr cellpadding="3"><td>&nbsp;</td><td>&nbsp;</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Carsten Bormann</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Universität Bremen TZI</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Postfach 330440</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Bremen  D-28359</td></tr>
<tr><td class="author-text">&nbsp;</td>
<td class="author-text">Germany</td></tr>
<tr><td class="author" align="right">Phone:&nbsp;</td>
<td class="author-text">+49-421-218-63921</td></tr>
<tr><td class="author" align="right">Fax:&nbsp;</td>
<td class="author-text">+49-421-218-7000</td></tr>
<tr><td class="author" align="right">Email:&nbsp;</td>
<td class="author-text"><a href="mailto:cabo@tzi.org">cabo@tzi.org</a></td></tr>
</table>
</body></html>
