token            =     (name / opcode / delimiter / dec / bin / hex)
name             =     (lowercase / "_") 0*(lowercase / digit / "_")
opcode           =     uppercase *(uppercase / digit / "-")
delimiter        =     "." / "," / "!" / "$" / ":" / "(" / ")" /
                          operator
dec              =     1*(digit)
bin              =     "0b" 1*("0" / "1")
hex              =     "0x" 1*(hex_digit)
hex_digit        =     digit / %x41-46 / %x61-66
digit            =     %x30-39
uppercase        =     %x41-5a
lowercase        =     %x61-7a
operator         =     "+" / "-" / "*" / "/" / "%" / "&" / "|" /
                          "^" / "~" / "<<" / ">>"

ws               =     *(%x09 / %x0a / %x0d / %x20 / comment)
comment          =     ";" *(%x00-09 / %x0b-0c / %x0e-ff)
                          (%x0a / %x0d)

assembly          =    *(instruction / directive / label)
instruction       =    opcode ["(" operand *("," operand) ")"]
operand           =    [["$"] expression]
                              ; Operands can be left blank if they can
                              ; be automatically inferred by the
                              ; compiler, e.g. a literal operand
                              ; that specifies the total number of
                              ; operands for the instruction.
                              ; When "$" is prepended to an operand,
                              ; the corresponding integer is an
                              ; address rather than the actual operand
                              ; value. This symbol is mandatory for
                              ; reference operands, optional for
                              ; multitypes and addresses, and
                              ; disallowed for literals.
label             =    ":" name
directive         =    padding / data / set / readonly /
                          unknown_directive
unknown_directive =    name ["(" expression *("," expression) ")"]
                              ; The parser can ignore unknown
                              ; directives.  The resulting bytecode
                              ; may or may not generate the expected
                              ; results.
padding           =    ("pad" / "align" / "at") "(" expression ")"
data              =    ("byte" / "word") "(" expression *(","
                          expression) ")"
readonly          =    "readonly" "(" "0" / "1" ")"
set               =    "set" "(" name "," expression ")"
expression        =    value / "(" expression operator expression ")"
value             =    dec / bin / hex / name / "." / "!"
                              ; "." is the location of this
                              ; instruction/directive, whereas "!" is
                              ; the location of the closest
                              ; DECOMPRESSION-FAILURE

