WSP =   SP / HTAB
LWSP =  *(WSP / CRLF WSP)
FWS =   [*WSP CRLF] 1*WSP

hyphenated-word =  ALPHA [ *(ALPHA / DIGIT / "-") (ALPHA / DIGIT) ]
base64string =     1*(ALPHA / DIGIT / "+" / "/" / LWSP)
                          [ "=" LWSP [ "=" LWSP ] ]

dkim-quoted-printable =
                          *(FWS / hex-octet / dkim-safe-char)
                     ; hex-octet is from RFC 2045
dkim-safe-char =   %x21-3A / %x3C / %x3E-7E
                     ; '!' - ':', '<', '>' - '~'
                     ; Characters not listed as "mail-safe" in
                     ; RFC 2049 are also not recommended.

selector =   sub-domain *( "." sub-domain )

tag-list  =  tag-spec 0*( ";" tag-spec ) [ ";" ]
tag-spec  =  [FWS] tag-name [FWS] "=" [FWS] tag-value [FWS]
tag-name  =  ALPHA 0*ALNUMPUNC
tag-value =  [ tval 0*( 1*(WSP / FWS) tval ) ]
                          ; WSP and FWS prohibited at beginning and end
tval      =  1*VALCHAR
VALCHAR   =  %x21-3A / %x3C-7E
                          ; EXCLAMATION to TILDE except SEMICOLON
ALNUMPUNC =  ALPHA / DIGIT / "_"

Tag=value pairs that represent the default value MAY be included to
v=  Version (MUST be included).  This tag defines the version of this
       specification that applies to the signature record.  It MUST have
       the value 0.5.  Note that verifiers must do a string comparison
       on this value; for example, "1" is not the same as "1.0".

       ABNF:


sig-v-tag   = %x76 [FWS] "=" [FWS] "0.5"

           INFORMATIVE NOTE:  DKIM-Signature version numbers are
           expected to increase arithmetically as new versions of this
           specification are released.

           [[INFORMATIVE NOTE:  Upon publication, this version number
           should be changed to "1" (two places), and this note should
           be deleted.]]

a=  The algorithm used to generate the signature (plain-text;
       REQUIRED).  Verifiers MUST support "rsa-sha1" and "rsa-sha256";
       signers SHOULD sign using "rsa-sha256".  See Section 3.3 for a
       description of algorithms.

       ABNF:


sig-a-tag       = %x61 [FWS] "=" [FWS] sig-a-tag-alg
sig-a-tag-alg   = sig-a-tag-k "-" sig-a-tag-h
sig-a-tag-k     = "rsa" / x-sig-a-tag-k
sig-a-tag-h     = "sha1" / "sha256" / x-sig-a-tag-h
x-sig-a-tag-k   = ALPHA *(ALPHA / DIGIT)   ; for later extension
x-sig-a-tag-h   = ALPHA *(ALPHA / DIGIT)   ; for later extension

b=  The signature data (base64; REQUIRED).  Whitespace is ignored in
       this value and MUST be ignored when re-assembling the original
       signature.  In particular, the signing process can safely insert
       FWS in this value in arbitrary places to conform to line-length
       limits.  See Signer Actions (Section 5) for how the signature is
       computed.

       ABNF:
sig-b-tag       = %x62 [FWS] "=" [FWS] sig-b-tag-data
sig-b-tag-data  = base64string

bh= The hash of the canonicalized body part of the message as limited
       by the "l=" tag (base64; REQUIRED).  Whitespace is ignored in
       this value and MUST be ignored when re-assembling the original
       signature.  In particular, the signing process can safely insert
       FWS in this value in arbitrary places to conform to line-length
       limits.  See Section 3.7 for how the body hash is computed.

       ABNF:


sig-bh-tag      = %x62 %x68 [FWS] "=" [FWS] sig-bh-tag-data
sig-bh-tag-data = base64string

c=  Message canonicalization (plain-text; OPTIONAL, default is
       "simple/simple").  This tag informs the verifier of the type of
       canonicalization used to prepare the message for signing.  It
       consists of two names separated by a "slash" (%d47) character,
       corresponding to the header and body canonicalization algorithms
       respectively.  These algorithms are described in Section 3.4.  If
       only one algorithm is named, that algorithm is used for the
       header and "simple" is used for the body.  For example,
       "c=relaxed" is treated the same as "c=relaxed/simple".

       ABNF:


sig-c-tag       = %x63 [FWS] "=" [FWS] sig-c-tag-alg
                     ["/" sig-c-tag-alg]
sig-c-tag-alg   = "simple" / "relaxed" / x-sig-c-tag-alg
x-sig-c-tag-alg = hyphenated-word    ; for later extension

d=  The domain of the signing entity (plain-text; REQUIRED).  This is
       the domain that will be queried for the public key.  This domain
       MUST be the same as or a parent domain of the "i=" tag (the
       signing identity, as described below), or it MUST meet the
       requirements for parent domain signing described in Section 3.8.
       When presented with a signature that does not meet these
       requirement, verifiers MUST consider the signature invalid.

       Internationalized domain names MUST be encoded as described in
       [RFC3490].
       ABNF:


sig-d-tag       = %x64 [FWS] "=" [FWS] domain-name
domain-name     = sub-domain 1*("." sub-domain)
                ; from RFC 2821 Domain, but excluding address-literal

h=  Signed header fields (plain-text, but see description; REQUIRED).
       A colon-separated list of header field names that identify the
       header fields presented to the signing algorithm.  The field MUST
       contain the complete list of header fields in the order presented
       to the signing algorithm.  The field MAY contain names of header
       fields that do not exist when signed; nonexistent header fields
       do not contribute to the signature computation (that is, they are
       treated as the null input, including the header field name, the
       separating colon, the header field value, and any CRLF
       terminator).  The field MUST NOT include the DKIM-Signature
       header field that is being created or verified, but may include
       others.  Folding white space (FWS) MAY be included on either side
       of the colon separator.  Header field names MUST be compared
       against actual header field names in a case insensitive manner.
       This list MUST NOT be empty.  See Section 5.4 for a discussion of
       choosing header fields to sign.

       ABNF:


sig-h-tag       = %x68 [FWS] "=" [FWS] hdr-name
                     0*( *FWS ":" *FWS hdr-name )
hdr-name        = field-name

           INFORMATIVE EXPLANATION:  By "signing" header fields that do
           not actually exist, a signer can prevent insertion of those
           header fields before verification.  However, since a signer
           cannot possibly know what header fields might be created in
           the future, and that some MUAs might present header fields
           that are embedded inside a message (e.g., as a message/rfc822
           content type), the security of this solution is not total.

           INFORMATIVE EXPLANATION:  The exclusion of the header field
           name and colon as well as the header field value for non-
           existent header fields prevents an attacker from inserting an
           actual header field with a null value.
i=  Identity of the user or agent (e.g., a mailing list manager) on
       behalf of which this message is signed (dkim-quoted-printable;
       OPTIONAL, default is an empty local-part followed by an "@"
       followed by the domain from the "d=" tag).  The syntax is a
       standard email address where the local-part MAY be omitted.  The
       domain part of the address MUST be the same as or a subdomain of
       the value of the "d=" tag.

       Internationalized domain names MUST be converted using the steps
       listed in section 4 of [RFC3490] using the "ToASCII" function.

       ABNF:


sig-i-tag =   %x69 [FWS] "=" [FWS] [ Local-part ] "@" domain-name

           INFORMATIVE NOTE:  The local-part of the "i=" tag is optional
           because in some cases a signer may not be able to establish a
           verified individual identity.  In such cases, the signer may
           wish to assert that although it is willing to go as far as
           signing for the domain, it is unable or unwilling to commit
           to an individual user name within their domain.  It can do so
           by including the domain part but not the local-part of the
           identity.

           INFORMATIVE DISCUSSION:  This document does not require the
           value of the "i=" tag to match the identity in any message
           header field fields.  This is considered to be a verifier
           policy issue.  Constraints between the value of the "i=" tag
           and other identities in other header fields seek to apply
           basic authentication into the semantics of trust associated
           with a role such as content author.  Trust is a broad and
           complex topic and trust mechanisms are subject to highly
           creative attacks.  The real-world efficacy of any but the
           most basic bindings between the "i=" value and other
           identities is not well established, nor is its vulnerability
           to subversion by an attacker.  Hence reliance on the use of
           these options should be strictly limited.  In particular it
           is not at all clear to what extent a typical end-user
           recipient can rely on any assurances that might be made by
           successful use of the "i=" options.

l=  Body length count (plain-text unsigned decimal integer; OPTIONAL,
       default is entire body).  This tag informs the verifier of the
       number of octets in the body of the email after canonicalization
       included in the cryptographic hash, starting from 0 immediately
       following the CRLF preceding the body.  This value MUST NOT be
       larger than the actual number of octets in the canonicalized
       message body.

           INFORMATIVE IMPLEMENTATION WARNING:  Use of the l= tag might
           allow display of fraudulent content without appropriate
           warning to end users.  The l= tag is intended for increasing
           signature robustness when sending to mailing lists that both
           modify their content and do not sign their messages.
           However, using the l= tag enables attacks in which an
           intermediary with malicious intent modifies a message to
           include content that solely benefits the attacker.  It is
           possible for the appended content to completely replace the
           original content in the end recipient's eyes and to defeat
           duplicate message detection algorithms.  Examples are
           described in Security Considerations (Section 8).  To avoid
           this attack, signers should be extremely wary of using this
           tag, and verifiers might wish to ignore the tag or remove
           text that appears after the specified content length.

           INFORMATIVE NOTE:  The value of the l= tag is constrained to
           76 decimal digits.  This constraint is not intended to
           predict the size of future messages or to require
           implementations to use an integer representation large enough
           to represent the maximum possible value, but is intended to
           remind the implementer to check the length of this and all
           other tags during verification and to test for integer
           overflow when decoding the value.  Implementers may need to
           limit the actual value expressed to a value smaller than
           10^76, e.g., to allow a message to fit within the available
           storage space.

       ABNF:


sig-l-tag    = %x6c [FWS] "=" [FWS] 1*76DIGIT

q=  A colon-separated list of query methods used to retrieve the
       public key (plain-text; OPTIONAL, default is "dns/txt").  Each
       query method is of the form "type[/options]", where the syntax
       and semantics of the options depends on the type and specified
       options.  If there are multiple query mechanisms listed, the
       choice of query mechanism MUST NOT change the interpretation of
       the signature.  Implementations MUST use the recognized query
       mechanisms in the order presented.

       Currently the only valid value is "dns/txt" which defines the DNS
       TXT record lookup algorithm described elsewhere in this document.
       The only option defined for the "dns" query type is "txt", which
       MUST be included.  Verifiers and signers MUST support "dns/txt".
       ABNF:


sig-q-tag        = %x71 [FWS] "=" [FWS] sig-q-tag-method
                      *([FWS] ":" [FWS] sig-q-tag-method)
sig-q-tag-method = "dns/txt" / x-sig-q-tag-type
                      ["/" x-sig-q-tag-args]
x-sig-q-tag-type = hyphenated-word  ; for future extension
x-sig-q-tag-args = qp-hdr-value

s=  The Selector subdividing the namespace for the "d=" (domain) tag
       (plain-text; REQUIRED).

       ABNF:


sig-s-tag    = %x73 [FWS] "=" [FWS] selector

t=  Signature Timestamp (plain-text unsigned decimal integer;
       RECOMMENDED, default is an unknown creation time).  The time that
       this signature was created.  The format is the number of seconds
       since 00:00:00 on January 1, 1970 in the UTC time zone.  The
       value is expressed as an unsigned integer in decimal ASCII.  This
       value is not constrained to fit into a 31- or 32-bit integer.
       Implementations SHOULD be prepared to handle values up to at
       least 10^12 (until approximately AD 200,000; this fits into 40
       bits).  To avoid denial of service attacks, implementations MAY
       consider any value longer than 12 digits to be infinite.  Leap
       seconds are not counted.  Implementations MAY ignore signatures
       that have a timestamp in the future.

       ABNF:


sig-t-tag    = %x74 [FWS] "=" [FWS] 1*12DIGIT

x=  Signature Expiration (plain-text unsigned decimal integer;
       RECOMMENDED, default is no expiration).  The format is the same
       as in the "t=" tag, represented as an absolute date, not as a
       time delta from the signing timestamp.  The value is expressed as
       an unsigned integer in decimal ASCII, with the same constraints
       on the value in the "t=" tag.  Signatures MAY be considered
       invalid if the verification time at the verifier is past the
       expiration date.  The verification time should be the time that
       the message was first received at the administrative domain of
       the verifier if that time is reliably available; otherwise the
       current time should be used.  The value of the "x=" tag MUST be
       greater than the value of the "t=" tag if both are present.
           INFORMATIVE NOTE:  The x= tag is not intended as an anti-
           replay defense.

       ABNF:


sig-x-tag    = %x78 [FWS] "=" [FWS] 1*12DIGIT

z=  Copied header fields (dkim-quoted-printable, but see description;
       OPTIONAL, default is null).  A vertical-bar-separated list of
       selected header fields present when the message was signed,
       including both the field name and value.  It is not required to
       include all header fields present at the time of signing.  This
       field need not contain the same header fields listed in the "h="
       tag.  The header field text itself must encode the vertical bar
       ("|", %x7C) character (i.e., vertical bars in the z= text are
       metacharacters, and any actual vertical bar characters in a
       copied header field must be encoded).  Note that all white space
       must be encoded, including white space between the colon and the
       header field value.  After encoding, LWSP MAY be added at
       arbitrary locations in order to avoid excessively long lines;
       such white space is NOT part of the value of the header field,
       and MUST be removed before decoding.

       The header fields referenced by the h= tag refer to the fields in
       the 2822 header of the message, not to any copied fields in the
z= tag.  Copied header field values are for diagnostic use.

sig-z-tag      = %x7A [FWS] "=" [FWS] sig-z-tag-copy
                    *( [FWS] "|" sig-z-tag-copy )
sig-z-tag-copy = hdr-name ":" qp-hdr-value
qp-hdr-value   = dkim-quoted-printable    ; with "|" encoded

      INFORMATIVE EXAMPLE of a signature header field spread across
      multiple continuation lines:
c=simple; q=dns/txt; i=@eng.example.net;
t=1117574938; x=1118006938;
h=from:to:subject:date;
z=From:foo@eng.example.net|To:joe@example.com|
        Subject:demo=20run|Date:July=205,=202005=203:44:08=20PM=20-0700;
bh=MTIzNDU2Nzg5MDEyMzQ1Njc4OTAxMjM0NTY3ODkwMTI=;
b=dzdVyOfAKCdLXdJOc9G2q8LoXSlEniSbav+yuU4zGeeruD00lszZ
               VoG4ZHRNiYzR

public_key = dkim_find_key(q_val, d_val, s_val)

v=  Version of the DKIM key record (plain-text; RECOMMENDED, default
       is "DKIM1").  If specified, this tag MUST be set to "DKIM1"
       (without the quotes).  This tag MUST be the first tag in the
       record.  Records beginning with a "v=" tag with any other value
       MUST be discarded.  Note that verifiers must do a string
       comparison on this value; for example, "DKIM1" is not the same as
       "DKIM1.0".

       ABNF:


key-v-tag    = %x76 [FWS] "=" [FWS] "DKIM1"

g=  granularity of the key (plain-text; OPTIONAL, default is "*").
       This value MUST match the Local-part of the "i=" tag of the DKIM-
       Signature header field (or its default value of the empty string
       if "i=" is not specified), with a single, optional "*" character
       matching a sequence of zero or more arbitrary characters
       ("wildcarding").  An email with a signing address that does not
       match the value of this tag constitutes a failed verification.
       The intent of this tag is to constrain which signing address can
       legitimately use this Selector, for example, when delegating a
       key to a third party that should only be used for special
       purposes.  Wildcarding allows matching for addresses such as
       "user+*" or "*-offer".  An empty "g=" value never matches any
       addresses.

       ABNF:


key-g-tag       = %x67 [FWS] "=" [FWS] key-g-tag-lpart
key-g-tag-lpart = [dot-atom-text] ["*" [dot-atom-text] ]

           [[NON-NORMATIVE DISCUSSION POINT:  "*" is legal in a
           "dot-atom-text".  This should probably use a different
           character for wildcarding.  Unfortunately, the options are
           non-mnemonic (e.g., "@", "(", ":").  Alternatively we could
           insist on escaping a "*" intended as a literal "*" in the
           address.]]

h=  Acceptable hash algorithms (plain-text; OPTIONAL, defaults to
       allowing all algorithms).  A colon-separated list of hash
       algorithms that might be used.  Signers and Verifiers MUST
       support the "sha256" hash algorithm.  Verifiers MUST also support
       the "sha1" hash algorithm.

       ABNF:
key-h-tag       = %x68 [FWS] "=" [FWS] key-h-tag-alg
                     0*( [FWS] ":" [FWS] key-h-tag-alg )
key-h-tag-alg   = "sha1" / "sha256" / x-key-h-tag-alg
x-key-h-tag-alg = hyphenated-word   ; for future extension

k=  Key type (plain-text; OPTIONAL, default is "rsa").  Signers and
       verifiers MUST support the "rsa" key type.  The "rsa" key type
       indicates that an ASN.1 DER-encoded [ITU.X660.1997] RSAPublicKey
       [RFC3447] (see sections 3.1 and A.1.1) is being used in the p=
       tag.  (Note:  the p= tag further encodes the value using the
       base64 algorithm.)

       ABNF:


key-k-tag        = %x76 [FWS] "=" [FWS] key-k-tag-type
key-k-tag-type   = "rsa" / x-key-k-tag-type
x-key-k-tag-type = hyphenated-word   ; for future extension

n=  Notes that might be of interest to a human (qp-section; OPTIONAL,
       default is empty).  No interpretation is made by any program.
       This tag should be used sparingly in any key server mechanism
       that has space limitations (notably DNS).  This is intended for
       use by administrators, not end users.

       ABNF:


key-n-tag    = %x6e [FWS] "=" [FWS] qp-section

p=  Public-key data (base64; REQUIRED).  An empty value means that
       this public key has been revoked.  The syntax and semantics of
       this tag value before being encoded in base64 is defined by the
k= tag.

           INFORMATIVE RATIONALE:  If a private key has been compromised
           or otherwise disabled (e.g., an outsourcing contract has been
           terminated), a signer might want to explicitly state that it
           knows about the selector, but all messages using that
           selector should fail verification.  Verifiers should ignore
           any DKIM-Signature header fields with a selector referencing
           a revoked key.
key-p-tag    = %x70 [FWS] "=" [ [FWS] base64string ]

s=  Service Type (plain-text; OPTIONAL; default is "*").  A colon-
       separated list of service types to which this record applies.
       Verifiers for a given service type MUST ignore this record if the
       appropriate type is not listed.  Currently defined service types
       are:

       *   matches all service types

       email   electronic mail (not necessarily limited to SMTP)

       This tag is intended to constrain the use of keys for other
       purposes, should use of DKIM be defined by other services in the
       future.

       ABNF:


key-s-tag        = %x73 [FWS] "=" [FWS] key-s-tag-type
                       0*( [FWS] ":" [FWS] key-s-tag-type )
key-s-tag-type   = "email" / "*" / x-key-s-tag-type
x-key-s-tag-type = hyphenated-word   ; for future extension

t=  Flags, represented as a colon-separated list of names (plain-
       text; OPTIONAL, default is no flags set).  The defined flags are:

       y   This domain is testing DKIM.  Verifiers MUST NOT treat
           messages from signers in testing mode differently from
           unsigned email, even should the signature fail to verify.
           Verifiers MAY wish to track testing mode results to assist
           the signer.

       s   Any DKIM-Signature header fields using the "i=" tag MUST have
           the same domain value on the right hand side of the "@" in
           the "i=" tag and the value of the "d=" tag.  That is, the
           "i=" domain MUST NOT be a subdomain of "d=".  Use of this
           flag is RECOMMENDED unless subdomaining is required.

       ABNF:
key-t-tag        = %x74 [FWS] "=" [FWS] key-t-tag-flag
                      0*( [FWS] ":" [FWS] key-t-tag-flag )
key-t-tag-flag   = "y" / "s" / x-key-t-tag-flag
x-key-t-tag-flag = hyphenated-word   ; for future extension

       Unrecognized flags MUST be ignored.

body-hash = hash-alg(canon_body)
header-hash = hash-alg(canon_header || DKIM-SIG)
signature = sig-alg(header-hash, key)

width=578 height=370>
c=simple; q=dns/txt; i=joe@football.example.com;
h=Received : From : To : Subject : Date : Message-ID;
bh=jpltwNFTq83Bkjt/Y2ekyqr/+i296daNkFZSdaz8VCY=;
b=bnUoMBPJ5wBigyZG2V4OG2JxLWJATkSkb9Ig+8OAu3cE2x/er+B
Hs6fxOzzAB7Wro=;
c=simple; q=dns/txt; i=joe@football.example.com;
h=Received : From : To : Subject : Date : Message-ID;
bh=jpltwNFTq83Bkjt/Y2ekyqr/+i296daNkFZSdaz8VCY=;
b=bnUoMBPJ5wBigyZG2V4OG2JxLWJATkSkb9Ig+8OAu3cE2x/er+B
Hs6fxOzzAB7Wro=;
